<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Column_copy</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__column__copy.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#files">文件</a> &#124;
<a href="#nested-classes">类</a> &#124;
<a href="#enum-members">枚举</a> &#124;
<a href="#func-members">函数</a>  </div>
  <div class="headertitle"><div class="title">Column_copy</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
文件</h2></td></tr>
<tr class="memitem:copying_8hpp"><td class="memItemLeft" align="right" valign="top">文件 &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="copying_8hpp.html">copying.hpp</a></td></tr>
<tr class="memdesc:copying_8hpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column APIs for gather, scatter, split, slice, etc. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
类</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1packed__columns.html">cudf::packed_columns</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column data in a serialized format  <a href="structcudf_1_1packed__columns.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1packed__table.html">cudf::packed_table</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result(s) of a <a class="el" href="group__column__copy.html#gab171e877b57253d521eb8f6d3c7d7c4a" title="Performs a deep-copy split of a table_view into a set of table_views into a single contiguous block o...">cudf::contiguous_split</a>  <a href="structcudf_1_1packed__table.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
枚举</h2></td></tr>
<tr class="memitem:gae3ba74951558bc7966aae86abc6af5df"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gae3ba74951558bc7966aae86abc6af5df">cudf::out_of_bounds_policy</a> : bool { <a class="el" href="group__column__copy.html#ggae3ba74951558bc7966aae86abc6af5dfacac2cdaff9b4ab3bcda3b538a86f9edb">cudf::out_of_bounds_policy::NULLIFY</a>
, <a class="el" href="group__column__copy.html#ggae3ba74951558bc7966aae86abc6af5dfa12c1109487cf9a6a336b1dfe462bfd2d">cudf::out_of_bounds_policy::DONT_CHECK</a>
 }</td></tr>
<tr class="memdesc:gae3ba74951558bc7966aae86abc6af5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy to account for possible out-of-bounds indices  <a href="group__column__copy.html#gae3ba74951558bc7966aae86abc6af5df">更多...</a><br /></td></tr>
<tr class="separator:gae3ba74951558bc7966aae86abc6af5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga267e03474dcfd85242d2fdc6e5846ec6"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga267e03474dcfd85242d2fdc6e5846ec6">cudf::mask_allocation_policy</a> { <a class="el" href="group__column__copy.html#gga267e03474dcfd85242d2fdc6e5846ec6a443475558f0168dff92ecde26b98ae5a">cudf::mask_allocation_policy::NEVER</a>
, <a class="el" href="group__column__copy.html#gga267e03474dcfd85242d2fdc6e5846ec6a47e9136fa770199f6a8a9727b6173eb4">cudf::mask_allocation_policy::RETAIN</a>
, <a class="el" href="group__column__copy.html#gga267e03474dcfd85242d2fdc6e5846ec6af3fc827ade4b968e50406496907ef962">cudf::mask_allocation_policy::ALWAYS</a>
 }</td></tr>
<tr class="memdesc:ga267e03474dcfd85242d2fdc6e5846ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates when to allocate a mask, based on an existing mask.  <a href="group__column__copy.html#ga267e03474dcfd85242d2fdc6e5846ec6">更多...</a><br /></td></tr>
<tr class="separator:ga267e03474dcfd85242d2fdc6e5846ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7607cde56cb602ab1b198b5bebf7cba"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gae7607cde56cb602ab1b198b5bebf7cba">cudf::sample_with_replacement</a> : bool { <a class="el" href="group__column__copy.html#ggae7607cde56cb602ab1b198b5bebf7cbaa946003f97ccc52d5d3b54ac0ec31bbfc">cudf::sample_with_replacement::FALSE</a>
, <a class="el" href="group__column__copy.html#ggae7607cde56cb602ab1b198b5bebf7cbaac0d83f0b82a6b30de8811e69e6d95c61">cudf::sample_with_replacement::TRUE</a>
 }</td></tr>
<tr class="memdesc:gae7607cde56cb602ab1b198b5bebf7cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether a row can be sampled more than once.  <a href="group__column__copy.html#gae7607cde56cb602ab1b198b5bebf7cba">更多...</a><br /></td></tr>
<tr class="separator:gae7607cde56cb602ab1b198b5bebf7cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
函数</h2></td></tr>
<tr class="memitem:ga19ea162e7794e6cbbc2faba70fbd91aa"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga19ea162e7794e6cbbc2faba70fbd91aa">cudf::gather</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;source_table, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;gather_map, <a class="el" href="group__column__copy.html#gae3ba74951558bc7966aae86abc6af5df">out_of_bounds_policy</a> bounds_policy=<a class="el" href="group__column__copy.html#ggae3ba74951558bc7966aae86abc6af5dfa12c1109487cf9a6a336b1dfe462bfd2d">out_of_bounds_policy::DONT_CHECK</a>, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga19ea162e7794e6cbbc2faba70fbd91aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers the specified rows (including null values) of a set of columns.  <br /></td></tr>
<tr class="separator:ga19ea162e7794e6cbbc2faba70fbd91aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbbf4a02a5108cbcd9368ce31efc7f2a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gafbbf4a02a5108cbcd9368ce31efc7f2a">cudf::reverse</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;source_table, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gafbbf4a02a5108cbcd9368ce31efc7f2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the rows within a table.  <br /></td></tr>
<tr class="separator:gafbbf4a02a5108cbcd9368ce31efc7f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f6bd5517ff6f32a20b20d66a22616a7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga6f6bd5517ff6f32a20b20d66a22616a7">cudf::reverse</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;source_column, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga6f6bd5517ff6f32a20b20d66a22616a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the elements of a column  <br /></td></tr>
<tr class="separator:ga6f6bd5517ff6f32a20b20d66a22616a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd90ba38ea2655ce3b435d2a4f199358"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gabd90ba38ea2655ce3b435d2a4f199358">cudf::scatter</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;source, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;scatter_map, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;target, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gabd90ba38ea2655ce3b435d2a4f199358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatters the rows of the source table into a copy of the target table according to a scatter map.  <br /></td></tr>
<tr class="separator:gabd90ba38ea2655ce3b435d2a4f199358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga474f55905324aea8ed00ff8e3e3fecea"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga474f55905324aea8ed00ff8e3e3fecea">cudf::scatter</a> (std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt; &gt; const &amp;source, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;indices, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;target, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga474f55905324aea8ed00ff8e3e3fecea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatters a row of scalar values into a copy of the target table according to a scatter map.  <br /></td></tr>
<tr class="separator:ga474f55905324aea8ed00ff8e3e3fecea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62eff2fcac7ff377df316c7ef37ee4fd"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga62eff2fcac7ff377df316c7ef37ee4fd">cudf::empty_like</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input)</td></tr>
<tr class="memdesc:ga62eff2fcac7ff377df316c7ef37ee4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes and returns an empty column of the same type as the <code>input</code>.  <br /></td></tr>
<tr class="separator:ga62eff2fcac7ff377df316c7ef37ee4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf190ab1fe40049bc95bf7aebad93450"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gadf190ab1fe40049bc95bf7aebad93450">cudf::empty_like</a> (<a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;input)</td></tr>
<tr class="memdesc:gadf190ab1fe40049bc95bf7aebad93450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes and returns an empty column of the same type as the <code>input</code>.  <br /></td></tr>
<tr class="separator:gadf190ab1fe40049bc95bf7aebad93450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5aa629d9ff2157990e7187b9e1552df"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gab5aa629d9ff2157990e7187b9e1552df">cudf::allocate_like</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="group__column__copy.html#ga267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a> mask_alloc=<a class="el" href="group__column__copy.html#gga267e03474dcfd85242d2fdc6e5846ec6a47e9136fa770199f6a8a9727b6173eb4">mask_allocation_policy::RETAIN</a>, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gab5aa629d9ff2157990e7187b9e1552df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an uninitialized new column of the same size and type as the <code>input</code>.  <br /></td></tr>
<tr class="separator:gab5aa629d9ff2157990e7187b9e1552df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c1552cc6c2d49d1a74b907bd4bb2baa"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga9c1552cc6c2d49d1a74b907bd4bb2baa">cudf::allocate_like</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> size, <a class="el" href="group__column__copy.html#ga267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a> mask_alloc=<a class="el" href="group__column__copy.html#gga267e03474dcfd85242d2fdc6e5846ec6a47e9136fa770199f6a8a9727b6173eb4">mask_allocation_policy::RETAIN</a>, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga9c1552cc6c2d49d1a74b907bd4bb2baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an uninitialized new column of the specified size and same type as the <code>input</code>.  <br /></td></tr>
<tr class="separator:ga9c1552cc6c2d49d1a74b907bd4bb2baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf51eaa0bed9085f857e8edbcb4141d76"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gaf51eaa0bed9085f857e8edbcb4141d76">cudf::empty_like</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input_table)</td></tr>
<tr class="memdesc:gaf51eaa0bed9085f857e8edbcb4141d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a table of empty columns with the same types as the <code>input_table</code>  <br /></td></tr>
<tr class="separator:gaf51eaa0bed9085f857e8edbcb4141d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7453a32aa49fd9a55287a776f2b4b2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gaf7453a32aa49fd9a55287a776f2b4b2f">cudf::copy_range_in_place</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;source, <a class="el" href="classcudf_1_1mutable__column__view.html">mutable_column_view</a> &amp;target, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> source_begin, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> source_end, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> target_begin)</td></tr>
<tr class="memdesc:gaf7453a32aa49fd9a55287a776f2b4b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a range of elements in-place from one column to another.  <br /></td></tr>
<tr class="separator:gaf7453a32aa49fd9a55287a776f2b4b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9358e7f2ed4d47e3ee03f24ef711e402"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga9358e7f2ed4d47e3ee03f24ef711e402">cudf::copy_range</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;source, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;target, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> source_begin, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> source_end, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> target_begin, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga9358e7f2ed4d47e3ee03f24ef711e402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a range of elements out-of-place from one column to another.  <br /></td></tr>
<tr class="separator:ga9358e7f2ed4d47e3ee03f24ef711e402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80b6ccd43dbb2359d520a3f3ea100e8e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga80b6ccd43dbb2359d520a3f3ea100e8e">cudf::shift</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> offset, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;fill_value, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga80b6ccd43dbb2359d520a3f3ea100e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new column by shifting all values by an offset.  <br /></td></tr>
<tr class="separator:ga80b6ccd43dbb2359d520a3f3ea100e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52223b0ef6807f9a2454f7395b5425d4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcudf_1_1column__view.html">column_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga52223b0ef6807f9a2454f7395b5425d4">cudf::slice</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt; indices)</td></tr>
<tr class="memdesc:ga52223b0ef6807f9a2454f7395b5425d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slices a <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> into a set of <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code>s according to a set of indices.  <br /></td></tr>
<tr class="separator:ga52223b0ef6807f9a2454f7395b5425d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77b1d2c6579fa0ad8da690c8cd4c3192"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcudf_1_1column__view.html">column_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga77b1d2c6579fa0ad8da690c8cd4c3192">cudf::slice</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, std::initializer_list&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; indices)</td></tr>
<tr class="separator:ga77b1d2c6579fa0ad8da690c8cd4c3192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61a6785244331834b458545e084b7017"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcudf_1_1table__view.html">table_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga61a6785244331834b458545e084b7017">cudf::slice</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, <a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt; indices)</td></tr>
<tr class="memdesc:ga61a6785244331834b458545e084b7017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slices a <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> into a set of <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code>s according to a set of indices.  <br /></td></tr>
<tr class="separator:ga61a6785244331834b458545e084b7017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadc72fabae41e8187065211ebe7d6cce"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcudf_1_1table__view.html">table_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gaadc72fabae41e8187065211ebe7d6cce">cudf::slice</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, std::initializer_list&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; indices)</td></tr>
<tr class="separator:gaadc72fabae41e8187065211ebe7d6cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95ac220988903ef24d698ff49c683bfc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcudf_1_1column__view.html">column_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga95ac220988903ef24d698ff49c683bfc">cudf::split</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt; splits)</td></tr>
<tr class="memdesc:ga95ac220988903ef24d698ff49c683bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> into a set of <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code>s according to a set of indices derived from expected splits.  <br /></td></tr>
<tr class="separator:ga95ac220988903ef24d698ff49c683bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fb87b85cb2fedb682a6f4103414f97f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcudf_1_1column__view.html">column_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga5fb87b85cb2fedb682a6f4103414f97f">cudf::split</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, std::initializer_list&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; splits)</td></tr>
<tr class="separator:ga5fb87b85cb2fedb682a6f4103414f97f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72d5748fbf4bd848295769dce8a80979"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcudf_1_1table__view.html">table_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga72d5748fbf4bd848295769dce8a80979">cudf::split</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, <a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt; splits)</td></tr>
<tr class="memdesc:ga72d5748fbf4bd848295769dce8a80979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> into a set of <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code>s according to a set of indices derived from expected splits.  <br /></td></tr>
<tr class="separator:ga72d5748fbf4bd848295769dce8a80979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94277c977c86ac93ebb279f562906aa0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcudf_1_1table__view.html">table_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga94277c977c86ac93ebb279f562906aa0">cudf::split</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, std::initializer_list&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; splits)</td></tr>
<tr class="separator:ga94277c977c86ac93ebb279f562906aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab171e877b57253d521eb8f6d3c7d7c4a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structcudf_1_1packed__table.html">packed_table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gab171e877b57253d521eb8f6d3c7d7c4a">cudf::contiguous_split</a> (<a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;input, std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; const &amp;splits, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gab171e877b57253d521eb8f6d3c7d7c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a deep-copy split of a <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> into a set of <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code>s into a single contiguous block of memory.  <br /></td></tr>
<tr class="separator:gab171e877b57253d521eb8f6d3c7d7c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb39dd8301fb76bfec9e777820bda3f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1packed__columns.html">packed_columns</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gaeb39dd8301fb76bfec9e777820bda3f2">cudf::pack</a> (<a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;input, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gaeb39dd8301fb76bfec9e777820bda3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep-copy a <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> into a serialized contiguous memory format  <br /></td></tr>
<tr class="separator:gaeb39dd8301fb76bfec9e777820bda3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab28fc2d2294f2840df37814e7a4aa582"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1packed__columns_1_1metadata.html">packed_columns::metadata</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gab28fc2d2294f2840df37814e7a4aa582">cudf::pack_metadata</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;<a class="el" href="classcudf_1_1table.html">table</a>, uint8_t const *contiguous_buffer, size_t buffer_size)</td></tr>
<tr class="memdesc:gab28fc2d2294f2840df37814e7a4aa582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce the metadata used for packing a table stored in a contiguous buffer.  <br /></td></tr>
<tr class="separator:gab28fc2d2294f2840df37814e7a4aa582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d62a18c2e6f087a92289c63693762cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcudf_1_1table__view.html">table_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga1d62a18c2e6f087a92289c63693762cc">cudf::unpack</a> (<a class="el" href="structcudf_1_1packed__columns.html">packed_columns</a> const &amp;input)</td></tr>
<tr class="memdesc:ga1d62a18c2e6f087a92289c63693762cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize the result of <code><a class="el" href="group__column__copy.html#gaeb39dd8301fb76bfec9e777820bda3f2" title="Deep-copy a table_view into a serialized contiguous memory format">cudf::pack</a></code>  <br /></td></tr>
<tr class="separator:ga1d62a18c2e6f087a92289c63693762cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaebfb6742c09cccda8fb8a78e19fbd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcudf_1_1table__view.html">table_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gaaaebfb6742c09cccda8fb8a78e19fbd6">cudf::unpack</a> (uint8_t const *metadata, uint8_t const *gpu_data)</td></tr>
<tr class="memdesc:gaaaebfb6742c09cccda8fb8a78e19fbd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize the result of <code><a class="el" href="group__column__copy.html#gaeb39dd8301fb76bfec9e777820bda3f2" title="Deep-copy a table_view into a serialized contiguous memory format">cudf::pack</a></code>  <br /></td></tr>
<tr class="separator:gaaaebfb6742c09cccda8fb8a78e19fbd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20a8a274e5efd32f012ada60ed20fbf1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga20a8a274e5efd32f012ada60ed20fbf1">cudf::copy_if_else</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;lhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;rhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;boolean_mask, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga20a8a274e5efd32f012ada60ed20fbf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>  <br /></td></tr>
<tr class="separator:ga20a8a274e5efd32f012ada60ed20fbf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9419155faa6145c567bc10f4a9022b2f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga9419155faa6145c567bc10f4a9022b2f">cudf::copy_if_else</a> (<a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;lhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;rhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;boolean_mask, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga9419155faa6145c567bc10f4a9022b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>  <br /></td></tr>
<tr class="separator:ga9419155faa6145c567bc10f4a9022b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ef360d8b66500f7da10f9cb8298e079"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga0ef360d8b66500f7da10f9cb8298e079">cudf::copy_if_else</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;lhs, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;rhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;boolean_mask, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga0ef360d8b66500f7da10f9cb8298e079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>  <br /></td></tr>
<tr class="separator:ga0ef360d8b66500f7da10f9cb8298e079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f5e9508f27672af7450bbfc7a4acdb4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga5f5e9508f27672af7450bbfc7a4acdb4">cudf::copy_if_else</a> (<a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;lhs, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;rhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;boolean_mask, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga5f5e9508f27672af7450bbfc7a4acdb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>  <br /></td></tr>
<tr class="separator:ga5f5e9508f27672af7450bbfc7a4acdb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5cc9b107359c2666847a4586d07ef70"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gae5cc9b107359c2666847a4586d07ef70">cudf::boolean_mask_scatter</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;target, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;boolean_mask, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gae5cc9b107359c2666847a4586d07ef70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatters rows from the input table to rows of the output corresponding to true values in a boolean mask.  <br /></td></tr>
<tr class="separator:gae5cc9b107359c2666847a4586d07ef70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7945f25673f72c65e1bf60821fa579e7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga7945f25673f72c65e1bf60821fa579e7">cudf::boolean_mask_scatter</a> (std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt; &gt; const &amp;input, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;target, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;boolean_mask, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga7945f25673f72c65e1bf60821fa579e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatters scalar values to rows of the output corresponding to true values in a boolean mask.  <br /></td></tr>
<tr class="separator:ga7945f25673f72c65e1bf60821fa579e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c310958af4e031737d80ba8015452b6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga3c310958af4e031737d80ba8015452b6">cudf::get_element</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> index, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga3c310958af4e031737d80ba8015452b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the element at specified index from a column  <br /></td></tr>
<tr class="separator:ga3c310958af4e031737d80ba8015452b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29e76351f1ae5bd91dc922ad24243b1f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga29e76351f1ae5bd91dc922ad24243b1f">cudf::sample</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const n, <a class="el" href="group__column__copy.html#gae7607cde56cb602ab1b198b5bebf7cba">sample_with_replacement</a> replacement=<a class="el" href="group__column__copy.html#ggae7607cde56cb602ab1b198b5bebf7cbaa946003f97ccc52d5d3b54ac0ec31bbfc">sample_with_replacement::FALSE</a>, int64_t const seed=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga29e76351f1ae5bd91dc922ad24243b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather <code>n</code> samples from given <code>input</code> randomly  <br /></td></tr>
<tr class="separator:ga29e76351f1ae5bd91dc922ad24243b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c61528cb588874f9c07c6f766f232db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga0c61528cb588874f9c07c6f766f232db">cudf::has_nonempty_nulls</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input)</td></tr>
<tr class="memdesc:ga0c61528cb588874f9c07c6f766f232db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a column or its descendants have non-empty null rows  <br /></td></tr>
<tr class="separator:ga0c61528cb588874f9c07c6f766f232db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a9c46582ed07509d4bfe24e50d59bf2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga9a9c46582ed07509d4bfe24e50d59bf2">cudf::may_have_nonempty_nulls</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input)</td></tr>
<tr class="memdesc:ga9a9c46582ed07509d4bfe24e50d59bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximates if a column or its descendants <em>may</em> have non-empty null elements  <br /></td></tr>
<tr class="separator:ga9a9c46582ed07509d4bfe24e50d59bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga387d2221ad89e737e89270bf8c56dfa5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga387d2221ad89e737e89270bf8c56dfa5">cudf::purge_nonempty_nulls</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga387d2221ad89e737e89270bf8c56dfa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy <code>input</code> into output while purging any non-empty null rows in the column or its descendants.  <br /></td></tr>
<tr class="separator:ga387d2221ad89e737e89270bf8c56dfa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<h2 class="groupheader">枚举类型说明</h2>
<a id="ga267e03474dcfd85242d2fdc6e5846ec6" name="ga267e03474dcfd85242d2fdc6e5846ec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga267e03474dcfd85242d2fdc6e5846ec6">&#9670;&#160;</a></span>mask_allocation_policy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="group__column__copy.html#ga267e03474dcfd85242d2fdc6e5846ec6">cudf::mask_allocation_policy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates when to allocate a mask, based on an existing mask. </p>
<table class="fieldtable">
<tr><th colspan="2">枚举值</th></tr><tr><td class="fieldname"><a id="gga267e03474dcfd85242d2fdc6e5846ec6a443475558f0168dff92ecde26b98ae5a" name="gga267e03474dcfd85242d2fdc6e5846ec6a443475558f0168dff92ecde26b98ae5a"></a>NEVER&#160;</td><td class="fielddoc"><p>Do not allocate a null mask, regardless of input </p>
</td></tr>
<tr><td class="fieldname"><a id="gga267e03474dcfd85242d2fdc6e5846ec6a47e9136fa770199f6a8a9727b6173eb4" name="gga267e03474dcfd85242d2fdc6e5846ec6a47e9136fa770199f6a8a9727b6173eb4"></a>RETAIN&#160;</td><td class="fielddoc"><p>Allocate a null mask if the input contains one </p>
</td></tr>
<tr><td class="fieldname"><a id="gga267e03474dcfd85242d2fdc6e5846ec6af3fc827ade4b968e50406496907ef962" name="gga267e03474dcfd85242d2fdc6e5846ec6af3fc827ade4b968e50406496907ef962"></a>ALWAYS&#160;</td><td class="fielddoc"><p>Allocate a null mask, regardless of input </p>
</td></tr>
</table>

<p class="definition">在文件 <a class="el" href="copying_8hpp_source.html">copying.hpp</a> 第 <a class="el" href="copying_8hpp_source.html#l00204">204</a> 行定义.</p>

</div>
</div>
<a id="gae3ba74951558bc7966aae86abc6af5df" name="gae3ba74951558bc7966aae86abc6af5df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3ba74951558bc7966aae86abc6af5df">&#9670;&#160;</a></span>out_of_bounds_policy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="group__column__copy.html#gae3ba74951558bc7966aae86abc6af5df">cudf::out_of_bounds_policy</a> : bool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Policy to account for possible out-of-bounds indices </p>
<p><code>NULLIFY</code> means to nullify output values corresponding to out-of-bounds gather_map values. <code>DONT_CHECK</code> means do not check whether the indices are out-of-bounds, for better performance. </p>
<table class="fieldtable">
<tr><th colspan="2">枚举值</th></tr><tr><td class="fieldname"><a id="ggae3ba74951558bc7966aae86abc6af5dfacac2cdaff9b4ab3bcda3b538a86f9edb" name="ggae3ba74951558bc7966aae86abc6af5dfacac2cdaff9b4ab3bcda3b538a86f9edb"></a>NULLIFY&#160;</td><td class="fielddoc"><p>Output values corresponding to out-of-bounds indices are null </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae3ba74951558bc7966aae86abc6af5dfa12c1109487cf9a6a336b1dfe462bfd2d" name="ggae3ba74951558bc7966aae86abc6af5dfa12c1109487cf9a6a336b1dfe462bfd2d"></a>DONT_CHECK&#160;</td><td class="fielddoc"><p>No bounds checking is performed, better performance </p>
</td></tr>
</table>

<p class="definition">在文件 <a class="el" href="copying_8hpp_source.html">copying.hpp</a> 第 <a class="el" href="copying_8hpp_source.html#l00048">48</a> 行定义.</p>

</div>
</div>
<a id="gae7607cde56cb602ab1b198b5bebf7cba" name="gae7607cde56cb602ab1b198b5bebf7cba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7607cde56cb602ab1b198b5bebf7cba">&#9670;&#160;</a></span>sample_with_replacement</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="group__column__copy.html#gae7607cde56cb602ab1b198b5bebf7cba">cudf::sample_with_replacement</a> : bool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether a row can be sampled more than once. </p>
<table class="fieldtable">
<tr><th colspan="2">枚举值</th></tr><tr><td class="fieldname"><a id="ggae7607cde56cb602ab1b198b5bebf7cbaa946003f97ccc52d5d3b54ac0ec31bbfc" name="ggae7607cde56cb602ab1b198b5bebf7cbaa946003f97ccc52d5d3b54ac0ec31bbfc"></a>FALSE&#160;</td><td class="fielddoc"><p>A row can be sampled only once </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae7607cde56cb602ab1b198b5bebf7cbaac0d83f0b82a6b30de8811e69e6d95c61" name="ggae7607cde56cb602ab1b198b5bebf7cbaac0d83f0b82a6b30de8811e69e6d95c61"></a>TRUE&#160;</td><td class="fielddoc"><p>A row can be sampled more than once </p>
</td></tr>
</table>

<p class="definition">在文件 <a class="el" href="copying_8hpp_source.html">copying.hpp</a> 第 <a class="el" href="copying_8hpp_source.html#l00933">933</a> 行定义.</p>

</div>
</div>
<h2 class="groupheader">函数说明</h2>
<a id="gab5aa629d9ff2157990e7187b9e1552df" name="gab5aa629d9ff2157990e7187b9e1552df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5aa629d9ff2157990e7187b9e1552df">&#9670;&#160;</a></span>allocate_like() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::allocate_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__column__copy.html#ga267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a>&#160;</td>
          <td class="paramname"><em>mask_alloc</em> = <code><a class="el" href="group__column__copy.html#gga267e03474dcfd85242d2fdc6e5846ec6a47e9136fa770199f6a8a9727b6173eb4">mask_allocation_policy::RETAIN</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an uninitialized new column of the same size and type as the <code>input</code>. </p>
<p>Supports only fixed-width types.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Immutable view of input column to emulate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask_alloc</td><td>Optional, Policy for allocating null mask. Defaults to RETAIN </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A column with sufficient uninitialized capacity to hold the same number of elements as <code>input</code> of the same type as <code>input.type()</code> </dd></dl>

</div>
</div>
<a id="ga9c1552cc6c2d49d1a74b907bd4bb2baa" name="ga9c1552cc6c2d49d1a74b907bd4bb2baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c1552cc6c2d49d1a74b907bd4bb2baa">&#9670;&#160;</a></span>allocate_like() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::allocate_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__column__copy.html#ga267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a>&#160;</td>
          <td class="paramname"><em>mask_alloc</em> = <code><a class="el" href="group__column__copy.html#gga267e03474dcfd85242d2fdc6e5846ec6a47e9136fa770199f6a8a9727b6173eb4">mask_allocation_policy::RETAIN</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an uninitialized new column of the specified size and same type as the <code>input</code>. </p>
<p>Supports only fixed-width types.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Immutable view of input column to emulate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The desired number of elements that the new column should have capacity for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask_alloc</td><td>Optional, Policy for allocating null mask. Defaults to RETAIN </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A column with sufficient uninitialized capacity to hold the specified number of elements as <code>input</code> of the same type as <code>input.type()</code> </dd></dl>

</div>
</div>
<a id="ga7945f25673f72c65e1bf60821fa579e7" name="ga7945f25673f72c65e1bf60821fa579e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7945f25673f72c65e1bf60821fa579e7">&#9670;&#160;</a></span>boolean_mask_scatter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt; cudf::boolean_mask_scatter </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>boolean_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scatters scalar values to rows of the output corresponding to true values in a boolean mask. </p>
<p>The <code>i</code>th scalar in <code>input</code> will be written to all columns of the output table at the location of the <code>i</code>th true value in <code>boolean_mask</code>. All other rows in the output will equal the same row in <code>target</code>.</p>
<div class="fragment"><div class="line">Example:</div>
<div class="line">input: {11}</div>
<div class="line">boolean_mask: {true, false, false, false, true, true, false, true, true, false}</div>
<div class="line">target:      {{   2,     2,     3,     4,    4,     7,    7,    7,    8,    10}}</div>
<div class="line"> </div>
<div class="line">output:       {{   11,    2,     3,     4,   11,    11,    7,   11,   11,    10}}</div>
</div><!-- fragment --><dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if input.size() != target.num_columns() </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if any <code>i</code>th input_scalar type != <code>i</code>th target_column type </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean_mask.type() != bool </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean_mask.size() != target.size()</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>scalars to scatter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a> to modify with scattered values from <code>input</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boolean_mask</td><td><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> which acts as boolean mask </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate device memory of the returned table</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Returns a table by scattering <code>input</code> into <code>target</code> as per <code>boolean_mask</code> </dd></dl>

</div>
</div>
<a id="gae5cc9b107359c2666847a4586d07ef70" name="gae5cc9b107359c2666847a4586d07ef70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5cc9b107359c2666847a4586d07ef70">&#9670;&#160;</a></span>boolean_mask_scatter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt; cudf::boolean_mask_scatter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>boolean_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scatters rows from the input table to rows of the output corresponding to true values in a boolean mask. </p>
<p>The <code>i</code>th row of <code>input</code> will be written to the output table at the location of the <code>i</code>th true value in <code>boolean_mask</code>. All other rows in the output will equal the same row in <code>target</code>.</p>
<p><code>boolean_mask</code> should have number of <code>true</code>s &lt;= number of rows in <code>input</code>. If boolean mask is <code>true</code>, corresponding value in target is updated with value from corresponding <code>input</code> column, else it is left untouched.</p>
<div class="fragment"><div class="line">Example:</div>
<div class="line">input: {{1, 5, 6, 8, 9}}</div>
<div class="line">boolean_mask: {true, false, false, false, true, true, false, true, true, false}</div>
<div class="line">target:       {{   2,     2,     3,     4,    4,     7,    7,    7,    8,    10}}</div>
<div class="line"> </div>
<div class="line">output:       {{   1,     2,     3,     4,    5,     6,    7,    8,    9,    10}}</div>
</div><!-- fragment --><dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if input.num_columns() != target.num_columns() </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if any <code>i</code>th input_column type != <code>i</code>th target_column type </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean_mask.type() != bool </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean_mask.size() != target.num_rows() </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if number of <code>true</code> in <code>boolean_mask</code> &gt; input.num_rows()</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a> (set of dense columns) to scatter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a> to modify with scattered values from <code>input</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boolean_mask</td><td><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> which acts as boolean mask </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate device memory of the returned table</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Returns a table by scattering <code>input</code> into <code>target</code> as per <code>boolean_mask</code> </dd></dl>

</div>
</div>
<a id="gab171e877b57253d521eb8f6d3c7d7c4a" name="gab171e877b57253d521eb8f6d3c7d7c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab171e877b57253d521eb8f6d3c7d7c4a">&#9670;&#160;</a></span>contiguous_split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structcudf_1_1packed__table.html">packed_table</a> &gt; cudf::contiguous_split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a deep-copy split of a <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> into a set of <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code>s into a single contiguous block of memory. </p>
<p>The memory for the output views is allocated in a single contiguous <code>rmm::device_buffer</code> returned in the <code><a class="el" href="structcudf_1_1packed__table.html" title="The result(s) of a cudf::contiguous_split">packed_table</a></code>. There is no top-level owning table.</p>
<p>The returned views of <code>input</code> are constructed from a vector of indices, that indicate where each split should occur. The <code>i</code>th returned <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> is sliced as <code>[0, splits[i])</code> if <code>i</code>=0, else <code>[splits[i], input.size())</code> if <code>i</code> is the last view and <code>[splits[i-1], splits[i]]</code> otherwise.</p>
<p>For all <code>i</code> it is expected <code>splits[i] &lt;= splits[i+1] &lt;= input.size()</code> For a <code>splits</code> size N, there will always be N+1 splits in the output</p>
<dl class="section note"><dt>注解</dt><dd>It is the caller's responsibility to ensure that the returned views do not outlive the viewed device memory contained in the <code>all_data</code> field of the returned <a class="el" href="structcudf_1_1packed__table.html" title="The result(s) of a cudf::contiguous_split">packed_table</a>.</dd></dl>
<div class="fragment"><div class="line">Example:</div>
<div class="line">input:   [{10, 12, 14, 16, 18, 20, 22, 24, 26, 28},</div>
<div class="line">          {50, 52, 54, 56, 58, 60, 62, 64, 66, 68}]</div>
<div class="line">splits:  {2, 5, 9}</div>
<div class="line">output:  [{{10, 12}, {14, 16, 18}, {20, 22, 24, 26}, {28}},</div>
<div class="line">          {{50, 52}, {54, 56, 58}, {60, 62, 64, 66}, {68}}]</div>
</div><!-- fragment --><dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>splits</code> has end index &gt; size of <code>input</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>When the value in <code>splits</code> is not in the range [0, input.size()). </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>When the values in the <code>splits</code> are 'strictly decreasing'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">input</td><td>View of a table to split </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">splits</td><td>A vector of indices where the view will be split </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned result's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The set of requested views of <code>input</code> indicated by the <code>splits</code> and the viewed memory buffer. </dd></dl>

</div>
</div>
<a id="ga20a8a274e5efd32f012ada60ed20fbf1" name="ga20a8a274e5efd32f012ada60ed20fbf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20a8a274e5efd32f012ada60ed20fbf1">&#9670;&#160;</a></span>copy_if_else() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::copy_if_else </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>boolean_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code> </p>
<p>Selects each element i in the output column from either <code>rhs</code> or <code>lhs</code> using the following rule: <code>output[i] = (boolean_mask.valid(i) and boolean_mask[i]) ? lhs[i] : rhs[i]</code></p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if lhs and rhs are not of the same type </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if lhs and rhs are not of the same length </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of type bool </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of the same length as lhs and rhs </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>left-hand <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>right-hand <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boolean_mask</td><td>column of <code><a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd" title="Boolean using one byte per value, 0 == false, else true">type_id::BOOL8</a></code> representing "left (true) / right (false)" boolean for each element. Null element represents false. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>new column with the selected elements </dd></dl>

</div>
</div>
<a id="ga0ef360d8b66500f7da10f9cb8298e079" name="ga0ef360d8b66500f7da10f9cb8298e079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ef360d8b66500f7da10f9cb8298e079">&#9670;&#160;</a></span>copy_if_else() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::copy_if_else </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>boolean_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code> </p>
<p>Selects each element i in the output column from either <code>rhs</code> or <code>lhs</code> using the following rule: <code>output[i] = (boolean_mask.valid(i) and boolean_mask[i]) ? lhs[i] : rhs</code></p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if lhs and rhs are not of the same type </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of type bool </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of the same length as lhs </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>left-hand <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>right-hand scalar </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boolean_mask</td><td>column of <code><a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd" title="Boolean using one byte per value, 0 == false, else true">type_id::BOOL8</a></code> representing "left (true) / right (false)" boolean for each element. Null element represents false. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>new column with the selected elements </dd></dl>

</div>
</div>
<a id="ga9419155faa6145c567bc10f4a9022b2f" name="ga9419155faa6145c567bc10f4a9022b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9419155faa6145c567bc10f4a9022b2f">&#9670;&#160;</a></span>copy_if_else() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::copy_if_else </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>boolean_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code> </p>
<p>Selects each element i in the output column from either <code>rhs</code> or <code>lhs</code> using the following rule: <code>output[i] = (boolean_mask.valid(i) and boolean_mask[i]) ? lhs : rhs[i]</code></p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if lhs and rhs are not of the same type </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of type bool </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of the same length as rhs </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>left-hand scalar </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>right-hand <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boolean_mask</td><td>column of <code><a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd" title="Boolean using one byte per value, 0 == false, else true">type_id::BOOL8</a></code> representing "left (true) / right (false)" boolean for each element. Null element represents false. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>new column with the selected elements </dd></dl>

</div>
</div>
<a id="ga5f5e9508f27672af7450bbfc7a4acdb4" name="ga5f5e9508f27672af7450bbfc7a4acdb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f5e9508f27672af7450bbfc7a4acdb4">&#9670;&#160;</a></span>copy_if_else() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::copy_if_else </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>boolean_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code> </p>
<p>Selects each element i in the output column from either <code>rhs</code> or <code>lhs</code> using the following rule: <code>output[i] = (boolean_mask.valid(i) and boolean_mask[i]) ? lhs : rhs</code></p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of type bool </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>left-hand scalar </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>right-hand scalar </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boolean_mask</td><td>column of <code><a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd" title="Boolean using one byte per value, 0 == false, else true">type_id::BOOL8</a></code> representing "left (true) / right (false)" boolean for each element. null element represents false. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>new column with the selected elements </dd></dl>

</div>
</div>
<a id="ga9358e7f2ed4d47e3ee03f24ef711e402" name="ga9358e7f2ed4d47e3ee03f24ef711e402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9358e7f2ed4d47e3ee03f24ef711e402">&#9670;&#160;</a></span>copy_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::copy_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>source_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>source_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>target_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a range of elements out-of-place from one column to another. </p>
<p>Creates a new column as if an in-place copy was performed into <code>target</code>. A copy of <code>target</code> is created first and then the elements indicated by the indices [<code>target_begin</code>, <code>target_begin</code> + N) were copied from the elements indicated by the indices [<code>source_begin</code>, <code>source_end</code>) of <code>source</code> (where N = (<code>source_end</code> - <code>source_begin</code>)). Elements outside the range are copied from <code>target</code> into the returned new column target.</p>
<p>If <code>source</code> and <code>target</code> refer to the same elements and the ranges overlap, the behavior is undefined.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>for invalid range (if <code>source_begin</code> &gt; <code>source_end</code>, <code>source_begin</code> &lt; 0, <code>source_begin</code> &gt;= <code>source.size()</code>, <code>source_end</code> &gt; <code>source.size()</code>, <code>target_begin</code> &lt; 0, target_begin &gt;= <code>target.size()</code>, or <code>target_begin</code> + (<code>source_end</code> - <code>source_begin</code>) &gt; <code>target.size()</code>). </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>target</code> and <code>source</code> have different types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The column to copy from inside the range </td></tr>
    <tr><td class="paramname">target</td><td>The column to copy from outside the range </td></tr>
    <tr><td class="paramname">source_begin</td><td>The starting index of the source range (inclusive) </td></tr>
    <tr><td class="paramname">source_end</td><td>The index of the last element in the source range (exclusive) </td></tr>
    <tr><td class="paramname">target_begin</td><td>The starting index of the target range (inclusive) </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>std::unique_ptr&lt;column&gt; The result target column </dd></dl>

</div>
</div>
<a id="gaf7453a32aa49fd9a55287a776f2b4b2f" name="gaf7453a32aa49fd9a55287a776f2b4b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7453a32aa49fd9a55287a776f2b4b2f">&#9670;&#160;</a></span>copy_range_in_place()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::copy_range_in_place </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1mutable__column__view.html">mutable_column_view</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>source_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>source_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>target_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a range of elements in-place from one column to another. </p>
<p>Overwrites the range of elements in <code>target</code> indicated by the indices [<code>target_begin</code>, <code>target_begin</code> + N) with the elements from <code>source</code> indicated by the indices [<code>source_begin</code>, <code>source_end</code>) (where N = (<code>source_end</code> - <code>source_begin</code>)). Use the out-of-place copy function returning std::unique_ptr&lt;column&gt; for uses cases requiring memory reallocation. For example for strings columns and other variable-width types.</p>
<p>If <code>source</code> and <code>target</code> refer to the same elements and the ranges overlap, the behavior is undefined.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if memory reallocation is required (e.g. for variable width types). </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>for invalid range (if <code>source_begin</code> &gt; <code>source_end</code>, <code>source_begin</code> &lt; 0, <code>source_begin</code> &gt;= <code>source.size()</code>, <code>source_end</code> &gt; <code>source.size()</code>, <code>target_begin</code> &lt; 0, target_begin &gt;= <code>target.size()</code>, or <code>target_begin</code> + (<code>source_end</code> - <code>source_begin</code>) &gt; <code>target.size()</code>). </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>target</code> and <code>source</code> have different types. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>source</code> has null values and <code>target</code> is not nullable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The column to copy from </td></tr>
    <tr><td class="paramname">target</td><td>The preallocated column to copy into </td></tr>
    <tr><td class="paramname">source_begin</td><td>The starting index of the source range (inclusive) </td></tr>
    <tr><td class="paramname">source_end</td><td>The index of the last element in the source range (exclusive) </td></tr>
    <tr><td class="paramname">target_begin</td><td>The starting index of the target range (inclusive) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga62eff2fcac7ff377df316c7ef37ee4fd" name="ga62eff2fcac7ff377df316c7ef37ee4fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62eff2fcac7ff377df316c7ef37ee4fd">&#9670;&#160;</a></span>empty_like() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::empty_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes and returns an empty column of the same type as the <code>input</code>. </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Immutable view of input column to emulate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>std::unique_ptr&lt;column&gt; An empty column of same type as <code>input</code> </dd></dl>

</div>
</div>
<a id="gadf190ab1fe40049bc95bf7aebad93450" name="gadf190ab1fe40049bc95bf7aebad93450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf190ab1fe40049bc95bf7aebad93450">&#9670;&#160;</a></span>empty_like() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::empty_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes and returns an empty column of the same type as the <code>input</code>. </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Scalar to emulate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>std::unique_ptr&lt;column&gt; An empty column of same type as <code>input</code> </dd></dl>

</div>
</div>
<a id="gaf51eaa0bed9085f857e8edbcb4141d76" name="gaf51eaa0bed9085f857e8edbcb4141d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf51eaa0bed9085f857e8edbcb4141d76">&#9670;&#160;</a></span>empty_like() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt; cudf::empty_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input_table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a table of empty columns with the same types as the <code>input_table</code> </p>
<p>Creates the <code><a class="el" href="classcudf_1_1column.html" title="A container of nullable device data as a column of elements.">cudf::column</a></code> objects, but does not allocate any underlying device memory for the column's data or bitmask.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_table</td><td>Immutable view of input table to emulate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>std::unique_ptr&lt;table&gt; A table of empty columns with the same types as the columns in <code>input_table</code> </dd></dl>

</div>
</div>
<a id="ga19ea162e7794e6cbbc2faba70fbd91aa" name="ga19ea162e7794e6cbbc2faba70fbd91aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19ea162e7794e6cbbc2faba70fbd91aa">&#9670;&#160;</a></span>gather()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt; cudf::gather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>source_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>gather_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__column__copy.html#gae3ba74951558bc7966aae86abc6af5df">out_of_bounds_policy</a>&#160;</td>
          <td class="paramname"><em>bounds_policy</em> = <code><a class="el" href="group__column__copy.html#ggae3ba74951558bc7966aae86abc6af5dfa12c1109487cf9a6a336b1dfe462bfd2d">out_of_bounds_policy::DONT_CHECK</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gathers the specified rows (including null values) of a set of columns. </p>
<p>Gathers the rows of the source columns according to <code>gather_map</code> such that row "i" in the resulting table's columns will contain row "gather_map[i]" from the source columns. The number of rows in the result table will be equal to the number of elements in <code>gather_map</code>.</p>
<p>A negative value <code>i</code> in the <code>gather_map</code> is interpreted as <code>i+n</code>, where <code>n</code> is the number of rows in the <code>source_table</code>.</p>
<p>For dictionary columns, the keys column component is copied and not trimmed if the gather results in abandoned key elements.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if gather_map contains null values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source_table</td><td>The input columns whose rows will be gathered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gather_map</td><td>View into a non-nullable column of integral indices that maps the rows in the source columns to rows in the destination columns. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bounds_policy</td><td>Policy to apply to account for possible out-of-bounds indices <code>DONT_CHECK</code> skips all bounds checking for gather map values. <code>NULLIFY</code> coerces rows that corresponds to out-of-bounds indices in the gather map to be null elements. Callers should use <code>DONT_CHECK</code> when they are certain that the gather_map contains only valid indices for better performance. If <code>policy</code> is set to <code>DONT_CHECK</code> and there are out-of-bounds indices in the gather map, the behavior is undefined. Defaults to <code>DONT_CHECK</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned table's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>std::unique_ptr&lt;table&gt; Result of the gather </dd></dl>

</div>
</div>
<a id="ga3c310958af4e031737d80ba8015452b6" name="ga3c310958af4e031737d80ba8015452b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c310958af4e031737d80ba8015452b6">&#9670;&#160;</a></span>get_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt; cudf::get_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the element at specified index from a column </p>
<dl class="section warning"><dt>警告</dt><dd>This function is expensive (invokes a kernel launch). So, it is not recommended to be used in performance sensitive code or inside a loop.</dd></dl>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>index</code> is not within the range <code>[0, input.size())</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Column view to get the element from </td></tr>
    <tr><td class="paramname">index</td><td>Index into <code>input</code> to get the element at </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned scalar's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>std::unique_ptr&lt;scalar&gt; Scalar containing the single value </dd></dl>

</div>
</div>
<a id="ga0c61528cb588874f9c07c6f766f232db" name="ga0c61528cb588874f9c07c6f766f232db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c61528cb588874f9c07c6f766f232db">&#9670;&#160;</a></span>has_nonempty_nulls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cudf::has_nonempty_nulls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a column or its descendants have non-empty null rows </p>
<dl class="section note"><dt>注解</dt><dd>This function is exact. If it returns <code>true</code>, there exists one or more non-empty null elements.</dd></dl>
<p>A LIST or STRING column might have non-empty rows that are marked as null. A STRUCT OR LIST column might have child columns that have non-empty null rows. Other types of columns are deemed incapable of having non-empty null rows. E.g. Fixed width columns have no concept of an "empty" row.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The column which is (and whose descendants are) to be checked for non-empty null rows. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>true If either the column or its descendants have non-empty null rows </dd>
<dd>
false If neither the column or its descendants have non-empty null rows </dd></dl>

</div>
</div>
<a id="ga9a9c46582ed07509d4bfe24e50d59bf2" name="ga9a9c46582ed07509d4bfe24e50d59bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a9c46582ed07509d4bfe24e50d59bf2">&#9670;&#160;</a></span>may_have_nonempty_nulls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cudf::may_have_nonempty_nulls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Approximates if a column or its descendants <em>may</em> have non-empty null elements </p>
<dl class="section note"><dt>注解</dt><dd>This function is approximate.<ul>
<li><code>true</code>: Non-empty null elements could exist</li>
<li><code>false</code>: Non-empty null elements definitely do not exist</li>
</ul>
</dd></dl>
<p>False positives are possible, but false negatives are not.</p>
<p>Compared to the exact <code><a class="el" href="group__column__copy.html#ga0c61528cb588874f9c07c6f766f232db" title="Checks if a column or its descendants have non-empty null rows">has_nonempty_nulls()</a></code> function, this function is typically more efficient.</p>
<p>Complexity:</p><ul>
<li>Best case: <code>O(count_descendants(input))</code></li>
<li>Worst case: <code>O(count_descendants(input)) * m</code>, where <code>m</code> is the number of rows in the largest descendant</li>
</ul>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The column which is (and whose descendants are) to be checked for non-empty null rows </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>true If either the column or its descendants have null rows </dd>
<dd>
false If neither the column nor its descendants have null rows </dd></dl>

</div>
</div>
<a id="gaeb39dd8301fb76bfec9e777820bda3f2" name="gaeb39dd8301fb76bfec9e777820bda3f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb39dd8301fb76bfec9e777820bda3f2">&#9670;&#160;</a></span>pack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1packed__columns.html">packed_columns</a> cudf::pack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deep-copy a <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> into a serialized contiguous memory format </p>
<p>The metadata from the <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> is copied into a host vector of bytes and the data from the <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> is copied into a <code>device_buffer</code>. Pass the output of this function into <code><a class="el" href="group__column__copy.html#ga1d62a18c2e6f087a92289c63693762cc" title="Deserialize the result of cudf::pack">cudf::unpack</a></code> to deserialize.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">input</td><td>View of the table to pack </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Optional, The resource to use for all returned device allocations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><a class="el" href="structcudf_1_1packed__columns.html" title="Column data in a serialized format">packed_columns</a> A struct containing the serialized metadata and data in contiguous host and device memory respectively </dd></dl>

</div>
</div>
<a id="gab28fc2d2294f2840df37814e7a4aa582" name="gab28fc2d2294f2840df37814e7a4aa582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab28fc2d2294f2840df37814e7a4aa582">&#9670;&#160;</a></span>pack_metadata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1packed__columns_1_1metadata.html">packed_columns::metadata</a> cudf::pack_metadata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const *&#160;</td>
          <td class="paramname"><em>contiguous_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produce the metadata used for packing a table stored in a contiguous buffer. </p>
<p>The metadata from the <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> is copied into a host vector of bytes which can be used to construct a <code><a class="el" href="structcudf_1_1packed__columns.html" title="Column data in a serialized format">packed_columns</a></code> or <code><a class="el" href="structcudf_1_1packed__table.html" title="The result(s) of a cudf::contiguous_split">packed_table</a></code> structure. The caller is responsible for guaranteeing that that all of the columns in the table point into <code>contiguous_buffer</code>.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>View of the table to pack </td></tr>
    <tr><td class="paramname">contiguous_buffer</td><td>A contiguous buffer of device memory which contains the data referenced by the columns in <code>table</code> </td></tr>
    <tr><td class="paramname">buffer_size</td><td>The size of <code>contiguous_buffer</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Vector of bytes representing the metadata used to <code>unpack</code> a <a class="el" href="structcudf_1_1packed__columns.html" title="Column data in a serialized format">packed_columns</a> struct </dd></dl>

</div>
</div>
<a id="ga387d2221ad89e737e89270bf8c56dfa5" name="ga387d2221ad89e737e89270bf8c56dfa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga387d2221ad89e737e89270bf8c56dfa5">&#9670;&#160;</a></span>purge_nonempty_nulls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::purge_nonempty_nulls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy <code>input</code> into output while purging any non-empty null rows in the column or its descendants. </p>
<p>If the input column is not of compound type (LIST/STRING/STRUCT/DICTIONARY), the output will be the same as input.</p>
<p>The purge operation only applies directly to LIST and STRING columns, but it applies indirectly to STRUCT/DICTIONARY columns as well, since these columns may have child columns that are LIST or STRING.</p>
<p>Examples:</p>
<div class="fragment"><div class="line">auto const lists   = lists_column_wrapper&lt;int32_t&gt;{ {0,1}, {2,3}, {4,5} }.release();</div>
<div class="line">cudf::detail::set_null_mask(lists-&gt;null_mask(), 1, 2, false);</div>
<div class="line"> </div>
<div class="line">lists[1] is now null, but the lists child column still stores `{2,3}`.</div>
<div class="line">The lists column contents will be:</div>
<div class="line">  Validity: 101</div>
<div class="line">  Offsets:  [0, 2, 4, 6]</div>
<div class="line">  Child:    [0, 1, 2, 3, 4, 5]</div>
<div class="line"> </div>
<div class="line">After purging the contents of the list&#39;s null rows, the column&#39;s contents will be:</div>
<div class="line">  Validity: 101</div>
<div class="line">  Offsets:  [0, 2, 2, 4]</div>
<div class="line">  Child:    [0, 1, 4, 5]</div>
</div><!-- fragment --><div class="fragment"><div class="line">auto const strings = strings_column_wrapper{ &quot;AB&quot;, &quot;CD&quot;, &quot;EF&quot; }.release();</div>
<div class="line">cudf::detail::set_null_mask(strings-&gt;null_mask(), 1, 2, false);</div>
<div class="line"> </div>
<div class="line">strings[1] is now null, but the strings column still stores `&quot;CD&quot;`.</div>
<div class="line">The lists column contents will be:</div>
<div class="line">  Validity: 101</div>
<div class="line">  Offsets:  [0, 2, 4, 6]</div>
<div class="line">  Child:    [A, B, C, D, E, F]</div>
<div class="line"> </div>
<div class="line">After purging the contents of the list&#39;s null rows, the column&#39;s contents</div>
<div class="line">will be:</div>
<div class="line">  Validity: 101</div>
<div class="line">  Offsets:  [0, 2, 2, 4]</div>
<div class="line">  Child:    [A, B, E, F]</div>
</div><!-- fragment --><div class="fragment"><div class="line">auto const lists   = lists_column_wrapper&lt;int32_t&gt;{ {0,1}, {2,3}, {4,5} };</div>
<div class="line">auto const structs = structs_column_wrapper{ {lists}, null_at(1) };</div>
<div class="line"> </div>
<div class="line">structs[1].child is now null, but the lists column still stores `{2,3}`.</div>
<div class="line">The lists column contents will be:</div>
<div class="line">  Validity: 101</div>
<div class="line">  Offsets:  [0, 2, 4, 6]</div>
<div class="line">  Child:    [0, 1, 2, 3, 4, 5]</div>
<div class="line"> </div>
<div class="line">After purging the contents of the list&#39;s null rows, the column&#39;s contents</div>
<div class="line">will be:</div>
<div class="line">  Validity: 101</div>
<div class="line">  Offsets:  [0, 2, 2, 4]</div>
<div class="line">  Child:    [0, 1, 4, 5]</div>
</div><!-- fragment --><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The column whose null rows are to be checked and purged </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A new column with equivalent contents to <code>input</code>, but with null rows purged </dd></dl>

</div>
</div>
<a id="ga6f6bd5517ff6f32a20b20d66a22616a7" name="ga6f6bd5517ff6f32a20b20d66a22616a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f6bd5517ff6f32a20b20d66a22616a7">&#9670;&#160;</a></span>reverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>source_column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses the elements of a column </p>
<p>Creates a new column that is the reverse of <code>source_column</code>. Example: </p><div class="fragment"><div class="line">source = [4,5,6]</div>
<div class="line"><span class="keywordflow">return</span> = [6,5,4]</div>
</div><!-- fragment --><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_column</td><td>Column that will be reversed </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned table's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Reversed column </dd></dl>

</div>
</div>
<a id="gafbbf4a02a5108cbcd9368ce31efc7f2a" name="gafbbf4a02a5108cbcd9368ce31efc7f2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbbf4a02a5108cbcd9368ce31efc7f2a">&#9670;&#160;</a></span>reverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt; cudf::reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>source_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses the rows within a table. </p>
<p>Creates a new table that is the reverse of <code>source_table</code>. Example: </p><div class="fragment"><div class="line">source = [[4,5,6], [7,8,9], [10,11,12]]</div>
<div class="line"><span class="keywordflow">return</span> = [[6,5,4], [9,8,7], [12,11,10]]</div>
</div><!-- fragment --><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_table</td><td>Table that will be reversed </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned table's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Reversed table </dd></dl>

</div>
</div>
<a id="ga29e76351f1ae5bd91dc922ad24243b1f" name="ga29e76351f1ae5bd91dc922ad24243b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29e76351f1ae5bd91dc922ad24243b1f">&#9670;&#160;</a></span>sample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt; cudf::sample </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__column__copy.html#gae7607cde56cb602ab1b198b5bebf7cba">sample_with_replacement</a>&#160;</td>
          <td class="paramname"><em>replacement</em> = <code><a class="el" href="group__column__copy.html#ggae7607cde56cb602ab1b198b5bebf7cbaa946003f97ccc52d5d3b54ac0ec31bbfc">sample_with_replacement::FALSE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t const&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gather <code>n</code> samples from given <code>input</code> randomly </p>
<div class="fragment"><div class="line">Example:</div>
<div class="line">input: {col1: {1, 2, 3, 4, 5}, col2: {6, 7, 8, 9, 10}}</div>
<div class="line">n: 3</div>
<div class="line">replacement: false</div>
<div class="line"> </div>
<div class="line">output:       {col1: {3, 1, 4}, col2: {8, 6, 9}}</div>
<div class="line"> </div>
<div class="line">replacement: true</div>
<div class="line"> </div>
<div class="line">output:       {col1: {3, 1, 1}, col2: {8, 6, 6}}</div>
</div><!-- fragment --><dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>n</code> &gt; <code>input.num_rows()</code> and <code>replacement</code> == FALSE. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>n</code> &lt; 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>View of a table to sample </td></tr>
    <tr><td class="paramname">n</td><td>non-negative number of samples expected from <code>input</code> </td></tr>
    <tr><td class="paramname">replacement</td><td>Allow or disallow sampling of the same row more than once </td></tr>
    <tr><td class="paramname">seed</td><td>Seed value to initiate random number generator </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned table's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>std::unique_ptr&lt;table&gt; Table containing samples from <code>input</code> </dd></dl>

</div>
</div>
<a id="ga474f55905324aea8ed00ff8e3e3fecea" name="ga474f55905324aea8ed00ff8e3e3fecea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga474f55905324aea8ed00ff8e3e3fecea">&#9670;&#160;</a></span>scatter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt; cudf::scatter </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scatters a row of scalar values into a copy of the target table according to a scatter map. </p>
<p>Scatters values from the source row into the target table out-of-place, returning a "destination table". The scatter is performed according to a scatter map such that row <code>scatter_map[i]</code> of the destination table is replaced by the source row. All other rows of the destination table equal corresponding rows of the target table.</p>
<p>The number of elements in source must match the number of columns in target and their corresponding datatypes must be the same.</p>
<p>If the same index appears more than once in the scatter map, the result is undefined.</p>
<p>If any values in <code>scatter_map</code> are outside of the interval [-n, n) where <code>n</code> is the number of rows in the <code>target</code> table, behavior is undefined.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The input scalars containing values to be scattered into the target columns </td></tr>
    <tr><td class="paramname">indices</td><td>A non-nullable column of integral indices that indicate the rows in the target table to be replaced by source. </td></tr>
    <tr><td class="paramname">target</td><td>The set of columns into which values from the source_table are to be scattered </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned table's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Result of scattering values from source to target </dd></dl>

</div>
</div>
<a id="gabd90ba38ea2655ce3b435d2a4f199358" name="gabd90ba38ea2655ce3b435d2a4f199358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd90ba38ea2655ce3b435d2a4f199358">&#9670;&#160;</a></span>scatter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt; cudf::scatter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>scatter_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scatters the rows of the source table into a copy of the target table according to a scatter map. </p>
<p>Scatters values from the source table into the target table out-of-place, returning a "destination table". The scatter is performed according to a scatter map such that row <code>scatter_map[i]</code> of the destination table gets row <code>i</code> of the source table. All other rows of the destination table equal corresponding rows of the target table.</p>
<p>The number of columns in source must match the number of columns in target and their corresponding datatypes must be the same.</p>
<p>If the same index appears more than once in the scatter map, the result is undefined.</p>
<p>If any values in <code>scatter_map</code> are outside of the interval [-n, n) where <code>n</code> is the number of rows in the <code>target</code> table, behavior is undefined.</p>
<p>A negative value <code>i</code> in the <code>scatter_map</code> is interpreted as <code>i+n</code>, where <code>n</code> is the number of rows in the <code>target</code> table.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The input columns containing values to be scattered into the target columns </td></tr>
    <tr><td class="paramname">scatter_map</td><td>A non-nullable column of integral indices that maps the rows in the source table to rows in the target table. The size must be equal to or less than the number of elements in the source columns. </td></tr>
    <tr><td class="paramname">target</td><td>The set of columns into which values from the source_table are to be scattered </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned table's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Result of scattering values from source to target </dd></dl>

</div>
</div>
<a id="ga80b6ccd43dbb2359d520a3f3ea100e8e" name="ga80b6ccd43dbb2359d520a3f3ea100e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80b6ccd43dbb2359d520a3f3ea100e8e">&#9670;&#160;</a></span>shift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::shift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>fill_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new column by shifting all values by an offset. </p>
<p>Elements will be determined by <code>output[idx] = input[idx - offset]</code>. Some elements in the output may be indeterminable from the input. For those elements, the value will be determined by <code>fill_values</code>.</p>
<div class="fragment"><div class="line">Examples</div>
<div class="line">-------------------------------------------------</div>
<div class="line">input       = [0, 1, 2, 3, 4]</div>
<div class="line">offset      = 3</div>
<div class="line">fill_values = @</div>
<div class="line">return      = [@, @, @, 0, 1]</div>
<div class="line">-------------------------------------------------</div>
<div class="line">input       = [5, 4, 3, 2, 1]</div>
<div class="line">offset      = -2</div>
<div class="line">fill_values = 7</div>
<div class="line">return      = [3, 2, 1, 7, 7]</div>
</div><!-- fragment --><dl class="section note"><dt>注解</dt><dd>if the input is nullable, the output will be nullable. </dd>
<dd>
if the fill value is null, the output will be nullable.</dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Column to be shifted </td></tr>
    <tr><td class="paramname">offset</td><td>The offset by which to shift the input </td></tr>
    <tr><td class="paramname">fill_value</td><td>Fill value for indeterminable outputs </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned result's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>input</code> dtype is neither fixed-width nor string type </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>fill_value</code> dtype does not match <code>input</code> dtype.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The shifted column </dd></dl>

</div>
</div>
<a id="ga52223b0ef6807f9a2454f7395b5425d4" name="ga52223b0ef6807f9a2454f7395b5425d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52223b0ef6807f9a2454f7395b5425d4">&#9670;&#160;</a></span>slice() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classcudf_1_1column__view.html">column_view</a> &gt; cudf::slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slices a <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> into a set of <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code>s according to a set of indices. </p>
<p>The returned views of <code>input</code> are constructed from an even number indices where the <code>i</code>th returned <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> views the elements in <code>input</code> indicated by the range <code>[indices[2*i], indices[(2*i)+1])</code>.</p>
<p>For all <code>i</code> it is expected <code>indices[i] &lt;= input.size()</code> For all <code>i%2==0</code>, it is expected that <code>indices[i] &lt;= indices[i+1]</code></p>
<dl class="section note"><dt>注解</dt><dd>It is the caller's responsibility to ensure that the returned views do not outlive the viewed device memory.</dd></dl>
<div class="fragment"><div class="line">input:   {10, 12, 14, 16, 18, 20, 22, 24, 26, 28}</div>
<div class="line">indices: {1, 3, 5, 9, 2, 4, 8, 8}</div>
<div class="line">output:  {{12, 14}, {20, 22, 24, 26}, {14, 16}, {}}</div>
</div><!-- fragment --><dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>indices</code> size is not even. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>When the values in the pair are strictly decreasing. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>When any of the values in the pair don't belong to the range [0, input.size()).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>View of column to slice </td></tr>
    <tr><td class="paramname">indices</td><td>Indices used to take slices of <code>input</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Vector of views of <code>input</code> indicated by the ranges in <code>indices</code> </dd></dl>

</div>
</div>
<a id="ga77b1d2c6579fa0ad8da690c8cd4c3192" name="ga77b1d2c6579fa0ad8da690c8cd4c3192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77b1d2c6579fa0ad8da690c8cd4c3192">&#9670;&#160;</a></span>slice() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classcudf_1_1column__view.html">column_view</a> &gt; cudf::slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Slices a <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> into a set of <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code>s according to a set of indices.  </p>
<p>The returned views of <code>input</code> are constructed from an even number indices where the <code>i</code>th returned <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> views the elements in <code>input</code> indicated by the range <code>[indices[2*i], indices[(2*i)+1])</code>.</p>
<p>For all <code>i</code> it is expected <code>indices[i] &lt;= input.size()</code> For all <code>i%2==0</code>, it is expected that <code>indices[i] &lt;= indices[i+1]</code></p>
<dl class="section note"><dt>注解</dt><dd>It is the caller's responsibility to ensure that the returned views do not outlive the viewed device memory.</dd></dl>
<div class="fragment"><div class="line">input:   {10, 12, 14, 16, 18, 20, 22, 24, 26, 28}</div>
<div class="line">indices: {1, 3, 5, 9, 2, 4, 8, 8}</div>
<div class="line">output:  {{12, 14}, {20, 22, 24, 26}, {14, 16}, {}}</div>
</div><!-- fragment --><dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>indices</code> size is not even. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>When the values in the pair are strictly decreasing. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>When any of the values in the pair don't belong to the range [0, input.size()).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>View of column to slice </td></tr>
    <tr><td class="paramname">indices</td><td>Indices used to take slices of <code>input</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Vector of views of <code>input</code> indicated by the ranges in <code>indices</code>   </dd></dl>

</div>
</div>
<a id="ga61a6785244331834b458545e084b7017" name="ga61a6785244331834b458545e084b7017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61a6785244331834b458545e084b7017">&#9670;&#160;</a></span>slice() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classcudf_1_1table__view.html">table_view</a> &gt; cudf::slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slices a <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> into a set of <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code>s according to a set of indices. </p>
<p>The returned views of <code>input</code> are constructed from an even number indices where the <code>i</code>th returned <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> views the elements in <code>input</code> indicated by the range <code>[indices[2*i], indices[(2*i)+1])</code>.</p>
<p>For all <code>i</code> it is expected <code>indices[i] &lt;= input.size()</code> For all <code>i%2==0</code>, it is expected that <code>indices[i] &lt;= indices[i+1]</code></p>
<dl class="section note"><dt>注解</dt><dd>It is the caller's responsibility to ensure that the returned views do not outlive the viewed device memory.</dd></dl>
<div class="fragment"><div class="line">input:   [{10, 12, 14, 16, 18, 20, 22, 24, 26, 28},</div>
<div class="line">          {50, 52, 54, 56, 58, 60, 62, 64, 66, 68}]</div>
<div class="line">indices: {1, 3, 5, 9, 2, 4, 8, 8}</div>
<div class="line">output:  [{{12, 14}, {20, 22, 24, 26}, {14, 16}, {}},</div>
<div class="line">          {{52, 54}, {60, 22, 24, 26}, {14, 16}, {}}]</div>
</div><!-- fragment --><dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>indices</code> size is not even. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>When the values in the pair are strictly decreasing. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>When any of the values in the pair don't belong to the range [0, input.size()).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>View of table to slice </td></tr>
    <tr><td class="paramname">indices</td><td>Indices used to take slices of <code>input</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Vector of views of <code>input</code> indicated by the ranges in <code>indices</code> </dd></dl>

</div>
</div>
<a id="gaadc72fabae41e8187065211ebe7d6cce" name="gaadc72fabae41e8187065211ebe7d6cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadc72fabae41e8187065211ebe7d6cce">&#9670;&#160;</a></span>slice() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classcudf_1_1table__view.html">table_view</a> &gt; cudf::slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Slices a <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> into a set of <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code>s according to a set of indices.  </p>
<p>The returned views of <code>input</code> are constructed from an even number indices where the <code>i</code>th returned <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> views the elements in <code>input</code> indicated by the range <code>[indices[2*i], indices[(2*i)+1])</code>.</p>
<p>For all <code>i</code> it is expected <code>indices[i] &lt;= input.size()</code> For all <code>i%2==0</code>, it is expected that <code>indices[i] &lt;= indices[i+1]</code></p>
<dl class="section note"><dt>注解</dt><dd>It is the caller's responsibility to ensure that the returned views do not outlive the viewed device memory.</dd></dl>
<div class="fragment"><div class="line">input:   [{10, 12, 14, 16, 18, 20, 22, 24, 26, 28},</div>
<div class="line">          {50, 52, 54, 56, 58, 60, 62, 64, 66, 68}]</div>
<div class="line">indices: {1, 3, 5, 9, 2, 4, 8, 8}</div>
<div class="line">output:  [{{12, 14}, {20, 22, 24, 26}, {14, 16}, {}},</div>
<div class="line">          {{52, 54}, {60, 22, 24, 26}, {14, 16}, {}}]</div>
</div><!-- fragment --><dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>indices</code> size is not even. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>When the values in the pair are strictly decreasing. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>When any of the values in the pair don't belong to the range [0, input.size()).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>View of table to slice </td></tr>
    <tr><td class="paramname">indices</td><td>Indices used to take slices of <code>input</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Vector of views of <code>input</code> indicated by the ranges in <code>indices</code>   </dd></dl>

</div>
</div>
<a id="ga95ac220988903ef24d698ff49c683bfc" name="ga95ac220988903ef24d698ff49c683bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95ac220988903ef24d698ff49c683bfc">&#9670;&#160;</a></span>split() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classcudf_1_1column__view.html">column_view</a> &gt; cudf::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt;&#160;</td>
          <td class="paramname"><em>splits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> into a set of <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code>s according to a set of indices derived from expected splits. </p>
<p>The returned view's of <code>input</code> are constructed from vector of splits, which indicates where the split should occur. The <code>i</code>th returned <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> is sliced as <code>[0, splits[i])</code> if <code>i</code>=0, else <code>[splits[i], input.size())</code> if <code>i</code> is the last view and <code>[splits[i-1], splits[i]]</code> otherwise.</p>
<p>For all <code>i</code> it is expected <code>splits[i] &lt;= splits[i+1] &lt;= input.size()</code> For a <code>splits</code> size N, there will always be N+1 splits in the output</p>
<dl class="section note"><dt>注解</dt><dd>It is the caller's responsibility to ensure that the returned views do not outlive the viewed device memory.</dd></dl>
<div class="fragment"><div class="line">Example:</div>
<div class="line">input:   {10, 12, 14, 16, 18, 20, 22, 24, 26, 28}</div>
<div class="line">splits:  {2, 5, 9}</div>
<div class="line">output:  {{10, 12}, {14, 16, 18}, {20, 22, 24, 26}, {28}}</div>
</div><!-- fragment --><dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>splits</code> has end index &gt; size of <code>input</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>When the value in <code>splits</code> is not in the range [0, input.size()). </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>When the values in the <code>splits</code> are 'strictly decreasing'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>View of column to split </td></tr>
    <tr><td class="paramname">splits</td><td>Indices where the view will be split </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The set of requested views of <code>input</code> indicated by the <code>splits</code> </dd></dl>

</div>
</div>
<a id="ga5fb87b85cb2fedb682a6f4103414f97f" name="ga5fb87b85cb2fedb682a6f4103414f97f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fb87b85cb2fedb682a6f4103414f97f">&#9670;&#160;</a></span>split() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classcudf_1_1column__view.html">column_view</a> &gt; cudf::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt;&#160;</td>
          <td class="paramname"><em>splits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Splits a <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> into a set of <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code>s according to a set of indices derived from expected splits.  </p>
<p>The returned view's of <code>input</code> are constructed from vector of splits, which indicates where the split should occur. The <code>i</code>th returned <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> is sliced as <code>[0, splits[i])</code> if <code>i</code>=0, else <code>[splits[i], input.size())</code> if <code>i</code> is the last view and <code>[splits[i-1], splits[i]]</code> otherwise.</p>
<p>For all <code>i</code> it is expected <code>splits[i] &lt;= splits[i+1] &lt;= input.size()</code> For a <code>splits</code> size N, there will always be N+1 splits in the output</p>
<dl class="section note"><dt>注解</dt><dd>It is the caller's responsibility to ensure that the returned views do not outlive the viewed device memory.</dd></dl>
<div class="fragment"><div class="line">Example:</div>
<div class="line">input:   {10, 12, 14, 16, 18, 20, 22, 24, 26, 28}</div>
<div class="line">splits:  {2, 5, 9}</div>
<div class="line">output:  {{10, 12}, {14, 16, 18}, {20, 22, 24, 26}, {28}}</div>
</div><!-- fragment --><dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>splits</code> has end index &gt; size of <code>input</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>When the value in <code>splits</code> is not in the range [0, input.size()). </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>When the values in the <code>splits</code> are 'strictly decreasing'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>View of column to split </td></tr>
    <tr><td class="paramname">splits</td><td>Indices where the view will be split </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The set of requested views of <code>input</code> indicated by the <code>splits</code>   </dd></dl>

</div>
</div>
<a id="ga72d5748fbf4bd848295769dce8a80979" name="ga72d5748fbf4bd848295769dce8a80979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72d5748fbf4bd848295769dce8a80979">&#9670;&#160;</a></span>split() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classcudf_1_1table__view.html">table_view</a> &gt; cudf::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt;&#160;</td>
          <td class="paramname"><em>splits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> into a set of <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code>s according to a set of indices derived from expected splits. </p>
<p>The returned views of <code>input</code> are constructed from vector of splits, which indicates where the split should occur. The <code>i</code>th returned <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> is sliced as <code>[0, splits[i])</code> if <code>i</code>=0, else <code>[splits[i], input.size())</code> if <code>i</code> is the last view and <code>[splits[i-1], splits[i]]</code> otherwise.</p>
<p>For all <code>i</code> it is expected <code>splits[i] &lt;= splits[i+1] &lt;= input.size()</code> For a <code>splits</code> size N, there will always be N+1 splits in the output</p>
<dl class="section note"><dt>注解</dt><dd>It is the caller's responsibility to ensure that the returned views do not outlive the viewed device memory.</dd></dl>
<div class="fragment"><div class="line">Example:</div>
<div class="line">input:   [{10, 12, 14, 16, 18, 20, 22, 24, 26, 28},</div>
<div class="line">          {50, 52, 54, 56, 58, 60, 62, 64, 66, 68}]</div>
<div class="line">splits:  {2, 5, 9}</div>
<div class="line">output:  [{{10, 12}, {14, 16, 18}, {20, 22, 24, 26}, {28}},</div>
<div class="line">          {{50, 52}, {54, 56, 58}, {60, 62, 64, 66}, {68}}]</div>
</div><!-- fragment --><dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>splits</code> has end index &gt; size of <code>input</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>When the value in <code>splits</code> is not in the range [0, input.size()). </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>When the values in the <code>splits</code> are 'strictly decreasing'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>View of a table to split </td></tr>
    <tr><td class="paramname">splits</td><td>Indices where the view will be split </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The set of requested views of <code>input</code> indicated by the <code>splits</code> </dd></dl>

</div>
</div>
<a id="ga94277c977c86ac93ebb279f562906aa0" name="ga94277c977c86ac93ebb279f562906aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94277c977c86ac93ebb279f562906aa0">&#9670;&#160;</a></span>split() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classcudf_1_1table__view.html">table_view</a> &gt; cudf::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt;&#160;</td>
          <td class="paramname"><em>splits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Splits a <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> into a set of <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code>s according to a set of indices derived from expected splits.  </p>
<p>The returned views of <code>input</code> are constructed from vector of splits, which indicates where the split should occur. The <code>i</code>th returned <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> is sliced as <code>[0, splits[i])</code> if <code>i</code>=0, else <code>[splits[i], input.size())</code> if <code>i</code> is the last view and <code>[splits[i-1], splits[i]]</code> otherwise.</p>
<p>For all <code>i</code> it is expected <code>splits[i] &lt;= splits[i+1] &lt;= input.size()</code> For a <code>splits</code> size N, there will always be N+1 splits in the output</p>
<dl class="section note"><dt>注解</dt><dd>It is the caller's responsibility to ensure that the returned views do not outlive the viewed device memory.</dd></dl>
<div class="fragment"><div class="line">Example:</div>
<div class="line">input:   [{10, 12, 14, 16, 18, 20, 22, 24, 26, 28},</div>
<div class="line">          {50, 52, 54, 56, 58, 60, 62, 64, 66, 68}]</div>
<div class="line">splits:  {2, 5, 9}</div>
<div class="line">output:  [{{10, 12}, {14, 16, 18}, {20, 22, 24, 26}, {28}},</div>
<div class="line">          {{50, 52}, {54, 56, 58}, {60, 62, 64, 66}, {68}}]</div>
</div><!-- fragment --><dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>splits</code> has end index &gt; size of <code>input</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>When the value in <code>splits</code> is not in the range [0, input.size()). </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>When the values in the <code>splits</code> are 'strictly decreasing'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>View of a table to split </td></tr>
    <tr><td class="paramname">splits</td><td>Indices where the view will be split </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The set of requested views of <code>input</code> indicated by the <code>splits</code>   </dd></dl>

</div>
</div>
<a id="ga1d62a18c2e6f087a92289c63693762cc" name="ga1d62a18c2e6f087a92289c63693762cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d62a18c2e6f087a92289c63693762cc">&#9670;&#160;</a></span>unpack() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcudf_1_1table__view.html">table_view</a> cudf::unpack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1packed__columns.html">packed_columns</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserialize the result of <code><a class="el" href="group__column__copy.html#gaeb39dd8301fb76bfec9e777820bda3f2" title="Deep-copy a table_view into a serialized contiguous memory format">cudf::pack</a></code> </p>
<p>Converts the result of a serialized table into a <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> that points to the data stored in the contiguous device buffer contained in <code>input</code>.</p>
<p>It is the caller's responsibility to ensure that the <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> in the output does not outlive the data in the input.</p>
<p>No new device memory is allocated in this function.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The packed columns to unpack </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The unpacked <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> </dd></dl>

</div>
</div>
<a id="gaaaebfb6742c09cccda8fb8a78e19fbd6" name="gaaaebfb6742c09cccda8fb8a78e19fbd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaaebfb6742c09cccda8fb8a78e19fbd6">&#9670;&#160;</a></span>unpack() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcudf_1_1table__view.html">table_view</a> cudf::unpack </td>
          <td>(</td>
          <td class="paramtype">uint8_t const *&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const *&#160;</td>
          <td class="paramname"><em>gpu_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserialize the result of <code><a class="el" href="group__column__copy.html#gaeb39dd8301fb76bfec9e777820bda3f2" title="Deep-copy a table_view into a serialized contiguous memory format">cudf::pack</a></code> </p>
<p>Converts the result of a serialized table into a <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> that points to the data stored in the contiguous device buffer contained in <code>gpu_data</code> using the metadata contained in the host buffer <code>metadata</code>.</p>
<p>It is the caller's responsibility to ensure that the <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> in the output does not outlive the data in the input.</p>
<p>No new device memory is allocated in this function.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">metadata</td><td>The host-side metadata buffer resulting from the initial <a class="el" href="group__column__copy.html#gaeb39dd8301fb76bfec9e777820bda3f2" title="Deep-copy a table_view into a serialized contiguous memory format">pack()</a> call </td></tr>
    <tr><td class="paramname">gpu_data</td><td>The device-side contiguous buffer storing the data that will be referenced by the resulting <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The unpacked <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
