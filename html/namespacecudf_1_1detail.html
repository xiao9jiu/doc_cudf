<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: cudf::detail 命名空间参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacecudf_1_1detail.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">类</a> &#124;
<a href="#typedef-members">类型定义</a> &#124;
<a href="#enum-members">枚举</a> &#124;
<a href="#func-members">函数</a> &#124;
<a href="#var-members">变量</a>  </div>
  <div class="headertitle"><div class="title">cudf::detail 命名空间参考<div class="ingroups"><a class="el" href="group__aggregation__factories.html">Aggregation_factories</a> &#124; <a class="el" href="group__scalar__classes.html">Scalar_classes</a> &#124; <a class="el" href="group__utility__types.html">Utility_types</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Inner interfaces and implementations  
<a href="namespacecudf_1_1detail.html#details">更多...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
类</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1aggregation__finalizer.html">aggregation_finalizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1all__aggregation.html">all_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class for specifying an all aggregation  <a href="classcudf_1_1detail_1_1all__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1any__aggregation.html">any_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class for specifying an any aggregation  <a href="classcudf_1_1detail_1_1any__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1argmax__aggregation.html">argmax_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class for specifying an argmax aggregation  <a href="classcudf_1_1detail_1_1argmax__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1argmin__aggregation.html">argmin_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class for specifying an argmin aggregation  <a href="classcudf_1_1detail_1_1argmin__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1base__2dspan.html">base_2dspan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic class for row-major 2D spans. Not compliant with STL container semantics/syntax.  <a href="classcudf_1_1detail_1_1base__2dspan.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1collect__list__aggregation.html">collect_list_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived aggregation class for specifying COLLECT_LIST aggregation  <a href="classcudf_1_1detail_1_1collect__list__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1collect__set__aggregation.html">collect_set_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived aggregation class for specifying COLLECT_SET aggregation  <a href="classcudf_1_1detail_1_1collect__set__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1column__view__base.html">column_view_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-owning, immutable view of device data as a column of elements, some of which may be null as indicated by a bitmask.  <a href="classcudf_1_1detail_1_1column__view__base.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1correlation__aggregation.html">correlation_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived aggregation class for specifying CORRELATION aggregation  <a href="classcudf_1_1detail_1_1correlation__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1count__aggregation.html">count_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class for specifying a count aggregation  <a href="classcudf_1_1detail_1_1count__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1covariance__aggregation.html">covariance_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived aggregation class for specifying COVARIANCE aggregation  <a href="classcudf_1_1detail_1_1covariance__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1dispatch__aggregation.html">dispatch_aggregation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1dispatch__source.html">dispatch_source</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1dremel__data.html">dremel_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dremel data that describes one nested type column  <a href="structcudf_1_1detail_1_1dremel__data.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1dremel__device__view.html">dremel_device_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device view for <code><a class="el" href="structcudf_1_1detail_1_1dremel__data.html" title="Dremel data that describes one nested type column">dremel_data</a></code>.  <a href="structcudf_1_1detail_1_1dremel__device__view.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1fixed__width__scalar.html">fixed_width_scalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An owning class to represent a fixed-width type value in device memory.  <a href="classcudf_1_1detail_1_1fixed__width__scalar.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1has__common__type__impl.html">has_common_type_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1has__common__type__impl_3_01void__t_3_01std_1_1common__type__t_3_01_ts_8e2d33eab3ad4b77e8506b3fe056aacf5.html">has_common_type_impl&lt; void_t&lt; std::common_type_t&lt; Ts... &gt; &gt;, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1hash__join.html">hash_join</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash join that builds hash table in creation and probes results in subsequent <code>*_join</code> member functions.  <a href="structcudf_1_1detail_1_1hash__join.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1is__equality__comparable__impl.html">is_equality_comparable_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1is__equality__comparable__impl_3_01_l_00_01_r_00_01void__t_3_01equality_2f83d168aaedf92541e7f7f4a1af5cfa.html">is_equality_comparable_impl&lt; L, R, void_t&lt; equality_comparable&lt; L, R &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1is__relationally__comparable__impl.html">is_relationally_comparable_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1is__relationally__comparable__impl_3_01_l_00_01_r_00_01void__t_3_01less_58b6dd73ceb6a464bcab762425ace104.html">is_relationally_comparable_impl&lt; L, R, void_t&lt; less_comparable&lt; L, R &gt;, greater_comparable&lt; L, R &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1kind__to__type__impl.html">kind_to_type_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1lead__lag__aggregation.html">lead_lag_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived aggregation class for specifying LEAD/LAG window aggregations  <a href="classcudf_1_1detail_1_1lead__lag__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1linked__column__view.html">linked_column_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> with the added member pointer to the parent of this column.  <a href="structcudf_1_1detail_1_1linked__column__view.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1m2__aggregation.html">m2_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class for specifying a m2 aggregation  <a href="classcudf_1_1detail_1_1m2__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1max__aggregation.html">max_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class for specifying a max aggregation  <a href="classcudf_1_1detail_1_1max__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1mean__aggregation.html">mean_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class for specifying a mean aggregation  <a href="classcudf_1_1detail_1_1mean__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1median__aggregation.html">median_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class for specifying a median aggregation  <a href="classcudf_1_1detail_1_1median__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1merge__lists__aggregation.html">merge_lists_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived aggregation class for specifying MERGE_LISTS aggregation  <a href="classcudf_1_1detail_1_1merge__lists__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1merge__m2__aggregation.html">merge_m2_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived aggregation class for specifying MERGE_M2 aggregation  <a href="classcudf_1_1detail_1_1merge__m2__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1merge__sets__aggregation.html">merge_sets_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived aggregation class for specifying MERGE_SETS aggregation  <a href="classcudf_1_1detail_1_1merge__sets__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1merge__tdigest__aggregation.html">merge_tdigest_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived aggregation class for specifying MERGE_TDIGEST aggregation  <a href="classcudf_1_1detail_1_1merge__tdigest__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1min__aggregation.html">min_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class for specifying a min aggregation  <a href="classcudf_1_1detail_1_1min__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1_murmur_hash3__32.html">MurmurHash3_32</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1mutable__column__view__base.html">mutable_column_view_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1nth__element__aggregation.html">nth_element_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class for specifying a nth element aggregation  <a href="classcudf_1_1detail_1_1nth__element__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1nunique__aggregation.html">nunique_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class for specifying a nunique aggregation  <a href="classcudf_1_1detail_1_1nunique__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1pair__column__aggregation__equal__to.html">pair_column_aggregation_equal_to</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1pair__column__aggregation__hash.html">pair_column_aggregation_hash</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1pinned__allocator.html">pinned_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1pinned__allocator_3_01void_01_4.html">pinned_allocator&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1product__aggregation.html">product_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class for specifying a product aggregation  <a href="classcudf_1_1detail_1_1product__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1quantile__aggregation.html">quantile_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class for specifying a quantile aggregation  <a href="classcudf_1_1detail_1_1quantile__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1rank__aggregation.html">rank_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class for specifying a rank aggregation  <a href="classcudf_1_1detail_1_1rank__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1result__cache.html">result_cache</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1row__number__aggregation.html">row_number_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class for specifying a row_number aggregation  <a href="classcudf_1_1detail_1_1row__number__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1simple__aggregations__collector.html">simple_aggregations_collector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1span__base.html">span_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++20 std::span with reduced feature set.  <a href="classcudf_1_1detail_1_1span__base.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1std__aggregation.html">std_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class for specifying a standard deviation aggregation  <a href="classcudf_1_1detail_1_1std__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1std__var__aggregation.html">std_var_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class for specifying a standard deviation/variance aggregation  <a href="classcudf_1_1detail_1_1std__var__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1sum__aggregation.html">sum_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class for specifying a sum aggregation  <a href="classcudf_1_1detail_1_1sum__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1sum__of__squares__aggregation.html">sum_of_squares_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class for specifying a sum_of_squares aggregation  <a href="classcudf_1_1detail_1_1sum__of__squares__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1table__view__base.html">table_view_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for a table of <code>ColumnView</code>s  <a href="classcudf_1_1detail_1_1table__view__base.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1target__type__impl.html">target_type_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines accumulator type based on input type and aggregation.  <a href="structcudf_1_1detail_1_1target__type__impl.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_a_l_l_01_4.html">target_type_impl&lt; Source, aggregation::ALL &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_a_n_y_01_4.html">target_type_impl&lt; Source, aggregation::ANY &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_a_r_g_m_a_x_01_4.html">target_type_impl&lt; Source, aggregation::ARGMAX &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_a_r_g_m_i_n_01_4.html">target_type_impl&lt; Source, aggregation::ARGMIN &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_c_o_l_l_e_c_t___l_i_s_t_01_4.html">target_type_impl&lt; Source, aggregation::COLLECT_LIST &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_c_o_l_l_e_c_t___s_e_t_01_4.html">target_type_impl&lt; Source, aggregation::COLLECT_SET &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_c_o_u_n_t___a_l_l_01_4.html">target_type_impl&lt; Source, aggregation::COUNT_ALL &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_c_o_u_n_t___v_a_l_i_d_01_4.html">target_type_impl&lt; Source, aggregation::COUNT_VALID &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_l_a_g_01_4.html">target_type_impl&lt; Source, aggregation::LAG &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_l_e_a_d_01_4.html">target_type_impl&lt; Source, aggregation::LEAD &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_m_a_x_01_4.html">target_type_impl&lt; Source, aggregation::MAX &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_m_e_d_i_a_n_01_4.html">target_type_impl&lt; Source, aggregation::MEDIAN &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_m_e_r_g_e___l_i_s_t_s_01_4.html">target_type_impl&lt; Source, aggregation::MERGE_LISTS &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_m_e_r_g_e___s_e_t_s_01_4.html">target_type_impl&lt; Source, aggregation::MERGE_SETS &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_m_e_r_g_e___t_d_i_g_b6032354e9dd2aab59ead12451496ee9.html">target_type_impl&lt; Source, aggregation::MERGE_TDIGEST, std::enable_if_t&lt; std::is_same_v&lt; Source, cudf::struct_view &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_m_i_n_01_4.html">target_type_impl&lt; Source, aggregation::MIN &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_n_t_h___e_l_e_m_e_n_t_01_4.html">target_type_impl&lt; Source, aggregation::NTH_ELEMENT &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_n_u_n_i_q_u_e_01_4.html">target_type_impl&lt; Source, aggregation::NUNIQUE &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_q_u_a_n_t_i_l_e_01_4.html">target_type_impl&lt; Source, aggregation::QUANTILE &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_r_a_n_k_01_4.html">target_type_impl&lt; Source, aggregation::RANK &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_r_o_w___n_u_m_b_e_r_01_4.html">target_type_impl&lt; Source, aggregation::ROW_NUMBER &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_t_d_i_g_e_s_t_00_01s5303a4b781861b9f20be89a332eefbb3.html">target_type_impl&lt; Source, aggregation::TDIGEST, std::enable_if_t&lt;(is_numeric&lt; Source &gt;()||is_fixed_point&lt; Source &gt;())&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01k_00_01std_1_1enable__if__t_3_01std_9f689773868603c824fb593bd3e5e573.html">target_type_impl&lt; Source, k, std::enable_if_t&lt; std::is_floating_point_v&lt; Source &gt; &amp;&amp;is_sum_product_agg(k)&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01k_00_01std_1_1enable__if__t_3_01std_eb928db258a099e4b94f2dc9fe8c0a44.html">target_type_impl&lt; Source, k, std::enable_if_t&lt; std::is_integral_v&lt; Source &gt; &amp;&amp;is_sum_product_agg(k)&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01k_00_01std_1_1enable__if__t_3_07is__2d246396d9b567139696a42c8c67e9c9.html">target_type_impl&lt; Source, k, std::enable_if_t&lt;(is_chrono&lt; Source &gt;() or is_fixed_point&lt; Source &gt;()) &amp;&amp;(k==aggregation::MEAN)&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1target__type__impl_3_01_source_type_00_01aggregation_1_1_c_o_r_r_e_l_a_t_i_o_n_01_4.html">target_type_impl&lt; SourceType, aggregation::CORRELATION &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1target__type__impl_3_01_source_type_00_01aggregation_1_1_c_o_v_a_r_i_a_n_c_e_01_4.html">target_type_impl&lt; SourceType, aggregation::COVARIANCE &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1target__type__impl_3_01_source_type_00_01aggregation_1_1_m2_01_4.html">target_type_impl&lt; SourceType, aggregation::M2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1target__type__impl_3_01_source_type_00_01aggregation_1_1_m_e_r_g_e___m2_01_4.html">target_type_impl&lt; SourceType, aggregation::MERGE_M2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1target__type__impl_3_01_source_type_00_01aggregation_1_1_s_t_d_01_4.html">target_type_impl&lt; SourceType, aggregation::STD &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1target__type__impl_3_01_source_type_00_01aggregation_1_1_v_a_r_i_a_n_c_e_01_4.html">target_type_impl&lt; SourceType, aggregation::VARIANCE &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1tdigest__aggregation.html">tdigest_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived aggregation class for specifying TDIGEST aggregation  <a href="classcudf_1_1detail_1_1tdigest__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1udf__aggregation.html">udf_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class for specifying a custom aggregation specified in udf  <a href="classcudf_1_1detail_1_1udf__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1detail_1_1var__aggregation.html">var_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class for specifying a variance aggregation  <a href="classcudf_1_1detail_1_1var__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1detail_1_1visitor__overload.html">visitor_overload</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to support inline-overloading for all of a variant's alternative types  <a href="structcudf_1_1detail_1_1visitor__overload.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
类型定义</h2></td></tr>
<tr class="memitem:ad9f4583fad6d64406129dc1978027b6b"><td class="memTemplParams" colspan="2">template&lt;typename Source , <a class="el" href="classcudf_1_1aggregation.html#a83579ae3cab2fc3d1c3b377d1cfab24c">aggregation::Kind</a> k&gt; </td></tr>
<tr class="memitem:ad9f4583fad6d64406129dc1978027b6b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#ad9f4583fad6d64406129dc1978027b6b">target_type_t</a> = typename <a class="el" href="structcudf_1_1detail_1_1target__type__impl.html">target_type_impl</a>&lt; Source, k &gt;::type</td></tr>
<tr class="memdesc:ad9f4583fad6d64406129dc1978027b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper alias to get the accumulator type for performing aggregation <code>k</code> on elements of type <code>Source</code>  <br /></td></tr>
<tr class="separator:ad9f4583fad6d64406129dc1978027b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a62804f4d08dbf686b957e2bdfb06be"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classcudf_1_1aggregation.html#a83579ae3cab2fc3d1c3b377d1cfab24c">aggregation::Kind</a> k&gt; </td></tr>
<tr class="memitem:a8a62804f4d08dbf686b957e2bdfb06be"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a8a62804f4d08dbf686b957e2bdfb06be">kind_to_type</a> = typename <a class="el" href="structcudf_1_1detail_1_1kind__to__type__impl.html">kind_to_type_impl</a>&lt; k &gt;::type</td></tr>
<tr class="separator:a8a62804f4d08dbf686b957e2bdfb06be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bef759d42ac528d33f331de080d5584"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a8bef759d42ac528d33f331de080d5584">LinkedColPtr</a> = std::shared_ptr&lt; <a class="el" href="structcudf_1_1detail_1_1linked__column__view.html">linked_column_view</a> &gt;</td></tr>
<tr class="separator:a8bef759d42ac528d33f331de080d5584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627e116400c1bed3d5f2b3ab78661fe8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a627e116400c1bed3d5f2b3ab78661fe8">LinkedColVector</a> = std::vector&lt; <a class="el" href="namespacecudf_1_1detail.html#a8bef759d42ac528d33f331de080d5584">LinkedColPtr</a> &gt;</td></tr>
<tr class="separator:a627e116400c1bed3d5f2b3ab78661fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad766fd47aef5cd45824e7789f42247ed"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad766fd47aef5cd45824e7789f42247ed"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#ad766fd47aef5cd45824e7789f42247ed">host_2dspan</a> = <a class="el" href="classcudf_1_1detail_1_1base__2dspan.html">base_2dspan</a>&lt; T, <a class="el" href="structcudf_1_1host__span.html">host_span</a> &gt;</td></tr>
<tr class="memdesc:ad766fd47aef5cd45824e7789f42247ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the 2D span for host data.  <br /></td></tr>
<tr class="separator:ad766fd47aef5cd45824e7789f42247ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d997e03a111aad833923bbfa0fc631"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa8d997e03a111aad833923bbfa0fc631"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#aa8d997e03a111aad833923bbfa0fc631">device_2dspan</a> = <a class="el" href="classcudf_1_1detail_1_1base__2dspan.html">base_2dspan</a>&lt; T, <a class="el" href="structcudf_1_1device__span.html">device_span</a> &gt;</td></tr>
<tr class="memdesc:aa8d997e03a111aad833923bbfa0fc631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the 2D span for device data.  <br /></td></tr>
<tr class="separator:aa8d997e03a111aad833923bbfa0fc631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d645cde6078342234d5d6ee2c8cd9f9"><td class="memTemplParams" colspan="2">template&lt;class Duration &gt; </td></tr>
<tr class="memitem:a2d645cde6078342234d5d6ee2c8cd9f9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a2d645cde6078342234d5d6ee2c8cd9f9">time_point</a> = cuda::std::chrono::sys_time&lt; Duration &gt;</td></tr>
<tr class="memdesc:a2d645cde6078342234d5d6ee2c8cd9f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time point type  <br /></td></tr>
<tr class="separator:a2d645cde6078342234d5d6ee2c8cd9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3128cb15ed7da5bb5e926bb24a419262"><td class="memTemplParams" colspan="2">template&lt;class Duration &gt; </td></tr>
<tr class="memitem:a3128cb15ed7da5bb5e926bb24a419262"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a3128cb15ed7da5bb5e926bb24a419262">timestamp</a> = <a class="el" href="namespacecudf_1_1detail.html#a2d645cde6078342234d5d6ee2c8cd9f9">time_point</a>&lt; Duration &gt;</td></tr>
<tr class="memdesc:a3128cb15ed7da5bb5e926bb24a419262"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around a column of time_point in varying resolutions  <br /></td></tr>
<tr class="separator:a3128cb15ed7da5bb5e926bb24a419262"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
枚举</h2></td></tr>
<tr class="memitem:a1c29a0e8458ffb159e91481c0f37b0f5"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a1c29a0e8458ffb159e91481c0f37b0f5">negative_index_policy</a> : bool { <a class="el" href="namespacecudf_1_1detail.html#a1c29a0e8458ffb159e91481c0f37b0f5a9725825c796122ef40f01b2d8794f902">ALLOWED</a>
, <a class="el" href="namespacecudf_1_1detail.html#a1c29a0e8458ffb159e91481c0f37b0f5a4596302bc1e8ce6e62188e769aac94cf">NOT_ALLOWED</a>
 }</td></tr>
<tr class="separator:a1c29a0e8458ffb159e91481c0f37b0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe99faf2d7a570e5de8dbe1638f91dd0"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#afe99faf2d7a570e5de8dbe1638f91dd0">join_kind</a> { <br />
&#160;&#160;<a class="el" href="namespacecudf_1_1detail.html#afe99faf2d7a570e5de8dbe1638f91dd0adacfb6b4a93e8c0996af0a50896b2ad6">INNER_JOIN</a>
, <a class="el" href="namespacecudf_1_1detail.html#afe99faf2d7a570e5de8dbe1638f91dd0ab2f77eff2e65e96b41d17cef95c040ca">LEFT_JOIN</a>
, <a class="el" href="namespacecudf_1_1detail.html#afe99faf2d7a570e5de8dbe1638f91dd0a9e94c2918e6b37d619ac174c2f251c4a">FULL_JOIN</a>
, <a class="el" href="namespacecudf_1_1detail.html#afe99faf2d7a570e5de8dbe1638f91dd0a149cf6da1ad9e5e65b85a95c49449ae8">LEFT_SEMI_JOIN</a>
, <br />
&#160;&#160;<a class="el" href="namespacecudf_1_1detail.html#afe99faf2d7a570e5de8dbe1638f91dd0a148ec33d1c462dcb952eb70eae78fc6e">LEFT_ANTI_JOIN</a>
<br />
 }</td></tr>
<tr class="separator:afe99faf2d7a570e5de8dbe1638f91dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
函数</h2></td></tr>
<tr class="memitem:a560407ec1815ec2aff96a7c792f53428"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a560407ec1815ec2aff96a7c792f53428">shallow_hash</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input)</td></tr>
<tr class="memdesc:a560407ec1815ec2aff96a7c792f53428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a hash value from the shallow state of the specified column  <br /></td></tr>
<tr class="separator:a560407ec1815ec2aff96a7c792f53428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c566f1ff3c273be1518ca5f7d92d4cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a8c566f1ff3c273be1518ca5f7d92d4cc">is_shallow_equivalent</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;lhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;rhs)</td></tr>
<tr class="memdesc:a8c566f1ff3c273be1518ca5f7d92d4cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses only shallow state to determine if two <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code>s view equivalent columns  <br /></td></tr>
<tr class="separator:a8c566f1ff3c273be1518ca5f7d92d4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a7ba935c016e3b7c537937d88e038f"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#af8a7ba935c016e3b7c537937d88e038f">is_sum_product_agg</a> (<a class="el" href="classcudf_1_1aggregation.html#a83579ae3cab2fc3d1c3b377d1cfab24c">aggregation::Kind</a> k)</td></tr>
<tr class="separator:af8a7ba935c016e3b7c537937d88e038f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325dce4aa776c0bf7cf218e2a27714b5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a325dce4aa776c0bf7cf218e2a27714b5">AGG_KIND_MAPPING</a> (<a class="el" href="classcudf_1_1aggregation.html#a83579ae3cab2fc3d1c3b377d1cfab24ca6e5361905125d531234e50d50bcf5326">aggregation::QUANTILE</a>, <a class="el" href="classcudf_1_1detail_1_1quantile__aggregation.html">quantile_aggregation</a>)</td></tr>
<tr class="separator:a325dce4aa776c0bf7cf218e2a27714b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21777beb509d8944a3e936c0840e473"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#af21777beb509d8944a3e936c0840e473">AGG_KIND_MAPPING</a> (<a class="el" href="classcudf_1_1aggregation.html#a83579ae3cab2fc3d1c3b377d1cfab24ca6b1ba846de925ba39b9ee9e352adf84a">aggregation::STD</a>, <a class="el" href="classcudf_1_1detail_1_1std__aggregation.html">std_aggregation</a>)</td></tr>
<tr class="separator:af21777beb509d8944a3e936c0840e473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8f5a52bb309f1cdc4906eed538b45d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#aad8f5a52bb309f1cdc4906eed538b45d">AGG_KIND_MAPPING</a> (<a class="el" href="classcudf_1_1aggregation.html#a83579ae3cab2fc3d1c3b377d1cfab24ca668fb6976b34ba937eb74f77700e749d">aggregation::VARIANCE</a>, <a class="el" href="classcudf_1_1detail_1_1var__aggregation.html">var_aggregation</a>)</td></tr>
<tr class="separator:aad8f5a52bb309f1cdc4906eed538b45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f1cdfbe0b878b8b5143108ed352a2d"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... Ts&gt; </td></tr>
<tr class="memitem:a20f1cdfbe0b878b8b5143108ed352a2d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_8hpp.html#adc4a74f3fb4b327ed43b31d0fca65ba3">CUDF_HOST_DEVICE</a> decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a20f1cdfbe0b878b8b5143108ed352a2d">aggregation_dispatcher</a> (<a class="el" href="classcudf_1_1aggregation.html#a83579ae3cab2fc3d1c3b377d1cfab24c">aggregation::Kind</a> k, F &amp;&amp;f, Ts &amp;&amp;... args)</td></tr>
<tr class="memdesc:a20f1cdfbe0b878b8b5143108ed352a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches <code>k</code> as a non-type template parameter to a callable, <code>f</code>.  <br /></td></tr>
<tr class="separator:a20f1cdfbe0b878b8b5143108ed352a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0159f4dade1ab55499ee6d0606eae6fd"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... Ts&gt; </td></tr>
<tr class="memitem:a0159f4dade1ab55499ee6d0606eae6fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_8hpp.html#adc4a74f3fb4b327ed43b31d0fca65ba3">CUDF_HOST_DEVICE</a> constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a0159f4dade1ab55499ee6d0606eae6fd">dispatch_type_and_aggregation</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type, <a class="el" href="classcudf_1_1aggregation.html#a83579ae3cab2fc3d1c3b377d1cfab24c">aggregation::Kind</a> k, F &amp;&amp;f, Ts &amp;&amp;... args)</td></tr>
<tr class="memdesc:a0159f4dade1ab55499ee6d0606eae6fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches both a type and <code><a class="el" href="classcudf_1_1aggregation.html#a83579ae3cab2fc3d1c3b377d1cfab24c" title="Possible aggregation operations">aggregation::Kind</a></code> template parameters to a callable.  <br /></td></tr>
<tr class="separator:a0159f4dade1ab55499ee6d0606eae6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57278828a4e7e978f90c08968d9dec55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a57278828a4e7e978f90c08968d9dec55">target_type</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> source_type, <a class="el" href="classcudf_1_1aggregation.html#a83579ae3cab2fc3d1c3b377d1cfab24c">aggregation::Kind</a> k)</td></tr>
<tr class="memdesc:a57278828a4e7e978f90c08968d9dec55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the target <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> for the specified aggregation k performed on elements of type source_type.  <br /></td></tr>
<tr class="separator:a57278828a4e7e978f90c08968d9dec55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d87c0aa523a30c8ab5b806ab4bb62e"><td class="memTemplParams" colspan="2">template&lt;typename Source , <a class="el" href="classcudf_1_1aggregation.html#a83579ae3cab2fc3d1c3b377d1cfab24c">aggregation::Kind</a> k&gt; </td></tr>
<tr class="memitem:a79d87c0aa523a30c8ab5b806ab4bb62e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a79d87c0aa523a30c8ab5b806ab4bb62e">is_valid_aggregation</a> ()</td></tr>
<tr class="memdesc:a79d87c0aa523a30c8ab5b806ab4bb62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the specified aggregation <code>k</code> is valid to perform on the type <code>Source</code>.  <br /></td></tr>
<tr class="separator:a79d87c0aa523a30c8ab5b806ab4bb62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1ec5de7e8b76d00528c28ba90d8fc1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a2e1ec5de7e8b76d00528c28ba90d8fc1">is_valid_aggregation</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> source, <a class="el" href="classcudf_1_1aggregation.html#a83579ae3cab2fc3d1c3b377d1cfab24c">aggregation::Kind</a> k)</td></tr>
<tr class="memdesc:a2e1ec5de7e8b76d00528c28ba90d8fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the specified aggregation <code>k</code> is valid to perform on the <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> <code>source</code>.  <br /></td></tr>
<tr class="separator:a2e1ec5de7e8b76d00528c28ba90d8fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71131703adb680670a6b8592b92f56f6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a71131703adb680670a6b8592b92f56f6">binary_operation</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;lhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;rhs, std::string const &amp;ptx, <a class="el" href="classcudf_1_1data__type.html">data_type</a> output_type, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a71131703adb680670a6b8592b92f56f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary operation between two columns using a user-defined PTX function.    <br /></td></tr>
<tr class="separator:a71131703adb680670a6b8592b92f56f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d435282505118b2a58c875780c13890"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a4d435282505118b2a58c875780c13890">binary_operation</a> (<a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;lhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;rhs, <a class="el" href="group__transformation__binaryops.html#ga00ed76601b6db662550f6826cfd99edc">binary_operator</a> op, <a class="el" href="classcudf_1_1data__type.html">data_type</a> output_type, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a4d435282505118b2a58c875780c13890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary operation between a scalar and a column.    <br /></td></tr>
<tr class="separator:a4d435282505118b2a58c875780c13890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c8f19f207ee3db5e2284594edc600c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#ab6c8f19f207ee3db5e2284594edc600c">binary_operation</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;lhs, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;rhs, <a class="el" href="group__transformation__binaryops.html#ga00ed76601b6db662550f6826cfd99edc">binary_operator</a> op, <a class="el" href="classcudf_1_1data__type.html">data_type</a> output_type, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ab6c8f19f207ee3db5e2284594edc600c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary operation between a column and a scalar.    <br /></td></tr>
<tr class="separator:ab6c8f19f207ee3db5e2284594edc600c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4ce4e5ee2ebf383eaccdd2d8ab8233"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a6d4ce4e5ee2ebf383eaccdd2d8ab8233">binary_operation</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;lhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;rhs, <a class="el" href="group__transformation__binaryops.html#ga00ed76601b6db662550f6826cfd99edc">binary_operator</a> op, <a class="el" href="classcudf_1_1data__type.html">data_type</a> output_type, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a6d4ce4e5ee2ebf383eaccdd2d8ab8233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary operation between two columns.    <br /></td></tr>
<tr class="separator:a6d4ce4e5ee2ebf383eaccdd2d8ab8233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff65803386d36f8a139f59f14506eef"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a4ff65803386d36f8a139f59f14506eef">concatenate</a> (<a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &gt; columns_to_concat, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a4ff65803386d36f8a139f59f14506eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple columns into a single column.    <br /></td></tr>
<tr class="separator:a4ff65803386d36f8a139f59f14506eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a9a4dad8d8d93a07908bc682e3b76d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a03a9a4dad8d8d93a07908bc682e3b76d">concatenate</a> (<a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &gt; tables_to_concat, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a03a9a4dad8d8d93a07908bc682e3b76d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Columns of <code>tables_to_concat</code> are concatenated vertically to return a single table    <br /></td></tr>
<tr class="separator:a03a9a4dad8d8d93a07908bc682e3b76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accad26dd1e34404dea7ab68735bf8d64"><td class="memTemplParams" colspan="2">template&lt;typename ColumnView &gt; </td></tr>
<tr class="memitem:accad26dd1e34404dea7ab68735bf8d64"><td class="memTemplItemLeft" align="right" valign="top">ColumnView&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#accad26dd1e34404dea7ab68735bf8d64">slice</a> (ColumnView const &amp;input, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a> begin, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a> end)</td></tr>
<tr class="memdesc:accad26dd1e34404dea7ab68735bf8d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a zero-copy <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code>/<code><a class="el" href="classcudf_1_1mutable__column__view.html" title="A non-owning, mutable view of device data as a column of elements, some of which may be null as indic...">mutable_column_view</a></code> of the elements in the range <code>[begin,end)</code> in <code>input</code>.  <br /></td></tr>
<tr class="separator:accad26dd1e34404dea7ab68735bf8d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49deebc29b5e46589239ef45caadf78d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcudf_1_1column__view.html">column_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a49deebc29b5e46589239ef45caadf78d">slice</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt; indices, rmm::cuda_stream_view stream)</td></tr>
<tr class="memdesc:a49deebc29b5e46589239ef45caadf78d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slices a <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> into a set of <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code>s according to a set of indices.    <br /></td></tr>
<tr class="separator:a49deebc29b5e46589239ef45caadf78d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31cc81e8ff79807da425b06808628a3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcudf_1_1column__view.html">column_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#aa31cc81e8ff79807da425b06808628a3">slice</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, std::initializer_list&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; indices, rmm::cuda_stream_view stream)</td></tr>
<tr class="separator:aa31cc81e8ff79807da425b06808628a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5910f60027c0a5ed39ae6d3400504a4c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcudf_1_1table__view.html">table_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a5910f60027c0a5ed39ae6d3400504a4c">slice</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, <a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt; indices, rmm::cuda_stream_view stream)</td></tr>
<tr class="memdesc:a5910f60027c0a5ed39ae6d3400504a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slices a <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> into a set of <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code>s according to a set of indices.    <br /></td></tr>
<tr class="separator:a5910f60027c0a5ed39ae6d3400504a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981d0804d0e1b53e77bcb4b495effdd2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcudf_1_1table__view.html">table_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a981d0804d0e1b53e77bcb4b495effdd2">slice</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, std::initializer_list&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; indices, rmm::cuda_stream_view stream)</td></tr>
<tr class="separator:a981d0804d0e1b53e77bcb4b495effdd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92c0388c1c85c792be08da6986b8bed"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcudf_1_1column__view.html">column_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#ac92c0388c1c85c792be08da6986b8bed">split</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt; splits, rmm::cuda_stream_view stream)</td></tr>
<tr class="memdesc:ac92c0388c1c85c792be08da6986b8bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> into a set of <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code>s according to a set of indices derived from expected splits.    <br /></td></tr>
<tr class="separator:ac92c0388c1c85c792be08da6986b8bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bbfdd769874212ba1918473509e8d62"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcudf_1_1column__view.html">column_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a2bbfdd769874212ba1918473509e8d62">split</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, std::initializer_list&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; splits, rmm::cuda_stream_view stream)</td></tr>
<tr class="separator:a2bbfdd769874212ba1918473509e8d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c75abac479c304fa7ddd5e472489229"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcudf_1_1table__view.html">table_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a5c75abac479c304fa7ddd5e472489229">split</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, <a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt; splits, rmm::cuda_stream_view stream)</td></tr>
<tr class="memdesc:a5c75abac479c304fa7ddd5e472489229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> into a set of <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code>s according to a set of indices derived from expected splits.    <br /></td></tr>
<tr class="separator:a5c75abac479c304fa7ddd5e472489229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6bf2b8a180ce938904811ecb3fca6e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcudf_1_1table__view.html">table_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a1e6bf2b8a180ce938904811ecb3fca6e">split</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, std::initializer_list&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; splits, rmm::cuda_stream_view stream)</td></tr>
<tr class="separator:a1e6bf2b8a180ce938904811ecb3fca6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659e6bad07531f73e44b0e87e7a59449"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a659e6bad07531f73e44b0e87e7a59449">shift</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> offset, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;fill_value, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a659e6bad07531f73e44b0e87e7a59449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new column by shifting all values by an offset.    <br /></td></tr>
<tr class="separator:a659e6bad07531f73e44b0e87e7a59449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da5b63902793d46d2048b2f5ccb2e41"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a3da5b63902793d46d2048b2f5ccb2e41">segmented_shift</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;segmented_values, <a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt; segment_offsets, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> offset, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;fill_value, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a3da5b63902793d46d2048b2f5ccb2e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs segmented shifts for specified values.  <br /></td></tr>
<tr class="separator:a3da5b63902793d46d2048b2f5ccb2e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047f6e84ed9d8d30fd0a8703ac2085ee"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structcudf_1_1packed__table.html">packed_table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a047f6e84ed9d8d30fd0a8703ac2085ee">contiguous_split</a> (<a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;input, std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; const &amp;splits, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a047f6e84ed9d8d30fd0a8703ac2085ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a deep-copy split of a <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> into a set of <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code>s into a single contiguous block of memory.    <br /></td></tr>
<tr class="separator:a047f6e84ed9d8d30fd0a8703ac2085ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8fcbfc5ff5585cc426e609ab8da1720"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1packed__columns.html">packed_columns</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#ab8fcbfc5ff5585cc426e609ab8da1720">pack</a> (<a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;input, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ab8fcbfc5ff5585cc426e609ab8da1720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep-copy a <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> into a serialized contiguous memory format    <br /></td></tr>
<tr class="separator:ab8fcbfc5ff5585cc426e609ab8da1720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d90a4e2a03fd0f7bcaeee67267d1557"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a1d90a4e2a03fd0f7bcaeee67267d1557">allocate_like</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> size, <a class="el" href="group__column__copy.html#ga267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a> mask_alloc=<a class="el" href="group__column__copy.html#gga267e03474dcfd85242d2fdc6e5846ec6a47e9136fa770199f6a8a9727b6173eb4">mask_allocation_policy::RETAIN</a>, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a1d90a4e2a03fd0f7bcaeee67267d1557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an uninitialized new column of the specified size and same type as the <code>input</code>.    <br /></td></tr>
<tr class="separator:a1d90a4e2a03fd0f7bcaeee67267d1557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f095700ad533a04852f9b75ae33c2bc"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a1f095700ad533a04852f9b75ae33c2bc">copy_if_else</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;lhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;rhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;boolean_mask, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a1f095700ad533a04852f9b75ae33c2bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>    <br /></td></tr>
<tr class="separator:a1f095700ad533a04852f9b75ae33c2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca44d4fcbf12660edf218195e729eaa"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a3ca44d4fcbf12660edf218195e729eaa">copy_if_else</a> (<a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;lhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;rhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;boolean_mask, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a3ca44d4fcbf12660edf218195e729eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>    <br /></td></tr>
<tr class="separator:a3ca44d4fcbf12660edf218195e729eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44102048883bf4ae35957e48b4b650a3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a44102048883bf4ae35957e48b4b650a3">copy_if_else</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;lhs, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;rhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;boolean_mask, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a44102048883bf4ae35957e48b4b650a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>    <br /></td></tr>
<tr class="separator:a44102048883bf4ae35957e48b4b650a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60520ad2d4ed5741035a9e8dd9bfbe8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#ac60520ad2d4ed5741035a9e8dd9bfbe8">copy_if_else</a> (<a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;lhs, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;rhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;boolean_mask, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ac60520ad2d4ed5741035a9e8dd9bfbe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>    <br /></td></tr>
<tr class="separator:ac60520ad2d4ed5741035a9e8dd9bfbe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a082f6c019d5d3462414e341e949c02"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a4a082f6c019d5d3462414e341e949c02">sample</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const n, <a class="el" href="group__column__copy.html#gae7607cde56cb602ab1b198b5bebf7cba">sample_with_replacement</a> replacement=<a class="el" href="group__column__copy.html#ggae7607cde56cb602ab1b198b5bebf7cbaa946003f97ccc52d5d3b54ac0ec31bbfc">sample_with_replacement::FALSE</a>, int64_t const seed=0, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a4a082f6c019d5d3462414e341e949c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather <code>n</code> samples from given <code>input</code> randomly    <br /></td></tr>
<tr class="separator:a4a082f6c019d5d3462414e341e949c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c26312d03ba6528aa4d28c9ec41a67"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a84c26312d03ba6528aa4d28c9ec41a67">get_element</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> index, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a84c26312d03ba6528aa4d28c9ec41a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the element at specified index from a column    <br /></td></tr>
<tr class="separator:a84c26312d03ba6528aa4d28c9ec41a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5758db52c9f99ddaab9a9de11fd25f4d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a5758db52c9f99ddaab9a9de11fd25f4d">has_nonempty_nulls</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, rmm::cuda_stream_view stream)</td></tr>
<tr class="memdesc:a5758db52c9f99ddaab9a9de11fd25f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a column or its descendants have non-empty null rows    <br /></td></tr>
<tr class="separator:a5758db52c9f99ddaab9a9de11fd25f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9d7614373d0ef4f4538d1920c6d732"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a0d9d7614373d0ef4f4538d1920c6d732">may_have_nonempty_nulls</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, rmm::cuda_stream_view stream)</td></tr>
<tr class="memdesc:a0d9d7614373d0ef4f4538d1920c6d732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximates if a column or its descendants <em>may</em> have non-empty null elements    <br /></td></tr>
<tr class="separator:a0d9d7614373d0ef4f4538d1920c6d732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc2fd111114777e8e4e26c3295ca04b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#aacc2fd111114777e8e4e26c3295ca04b">purge_nonempty_nulls</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:aacc2fd111114777e8e4e26c3295ca04b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy <code>input</code> into output while purging any non-empty null rows in the column or its descendants.    <br /></td></tr>
<tr class="separator:aacc2fd111114777e8e4e26c3295ca04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b739ba07b14a2274420abc4f2ea89c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#ac6b739ba07b14a2274420abc4f2ea89c">fill_in_place</a> (<a class="el" href="classcudf_1_1mutable__column__view.html">mutable_column_view</a> &amp;destination, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> begin, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> end, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;value, rmm::cuda_stream_view stream)</td></tr>
<tr class="memdesc:ac6b739ba07b14a2274420abc4f2ea89c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a range of elements in-place in a column with a scalar value.    <br /></td></tr>
<tr class="separator:ac6b739ba07b14a2274420abc4f2ea89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a397072949d54359e047f3dada74d5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#ab1a397072949d54359e047f3dada74d5">fill</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> begin, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> end, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;value, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ab1a397072949d54359e047f3dada74d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a range of elements in a column out-of-place with a scalar value.    <br /></td></tr>
<tr class="separator:ab1a397072949d54359e047f3dada74d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b23205b2ffc206924167683c00c48f5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a5b23205b2ffc206924167683c00c48f5">gather</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;source_table, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;gather_map, <a class="el" href="group__column__copy.html#gae3ba74951558bc7966aae86abc6af5df">out_of_bounds_policy</a> bounds_policy, <a class="el" href="namespacecudf_1_1detail.html#a1c29a0e8458ffb159e91481c0f37b0f5">negative_index_policy</a> neg_indices, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a5b23205b2ffc206924167683c00c48f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers the specified rows of a set of columns according to a gather map.  <br /></td></tr>
<tr class="separator:a5b23205b2ffc206924167683c00c48f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5dfc3e39242d68bd887f7e0b9fb373"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#aef5dfc3e39242d68bd887f7e0b9fb373">gather</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;source_table, <a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt; const gather_map, <a class="el" href="group__column__copy.html#gae3ba74951558bc7966aae86abc6af5df">out_of_bounds_policy</a> bounds_policy, <a class="el" href="namespacecudf_1_1detail.html#a1c29a0e8458ffb159e91481c0f37b0f5">negative_index_policy</a> neg_indices, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="separator:aef5dfc3e39242d68bd887f7e0b9fb373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac670d683b1e9e5c0682c3e2d23e79563"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#ac670d683b1e9e5c0682c3e2d23e79563">hash</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, <a class="el" href="group__column__hash.html#gaced8b9d129825edd13d76e912e4413c3">hash_id</a> hash_function=<a class="el" href="group__column__hash.html#ggaced8b9d129825edd13d76e912e4413c3ae9ec854e962136b1afcf108e5301c354">hash_id::HASH_MURMUR3</a>, uint32_t seed=<a class="el" href="group__column__hash.html#ga68de1d04aa2c0ea2eeacfc73fd99a915">cudf::DEFAULT_HASH_SEED</a>, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ac670d683b1e9e5c0682c3e2d23e79563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hash value of each row in the input set of columns.    <br /></td></tr>
<tr class="separator:ac670d683b1e9e5c0682c3e2d23e79563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349e2b28175e2d9ea71d7761fd9b03ce"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a349e2b28175e2d9ea71d7761fd9b03ce">murmur_hash3_32</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, uint32_t seed=<a class="el" href="group__column__hash.html#ga68de1d04aa2c0ea2eeacfc73fd99a915">cudf::DEFAULT_HASH_SEED</a>, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="separator:a349e2b28175e2d9ea71d7761fd9b03ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d4598400aec3bb414a475b0e67588a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a19d4598400aec3bb414a475b0e67588a">spark_murmur_hash3_32</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, uint32_t seed=<a class="el" href="group__column__hash.html#ga68de1d04aa2c0ea2eeacfc73fd99a915">cudf::DEFAULT_HASH_SEED</a>, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="separator:a19d4598400aec3bb414a475b0e67588a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affdf27f8bc86ce410050f009d8b9d894"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#affdf27f8bc86ce410050f009d8b9d894">md5_hash</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="separator:affdf27f8bc86ce410050f009d8b9d894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afacc4b3c523b45ae3046691dcc061191"><td class="memItemLeft" align="right" valign="top">constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#afacc4b3c523b45ae3046691dcc061191">hash_combine</a> (uint32_t lhs, uint32_t rhs)</td></tr>
<tr class="memdesc:afacc4b3c523b45ae3046691dcc061191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two hash values into a single hash value.  <br /></td></tr>
<tr class="separator:afacc4b3c523b45ae3046691dcc061191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fed6fb6d5421eadcf1516f8d4e4fe9"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a31fed6fb6d5421eadcf1516f8d4e4fe9">hash_combine</a> (std::size_t lhs, std::size_t rhs)</td></tr>
<tr class="memdesc:a31fed6fb6d5421eadcf1516f8d4e4fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two hash values into a single hash value.  <br /></td></tr>
<tr class="separator:a31fed6fb6d5421eadcf1516f8d4e4fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b63d8998a9b7eb5e1d4ae842f95a66"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a94b63d8998a9b7eb5e1d4ae842f95a66">from_dlpack</a> (DLManagedTensor const *managed_tensor, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a94b63d8998a9b7eb5e1d4ae842f95a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a DLPack DLTensor into a cudf table    <br /></td></tr>
<tr class="separator:a94b63d8998a9b7eb5e1d4ae842f95a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93794af21ad050c5390d6ccd97783c52"><td class="memItemLeft" align="right" valign="top">DLManagedTensor *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a93794af21ad050c5390d6ccd97783c52">to_dlpack</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a93794af21ad050c5390d6ccd97783c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a cudf table into a DLPack DLTensor    <br /></td></tr>
<tr class="separator:a93794af21ad050c5390d6ccd97783c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b402cf23474cf91d987693ebfdeaa9"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a65b402cf23474cf91d987693ebfdeaa9"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; arrow::Array &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a65b402cf23474cf91d987693ebfdeaa9">to_arrow_array</a> (<a class="el" href="group__utility__types.html#gadf077607da617d1dadcc5417e2783539">cudf::type_id</a> id, Ts &amp;&amp;... args)</td></tr>
<tr class="separator:a65b402cf23474cf91d987693ebfdeaa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b91b19cf5f6210875f2c8066c263092"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a1b91b19cf5f6210875f2c8066c263092">arrow_to_cudf_type</a> (arrow::DataType const &amp;arrow_type)</td></tr>
<tr class="separator:a1b91b19cf5f6210875f2c8066c263092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69fbe0566c564337747a5ba0c30f7813"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; arrow::Table &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a69fbe0566c564337747a5ba0c30f7813">to_arrow</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> input, std::vector&lt; <a class="el" href="structcudf_1_1column__metadata.html">column_metadata</a> &gt; const &amp;metadata={}, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), arrow::MemoryPool *ar_mr=arrow::default_memory_pool())</td></tr>
<tr class="memdesc:a69fbe0566c564337747a5ba0c30f7813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <code>arrow::Table</code> from cudf table <code>input</code>    <br /></td></tr>
<tr class="separator:a69fbe0566c564337747a5ba0c30f7813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d059bf11972e2337fde993dbd2582b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#ad2d059bf11972e2337fde993dbd2582b">from_arrow</a> (arrow::Table const &amp;input_table, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="separator:ad2d059bf11972e2337fde993dbd2582b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342ee3e4fa47300f2b57966d0eb3405f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a342ee3e4fa47300f2b57966d0eb3405f">is_element_valid_sync</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;col_view, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> element_index, rmm::cuda_stream_view stream)</td></tr>
<tr class="memdesc:a342ee3e4fa47300f2b57966d0eb3405f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return validity of a row  <br /></td></tr>
<tr class="separator:a342ee3e4fa47300f2b57966d0eb3405f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c25ea42d2c182e01e2eefb6174114f3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__label__bins.html#ga7c25ea42d2c182e01e2eefb6174114f3">label_bins</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;left_edges, <a class="el" href="group__label__bins.html#gabadbffbcb403fac1ff712330ea10f2b3">inclusive</a> left_inclusive, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;right_edges, <a class="el" href="group__label__bins.html#gabadbffbcb403fac1ff712330ea10f2b3">inclusive</a> right_inclusive, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="separator:ga7c25ea42d2c182e01e2eefb6174114f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690f0e70c8c2bad53bf877483f2d346d"><td class="memItemLeft" align="right" valign="top">rmm::device_buffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a690f0e70c8c2bad53bf877483f2d346d">create_null_mask</a> (<a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> size, <a class="el" href="group__utility__types.html#ga4daf20c000ab374d76f4d56f0ddb7b26">mask_state</a> state, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a690f0e70c8c2bad53bf877483f2d346d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code>device_buffer</code> for use as a null value indicator bitmask of a <code>column</code>.    <br /></td></tr>
<tr class="separator:a690f0e70c8c2bad53bf877483f2d346d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522f5649cb74a11dba58378f96e40f01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a522f5649cb74a11dba58378f96e40f01">set_null_mask</a> (<a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> *bitmask, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> begin_bit, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> end_bit, bool valid, rmm::cuda_stream_view stream)</td></tr>
<tr class="memdesc:a522f5649cb74a11dba58378f96e40f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a pre-allocated bitmask buffer to a given state in the range <code>[begin_bit, end_bit)</code>    <br /></td></tr>
<tr class="separator:a522f5649cb74a11dba58378f96e40f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedafe62653e88ef1440aed7287f89ab8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#aedafe62653e88ef1440aed7287f89ab8">count_set_bits</a> (<a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> const *bitmask, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> start, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> stop, rmm::cuda_stream_view stream)</td></tr>
<tr class="memdesc:aedafe62653e88ef1440aed7287f89ab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a bitmask, counts the number of set (1) bits in the range <code>[start, stop)</code>.  <br /></td></tr>
<tr class="separator:aedafe62653e88ef1440aed7287f89ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a79295789c1ba220298ea1dbc0e8f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a96a79295789c1ba220298ea1dbc0e8f7">count_unset_bits</a> (<a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> const *bitmask, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> start, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> stop, rmm::cuda_stream_view stream)</td></tr>
<tr class="memdesc:a96a79295789c1ba220298ea1dbc0e8f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a bitmask, counts the number of unset (0) bits in the range <code>[start, stop)</code>.  <br /></td></tr>
<tr class="separator:a96a79295789c1ba220298ea1dbc0e8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0568781207d7824429d333aa3a8e0870"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a0568781207d7824429d333aa3a8e0870">segmented_count_set_bits</a> (<a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> const *bitmask, <a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt; indices, rmm::cuda_stream_view stream)</td></tr>
<tr class="memdesc:a0568781207d7824429d333aa3a8e0870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a bitmask, counts the number of set (1) bits in every range <code>[indices[2*i], indices[(2*i)+1])</code> (where 0 &lt;= i &lt; indices.size() / 2).  <br /></td></tr>
<tr class="separator:a0568781207d7824429d333aa3a8e0870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0e7344544634b61fd1f48a0931b231"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#aab0e7344544634b61fd1f48a0931b231">segmented_count_unset_bits</a> (<a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> const *bitmask, <a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt; indices, rmm::cuda_stream_view stream)</td></tr>
<tr class="memdesc:aab0e7344544634b61fd1f48a0931b231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a bitmask, counts the number of unset (0) bits in every range <code>[indices[2*i], indices[(2*i)+1])</code> (where 0 &lt;= i &lt; indices.size() / 2).  <br /></td></tr>
<tr class="separator:aab0e7344544634b61fd1f48a0931b231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a052b9cabb17b4fc2ef27e00a6414c707"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a052b9cabb17b4fc2ef27e00a6414c707">valid_count</a> (<a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> const *bitmask, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> start, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> stop, rmm::cuda_stream_view stream)</td></tr>
<tr class="memdesc:a052b9cabb17b4fc2ef27e00a6414c707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a validity bitmask, counts the number of valid elements (set bits) in the range <code>[start, stop)</code>.  <br /></td></tr>
<tr class="separator:a052b9cabb17b4fc2ef27e00a6414c707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289827dc5428527e139352669318e55f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a289827dc5428527e139352669318e55f">null_count</a> (<a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> const *bitmask, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> start, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> stop, rmm::cuda_stream_view stream)</td></tr>
<tr class="memdesc:a289827dc5428527e139352669318e55f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a validity bitmask, counts the number of null elements (unset bits) in the range <code>[start, stop)</code>.  <br /></td></tr>
<tr class="separator:a289827dc5428527e139352669318e55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35145843e5dd4a43853838b02241881f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a35145843e5dd4a43853838b02241881f">segmented_valid_count</a> (<a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> const *bitmask, <a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt; indices, rmm::cuda_stream_view stream)</td></tr>
<tr class="memdesc:a35145843e5dd4a43853838b02241881f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a validity bitmask, counts the number of valid elements (set bits) in every range <code>[indices[2*i], indices[(2*i)+1])</code> (where 0 &lt;= i &lt; indices.size() / 2).  <br /></td></tr>
<tr class="separator:a35145843e5dd4a43853838b02241881f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee03027237bac182e4be6d37fa6c4f37"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#aee03027237bac182e4be6d37fa6c4f37">segmented_null_count</a> (<a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> const *bitmask, <a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt; indices, rmm::cuda_stream_view stream)</td></tr>
<tr class="memdesc:aee03027237bac182e4be6d37fa6c4f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a validity bitmask, counts the number of null elements (unset bits) in every range <code>[indices[2*i], indices[(2*i)+1])</code> (where 0 &lt;= i &lt; indices.size() / 2).  <br /></td></tr>
<tr class="separator:aee03027237bac182e4be6d37fa6c4f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9423550e270db631d429d61b140d7108"><td class="memItemLeft" align="right" valign="top">rmm::device_buffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a9423550e270db631d429d61b140d7108">copy_bitmask</a> (<a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> const *mask, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> begin_bit, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> end_bit, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a9423550e270db631d429d61b140d7108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code>device_buffer</code> from a slice of bitmask defined by a range of indices <code>[begin_bit, end_bit)</code>.    <br /></td></tr>
<tr class="separator:a9423550e270db631d429d61b140d7108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaddec64eefdf906a669dd8e65e23137c"><td class="memItemLeft" align="right" valign="top">rmm::device_buffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#aaddec64eefdf906a669dd8e65e23137c">copy_bitmask</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;view, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:aaddec64eefdf906a669dd8e65e23137c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies <code>view</code>'s bitmask from the bits <code>[view.offset(), view.offset() + view.size())</code> into a <code>device_buffer</code>    <br /></td></tr>
<tr class="separator:aaddec64eefdf906a669dd8e65e23137c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5e9bcff0d652d054817afa71d20399"><td class="memItemLeft" align="right" valign="top">std::pair&lt; rmm::device_buffer, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#adc5e9bcff0d652d054817afa71d20399">bitmask_and</a> (<a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> const *const &gt; masks, <a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt; masks_begin_bits, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> mask_size_bits, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="separator:adc5e9bcff0d652d054817afa71d20399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf99352f85f59ae17972b8462cfb4760"><td class="memItemLeft" align="right" valign="top">std::pair&lt; rmm::device_buffer, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#abf99352f85f59ae17972b8462cfb4760">bitmask_and</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;view, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:abf99352f85f59ae17972b8462cfb4760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs bitwise AND of the bitmasks of columns of a table. Returns a pair of resulting mask and count of unset bits.    <br /></td></tr>
<tr class="separator:abf99352f85f59ae17972b8462cfb4760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280d3e05cbbc973356f38c0ee1fca2e3"><td class="memItemLeft" align="right" valign="top">std::pair&lt; rmm::device_buffer, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a280d3e05cbbc973356f38c0ee1fca2e3">bitmask_or</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;view, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a280d3e05cbbc973356f38c0ee1fca2e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs bitwise OR of the bitmasks of columns of a table. Returns a pair of resulting mask and count of unset bits.    <br /></td></tr>
<tr class="separator:a280d3e05cbbc973356f38c0ee1fca2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99f371b8101fc545e0c64553e5d81a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#af99f371b8101fc545e0c64553e5d81a9">inplace_bitmask_and</a> (<a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; <a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> &gt; dest_mask, <a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> const *const &gt; masks, <a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt; masks_begin_bits, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> mask_size_bits, rmm::cuda_stream_view stream)</td></tr>
<tr class="memdesc:af99f371b8101fc545e0c64553e5d81a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a bitwise AND of the specified bitmasks, and writes in place to destination  <br /></td></tr>
<tr class="separator:af99f371b8101fc545e0c64553e5d81a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9e3cf937df8cb28860d3fc8e9843d7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a3f9e3cf937df8cb28860d3fc8e9843d7">quantile</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, std::vector&lt; double &gt; const &amp;q, <a class="el" href="group__utility__types.html#ga9cd17c1cdf028ead9a4783f605276ab3">interpolation</a> interp=<a class="el" href="group__utility__types.html#gga9cd17c1cdf028ead9a4783f605276ab3aaac544aacc3615aada24897a215f5046">interpolation::LINEAR</a>, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;ordered_indices={}, bool exact=true, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a3f9e3cf937df8cb28860d3fc8e9843d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes quantiles with interpolation.    <br /></td></tr>
<tr class="separator:a3f9e3cf937df8cb28860d3fc8e9843d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db69c255a5f64c2b3f9e4bc7e73caa9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a9db69c255a5f64c2b3f9e4bc7e73caa9">quantiles</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, std::vector&lt; double &gt; const &amp;q, <a class="el" href="group__utility__types.html#ga9cd17c1cdf028ead9a4783f605276ab3">interpolation</a> interp=<a class="el" href="group__utility__types.html#gga9cd17c1cdf028ead9a4783f605276ab3aad135772d7cf93dd0ccf9d2474b34e6a">interpolation::NEAREST</a>, <a class="el" href="group__utility__types.html#gab283c517931abd4152ffa62fec62425d">cudf::sorted</a> is_input_sorted=<a class="el" href="group__utility__types.html#ggab283c517931abd4152ffa62fec62425dac2f3f489a00553e7a01d369c103c7251">sorted::NO</a>, std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;column_order={}, std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;null_precedence={}, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a9db69c255a5f64c2b3f9e4bc7e73caa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rows of the input corresponding to the requested quantiles.    <br /></td></tr>
<tr class="separator:a9db69c255a5f64c2b3f9e4bc7e73caa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698c778a6399397c6013e7d45c835b4c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a698c778a6399397c6013e7d45c835b4c">percentile_approx</a> (<a class="el" href="classcudf_1_1tdigest_1_1tdigest__column__view.html">tdigest::tdigest_column_view</a> const &amp;input, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;percentiles, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="separator:a698c778a6399397c6013e7d45c835b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a307e124575b78186601f1c689c05c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a47a307e124575b78186601f1c689c05c">repeat</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input_table, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;count, bool check_count, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="separator:a47a307e124575b78186601f1c689c05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75705d38197681267f667733ef0c1be4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a75705d38197681267f667733ef0c1be4">repeat</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input_table, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> count, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a75705d38197681267f667733ef0c1be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeat rows of a Table.    <br /></td></tr>
<tr class="separator:a75705d38197681267f667733ef0c1be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2782e7c057de7e1596841c366b471b3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#aa2782e7c057de7e1596841c366b471b3">replace_nulls</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> const &amp;replacement, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:aa2782e7c057de7e1596841c366b471b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all null values in a column with corresponding values of another column    <br /></td></tr>
<tr class="separator:aa2782e7c057de7e1596841c366b471b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089e06d35c8fc924a836da9e7fcce84e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a089e06d35c8fc924a836da9e7fcce84e">replace_nulls</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;replacement, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a089e06d35c8fc924a836da9e7fcce84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all null values in a column with a scalar.    <br /></td></tr>
<tr class="separator:a089e06d35c8fc924a836da9e7fcce84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0b4a9cf791df1c239576b67b2d9255"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a9c0b4a9cf791df1c239576b67b2d9255">replace_nulls</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="group__transformation__replace.html#ga7cdbc9bc3671930a743c86f36c38abf9">replace_policy</a> const &amp;<a class="el" href="group__transformation__replace.html#ga7cdbc9bc3671930a743c86f36c38abf9">replace_policy</a>, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a9c0b4a9cf791df1c239576b67b2d9255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all null values in a column with the first non-null value that precedes/follows.    <br /></td></tr>
<tr class="separator:a9c0b4a9cf791df1c239576b67b2d9255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade00a5854797478de85ef4f4735be57d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#ade00a5854797478de85ef4f4735be57d">replace_nans</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;replacement, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ade00a5854797478de85ef4f4735be57d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all NaN values in a column with corresponding values from another column    <br /></td></tr>
<tr class="separator:ade00a5854797478de85ef4f4735be57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0298a6133c943e5ef6107630fd267f1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#ad0298a6133c943e5ef6107630fd267f1">replace_nans</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;replacement, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ad0298a6133c943e5ef6107630fd267f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all NaN values in a column with a scalar    <br /></td></tr>
<tr class="separator:ad0298a6133c943e5ef6107630fd267f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacfa4e22fd6f93938a4d72131d9aff7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#adacfa4e22fd6f93938a4d72131d9aff7">find_and_replace_all</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input_col, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;values_to_replace, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;replacement_values, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:adacfa4e22fd6f93938a4d72131d9aff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of <code>input_col</code> replacing any <code>values_to_replace[i]</code> found with <code>replacement_values[i]</code>.    <br /></td></tr>
<tr class="separator:adacfa4e22fd6f93938a4d72131d9aff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841c17146b279d123c4d579ddd7e7f14"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a841c17146b279d123c4d579ddd7e7f14">normalize_nans_and_zeros</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a841c17146b279d123c4d579ddd7e7f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies from a column of floating-point elements and replaces <code>-NaN</code> and <code>-0.0</code> with <code>+NaN</code> and <code>+0.0</code>, respectively.    <br /></td></tr>
<tr class="separator:a841c17146b279d123c4d579ddd7e7f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0390f62b7fcc7ea895d0ca910e6403c7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a0390f62b7fcc7ea895d0ca910e6403c7">tile</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> count, rmm::cuda_stream_view, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a0390f62b7fcc7ea895d0ca910e6403c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeats the rows from <code>input</code> table <code>count</code> times to form a new table.    <br /></td></tr>
<tr class="separator:a0390f62b7fcc7ea895d0ca910e6403c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a76bcdabba736bbb9948129f723028"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a08a76bcdabba736bbb9948129f723028">interleave_columns</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, rmm::cuda_stream_view, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a08a76bcdabba736bbb9948129f723028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleave columns of a table into a single column.    <br /></td></tr>
<tr class="separator:a08a76bcdabba736bbb9948129f723028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e1b8f89952c1c18a574a822fa8c189"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a10e1b8f89952c1c18a574a822fa8c189">rolling_window</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;preceding_window, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;following_window, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> min_periods, <a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;agg, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a10e1b8f89952c1c18a574a822fa8c189"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__aggregation__rolling.html#gaaed6574615700cec1d4bf5469fe28141" title="Applies a variable-size rolling window function to the values in a column.">rolling_window(           column_view const&amp; input,           column_view const&amp; preceding_window,           column_view const&amp; following_window,           size_type min_periods,           rolling_aggregation const&amp; agg,           rmm::mr::device_memory_resource* mr)</a>  <br /></td></tr>
<tr class="separator:a10e1b8f89952c1c18a574a822fa8c189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8131d320d1ae7d8daea58311bc10ffeb"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a8131d320d1ae7d8daea58311bc10ffeb">round</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, int32_t decimal_places, <a class="el" href="group__transformation__unaryops.html#ga02028fc18312cdb2f07159c6297e74bb">rounding_method</a> method, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a8131d320d1ae7d8daea58311bc10ffeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds all the values in a column to the specified number of decimal places.    <br /></td></tr>
<tr class="separator:a8131d320d1ae7d8daea58311bc10ffeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9be538c2fe0b9e74c569460ecc65261"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#ac9be538c2fe0b9e74c569460ecc65261">scan_exclusive</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="classcudf_1_1scan__aggregation.html">scan_aggregation</a> const &amp;agg, <a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a> null_handling, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr)</td></tr>
<tr class="memdesc:ac9be538c2fe0b9e74c569460ecc65261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the exclusive scan of a column.  <br /></td></tr>
<tr class="separator:ac9be538c2fe0b9e74c569460ecc65261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc391e283f48ecd780dec6ceb2d0a6f9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#adc391e283f48ecd780dec6ceb2d0a6f9">scan_inclusive</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="classcudf_1_1scan__aggregation.html">scan_aggregation</a> const &amp;agg, <a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a> null_handling, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr)</td></tr>
<tr class="memdesc:adc391e283f48ecd780dec6ceb2d0a6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inclusive scan of a column.  <br /></td></tr>
<tr class="separator:adc391e283f48ecd780dec6ceb2d0a6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b644db01ab5c564aa3e2e865669b59d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a2b644db01ab5c564aa3e2e865669b59d">inclusive_rank_scan</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;order_by, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr)</td></tr>
<tr class="memdesc:a2b644db01ab5c564aa3e2e865669b59d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate row ranks for a column.  <br /></td></tr>
<tr class="separator:a2b644db01ab5c564aa3e2e865669b59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8016a38976fc8af9b8a9b3c23a08ae"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#acc8016a38976fc8af9b8a9b3c23a08ae">inclusive_dense_rank_scan</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;order_by, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr)</td></tr>
<tr class="memdesc:acc8016a38976fc8af9b8a9b3c23a08ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate row dense ranks for a column.  <br /></td></tr>
<tr class="separator:acc8016a38976fc8af9b8a9b3c23a08ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f61e90d14f101f0f7da7f140649f80"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#ab6f61e90d14f101f0f7da7f140649f80">inclusive_one_normalized_percent_rank_scan</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;order_by, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr)</td></tr>
<tr class="memdesc:ab6f61e90d14f101f0f7da7f140649f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate row ONE_NORMALIZED percent ranks for a column. Also, knowns as ANSI SQL PERCENT RANK. Calculated by (rank - 1) / (count - 1).  <br /></td></tr>
<tr class="separator:ab6f61e90d14f101f0f7da7f140649f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0fafddc49374af3d9ab6815196d426f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#ab0fafddc49374af3d9ab6815196d426f">scatter</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;source, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;scatter_map, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;target, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ab0fafddc49374af3d9ab6815196d426f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatters the rows of the source table into a copy of the target table according to a scatter map.  <br /></td></tr>
<tr class="separator:ab0fafddc49374af3d9ab6815196d426f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642afeffe44abb5382a4c44534503907"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a642afeffe44abb5382a4c44534503907">scatter</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;source, <a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt; const scatter_map, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;target, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="separator:a642afeffe44abb5382a4c44534503907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bdf86f00fd97bb400afe50fe644af52"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a5bdf86f00fd97bb400afe50fe644af52">scatter</a> (std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt; &gt; const &amp;source, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;indices, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;target, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a5bdf86f00fd97bb400afe50fe644af52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatters a row of scalar values into a copy of the target table according to a scatter map.  <br /></td></tr>
<tr class="separator:a5bdf86f00fd97bb400afe50fe644af52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab632fac16d86dcdec8172f105e9cc3bb"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#ab632fac16d86dcdec8172f105e9cc3bb">boolean_mask_scatter</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;source, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;target, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;boolean_mask, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ab632fac16d86dcdec8172f105e9cc3bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatters rows from the input table to rows of the output corresponding to true values in a boolean mask.    <br /></td></tr>
<tr class="separator:ab632fac16d86dcdec8172f105e9cc3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6f0ca2c888fcffaf3c516ba0b05498"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#aca6f0ca2c888fcffaf3c516ba0b05498">boolean_mask_scatter</a> (std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt; &gt; const &amp;source, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;target, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;boolean_mask, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="separator:aca6f0ca2c888fcffaf3c516ba0b05498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45dd74287624f555fcfb232087bb16e6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a45dd74287624f555fcfb232087bb16e6">lower_bound</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;haystack, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;needles, std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;column_order, std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;null_precedence, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr)</td></tr>
<tr class="memdesc:a45dd74287624f555fcfb232087bb16e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find smallest indices in a sorted table where values should be inserted to maintain order.    <br /></td></tr>
<tr class="separator:a45dd74287624f555fcfb232087bb16e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c2375ffd17459ecf1ef510fe8c2ea2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#ad5c2375ffd17459ecf1ef510fe8c2ea2">upper_bound</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;haystack, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;needles, std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;column_order, std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;null_precedence, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr)</td></tr>
<tr class="memdesc:ad5c2375ffd17459ecf1ef510fe8c2ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find largest indices in a sorted table where values should be inserted to maintain order.    <br /></td></tr>
<tr class="separator:ad5c2375ffd17459ecf1ef510fe8c2ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbae19d91d3507be87defb820d2e603"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#aabbae19d91d3507be87defb820d2e603">contains</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;haystack, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;needle, rmm::cuda_stream_view stream)</td></tr>
<tr class="separator:aabbae19d91d3507be87defb820d2e603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1de6dab4d4d341e17ff17cdff7a133"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a6c1de6dab4d4d341e17ff17cdff7a133">contains</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;haystack, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;needles, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr)</td></tr>
<tr class="memdesc:a6c1de6dab4d4d341e17ff17cdff7a133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given <code>needles</code> values exists in the <code>haystack</code> column.    <br /></td></tr>
<tr class="separator:a6c1de6dab4d4d341e17ff17cdff7a133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa272dc48c5c03c83e46dc103a86bdeb4"><td class="memItemLeft" align="right" valign="top">rmm::device_uvector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#aa272dc48c5c03c83e46dc103a86bdeb4">contains</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;haystack, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;needles, <a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a> compare_nulls, <a class="el" href="group__utility__types.html#gae9d1055c69c3089452794783c7c82f83">nan_equality</a> compare_nans, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:aa272dc48c5c03c83e46dc103a86bdeb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if rows in the given <code>needles</code> table exist in the <code>haystack</code> table.  <br /></td></tr>
<tr class="separator:aa272dc48c5c03c83e46dc103a86bdeb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaed9837e40ff8bcba1cb84806e191f3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#acaed9837e40ff8bcba1cb84806e191f3">sequence</a> (<a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> size, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;init, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;step, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:acaed9837e40ff8bcba1cb84806e191f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a column with a sequence of value specified by an initial value and a step.    <br /></td></tr>
<tr class="separator:acaed9837e40ff8bcba1cb84806e191f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de28f6150ae69e92bb463bdb86c94e3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a4de28f6150ae69e92bb463bdb86c94e3">sequence</a> (<a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> size, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;init, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a4de28f6150ae69e92bb463bdb86c94e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a column with a sequence of value specified by an initial value and a step of 1.    <br /></td></tr>
<tr class="separator:a4de28f6150ae69e92bb463bdb86c94e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab76605084c4a005ccd720c76fb828f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a8ab76605084c4a005ccd720c76fb828f">calendrical_month_sequence</a> (<a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> size, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;init, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> months, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a8ab76605084c4a005ccd720c76fb828f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a sequence of timestamps beginning at <code>init</code> and incrementing by <code>months</code> for each successive element, i.e., <code>output[i] = init + i * months</code> for <code>i</code> in <code>[0, size)</code>.    <br /></td></tr>
<tr class="separator:a8ab76605084c4a005ccd720c76fb828f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02dc7ba3e6b64741911634d22f34fa91"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a02dc7ba3e6b64741911634d22f34fa91">sorted_order</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;column_order={}, std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;null_precedence={}, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a02dc7ba3e6b64741911634d22f34fa91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the row indices that would produce <code>input</code> in a lexicographical sorted order.    <br /></td></tr>
<tr class="separator:a02dc7ba3e6b64741911634d22f34fa91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eacf26ccb873b752827c9316f858ca9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a7eacf26ccb873b752827c9316f858ca9">stable_sorted_order</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;column_order={}, std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;null_precedence={}, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a7eacf26ccb873b752827c9316f858ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the row indices that would produce <code>input</code> in a stable lexicographical sorted order.    <br /></td></tr>
<tr class="separator:a7eacf26ccb873b752827c9316f858ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef04bcc6a371c3a2ecdd1a24d413b06"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a8ef04bcc6a371c3a2ecdd1a24d413b06">sort_by_key</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;values, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;keys, std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;column_order={}, std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;null_precedence={}, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a8ef04bcc6a371c3a2ecdd1a24d413b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a key-value sort.    <br /></td></tr>
<tr class="separator:a8ef04bcc6a371c3a2ecdd1a24d413b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ef84bbffe708df280ab3edd030a761"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#af8ef84bbffe708df280ab3edd030a761">stable_sort_by_key</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;values, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;keys, std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;column_order={}, std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;null_precedence={}, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:af8ef84bbffe708df280ab3edd030a761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a key-value stable sort.    <br /></td></tr>
<tr class="separator:af8ef84bbffe708df280ab3edd030a761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee83cd6aa2e87076b5f8c39fbf08719"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a5ee83cd6aa2e87076b5f8c39fbf08719">segmented_sorted_order</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;keys, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;segment_offsets, std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;column_order={}, std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;null_precedence={}, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a5ee83cd6aa2e87076b5f8c39fbf08719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns sorted order after sorting each segment in the table.    <br /></td></tr>
<tr class="separator:a5ee83cd6aa2e87076b5f8c39fbf08719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2457ab266f3c83ee1803af46d40431"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a9f2457ab266f3c83ee1803af46d40431">stable_segmented_sorted_order</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;keys, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;segment_offsets, std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;column_order={}, std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;null_precedence={}, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a9f2457ab266f3c83ee1803af46d40431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns sorted order after stably sorting each segment in the table.    <br /></td></tr>
<tr class="separator:a9f2457ab266f3c83ee1803af46d40431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0143b14fe58e9f453958200e4bd745b2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a0143b14fe58e9f453958200e4bd745b2">segmented_sort_by_key</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;values, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;keys, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;segment_offsets, std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;column_order={}, std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;null_precedence={}, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a0143b14fe58e9f453958200e4bd745b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a lexicographic segmented sort of a table    <br /></td></tr>
<tr class="separator:a0143b14fe58e9f453958200e4bd745b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617cf9daf1ccb662f23d1751d8e9eef1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a617cf9daf1ccb662f23d1751d8e9eef1">stable_segmented_sort_by_key</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;values, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;keys, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;segment_offsets, std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;column_order={}, std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;null_precedence={}, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a617cf9daf1ccb662f23d1751d8e9eef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a stably lexicographic segmented sort of a table    <br /></td></tr>
<tr class="separator:a617cf9daf1ccb662f23d1751d8e9eef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ecb769bcadd1469d96dab94bc9fb92c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a6ecb769bcadd1469d96dab94bc9fb92c">sort</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;values, std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;column_order={}, std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;null_precedence={}, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a6ecb769bcadd1469d96dab94bc9fb92c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a lexicographic sort of the rows of a table    <br /></td></tr>
<tr class="separator:a6ecb769bcadd1469d96dab94bc9fb92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad692201878dfd4b9058cef0428bf3d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a3ad692201878dfd4b9058cef0428bf3d">drop_nulls</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; const &amp;keys, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a> keep_threshold, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a3ad692201878dfd4b9058cef0428bf3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a table to remove null elements with threshold count.    <br /></td></tr>
<tr class="separator:a3ad692201878dfd4b9058cef0428bf3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bde81471b27ab73aa588c4e79937199"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a8bde81471b27ab73aa588c4e79937199">drop_nans</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; const &amp;keys, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a> keep_threshold, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a8bde81471b27ab73aa588c4e79937199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a table to remove NANs with threshold count.    <br /></td></tr>
<tr class="separator:a8bde81471b27ab73aa588c4e79937199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b172e383c23e8f5266dae0ffc4d53d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a37b172e383c23e8f5266dae0ffc4d53d">apply_boolean_mask</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;boolean_mask, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a37b172e383c23e8f5266dae0ffc4d53d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters <code>input</code> using <code>boolean_mask</code> of boolean values as a mask.    <br /></td></tr>
<tr class="separator:a37b172e383c23e8f5266dae0ffc4d53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641f75ce86d28e459d73c6afe246f43c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a641f75ce86d28e459d73c6afe246f43c">unique</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; const &amp;keys, <a class="el" href="group__reorder__compact.html#ga69091647ea1f9c9d4cdcf7c8876bea3a">duplicate_keep_option</a> keep, <a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a> nulls_equal=<a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44">null_equality::EQUAL</a>, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a641f75ce86d28e459d73c6afe246f43c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new table with consecutive duplicate rows removed.    <br /></td></tr>
<tr class="separator:a641f75ce86d28e459d73c6afe246f43c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d13444c532389ceda0e73e6fa73081"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a32d13444c532389ceda0e73e6fa73081">distinct</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; const &amp;keys, <a class="el" href="group__reorder__compact.html#ga69091647ea1f9c9d4cdcf7c8876bea3a">duplicate_keep_option</a> keep=<a class="el" href="group__reorder__compact.html#gga69091647ea1f9c9d4cdcf7c8876bea3aa0546025abe5830d9334bb82102420394">duplicate_keep_option::KEEP_ANY</a>, <a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a> nulls_equal=<a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44">null_equality::EQUAL</a>, <a class="el" href="group__utility__types.html#gae9d1055c69c3089452794783c7c82f83">nan_equality</a> nans_equal=<a class="el" href="group__utility__types.html#ggae9d1055c69c3089452794783c7c82f83acd6d9f766e6e2753da429d26078711d7">nan_equality::ALL_EQUAL</a>, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a32d13444c532389ceda0e73e6fa73081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new table without duplicate rows.    <br /></td></tr>
<tr class="separator:a32d13444c532389ceda0e73e6fa73081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae447240ab710451b66b73e15b19e50f4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#ae447240ab710451b66b73e15b19e50f4">stable_distinct</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; const &amp;keys, <a class="el" href="group__reorder__compact.html#ga69091647ea1f9c9d4cdcf7c8876bea3a">duplicate_keep_option</a> keep=<a class="el" href="group__reorder__compact.html#gga69091647ea1f9c9d4cdcf7c8876bea3aa0546025abe5830d9334bb82102420394">duplicate_keep_option::KEEP_ANY</a>, <a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a> nulls_equal=<a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44">null_equality::EQUAL</a>, <a class="el" href="group__utility__types.html#gae9d1055c69c3089452794783c7c82f83">nan_equality</a> nans_equal=<a class="el" href="group__utility__types.html#ggae9d1055c69c3089452794783c7c82f83acd6d9f766e6e2753da429d26078711d7">nan_equality::ALL_EQUAL</a>, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ae447240ab710451b66b73e15b19e50f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new table without duplicate rows.  <br /></td></tr>
<tr class="separator:ae447240ab710451b66b73e15b19e50f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67374a27ed17df376e445010d699fc62"><td class="memItemLeft" align="right" valign="top">rmm::device_uvector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a67374a27ed17df376e445010d699fc62">get_distinct_indices</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, <a class="el" href="group__reorder__compact.html#ga69091647ea1f9c9d4cdcf7c8876bea3a">duplicate_keep_option</a> keep=<a class="el" href="group__reorder__compact.html#gga69091647ea1f9c9d4cdcf7c8876bea3aa0546025abe5830d9334bb82102420394">duplicate_keep_option::KEEP_ANY</a>, <a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a> nulls_equal=<a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44">null_equality::EQUAL</a>, <a class="el" href="group__utility__types.html#gae9d1055c69c3089452794783c7c82f83">nan_equality</a> nans_equal=<a class="el" href="group__utility__types.html#ggae9d1055c69c3089452794783c7c82f83acd6d9f766e6e2753da429d26078711d7">nan_equality::ALL_EQUAL</a>, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a67374a27ed17df376e445010d699fc62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a column of indices of all distinct rows in the input table.  <br /></td></tr>
<tr class="separator:a67374a27ed17df376e445010d699fc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e8b391af43f65454777fb93ac1810b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a98e8b391af43f65454777fb93ac1810b">unique_count</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a> null_handling, <a class="el" href="group__utility__types.html#ga74641d3dfd6d96d0939b492ecf9b9cc8">nan_policy</a> nan_handling, rmm::cuda_stream_view stream)</td></tr>
<tr class="memdesc:a98e8b391af43f65454777fb93ac1810b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of consecutive groups of equivalent rows in a column.    <br /></td></tr>
<tr class="separator:a98e8b391af43f65454777fb93ac1810b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310da6da06499f366f5df272a540182e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a310da6da06499f366f5df272a540182e">unique_count</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a> nulls_equal=<a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44">null_equality::EQUAL</a>, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>())</td></tr>
<tr class="memdesc:a310da6da06499f366f5df272a540182e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of consecutive groups of equivalent rows in a table.    <br /></td></tr>
<tr class="separator:a310da6da06499f366f5df272a540182e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc80778d27d66fad4e9e6d102f5b4f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#aedc80778d27d66fad4e9e6d102f5b4f6">distinct_count</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a> null_handling, <a class="el" href="group__utility__types.html#ga74641d3dfd6d96d0939b492ecf9b9cc8">nan_policy</a> nan_handling, rmm::cuda_stream_view stream)</td></tr>
<tr class="memdesc:aedc80778d27d66fad4e9e6d102f5b4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the distinct elements in the <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a>.    <br /></td></tr>
<tr class="separator:aedc80778d27d66fad4e9e6d102f5b4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e020feeee7f44561f850a2e42647d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#ab3e020feeee7f44561f850a2e42647d5">distinct_count</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a> nulls_equal=<a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44">null_equality::EQUAL</a>, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>())</td></tr>
<tr class="memdesc:ab3e020feeee7f44561f850a2e42647d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the distinct rows in a table.    <br /></td></tr>
<tr class="separator:ab3e020feeee7f44561f850a2e42647d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dea2d4015483abd8062b4f3e8c49ecf"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a8dea2d4015483abd8062b4f3e8c49ecf">transform</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, std::string const &amp;unary_udf, <a class="el" href="classcudf_1_1data__type.html">data_type</a> output_type, bool is_ptx, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a8dea2d4015483abd8062b4f3e8c49ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new column by applying a unary function against every element of an input column.    <br /></td></tr>
<tr class="separator:a8dea2d4015483abd8062b4f3e8c49ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8323757962d4b3d4b41b9d06289914"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a0c8323757962d4b3d4b41b9d06289914">compute_column</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const <a class="el" href="classcudf_1_1table.html">table</a>, <a class="el" href="classcudf_1_1ast_1_1operation.html">ast::operation</a> const &amp;expr, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a0c8323757962d4b3d4b41b9d06289914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a new column by evaluating an expression tree on a table.    <br /></td></tr>
<tr class="separator:a0c8323757962d4b3d4b41b9d06289914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7e1bd82e43f366a0455d2c606ff212"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; rmm::device_buffer &gt;, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#abb7e1bd82e43f366a0455d2c606ff212">nans_to_nulls</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:abb7e1bd82e43f366a0455d2c606ff212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a null_mask from <code>input</code> by converting <code>NaN</code> to null and preserving existing null values and also returns new null_count.    <br /></td></tr>
<tr class="separator:abb7e1bd82e43f366a0455d2c606ff212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38866396e5c2b317d7075374fe64777"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; rmm::device_buffer &gt;, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#ad38866396e5c2b317d7075374fe64777">bools_to_mask</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ad38866396e5c2b317d7075374fe64777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a bitmask from a column of boolean elements.    <br /></td></tr>
<tr class="separator:ad38866396e5c2b317d7075374fe64777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861eb8ba4d559b6db57beb584530fb31"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">cudf::table</a> &gt;, std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a861eb8ba4d559b6db57beb584530fb31">encode</a> (<a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;input, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a861eb8ba4d559b6db57beb584530fb31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode the rows of the given table as integers    <br /></td></tr>
<tr class="separator:a861eb8ba4d559b6db57beb584530fb31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30bc52a8dbe05164e2d5fc0b49e1844"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;, <a class="el" href="classcudf_1_1table__view.html">table_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#ad30bc52a8dbe05164e2d5fc0b49e1844">one_hot_encode</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;categories, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ad30bc52a8dbe05164e2d5fc0b49e1844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes <code>input</code> by generating a new column for each value in <code>categories</code> indicating the presence of that value in <code>input</code>.    <br /></td></tr>
<tr class="separator:ad30bc52a8dbe05164e2d5fc0b49e1844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcca95b53757f3fc776e4a53c762e318"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#adcca95b53757f3fc776e4a53c762e318">mask_to_bools</a> (<a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> const *null_mask, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> begin_bit, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> end_bit, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:adcca95b53757f3fc776e4a53c762e318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a boolean column from given bitmask.    <br /></td></tr>
<tr class="separator:adcca95b53757f3fc776e4a53c762e318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f65c99023599795be67aafb3c125b88"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a6f65c99023599795be67aafb3c125b88">row_bit_count</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;t, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a6f65c99023599795be67aafb3c125b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an approximate cumulative size in bits of all columns in the <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> for each row.    <br /></td></tr>
<tr class="separator:a6f65c99023599795be67aafb3c125b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5fe789c6b4148db15bad46557ad89d1"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;, <a class="el" href="classcudf_1_1table__view.html">table_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#ac5fe789c6b4148db15bad46557ad89d1">transpose</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ac5fe789c6b4148db15bad46557ad89d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes a table.    <br /></td></tr>
<tr class="separator:ac5fe789c6b4148db15bad46557ad89d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e1aa6f630065804422ba95e76da8f2"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:ac0e1aa6f630065804422ba95e76da8f2"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#ac0e1aa6f630065804422ba95e76da8f2">true_if</a> (InputIterator begin, InputIterator end, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> size, Predicate p, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ac0e1aa6f630065804422ba95e76da8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a column of <code><a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd" title="Boolean using one byte per value, 0 == false, else true">type_id::BOOL8</a></code> elements by applying a predicate to every element between [<code>begin,</code>end<code>)</code>true<code>indicates the value is satisfies the predicate and</code>false` indicates it doesn't.  <br /></td></tr>
<tr class="separator:ac0e1aa6f630065804422ba95e76da8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1d1df6733679d2f522bd838eae342a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#acc1d1df6733679d2f522bd838eae342a">unary_operation</a> (<a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> const &amp;input, <a class="el" href="group__transformation__unaryops.html#ga030e62f30b296602f398e70d1ca657c4">cudf::unary_operator</a> op, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:acc1d1df6733679d2f522bd838eae342a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs unary op on all values in column    <br /></td></tr>
<tr class="separator:acc1d1df6733679d2f522bd838eae342a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d9341a3c49eb3b9d237d9da1c1e5ac"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#ac2d9341a3c49eb3b9d237d9da1c1e5ac">cast</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="classcudf_1_1data__type.html">data_type</a> type, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ac2d9341a3c49eb3b9d237d9da1c1e5ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts data from dtype specified in input to dtype specified in output.    <br /></td></tr>
<tr class="separator:ac2d9341a3c49eb3b9d237d9da1c1e5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87fb076548c816c8477d213d3b56362a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a87fb076548c816c8477d213d3b56362a">is_nan</a> (<a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> const &amp;input, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a87fb076548c816c8477d213d3b56362a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a column of <code><a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd" title="Boolean using one byte per value, 0 == false, else true">type_id::BOOL8</a></code> elements indicating the presence of <code>NaN</code> values in a column of floating point values. The output element at row <code>i</code> is <code>true</code> if the element in <code>input</code> at row i is <code>NAN</code>, else <code>false</code>    <br /></td></tr>
<tr class="separator:a87fb076548c816c8477d213d3b56362a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab222fc99bdf3b292820aa2502058869"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#aab222fc99bdf3b292820aa2502058869">is_not_nan</a> (<a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> const &amp;input, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:aab222fc99bdf3b292820aa2502058869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a column of <code><a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd" title="Boolean using one byte per value, 0 == false, else true">type_id::BOOL8</a></code> elements indicating the absence of <code>NaN</code> values in a column of floating point values. The output element at row <code>i</code> is <code>false</code> if the element in <code>input</code> at row i is <code>NAN</code>, else <code>true</code>    <br /></td></tr>
<tr class="separator:aab222fc99bdf3b292820aa2502058869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1454447a634ec7b0e34b066fd6f950a2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1454447a634ec7b0e34b066fd6f950a2"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a1454447a634ec7b0e34b066fd6f950a2">align_ptr_for_type</a> (void *destination)</td></tr>
<tr class="memdesc:a1454447a634ec7b0e34b066fd6f950a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the aligned address for holding array of type T in pre-allocated memory.  <br /></td></tr>
<tr class="separator:a1454447a634ec7b0e34b066fd6f950a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6afca7c4d88ca63b0e0903ac5c09ae0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecudf_1_1detail.html#a627e116400c1bed3d5f2b3ab78661fe8">LinkedColVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#ab6afca7c4d88ca63b0e0903ac5c09ae0">table_to_linked_columns</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;<a class="el" href="classcudf_1_1table.html">table</a>)</td></tr>
<tr class="memdesc:ab6afca7c4d88ca63b0e0903ac5c09ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts all column_views of a table into linked_column_views  <br /></td></tr>
<tr class="separator:ab6afca7c4d88ca63b0e0903ac5c09ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab330bdc16d921431c949ade216386305"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab330bdc16d921431c949ade216386305"><td class="memTemplItemLeft" align="right" valign="top">rmm::device_uvector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#ab330bdc16d921431c949ade216386305">make_zeroed_device_uvector_async</a> (std::size_t size, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ab330bdc16d921431c949ade216386305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously construct a <code>device_uvector</code> and set all elements to zero.  <br /></td></tr>
<tr class="separator:ab330bdc16d921431c949ade216386305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbce3bdea9ae93c27fedd21b4177e4f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1cbce3bdea9ae93c27fedd21b4177e4f"><td class="memTemplItemLeft" align="right" valign="top">rmm::device_uvector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a1cbce3bdea9ae93c27fedd21b4177e4f">make_zeroed_device_uvector_sync</a> (std::size_t size, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a1cbce3bdea9ae93c27fedd21b4177e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously construct a <code>device_uvector</code> and set all elements to zero.  <br /></td></tr>
<tr class="separator:a1cbce3bdea9ae93c27fedd21b4177e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58212f43ad1509a309bf99b6abcabb3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af58212f43ad1509a309bf99b6abcabb3"><td class="memTemplItemLeft" align="right" valign="top">rmm::device_uvector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#af58212f43ad1509a309bf99b6abcabb3">make_device_uvector_async</a> (<a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; T const &gt; source_data, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:af58212f43ad1509a309bf99b6abcabb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously construct a <code>device_uvector</code> containing a deep copy of data from a <code><a class="el" href="structcudf_1_1host__span.html" title="C++20 std::span with reduced feature set.">host_span</a></code>  <br /></td></tr>
<tr class="separator:af58212f43ad1509a309bf99b6abcabb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3025511800f795e70b22eba7fd0def7"><td class="memTemplParams" colspan="2">template&lt;typename Container , std::enable_if_t&lt; std::is_convertible_v&lt; Container, <a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; typename Container::value_type const &gt; &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad3025511800f795e70b22eba7fd0def7"><td class="memTemplItemLeft" align="right" valign="top">rmm::device_uvector&lt; typename Container::value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#ad3025511800f795e70b22eba7fd0def7">make_device_uvector_async</a> (Container const &amp;c, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ad3025511800f795e70b22eba7fd0def7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously construct a <code>device_uvector</code> containing a deep copy of data from a host container  <br /></td></tr>
<tr class="separator:ad3025511800f795e70b22eba7fd0def7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556dd2e77b79628c78ec6718935f565d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a556dd2e77b79628c78ec6718935f565d"><td class="memTemplItemLeft" align="right" valign="top">rmm::device_uvector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a556dd2e77b79628c78ec6718935f565d">make_device_uvector_async</a> (<a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; T const &gt; source_data, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a556dd2e77b79628c78ec6718935f565d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously construct a <code>device_uvector</code> containing a deep copy of data from a <code><a class="el" href="structcudf_1_1device__span.html" title="Device version of C++20 std::span with reduced feature set.">device_span</a></code>  <br /></td></tr>
<tr class="separator:a556dd2e77b79628c78ec6718935f565d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567b65a608d7b1818cff9632b3dafde8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a567b65a608d7b1818cff9632b3dafde8"><td class="memTemplItemLeft" align="right" valign="top">rmm::device_uvector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a567b65a608d7b1818cff9632b3dafde8">make_device_uvector_sync</a> (<a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; T const &gt; source_data, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a567b65a608d7b1818cff9632b3dafde8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously construct a <code>device_uvector</code> containing a deep copy of data from a <code><a class="el" href="structcudf_1_1host__span.html" title="C++20 std::span with reduced feature set.">host_span</a></code>  <br /></td></tr>
<tr class="separator:a567b65a608d7b1818cff9632b3dafde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1c217de33d11bb490a51d1904361f9"><td class="memTemplParams" colspan="2">template&lt;typename Container , std::enable_if_t&lt; std::is_convertible_v&lt; Container, <a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; typename Container::value_type const &gt; &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5f1c217de33d11bb490a51d1904361f9"><td class="memTemplItemLeft" align="right" valign="top">rmm::device_uvector&lt; typename Container::value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a5f1c217de33d11bb490a51d1904361f9">make_device_uvector_sync</a> (Container const &amp;c, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a5f1c217de33d11bb490a51d1904361f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously construct a <code>device_uvector</code> containing a deep copy of data from a host container  <br /></td></tr>
<tr class="separator:a5f1c217de33d11bb490a51d1904361f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7fae42222fe71f2374141166c508cc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5a7fae42222fe71f2374141166c508cc"><td class="memTemplItemLeft" align="right" valign="top">rmm::device_uvector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a5a7fae42222fe71f2374141166c508cc">make_device_uvector_sync</a> (<a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; T const &gt; source_data, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a5a7fae42222fe71f2374141166c508cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously construct a <code>device_uvector</code> containing a deep copy of data from a <code><a class="el" href="structcudf_1_1device__span.html" title="Device version of C++20 std::span with reduced feature set.">device_span</a></code>  <br /></td></tr>
<tr class="separator:a5a7fae42222fe71f2374141166c508cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b73da63a9fe3fdc5f94d0095cb43c83"><td class="memTemplParams" colspan="2">template&lt;typename T , typename OutContainer &gt; </td></tr>
<tr class="memitem:a0b73da63a9fe3fdc5f94d0095cb43c83"><td class="memTemplItemLeft" align="right" valign="top">OutContainer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a0b73da63a9fe3fdc5f94d0095cb43c83">make_vector_async</a> (<a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; T const &gt; v, rmm::cuda_stream_view stream)</td></tr>
<tr class="separator:a0b73da63a9fe3fdc5f94d0095cb43c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f86869461e901b87a711c8fb331c17a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0f86869461e901b87a711c8fb331c17a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a0f86869461e901b87a711c8fb331c17a">make_std_vector_async</a> (<a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; T const &gt; v, rmm::cuda_stream_view stream)</td></tr>
<tr class="memdesc:a0f86869461e901b87a711c8fb331c17a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously construct a <code>std::vector</code> containing a copy of data from a <code><a class="el" href="structcudf_1_1device__span.html" title="Device version of C++20 std::span with reduced feature set.">device_span</a></code>  <br /></td></tr>
<tr class="separator:a0f86869461e901b87a711c8fb331c17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13119be3a169f0210957725db3d144d"><td class="memTemplParams" colspan="2">template&lt;typename Container , std::enable_if_t&lt; std::is_convertible_v&lt; Container, <a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; typename Container::value_type const &gt; &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af13119be3a169f0210957725db3d144d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename Container::value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#af13119be3a169f0210957725db3d144d">make_std_vector_async</a> (Container const &amp;c, rmm::cuda_stream_view stream)</td></tr>
<tr class="memdesc:af13119be3a169f0210957725db3d144d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously construct a <code>std::vector</code> containing a copy of data from a device container  <br /></td></tr>
<tr class="separator:af13119be3a169f0210957725db3d144d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3ae2fa6ca2edd73742c6e0ffcb8d49"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aea3ae2fa6ca2edd73742c6e0ffcb8d49"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#aea3ae2fa6ca2edd73742c6e0ffcb8d49">make_std_vector_sync</a> (<a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; T const &gt; v, rmm::cuda_stream_view stream)</td></tr>
<tr class="memdesc:aea3ae2fa6ca2edd73742c6e0ffcb8d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously construct a <code>std::vector</code> containing a copy of data from a <code><a class="el" href="structcudf_1_1device__span.html" title="Device version of C++20 std::span with reduced feature set.">device_span</a></code>  <br /></td></tr>
<tr class="separator:aea3ae2fa6ca2edd73742c6e0ffcb8d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e49334977092cc1447d12b3aad3b76"><td class="memTemplParams" colspan="2">template&lt;typename Container , std::enable_if_t&lt; std::is_convertible_v&lt; Container, <a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; typename Container::value_type const &gt; &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a76e49334977092cc1447d12b3aad3b76"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename Container::value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a76e49334977092cc1447d12b3aad3b76">make_std_vector_sync</a> (Container const &amp;c, rmm::cuda_stream_view stream)</td></tr>
<tr class="memdesc:a76e49334977092cc1447d12b3aad3b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously construct a <code>std::vector</code> containing a copy of data from a device container  <br /></td></tr>
<tr class="separator:a76e49334977092cc1447d12b3aad3b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6bc114d57f9b4ebe7b1fd1c0debeb3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6a6bc114d57f9b4ebe7b1fd1c0debeb3"><td class="memTemplItemLeft" align="right" valign="top">thrust::host_vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a6a6bc114d57f9b4ebe7b1fd1c0debeb3">make_host_vector_async</a> (<a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; T const &gt; v, rmm::cuda_stream_view stream)</td></tr>
<tr class="memdesc:a6a6bc114d57f9b4ebe7b1fd1c0debeb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously construct a <code>thrust::host_vector</code> containing a copy of data from a <code><a class="el" href="structcudf_1_1device__span.html" title="Device version of C++20 std::span with reduced feature set.">device_span</a></code>  <br /></td></tr>
<tr class="separator:a6a6bc114d57f9b4ebe7b1fd1c0debeb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a6ec6815c3166045d3417e832d1601"><td class="memTemplParams" colspan="2">template&lt;typename Container , std::enable_if_t&lt; std::is_convertible_v&lt; Container, <a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; typename Container::value_type const &gt; &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac8a6ec6815c3166045d3417e832d1601"><td class="memTemplItemLeft" align="right" valign="top">thrust::host_vector&lt; typename Container::value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#ac8a6ec6815c3166045d3417e832d1601">make_host_vector_async</a> (Container const &amp;c, rmm::cuda_stream_view stream)</td></tr>
<tr class="memdesc:ac8a6ec6815c3166045d3417e832d1601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously construct a <code>std::vector</code> containing a copy of data from a device container  <br /></td></tr>
<tr class="separator:ac8a6ec6815c3166045d3417e832d1601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac324b531a3240ff154b04007561c9f34"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac324b531a3240ff154b04007561c9f34"><td class="memTemplItemLeft" align="right" valign="top">thrust::host_vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#ac324b531a3240ff154b04007561c9f34">make_host_vector_sync</a> (<a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; T const &gt; v, rmm::cuda_stream_view stream)</td></tr>
<tr class="memdesc:ac324b531a3240ff154b04007561c9f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously construct a <code>std::vector</code> containing a copy of data from a <code><a class="el" href="structcudf_1_1device__span.html" title="Device version of C++20 std::span with reduced feature set.">device_span</a></code>  <br /></td></tr>
<tr class="separator:ac324b531a3240ff154b04007561c9f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a07077e71fffd39a9bae1ef7bfa379"><td class="memTemplParams" colspan="2">template&lt;typename Container , std::enable_if_t&lt; std::is_convertible_v&lt; Container, <a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; typename Container::value_type const &gt; &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a19a07077e71fffd39a9bae1ef7bfa379"><td class="memTemplItemLeft" align="right" valign="top">thrust::host_vector&lt; typename Container::value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a19a07077e71fffd39a9bae1ef7bfa379">make_host_vector_sync</a> (Container const &amp;c, rmm::cuda_stream_view stream)</td></tr>
<tr class="memdesc:a19a07077e71fffd39a9bae1ef7bfa379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously construct a <code>std::vector</code> containing a copy of data from a device container  <br /></td></tr>
<tr class="separator:a19a07077e71fffd39a9bae1ef7bfa379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5582c4cfcb5c5c104088fb0d03596c"><td class="memTemplParams" colspan="2">template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:a3e5582c4cfcb5c5c104088fb0d03596c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a3e5582c4cfcb5c5c104088fb0d03596c">visitor_overload</a> (Ts...) -&gt; <a class="el" href="structcudf_1_1detail_1_1visitor__overload.html">visitor_overload</a>&lt; Ts... &gt;</td></tr>
<tr class="separator:a3e5582c4cfcb5c5c104088fb0d03596c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca203cd4504a08ef2fd489410d6db95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1detail_1_1dremel__data.html">dremel_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a6ca203cd4504a08ef2fd489410d6db95">get_dremel_data</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> h_col, std::vector&lt; uint8_t &gt; nullability, bool output_as_byte_array, rmm::cuda_stream_view stream)</td></tr>
<tr class="memdesc:a6ca203cd4504a08ef2fd489410d6db95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dremel offsets and repetition and definition levels for a LIST column  <br /></td></tr>
<tr class="separator:a6ca203cd4504a08ef2fd489410d6db95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee63ff93909aab1cf205625ee996236a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#aee63ff93909aab1cf205625ee996236a">has_nested_columns</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;<a class="el" href="classcudf_1_1table.html">table</a>)</td></tr>
<tr class="memdesc:aee63ff93909aab1cf205625ee996236a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if any nested columns exist in a given table.  <br /></td></tr>
<tr class="separator:aee63ff93909aab1cf205625ee996236a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3723537389c05b4a90958589c304f2fb"><td class="memTemplParams" colspan="2">template&lt;typename TableView &gt; </td></tr>
<tr class="memitem:a3723537389c05b4a90958589c304f2fb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a3723537389c05b4a90958589c304f2fb">is_relationally_comparable</a> (TableView const &amp;lhs, TableView const &amp;rhs)</td></tr>
<tr class="memdesc:a3723537389c05b4a90958589c304f2fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether respective columns in input tables are relationally comparable.  <br /></td></tr>
<tr class="separator:a3723537389c05b4a90958589c304f2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84962657d1071313a0e63f3c05a4c26a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a84962657d1071313a0e63f3c05a4c26a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="types_8hpp.html#adc4a74f3fb4b327ed43b31d0fca65ba3">CUDF_HOST_DEVICE</a> std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a84962657d1071313a0e63f3c05a4c26a">size_in_bits</a> ()</td></tr>
<tr class="memdesc:a84962657d1071313a0e63f3c05a4c26a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bits the given type can hold.  <br /></td></tr>
<tr class="separator:a84962657d1071313a0e63f3c05a4c26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
变量</h2></td></tr>
<tr class="memitem:a6696755213d5d4098e2057a314205f9c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a6696755213d5d4098e2057a314205f9c">ARGMAX_SENTINEL</a> {-1}</td></tr>
<tr class="memdesc:a6696755213d5d4098e2057a314205f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sentinel value used for <code>ARGMAX</code> aggregation.  <br /></td></tr>
<tr class="separator:a6696755213d5d4098e2057a314205f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ccf176241d88b7575d0e1f72d00c6c6"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a0ccf176241d88b7575d0e1f72d00c6c6">ARGMIN_SENTINEL</a> {-1}</td></tr>
<tr class="memdesc:a0ccf176241d88b7575d0e1f72d00c6c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sentinel value used for <code>ARGMIN</code> aggregation.  <br /></td></tr>
<tr class="separator:a0ccf176241d88b7575d0e1f72d00c6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5aa2bb950ef46c1f618dfa206142597"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#ab5aa2bb950ef46c1f618dfa206142597">DEFAULT_JOIN_CG_SIZE</a> = 2</td></tr>
<tr class="separator:ab5aa2bb950ef46c1f618dfa206142597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dea3cc353c312e3683f15e4a01cf752"><td class="memItemLeft" align="right" valign="top">rmm::cuda_stream_view const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html#a1dea3cc353c312e3683f15e4a01cf752">default_stream_value</a></td></tr>
<tr class="memdesc:a1dea3cc353c312e3683f15e4a01cf752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default stream for cudf  <br /></td></tr>
<tr class="separator:a1dea3cc353c312e3683f15e4a01cf752"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><p>Inner interfaces and implementations </p>
</div><h2 class="groupheader">类型定义说明</h2>
<a id="aa8d997e03a111aad833923bbfa0fc631" name="aa8d997e03a111aad833923bbfa0fc631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8d997e03a111aad833923bbfa0fc631">&#9670;&#160;</a></span>device_2dspan</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecudf_1_1detail.html#aa8d997e03a111aad833923bbfa0fc631">cudf::detail::device_2dspan</a> = typedef <a class="el" href="classcudf_1_1detail_1_1base__2dspan.html">base_2dspan</a>&lt;T, <a class="el" href="structcudf_1_1device__span.html">device_span</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for the 2D span for device data. </p>
<p>Index operator returns rows as <code><a class="el" href="structcudf_1_1device__span.html" title="Device version of C++20 std::span with reduced feature set.">device_span</a></code>. </p>

<p class="definition">在文件 <a class="el" href="span_8hpp_source.html">span.hpp</a> 第 <a class="el" href="span_8hpp_source.html#l00496">496</a> 行定义.</p>

</div>
</div>
<a id="ad766fd47aef5cd45824e7789f42247ed" name="ad766fd47aef5cd45824e7789f42247ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad766fd47aef5cd45824e7789f42247ed">&#9670;&#160;</a></span>host_2dspan</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecudf_1_1detail.html#ad766fd47aef5cd45824e7789f42247ed">cudf::detail::host_2dspan</a> = typedef <a class="el" href="classcudf_1_1detail_1_1base__2dspan.html">base_2dspan</a>&lt;T, <a class="el" href="structcudf_1_1host__span.html">host_span</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for the 2D span for host data. </p>
<p>Index operator returns rows as <code><a class="el" href="structcudf_1_1host__span.html" title="C++20 std::span with reduced feature set.">host_span</a></code>. </p>

<p class="definition">在文件 <a class="el" href="span_8hpp_source.html">span.hpp</a> 第 <a class="el" href="span_8hpp_source.html#l00488">488</a> 行定义.</p>

</div>
</div>
<a id="a8a62804f4d08dbf686b957e2bdfb06be" name="a8a62804f4d08dbf686b957e2bdfb06be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a62804f4d08dbf686b957e2bdfb06be">&#9670;&#160;</a></span>kind_to_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classcudf_1_1aggregation.html#a83579ae3cab2fc3d1c3b377d1cfab24c">aggregation::Kind</a> k&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecudf_1_1detail.html#a8a62804f4d08dbf686b957e2bdfb06be">cudf::detail::kind_to_type</a> = typedef typename <a class="el" href="structcudf_1_1detail_1_1kind__to__type__impl.html">kind_to_type_impl</a>&lt;k&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">在文件 <a class="el" href="detail_2aggregation_2aggregation_8hpp_source.html">aggregation.hpp</a> 第 <a class="el" href="detail_2aggregation_2aggregation_8hpp_source.html#l01370">1370</a> 行定义.</p>

</div>
</div>
<a id="a8bef759d42ac528d33f331de080d5584" name="a8bef759d42ac528d33f331de080d5584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bef759d42ac528d33f331de080d5584">&#9670;&#160;</a></span>LinkedColPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecudf_1_1detail.html#a8bef759d42ac528d33f331de080d5584">cudf::detail::LinkedColPtr</a> = typedef std::shared_ptr&lt;<a class="el" href="structcudf_1_1detail_1_1linked__column__view.html">linked_column_view</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">在文件 <a class="el" href="linked__column_8hpp_source.html">linked_column.hpp</a> 第 <a class="el" href="linked__column_8hpp_source.html#l00027">27</a> 行定义.</p>

</div>
</div>
<a id="a627e116400c1bed3d5f2b3ab78661fe8" name="a627e116400c1bed3d5f2b3ab78661fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627e116400c1bed3d5f2b3ab78661fe8">&#9670;&#160;</a></span>LinkedColVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecudf_1_1detail.html#a627e116400c1bed3d5f2b3ab78661fe8">cudf::detail::LinkedColVector</a> = typedef std::vector&lt;<a class="el" href="namespacecudf_1_1detail.html#a8bef759d42ac528d33f331de080d5584">LinkedColPtr</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">在文件 <a class="el" href="linked__column_8hpp_source.html">linked_column.hpp</a> 第 <a class="el" href="linked__column_8hpp_source.html#l00028">28</a> 行定义.</p>

</div>
</div>
<a id="ad9f4583fad6d64406129dc1978027b6b" name="ad9f4583fad6d64406129dc1978027b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f4583fad6d64406129dc1978027b6b">&#9670;&#160;</a></span>target_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Source , <a class="el" href="classcudf_1_1aggregation.html#a83579ae3cab2fc3d1c3b377d1cfab24c">aggregation::Kind</a> k&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecudf_1_1detail.html#ad9f4583fad6d64406129dc1978027b6b">cudf::detail::target_type_t</a> = typedef typename <a class="el" href="structcudf_1_1detail_1_1target__type__impl.html">target_type_impl</a>&lt;Source, k&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper alias to get the accumulator type for performing aggregation <code>k</code> on elements of type <code>Source</code> </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Source</td><td>The type on which the aggregation is computed </td></tr>
    <tr><td class="paramname">k</td><td>The aggregation performed </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="detail_2aggregation_2aggregation_8hpp_source.html">aggregation.hpp</a> 第 <a class="el" href="detail_2aggregation_2aggregation_8hpp_source.html#l01362">1362</a> 行定义.</p>

</div>
</div>
<a id="a2d645cde6078342234d5d6ee2c8cd9f9" name="a2d645cde6078342234d5d6ee2c8cd9f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d645cde6078342234d5d6ee2c8cd9f9">&#9670;&#160;</a></span>time_point</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Duration &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecudf_1_1detail.html#a2d645cde6078342234d5d6ee2c8cd9f9">cudf::detail::time_point</a> = typedef cuda::std::chrono::sys_time&lt;Duration&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Time point type </p>

<p class="definition">在文件 <a class="el" href="timestamps_8hpp_source.html">timestamps.hpp</a> 第 <a class="el" href="timestamps_8hpp_source.html#l00030">30</a> 行定义.</p>

</div>
</div>
<a id="a3128cb15ed7da5bb5e926bb24a419262" name="a3128cb15ed7da5bb5e926bb24a419262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3128cb15ed7da5bb5e926bb24a419262">&#9670;&#160;</a></span>timestamp</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Duration &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecudf_1_1detail.html#a3128cb15ed7da5bb5e926bb24a419262">cudf::detail::timestamp</a> = typedef <a class="el" href="namespacecudf_1_1detail.html#a2d645cde6078342234d5d6ee2c8cd9f9">time_point</a>&lt;Duration&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A wrapper around a column of time_point in varying resolutions </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Duration</td><td>The underlying duration type </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="timestamps_8hpp_source.html">timestamps.hpp</a> 第 <a class="el" href="timestamps_8hpp_source.html#l00038">38</a> 行定义.</p>

</div>
</div>
<h2 class="groupheader">枚举类型说明</h2>
<a id="afe99faf2d7a570e5de8dbe1638f91dd0" name="afe99faf2d7a570e5de8dbe1638f91dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe99faf2d7a570e5de8dbe1638f91dd0">&#9670;&#160;</a></span>join_kind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacecudf_1_1detail.html#afe99faf2d7a570e5de8dbe1638f91dd0">cudf::detail::join_kind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">枚举值</th></tr><tr><td class="fieldname"><a id="afe99faf2d7a570e5de8dbe1638f91dd0adacfb6b4a93e8c0996af0a50896b2ad6" name="afe99faf2d7a570e5de8dbe1638f91dd0adacfb6b4a93e8c0996af0a50896b2ad6"></a>INNER_JOIN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afe99faf2d7a570e5de8dbe1638f91dd0ab2f77eff2e65e96b41d17cef95c040ca" name="afe99faf2d7a570e5de8dbe1638f91dd0ab2f77eff2e65e96b41d17cef95c040ca"></a>LEFT_JOIN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afe99faf2d7a570e5de8dbe1638f91dd0a9e94c2918e6b37d619ac174c2f251c4a" name="afe99faf2d7a570e5de8dbe1638f91dd0a9e94c2918e6b37d619ac174c2f251c4a"></a>FULL_JOIN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afe99faf2d7a570e5de8dbe1638f91dd0a149cf6da1ad9e5e65b85a95c49449ae8" name="afe99faf2d7a570e5de8dbe1638f91dd0a149cf6da1ad9e5e65b85a95c49449ae8"></a>LEFT_SEMI_JOIN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afe99faf2d7a570e5de8dbe1638f91dd0a148ec33d1c462dcb952eb70eae78fc6e" name="afe99faf2d7a570e5de8dbe1638f91dd0a148ec33d1c462dcb952eb70eae78fc6e"></a>LEFT_ANTI_JOIN&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">在文件 <a class="el" href="detail_2join_8hpp_source.html">join.hpp</a> 第 <a class="el" href="detail_2join_8hpp_source.html#l00045">45</a> 行定义.</p>

</div>
</div>
<a id="a1c29a0e8458ffb159e91481c0f37b0f5" name="a1c29a0e8458ffb159e91481c0f37b0f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c29a0e8458ffb159e91481c0f37b0f5">&#9670;&#160;</a></span>negative_index_policy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacecudf_1_1detail.html#a1c29a0e8458ffb159e91481c0f37b0f5">cudf::detail::negative_index_policy</a> : bool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">枚举值</th></tr><tr><td class="fieldname"><a id="a1c29a0e8458ffb159e91481c0f37b0f5a9725825c796122ef40f01b2d8794f902" name="a1c29a0e8458ffb159e91481c0f37b0f5a9725825c796122ef40f01b2d8794f902"></a>ALLOWED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1c29a0e8458ffb159e91481c0f37b0f5a4596302bc1e8ce6e62188e769aac94cf" name="a1c29a0e8458ffb159e91481c0f37b0f5a4596302bc1e8ce6e62188e769aac94cf"></a>NOT_ALLOWED&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">在文件 <a class="el" href="detail_2gather_8hpp_source.html">gather.hpp</a> 第 <a class="el" href="detail_2gather_8hpp_source.html#l00033">33</a> 行定义.</p>

</div>
</div>
<h2 class="groupheader">函数说明</h2>
<a id="a325dce4aa776c0bf7cf218e2a27714b5" name="a325dce4aa776c0bf7cf218e2a27714b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a325dce4aa776c0bf7cf218e2a27714b5">&#9670;&#160;</a></span>AGG_KIND_MAPPING() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cudf::detail::AGG_KIND_MAPPING </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1aggregation.html#a83579ae3cab2fc3d1c3b377d1cfab24ca6e5361905125d531234e50d50bcf5326">aggregation::QUANTILE</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1detail_1_1quantile__aggregation.html">quantile_aggregation</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af21777beb509d8944a3e936c0840e473" name="af21777beb509d8944a3e936c0840e473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af21777beb509d8944a3e936c0840e473">&#9670;&#160;</a></span>AGG_KIND_MAPPING() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cudf::detail::AGG_KIND_MAPPING </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1aggregation.html#a83579ae3cab2fc3d1c3b377d1cfab24ca6b1ba846de925ba39b9ee9e352adf84a">aggregation::STD</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1detail_1_1std__aggregation.html">std_aggregation</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aad8f5a52bb309f1cdc4906eed538b45d" name="aad8f5a52bb309f1cdc4906eed538b45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad8f5a52bb309f1cdc4906eed538b45d">&#9670;&#160;</a></span>AGG_KIND_MAPPING() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cudf::detail::AGG_KIND_MAPPING </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1aggregation.html#a83579ae3cab2fc3d1c3b377d1cfab24ca668fb6976b34ba937eb74f77700e749d">aggregation::VARIANCE</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1detail_1_1var__aggregation.html">var_aggregation</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a20f1cdfbe0b878b8b5143108ed352a2d" name="a20f1cdfbe0b878b8b5143108ed352a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20f1cdfbe0b878b8b5143108ed352a2d">&#9670;&#160;</a></span>aggregation_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8hpp.html#adc4a74f3fb4b327ed43b31d0fca65ba3">CUDF_HOST_DEVICE</a> decltype(auto) cudf::detail::aggregation_dispatcher </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1aggregation.html#a83579ae3cab2fc3d1c3b377d1cfab24c">aggregation::Kind</a>&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatches <code>k</code> as a non-type template parameter to a callable, <code>f</code>. </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>Type of callable </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The <code><a class="el" href="classcudf_1_1aggregation.html#a83579ae3cab2fc3d1c3b377d1cfab24c" title="Possible aggregation operations">aggregation::Kind</a></code> value to dispatch aram f The callable that accepts an <code><a class="el" href="classcudf_1_1aggregation.html#a83579ae3cab2fc3d1c3b377d1cfab24c" title="Possible aggregation operations">aggregation::Kind</a></code> non-type template argument. </td></tr>
    <tr><td class="paramname">args</td><td>Parameter pack forwarded to the <code>operator()</code> invocation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Forwards the return value of the callable. </dd></dl>

<p class="definition">在文件 <a class="el" href="detail_2aggregation_2aggregation_8hpp_source.html">aggregation.hpp</a> 第 <a class="el" href="detail_2aggregation_2aggregation_8hpp_source.html#l01396">1396</a> 行定义.</p>

</div>
</div>
<a id="a1454447a634ec7b0e34b066fd6f950a2" name="a1454447a634ec7b0e34b066fd6f950a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1454447a634ec7b0e34b066fd6f950a2">&#9670;&#160;</a></span>align_ptr_for_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * cudf::detail::align_ptr_for_type </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>destination</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the aligned address for holding array of type T in pre-allocated memory. </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The data type to align upon.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>pointer to pre-allocated contiguous storage to store type T. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Pointer of type T, aligned to alignment of type T. </dd></dl>

<p class="definition">在文件 <a class="el" href="alignment_8hpp_source.html">alignment.hpp</a> 第 <a class="el" href="alignment_8hpp_source.html#l00033">33</a> 行定义.</p>

</div>
</div>
<a id="a1d90a4e2a03fd0f7bcaeee67267d1557" name="a1d90a4e2a03fd0f7bcaeee67267d1557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d90a4e2a03fd0f7bcaeee67267d1557">&#9670;&#160;</a></span>allocate_like()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::allocate_like </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__column__copy.html#ga267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a>&#160;</td>
          <td class="paramname"><em>mask_alloc</em> = <code><a class="el" href="group__column__copy.html#gga267e03474dcfd85242d2fdc6e5846ec6a47e9136fa770199f6a8a9727b6173eb4">mask_allocation_policy::RETAIN</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an uninitialized new column of the specified size and same type as the <code>input</code>.   </p>
<p>Supports only fixed-width types.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Immutable view of input column to emulate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The desired number of elements that the new column should have capacity for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask_alloc</td><td>Optional, Policy for allocating null mask. Defaults to RETAIN </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A column with sufficient uninitialized capacity to hold the specified number of elements as <code>input</code> of the same type as <code>input.type()</code>  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37b172e383c23e8f5266dae0ffc4d53d" name="a37b172e383c23e8f5266dae0ffc4d53d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b172e383c23e8f5266dae0ffc4d53d">&#9670;&#160;</a></span>apply_boolean_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt; cudf::detail::apply_boolean_mask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>boolean_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters <code>input</code> using <code>boolean_mask</code> of boolean values as a mask.   </p>
<p>Given an input <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> and a mask <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code>, an element <code>i</code> from each <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> of the <code>input</code> is copied to the corresponding output column if the corresponding element <code>i</code> in the mask is non-null and <code>true</code>. This operation is stable: the input order is preserved.</p>
<dl class="section note"><dt>注解</dt><dd>if <code>input.num_rows()</code> is zero, there is no error, and an empty table is returned.</dd></dl>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>input.num_rows() != boolean_mask.size()</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>boolean_mask</code> is not <code><a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd" title="Boolean using one byte per value, 0 == false, else true">type_id::BOOL8</a></code> type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input <a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a> to filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boolean_mask</td><td>A nullable <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> of type <a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd" title="Boolean using one byte per value, 0 == false, else true">type_id::BOOL8</a> used as a mask to filter the <code>input</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned table's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Table containing copy of all rows of <code>input</code> passing the filter defined by <code>boolean_mask</code>.  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b91b19cf5f6210875f2c8066c263092" name="a1b91b19cf5f6210875f2c8066c263092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b91b19cf5f6210875f2c8066c263092">&#9670;&#160;</a></span>arrow_to_cudf_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcudf_1_1data__type.html">data_type</a> cudf::detail::arrow_to_cudf_type </td>
          <td>(</td>
          <td class="paramtype">arrow::DataType const &amp;&#160;</td>
          <td class="paramname"><em>arrow_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d4ce4e5ee2ebf383eaccdd2d8ab8233" name="a6d4ce4e5ee2ebf383eaccdd2d8ab8233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d4ce4e5ee2ebf383eaccdd2d8ab8233">&#9670;&#160;</a></span>binary_operation() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::binary_operation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__transformation__binaryops.html#ga00ed76601b6db662550f6826cfd99edc">binary_operator</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>output_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a binary operation between two columns.   </p>
<p>The output contains the result of <code>op(lhs[i], rhs[i])</code> for all <code>0 &lt;= i &lt; lhs.size()</code></p>
<p>Regardless of the operator, the validity of the output value is the logical AND of the validity of the two operands except NullMin and NullMax (logical OR).</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left operand column </td></tr>
    <tr><td class="paramname">rhs</td><td>The right operand column </td></tr>
    <tr><td class="paramname">op</td><td>The binary operator </td></tr>
    <tr><td class="paramname">output_type</td><td>The desired data type of the output column </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Output column of <code>output_type</code> type containing the result of the binary operation </dd></dl>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>lhs</code> and <code>rhs</code> are different sizes </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>output_type</code> dtype isn't boolean for comparison and logical operations. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>output_type</code> dtype isn't fixed-width  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71131703adb680670a6b8592b92f56f6" name="a71131703adb680670a6b8592b92f56f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71131703adb680670a6b8592b92f56f6">&#9670;&#160;</a></span>binary_operation() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::binary_operation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>ptx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>output_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a binary operation between two columns using a user-defined PTX function.   </p>
<p>The output contains the result of <code>op(lhs[i], rhs[i])</code> for all <code>0 &lt;= i &lt; lhs.size()</code></p>
<p>Regardless of the operator, the validity of the output value is the logical AND of the validity of the two operands</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left operand column </td></tr>
    <tr><td class="paramname">rhs</td><td>The right operand column </td></tr>
    <tr><td class="paramname">ptx</td><td>String containing the PTX of a binary function </td></tr>
    <tr><td class="paramname">output_type</td><td>The desired data type of the output column. It is assumed that output_type is compatible with the output data type of the function in the PTX code </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Output column of <code>output_type</code> type containing the result of the binary operation </dd></dl>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>lhs</code> and <code>rhs</code> are different sizes </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>lhs</code> and <code>rhs</code> dtypes aren't numeric </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>output_type</code> dtype isn't numeric  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6c8f19f207ee3db5e2284594edc600c" name="ab6c8f19f207ee3db5e2284594edc600c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c8f19f207ee3db5e2284594edc600c">&#9670;&#160;</a></span>binary_operation() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::binary_operation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__transformation__binaryops.html#ga00ed76601b6db662550f6826cfd99edc">binary_operator</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>output_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a binary operation between a column and a scalar.   </p>
<p>The output contains the result of <code>op(lhs[i], rhs)</code> for all <code>0 &lt;= i &lt; lhs.size()</code> The column elements are the left operand and the scalar is the right operand. This distinction is significant in case of non-commutative binary operations</p>
<p>Regardless of the operator, the validity of the output value is the logical AND of the validity of the two operands except NullMin and NullMax (logical OR).</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left operand column </td></tr>
    <tr><td class="paramname">rhs</td><td>The right operand scalar </td></tr>
    <tr><td class="paramname">op</td><td>The binary operator </td></tr>
    <tr><td class="paramname">output_type</td><td>The desired data type of the output column </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Output column of <code>output_type</code> type containing the result of the binary operation </dd></dl>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>output_type</code> dtype isn't fixed-width </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>output_type</code> dtype isn't boolean for comparison and logical operations.  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d435282505118b2a58c875780c13890" name="a4d435282505118b2a58c875780c13890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d435282505118b2a58c875780c13890">&#9670;&#160;</a></span>binary_operation() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::binary_operation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__transformation__binaryops.html#ga00ed76601b6db662550f6826cfd99edc">binary_operator</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>output_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a binary operation between a scalar and a column.   </p>
<p>The output contains the result of <code>op(lhs, rhs[i])</code> for all <code>0 &lt;= i &lt; rhs.size()</code> The scalar is the left operand and the column elements are the right operand. This distinction is significant in case of non-commutative binary operations</p>
<p>Regardless of the operator, the validity of the output value is the logical AND of the validity of the two operands except NullMin and NullMax (logical OR).</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left operand scalar </td></tr>
    <tr><td class="paramname">rhs</td><td>The right operand column </td></tr>
    <tr><td class="paramname">op</td><td>The binary operator </td></tr>
    <tr><td class="paramname">output_type</td><td>The desired data type of the output column </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Output column of <code>output_type</code> type containing the result of the binary operation </dd></dl>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>output_type</code> dtype isn't fixed-width </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>output_type</code> dtype isn't boolean for comparison and logical operations.  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc5e9bcff0d652d054817afa71d20399" name="adc5e9bcff0d652d054817afa71d20399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5e9bcff0d652d054817afa71d20399">&#9670;&#160;</a></span>bitmask_and() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; rmm::device_buffer, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; cudf::detail::bitmask_and </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> const *const &gt;&#160;</td>
          <td class="paramname"><em>masks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt;&#160;</td>
          <td class="paramname"><em>masks_begin_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>mask_size_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf99352f85f59ae17972b8462cfb4760" name="abf99352f85f59ae17972b8462cfb4760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf99352f85f59ae17972b8462cfb4760">&#9670;&#160;</a></span>bitmask_and() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; rmm::device_buffer, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; cudf::detail::bitmask_and </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs bitwise AND of the bitmasks of columns of a table. Returns a pair of resulting mask and count of unset bits.   </p>
<p>If any of the columns isn't nullable, it is considered all valid. If no column in the table is nullable, an empty bitmask is returned.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>The table of columns </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned device_buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A pair of resulting bitmask and count of unset bits  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a280d3e05cbbc973356f38c0ee1fca2e3" name="a280d3e05cbbc973356f38c0ee1fca2e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a280d3e05cbbc973356f38c0ee1fca2e3">&#9670;&#160;</a></span>bitmask_or()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; rmm::device_buffer, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; cudf::detail::bitmask_or </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs bitwise OR of the bitmasks of columns of a table. Returns a pair of resulting mask and count of unset bits.   </p>
<p>If any of the columns isn't nullable, it is considered all valid. If no column in the table is nullable, an empty bitmask is returned.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>The table of columns </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned device_buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A pair of resulting bitmask and count of unset bits  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca6f0ca2c888fcffaf3c516ba0b05498" name="aca6f0ca2c888fcffaf3c516ba0b05498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca6f0ca2c888fcffaf3c516ba0b05498">&#9670;&#160;</a></span>boolean_mask_scatter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt; cudf::detail::boolean_mask_scatter </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>boolean_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab632fac16d86dcdec8172f105e9cc3bb" name="ab632fac16d86dcdec8172f105e9cc3bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab632fac16d86dcdec8172f105e9cc3bb">&#9670;&#160;</a></span>boolean_mask_scatter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt; cudf::detail::boolean_mask_scatter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>boolean_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scatters rows from the input table to rows of the output corresponding to true values in a boolean mask.   </p>
<p>The <code>i</code>th row of <code>input</code> will be written to the output table at the location of the <code>i</code>th true value in <code>boolean_mask</code>. All other rows in the output will equal the same row in <code>target</code>.</p>
<p><code>boolean_mask</code> should have number of <code>true</code>s &lt;= number of rows in <code>input</code>. If boolean mask is <code>true</code>, corresponding value in target is updated with value from corresponding <code>input</code> column, else it is left untouched.</p>
<div class="fragment"><div class="line">Example:</div>
<div class="line">input: {{1, 5, 6, 8, 9}}</div>
<div class="line">boolean_mask: {true, false, false, false, true, true, false, true, true, false}</div>
<div class="line">target:       {{   2,     2,     3,     4,    4,     7,    7,    7,    8,    10}}</div>
<div class="line"> </div>
<div class="line">output:       {{   1,     2,     3,     4,    5,     6,    7,    8,    9,    10}}</div>
</div><!-- fragment --><dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if input.num_columns() != target.num_columns() </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if any <code>i</code>th input_column type != <code>i</code>th target_column type </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean_mask.type() != bool </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean_mask.size() != target.num_rows() </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if number of <code>true</code> in <code>boolean_mask</code> &gt; input.num_rows()</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a> (set of dense columns) to scatter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a> to modify with scattered values from <code>input</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boolean_mask</td><td><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> which acts as boolean mask </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate device memory of the returned table</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Returns a table by scattering <code>input</code> into <code>target</code> as per <code>boolean_mask</code>  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad38866396e5c2b317d7075374fe64777" name="ad38866396e5c2b317d7075374fe64777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad38866396e5c2b317d7075374fe64777">&#9670;&#160;</a></span>bools_to_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::unique_ptr&lt; rmm::device_buffer &gt;, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a> &gt; cudf::detail::bools_to_mask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a bitmask from a column of boolean elements.   </p>
<p>If element <code>i</code> in <code>input</code> is <code>true</code>, bit <code>i</code> in the resulting mask is set (<code>1</code>). Else, if element <code>i</code> is <code>false</code> or null, bit <code>i</code> is unset (<code>0</code>).</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>input.type()</code> is a non-boolean type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Boolean elements to convert to a bitmask </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned bitmask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A pair containing a <code>device_buffer</code> with the new bitmask and it's null count obtained from input considering <code>true</code> represent <code>valid</code>/<code>1</code> and <code>false</code> represent <code>invalid</code>/<code>0</code>.  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ab76605084c4a005ccd720c76fb828f" name="a8ab76605084c4a005ccd720c76fb828f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab76605084c4a005ccd720c76fb828f">&#9670;&#160;</a></span>calendrical_month_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt; cudf::detail::calendrical_month_sequence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>months</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a sequence of timestamps beginning at <code>init</code> and incrementing by <code>months</code> for each successive element, i.e., <code>output[i] = init + i * months</code> for <code>i</code> in <code>[0, size)</code>.   </p>
<p>If a given date is invalid, the date is scaled back to the last available day of that month.</p>
<p>Example: </p><div class="fragment"><div class="line">size = 3</div>
<div class="line">init = 2020-01-31 08:00:00</div>
<div class="line">months = 1</div>
<div class="line"><span class="keywordflow">return</span> = [2020-01-31 08:00:00, 2020-02-29 08:00:00, 2020-03-31 08:00:00]</div>
</div><!-- fragment --><dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if input datatype is not a TIMESTAMP</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Number of timestamps to generate </td></tr>
    <tr><td class="paramname">init</td><td>The initial timestamp </td></tr>
    <tr><td class="paramname">months</td><td>Months to increment </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Timestamps column with sequences of months  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2d9341a3c49eb3b9d237d9da1c1e5ac" name="ac2d9341a3c49eb3b9d237d9da1c1e5ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d9341a3c49eb3b9d237d9da1c1e5ac">&#9670;&#160;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts data from dtype specified in input to dtype specified in output.   </p>
<p>Supports only fixed-width types.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Input column </td></tr>
    <tr><td class="paramname">out_type</td><td>Desired datatype of output column </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Column of same size as <code>input</code> containing result of the cast operation </dd></dl>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>out_type</code> is not a fixed-width type  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c8323757962d4b3d4b41b9d06289914" name="a0c8323757962d4b3d4b41b9d06289914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c8323757962d4b3d4b41b9d06289914">&#9670;&#160;</a></span>compute_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::compute_column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1ast_1_1operation.html">ast::operation</a> const &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a new column by evaluating an expression tree on a table.   </p>
<p>This evaluates an expression over a table to produce a new column. Also called an n-ary transform.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if passed an expression operating on table_reference::RIGHT.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>The table used for expression evaluation </td></tr>
    <tr><td class="paramname">expr</td><td>The root of the expression tree </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>std::unique_ptr&lt;column&gt; Output column  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ff65803386d36f8a139f59f14506eef" name="a4ff65803386d36f8a139f59f14506eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff65803386d36f8a139f59f14506eef">&#9670;&#160;</a></span>concatenate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::concatenate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &gt;&#160;</td>
          <td class="paramname"><em>columns_to_concat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates multiple columns into a single column.   </p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>If types of the input columns mismatch</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">columns_to_concat</td><td><a class="el" href="structcudf_1_1host__span.html" title="C++20 std::span with reduced feature set.">host_span</a> of column views to be concatenated into a single column </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A single column having all the rows from the elements of <code>columns_to_concat</code> respectively in the same order.  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03a9a4dad8d8d93a07908bc682e3b76d" name="a03a9a4dad8d8d93a07908bc682e3b76d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a9a4dad8d8d93a07908bc682e3b76d">&#9670;&#160;</a></span>concatenate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt; cudf::detail::concatenate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &gt;&#160;</td>
          <td class="paramname"><em>tables_to_concat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Columns of <code>tables_to_concat</code> are concatenated vertically to return a single table   </p>
<p>example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classcudf_1_1column__view.html">column_view</a> c0; <span class="comment">//Contains {0,1,2,3}</span></div>
<div class="line"><a class="code hl_class" href="classcudf_1_1column__view.html">column_view</a> c1; <span class="comment">//Contains {4,5,6,7}</span></div>
<div class="line"><a class="code hl_class" href="classcudf_1_1table__view.html">table_view</a> t0{{c0, c0}};</div>
<div class="line">table_view t1{{c1, c1}};</div>
<div class="line">...</div>
<div class="line">auto t = <a class="code hl_function" href="namespacecudf_1_1detail.html#a4ff65803386d36f8a139f59f14506eef">concatenate</a>({t0.view(), t1.view()});</div>
<div class="line">column_view tc0 = (t-&gt;view()).column(0); <span class="comment">//Contains {0,1,2,3,4,5,6,7}</span></div>
<div class="line">column_view tc1 = (t-&gt;view()).column(1); <span class="comment">//Contains {0,1,2,3,4,5,6,7}</span></div>
<div class="ttc" id="aclasscudf_1_1column__view_html"><div class="ttname"><a href="classcudf_1_1column__view.html">cudf::column_view</a></div><div class="ttdoc">A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...</div><div class="ttdef"><b>Definition</b> <a href="column__view_8hpp_source.html#l00322">column_view.hpp:322</a></div></div>
<div class="ttc" id="aclasscudf_1_1table__view_html"><div class="ttname"><a href="classcudf_1_1table__view.html">cudf::table_view</a></div><div class="ttdoc">A set of cudf::column_view's of the same size.</div><div class="ttdef"><b>Definition</b> <a href="table__view_8hpp_source.html#l00187">table_view.hpp:187</a></div></div>
<div class="ttc" id="anamespacecudf_1_1detail_html_a4ff65803386d36f8a139f59f14506eef"><div class="ttname"><a href="namespacecudf_1_1detail.html#a4ff65803386d36f8a139f59f14506eef">cudf::detail::concatenate</a></div><div class="ttdeci">std::unique_ptr&lt; column &gt; concatenate(host_span&lt; column_view const &gt; columns_to_concat, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</div><div class="ttdoc">Concatenates multiple columns into a single column.</div></div>
</div><!-- fragment --><dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>If number of columns mismatch</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">tables_to_concat</td><td><a class="el" href="structcudf_1_1host__span.html" title="C++20 std::span with reduced feature set.">host_span</a> of table views to be concatenated into a single table </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned table's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A single table having all the rows from the elements of <code>tables_to_concat</code> respectively in the same order.  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c1de6dab4d4d341e17ff17cdff7a133" name="a6c1de6dab4d4d341e17ff17cdff7a133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c1de6dab4d4d341e17ff17cdff7a133">&#9670;&#160;</a></span>contains() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>needles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the given <code>needles</code> values exists in the <code>haystack</code> column.   </p>
<p>The new column will have type BOOL and have the same size and null mask as the input <code>needles</code> column. That is, any null row in the <code>needles</code> column will result in a nul row in the output column.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>If <code>haystack.type() != needles.type()</code></td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">haystack = { 10, 20, 30, 40, 50 }</div>
<div class="line">needles  = { 20, 40, 60, 80 }</div>
<div class="line">result   = { true, true, false, false }</div>
</div><!-- fragment --><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>The column containing search space </td></tr>
    <tr><td class="paramname">needles</td><td>A column of values to check for existence in the search space </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A BOOL column indicating if each element in <code>needles</code> exists in the search space  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aabbae19d91d3507be87defb820d2e603" name="aabbae19d91d3507be87defb820d2e603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabbae19d91d3507be87defb820d2e603">&#9670;&#160;</a></span>contains() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cudf::detail::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa272dc48c5c03c83e46dc103a86bdeb4" name="aa272dc48c5c03c83e46dc103a86bdeb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa272dc48c5c03c83e46dc103a86bdeb4">&#9670;&#160;</a></span>contains() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rmm::device_uvector&lt; bool &gt; cudf::detail::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>needles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a>&#160;</td>
          <td class="paramname"><em>compare_nulls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#gae9d1055c69c3089452794783c7c82f83">nan_equality</a>&#160;</td>
          <td class="paramname"><em>compare_nans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if rows in the given <code>needles</code> table exist in the <code>haystack</code> table. </p>
<p>Given two tables, each row in the <code>needles</code> table is checked to see if there is any matching row (i.e., compared equal to it) in the <code>haystack</code> table. The boolean search results are written into the corresponding rows of the output array.</p>
<div class="fragment"><div class="line">Example:</div>
<div class="line"> </div>
<div class="line">haystack = { { 5, 4, 1, 2, 3 } }</div>
<div class="line">needles  = { { 0, 1, 2 } }</div>
<div class="line">output   = { false, true, true }</div>
</div><!-- fragment --><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>The table containing the search space </td></tr>
    <tr><td class="paramname">needles</td><td>A table of rows whose existence to check in the search space </td></tr>
    <tr><td class="paramname">compare_nulls</td><td>Control whether nulls should be compared as equal or not </td></tr>
    <tr><td class="paramname">compare_nans</td><td>Control whether floating-point NaNs values should be compared as equal or not </td></tr>
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A vector of bools indicating if each row in <code>needles</code> has matching rows in <code>haystack</code> </dd></dl>

</div>
</div>
<a id="a047f6e84ed9d8d30fd0a8703ac2085ee" name="a047f6e84ed9d8d30fd0a8703ac2085ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047f6e84ed9d8d30fd0a8703ac2085ee">&#9670;&#160;</a></span>contiguous_split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structcudf_1_1packed__table.html">packed_table</a> &gt; cudf::detail::contiguous_split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a deep-copy split of a <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> into a set of <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code>s into a single contiguous block of memory.   </p>
<p>The memory for the output views is allocated in a single contiguous <code>rmm::device_buffer</code> returned in the <code><a class="el" href="structcudf_1_1packed__table.html" title="The result(s) of a cudf::contiguous_split">packed_table</a></code>. There is no top-level owning table.</p>
<p>The returned views of <code>input</code> are constructed from a vector of indices, that indicate where each split should occur. The <code>i</code>th returned <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> is sliced as <code>[0, splits[i])</code> if <code>i</code>=0, else <code>[splits[i], input.size())</code> if <code>i</code> is the last view and <code>[splits[i-1], splits[i]]</code> otherwise.</p>
<p>For all <code>i</code> it is expected <code>splits[i] &lt;= splits[i+1] &lt;= input.size()</code> For a <code>splits</code> size N, there will always be N+1 splits in the output</p>
<dl class="section note"><dt>注解</dt><dd>It is the caller's responsibility to ensure that the returned views do not outlive the viewed device memory contained in the <code>all_data</code> field of the returned <a class="el" href="structcudf_1_1packed__table.html" title="The result(s) of a cudf::contiguous_split">packed_table</a>.</dd></dl>
<div class="fragment"><div class="line">Example:</div>
<div class="line">input:   [{10, 12, 14, 16, 18, 20, 22, 24, 26, 28},</div>
<div class="line">          {50, 52, 54, 56, 58, 60, 62, 64, 66, 68}]</div>
<div class="line">splits:  {2, 5, 9}</div>
<div class="line">output:  [{{10, 12}, {14, 16, 18}, {20, 22, 24, 26}, {28}},</div>
<div class="line">          {{50, 52}, {54, 56, 58}, {60, 62, 64, 66}, {68}}]</div>
</div><!-- fragment --><dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>splits</code> has end index &gt; size of <code>input</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>When the value in <code>splits</code> is not in the range [0, input.size()). </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>When the values in the <code>splits</code> are 'strictly decreasing'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">input</td><td>View of a table to split </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">splits</td><td>A vector of indices where the view will be split </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned result's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The set of requested views of <code>input</code> indicated by the <code>splits</code> and the viewed memory buffer.  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9423550e270db631d429d61b140d7108" name="a9423550e270db631d429d61b140d7108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9423550e270db631d429d61b140d7108">&#9670;&#160;</a></span>copy_bitmask() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rmm::device_buffer cudf::detail::copy_bitmask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> const *&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>begin_bit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>end_bit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <code>device_buffer</code> from a slice of bitmask defined by a range of indices <code>[begin_bit, end_bit)</code>.   </p>
<p>Returns empty <code>device_buffer</code> if <code>bitmask == nullptr</code>.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>begin_bit &gt; end_bit</code> </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>begin_bit &lt; 0</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Bitmask residing in device memory whose bits will be copied </td></tr>
    <tr><td class="paramname">begin_bit</td><td>Index of the first bit to be copied (inclusive) </td></tr>
    <tr><td class="paramname">end_bit</td><td>Index of the last bit to be copied (exclusive) </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned device_buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>rmm::device_buffer A <code>device_buffer</code> containing the bits <code>[begin_bit, end_bit)</code> from <code>mask</code>.  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaddec64eefdf906a669dd8e65e23137c" name="aaddec64eefdf906a669dd8e65e23137c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaddec64eefdf906a669dd8e65e23137c">&#9670;&#160;</a></span>copy_bitmask() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rmm::device_buffer cudf::detail::copy_bitmask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies <code>view</code>'s bitmask from the bits <code>[view.offset(), view.offset() + view.size())</code> into a <code>device_buffer</code>   </p>
<p>Returns empty <code>device_buffer</code> if the column is not nullable</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>Column view whose bitmask needs to be copied </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned device_buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>rmm::device_buffer A <code>device_buffer</code> containing the bits <code>[view.offset(), view.offset() + view.size())</code> from <code>view</code>'s bitmask.  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f095700ad533a04852f9b75ae33c2bc" name="a1f095700ad533a04852f9b75ae33c2bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f095700ad533a04852f9b75ae33c2bc">&#9670;&#160;</a></span>copy_if_else() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::copy_if_else </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>boolean_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>   </p>
<p>Selects each element i in the output column from either <code>rhs</code> or <code>lhs</code> using the following rule: <code>output[i] = (boolean_mask.valid(i) and boolean_mask[i]) ? lhs[i] : rhs[i]</code></p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if lhs and rhs are not of the same type </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if lhs and rhs are not of the same length </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of type bool </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of the same length as lhs and rhs </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>left-hand <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>right-hand <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boolean_mask</td><td>column of <code><a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd" title="Boolean using one byte per value, 0 == false, else true">type_id::BOOL8</a></code> representing "left (true) / right (false)" boolean for each element. Null element represents false. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>new column with the selected elements  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44102048883bf4ae35957e48b4b650a3" name="a44102048883bf4ae35957e48b4b650a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44102048883bf4ae35957e48b4b650a3">&#9670;&#160;</a></span>copy_if_else() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::copy_if_else </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>boolean_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>   </p>
<p>Selects each element i in the output column from either <code>rhs</code> or <code>lhs</code> using the following rule: <code>output[i] = (boolean_mask.valid(i) and boolean_mask[i]) ? lhs[i] : rhs</code></p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if lhs and rhs are not of the same type </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of type bool </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of the same length as lhs </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>left-hand <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>right-hand scalar </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boolean_mask</td><td>column of <code><a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd" title="Boolean using one byte per value, 0 == false, else true">type_id::BOOL8</a></code> representing "left (true) / right (false)" boolean for each element. Null element represents false. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>new column with the selected elements  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ca44d4fcbf12660edf218195e729eaa" name="a3ca44d4fcbf12660edf218195e729eaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ca44d4fcbf12660edf218195e729eaa">&#9670;&#160;</a></span>copy_if_else() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::copy_if_else </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>boolean_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>   </p>
<p>Selects each element i in the output column from either <code>rhs</code> or <code>lhs</code> using the following rule: <code>output[i] = (boolean_mask.valid(i) and boolean_mask[i]) ? lhs : rhs[i]</code></p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if lhs and rhs are not of the same type </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of type bool </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of the same length as rhs </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>left-hand scalar </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>right-hand <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boolean_mask</td><td>column of <code><a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd" title="Boolean using one byte per value, 0 == false, else true">type_id::BOOL8</a></code> representing "left (true) / right (false)" boolean for each element. Null element represents false. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>new column with the selected elements  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac60520ad2d4ed5741035a9e8dd9bfbe8" name="ac60520ad2d4ed5741035a9e8dd9bfbe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac60520ad2d4ed5741035a9e8dd9bfbe8">&#9670;&#160;</a></span>copy_if_else() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::copy_if_else </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>boolean_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>   </p>
<p>Selects each element i in the output column from either <code>rhs</code> or <code>lhs</code> using the following rule: <code>output[i] = (boolean_mask.valid(i) and boolean_mask[i]) ? lhs : rhs</code></p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if boolean mask is not of type bool </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>left-hand scalar </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>right-hand scalar </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boolean_mask</td><td>column of <code><a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd" title="Boolean using one byte per value, 0 == false, else true">type_id::BOOL8</a></code> representing "left (true) / right (false)" boolean for each element. null element represents false. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>new column with the selected elements  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aedafe62653e88ef1440aed7287f89ab8" name="aedafe62653e88ef1440aed7287f89ab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedafe62653e88ef1440aed7287f89ab8">&#9670;&#160;</a></span>count_set_bits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a> cudf::detail::count_set_bits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> const *&#160;</td>
          <td class="paramname"><em>bitmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>stop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a bitmask, counts the number of set (1) bits in the range <code>[start, stop)</code>. </p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>bitmask == nullptr</code> </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>start &gt; stop</code> </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>start &lt; 0</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmask</td><td>Bitmask residing in device memory whose bits will be counted. </td></tr>
    <tr><td class="paramname">start</td><td>Index of the first bit to count (inclusive). </td></tr>
    <tr><td class="paramname">stop</td><td>Index of the last bit to count (exclusive). </td></tr>
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The number of non-zero bits in the specified range. </dd></dl>

</div>
</div>
<a id="a96a79295789c1ba220298ea1dbc0e8f7" name="a96a79295789c1ba220298ea1dbc0e8f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a79295789c1ba220298ea1dbc0e8f7">&#9670;&#160;</a></span>count_unset_bits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a> cudf::detail::count_unset_bits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> const *&#160;</td>
          <td class="paramname"><em>bitmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>stop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a bitmask, counts the number of unset (0) bits in the range <code>[start, stop)</code>. </p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>bitmask == nullptr</code> </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>start &gt; stop</code> </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>start &lt; 0</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmask</td><td>Bitmask residing in device memory whose bits will be counted. </td></tr>
    <tr><td class="paramname">start</td><td>Index of the first bit to count (inclusive). </td></tr>
    <tr><td class="paramname">stop</td><td>Index of the last bit to count (exclusive). </td></tr>
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The number of zero bits in the specified range. </dd></dl>

</div>
</div>
<a id="a690f0e70c8c2bad53bf877483f2d346d" name="a690f0e70c8c2bad53bf877483f2d346d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a690f0e70c8c2bad53bf877483f2d346d">&#9670;&#160;</a></span>create_null_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rmm::device_buffer cudf::detail::create_null_mask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga4daf20c000ab374d76f4d56f0ddb7b26">mask_state</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <code>device_buffer</code> for use as a null value indicator bitmask of a <code>column</code>.   </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The number of elements to be represented by the mask </td></tr>
    <tr><td class="paramname">state</td><td>The desired state of the mask </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned device_buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>rmm::device_buffer A <code>device_buffer</code> for use as a null bitmask satisfying the desired size and state  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0159f4dade1ab55499ee6d0606eae6fd" name="a0159f4dade1ab55499ee6d0606eae6fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0159f4dade1ab55499ee6d0606eae6fd">&#9670;&#160;</a></span>dispatch_type_and_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8hpp.html#adc4a74f3fb4b327ed43b31d0fca65ba3">CUDF_HOST_DEVICE</a> constexpr decltype(auto) cudf::detail::dispatch_type_and_aggregation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1aggregation.html#a83579ae3cab2fc3d1c3b377d1cfab24c">aggregation::Kind</a>&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatches both a type and <code><a class="el" href="classcudf_1_1aggregation.html#a83579ae3cab2fc3d1c3b377d1cfab24c" title="Possible aggregation operations">aggregation::Kind</a></code> template parameters to a callable. </p>
<p>This function expects a callable <code>f</code> with an <code>operator()</code> template accepting two template parameters. The first is a type dispatched from <code>type</code>. The second is an <code><a class="el" href="classcudf_1_1aggregation.html#a83579ae3cab2fc3d1c3b377d1cfab24c" title="Possible aggregation operations">aggregation::Kind</a></code> dispatched from <code>k</code>.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> used to dispatch a type for the first template parameter of the callable <code>F</code> </td></tr>
    <tr><td class="paramname">k</td><td>The <code><a class="el" href="classcudf_1_1aggregation.html#a83579ae3cab2fc3d1c3b377d1cfab24c" title="Possible aggregation operations">aggregation::Kind</a></code> used to dispatch an <code><a class="el" href="classcudf_1_1aggregation.html#a83579ae3cab2fc3d1c3b377d1cfab24c" title="Possible aggregation operations">aggregation::Kind</a></code> non-type template parameter for the second template parameter of the callable </td></tr>
    <tr><td class="paramname">args</td><td>Parameter pack forwarded to the <code>operator()</code> invocation <code>F</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="detail_2aggregation_2aggregation_8hpp_source.html">aggregation.hpp</a> 第 <a class="el" href="detail_2aggregation_2aggregation_8hpp_source.html#l01511">1511</a> 行定义.</p>

</div>
</div>
<a id="a32d13444c532389ceda0e73e6fa73081" name="a32d13444c532389ceda0e73e6fa73081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32d13444c532389ceda0e73e6fa73081">&#9670;&#160;</a></span>distinct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt; cudf::detail::distinct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__reorder__compact.html#ga69091647ea1f9c9d4cdcf7c8876bea3a">duplicate_keep_option</a>&#160;</td>
          <td class="paramname"><em>keep</em> = <code><a class="el" href="group__reorder__compact.html#gga69091647ea1f9c9d4cdcf7c8876bea3aa0546025abe5830d9334bb82102420394">duplicate_keep_option::KEEP_ANY</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a>&#160;</td>
          <td class="paramname"><em>nulls_equal</em> = <code><a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44">null_equality::EQUAL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#gae9d1055c69c3089452794783c7c82f83">nan_equality</a>&#160;</td>
          <td class="paramname"><em>nans_equal</em> = <code><a class="el" href="group__utility__types.html#ggae9d1055c69c3089452794783c7c82f83acd6d9f766e6e2753da429d26078711d7">nan_equality::ALL_EQUAL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new table without duplicate rows.   </p>
<p>Given an <code>input</code> <a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a>, each row is copied to the output table to create a set of distinct rows. If there are duplicate rows, which row to be copied depends on the specified value of the <code>keep</code> parameter.</p>
<p>The order of rows in the output table is not specified.</p>
<p>Performance hint: if the input is pre-sorted, <code><a class="el" href="group__reorder__compact.html#ga87352ad4f282dd17365d4c9929d5c644" title="Create a new table with consecutive duplicate rows removed.">cudf::unique</a></code> can produce an equivalent result (i.e., same set of output rows) but with less running time than <code><a class="el" href="group__reorder__compact.html#ga201195610929658c5d383fa99434ef9c" title="Create a new table without duplicate rows.">cudf::distinct</a></code>.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>input <a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a> to copy only distinct rows </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td>vector of indices representing key columns from <code>input</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keep</td><td>keep any, first, last, or none of the found duplicates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nulls_equal</td><td>flag to control if nulls are compared equal or not </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nans_equal</td><td>flag to control if floating-point NaN values are compared equal or not </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned table's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Table with distinct rows in an unspecified order  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aedc80778d27d66fad4e9e6d102f5b4f6" name="aedc80778d27d66fad4e9e6d102f5b4f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc80778d27d66fad4e9e6d102f5b4f6">&#9670;&#160;</a></span>distinct_count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a> cudf::detail::distinct_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a>&#160;</td>
          <td class="paramname"><em>null_handling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga74641d3dfd6d96d0939b492ecf9b9cc8">nan_policy</a>&#160;</td>
          <td class="paramname"><em>nan_handling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the distinct elements in the <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a>.   </p>
<p>If <code>nulls_equal == nulls_equal::UNEQUAL</code>, all <code>null</code>s are distinct.</p>
<p>Given an input <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a>, number of distinct elements in this <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> is returned.</p>
<p>If <code>null_handling</code> is <a class="el" href="group__utility__types.html#gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8" title="exclude null elements">null_policy::EXCLUDE</a> and <code>nan_handling</code> is <a class="el" href="group__utility__types.html#gga74641d3dfd6d96d0939b492ecf9b9cc8aeed6bbfa0697c54960c7e0baa97313f4" title="treat nans as null elements">nan_policy::NAN_IS_NULL</a>, both <code>NaN</code> and <code>null</code> values are ignored. If <code>null_handling</code> is <a class="el" href="group__utility__types.html#gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8" title="exclude null elements">null_policy::EXCLUDE</a> and <code>nan_handling</code> is <a class="el" href="group__utility__types.html#gga74641d3dfd6d96d0939b492ecf9b9cc8a27adbe26caa2eb99976344933c281a77" title="treat nans as valid elements (non-null)">nan_policy::NAN_IS_VALID</a>, only <code>null</code> is ignored, <code>NaN</code> is considered in distinct count.</p>
<p><code>null</code>s are handled as equal.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> whose distinct elements will be counted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">null_handling</td><td>flag to include or ignore <code>null</code> while counting </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nan_handling</td><td>flag to consider <code>NaN==null</code> or not</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>number of distinct rows in the table  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3e020feeee7f44561f850a2e42647d5" name="ab3e020feeee7f44561f850a2e42647d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e020feeee7f44561f850a2e42647d5">&#9670;&#160;</a></span>distinct_count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a> cudf::detail::distinct_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a>&#160;</td>
          <td class="paramname"><em>nulls_equal</em> = <code><a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44">null_equality::EQUAL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the distinct rows in a table.   </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Table whose distinct rows will be counted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nulls_equal</td><td>flag to denote if null elements should be considered equal. nulls are not equal if <a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771ac0df9e531f39895029236b71d0d1c0ac" title="nulls compare unequal">null_equality::UNEQUAL</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>number of distinct rows in the table  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bde81471b27ab73aa588c4e79937199" name="a8bde81471b27ab73aa588c4e79937199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bde81471b27ab73aa588c4e79937199">&#9670;&#160;</a></span>drop_nans()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt; cudf::detail::drop_nans </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a>&#160;</td>
          <td class="paramname"><em>keep_threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters a table to remove NANs with threshold count.   </p>
<p>Filters the rows of the <code>input</code> considering specified columns indicated in <code>keys</code> for NANs. These key columns must be of floating-point type.</p>
<p>Given an input <a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a>, row <code>i</code> from the input columns is copied to the output if the same row <code>i</code> of <code>keys</code> has at least <code>keep_threshold</code> non-NAN elements.</p>
<p>This operation is stable: the input order is preserved in the output.</p>
<div class="fragment"><div class="line">input   {col1: {1.0, 2.0, 3.0, NAN},</div>
<div class="line">         col2: {4.0, null, NAN, NAN},</div>
<div class="line">         col3: {7.0, NAN, NAN, NAN}}</div>
<div class="line">keys = {0, 1, 2} // All columns</div>
<div class="line">keep_threshold = 2</div>
<div class="line"> </div>
<div class="line">output {col1: {1.0, 2.0}</div>
<div class="line">        col2: {4.0, null}</div>
<div class="line">        col3: {7.0, NAN}}</div>
</div><!-- fragment --><dl class="section note"><dt>注解</dt><dd>if <code>input.num_rows()</code> is zero, or <code>keys</code> is empty, there is no error, and an empty <code>table</code> is returned</dd></dl>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if The <code>keys</code> columns are not floating-point type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> to filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td>vector of indices representing key columns from <code>input</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keep_threshold</td><td>The minimum number of non-NAN elements in a row required to keep the row. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned table's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Table containing all rows of the <code>input</code> with at least <code>keep_threshold</code> non-NAN elements in <code>keys</code>.  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ad692201878dfd4b9058cef0428bf3d" name="a3ad692201878dfd4b9058cef0428bf3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad692201878dfd4b9058cef0428bf3d">&#9670;&#160;</a></span>drop_nulls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt; cudf::detail::drop_nulls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a>&#160;</td>
          <td class="paramname"><em>keep_threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters a table to remove null elements with threshold count.   </p>
<p>Filters the rows of the <code>input</code> considering specified columns indicated in <code>keys</code> for validity / null values.</p>
<p>Given an input <a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a>, row <code>i</code> from the input columns is copied to the output if the same row <code>i</code> of <code>keys</code> has at least <code>keep_threshold</code> non-null fields.</p>
<p>This operation is stable: the input order is preserved in the output.</p>
<p>Any non-nullable column in the input is treated as all non-null.</p>
<div class="fragment"><div class="line">input   {col1: {1, 2,    3,    null},</div>
<div class="line">         col2: {4, 5,    null, null},</div>
<div class="line">         col3: {7, null, null, null}}</div>
<div class="line">keys = {0, 1, 2} // All columns</div>
<div class="line">keep_threshold = 2</div>
<div class="line"> </div>
<div class="line">output {col1: {1, 2}</div>
<div class="line">        col2: {4, 5}</div>
<div class="line">        col3: {7, null}}</div>
</div><!-- fragment --><dl class="section note"><dt>注解</dt><dd>if <code>input.num_rows()</code> is zero, or <code>keys</code> is empty or has no nulls, there is no error, and an empty <code>table</code> is returned</dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> to filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td>vector of indices representing key columns from <code>input</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keep_threshold</td><td>The minimum number of non-null fields in a row required to keep the row. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned table's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Table containing all rows of the <code>input</code> with at least <code>keep_threshold</code> non-null fields in <code>keys</code>.  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a861eb8ba4d559b6db57beb584530fb31" name="a861eb8ba4d559b6db57beb584530fb31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861eb8ba4d559b6db57beb584530fb31">&#9670;&#160;</a></span>encode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">cudf::table</a> &gt;, std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt; &gt; cudf::detail::encode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode the rows of the given table as integers   </p>
<p>The encoded values are integers in the range [0, n), where <code>n</code> is the number of distinct rows in the input table. The result table is such that <code>keys[result[i]] == input[i]</code>, where <code>keys</code> is a table containing the distinct rows in <code>input</code> in sorted ascending order. Nulls, if any, are sorted to the end of the <code>keys</code> table.</p>
<p>Examples: </p><div class="fragment"><div class="line">input: [{&#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;a&#39;}]</div>
<div class="line">output: [{&#39;a&#39;, &#39;b&#39;}], {0, 1, 1, 0}</div>
<div class="line"> </div>
<div class="line">input: [{1, 3, 1, 2, 9}, {1, 2, 1, 3, 5}]</div>
<div class="line">output: [{1, 2, 3, 9}, {1, 3, 2, 5}], {0, 2, 0, 1, 3}</div>
</div><!-- fragment --><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Table containing values to be encoded </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned table's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A pair containing the distinct row of the input table in sorter order, and a column of integer indices representing the encoded rows.  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1a397072949d54359e047f3dada74d5" name="ab1a397072949d54359e047f3dada74d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a397072949d54359e047f3dada74d5">&#9670;&#160;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills a range of elements in a column out-of-place with a scalar value.   </p>
<p>Creates a new column as-if an in-place fill was performed into <code>input</code>; i.e. it is as if a copy of <code>input</code> was created first and then the elements indicated by the indices [<code>begin</code>, <code>end</code>) were overwritten by <code>value</code>.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>for invalid range (if <code>begin</code> &lt; 0, <code>begin</code> &gt; <code>end</code>, or <code>end</code> &gt; <code>destination.size()</code>). </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>destination</code> and <code>value</code> have different types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input column used to create a new column. The new column is created by replacing the values of <code>input</code> in the specified range with <code>value</code>. </td></tr>
    <tr><td class="paramname">begin</td><td>The starting index of the fill range (inclusive) </td></tr>
    <tr><td class="paramname">end</td><td>The index of the last element in the fill range (exclusive) </td></tr>
    <tr><td class="paramname">value</td><td>The scalar value to fill </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The result output column  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6b739ba07b14a2274420abc4f2ea89c" name="ac6b739ba07b14a2274420abc4f2ea89c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b739ba07b14a2274420abc4f2ea89c">&#9670;&#160;</a></span>fill_in_place()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::detail::fill_in_place </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1mutable__column__view.html">mutable_column_view</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills a range of elements in-place in a column with a scalar value.   </p>
<p>Fills N elements of <code>destination</code> starting at <code>begin</code> with <code>value</code>, where N = (<code>end</code> - <code>begin</code>).</p>
<p>Overwrites the range of elements in <code>destination</code> indicated by the indices [<code>begin</code>, <code>end</code>) with <code>value</code>. Use the out-of-place fill function returning std::unique_ptr&lt;column&gt; for use cases requiring memory reallocation.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if memory reallocation is required (e.g. for variable width types). </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>for invalid range (if <code>begin</code> &lt; 0, <code>begin</code> &gt; <code>end</code>, or <code>end</code> &gt; <code>destination.size()</code>). </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>destination</code> and <code>value</code> have different types. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>value</code> is invalid but <code>destination</code> is not nullable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>The preallocated column to fill into </td></tr>
    <tr><td class="paramname">begin</td><td>The starting index of the fill range (inclusive) </td></tr>
    <tr><td class="paramname">end</td><td>The index of the last element in the fill range (exclusive) </td></tr>
    <tr><td class="paramname">value</td><td>The scalar value to fill  </td></tr>
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adacfa4e22fd6f93938a4d72131d9aff7" name="adacfa4e22fd6f93938a4d72131d9aff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adacfa4e22fd6f93938a4d72131d9aff7">&#9670;&#160;</a></span>find_and_replace_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::find_and_replace_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>values_to_replace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>replacement_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a copy of <code>input_col</code> replacing any <code>values_to_replace[i]</code> found with <code>replacement_values[i]</code>.   </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_col</td><td>The column to find and replace values in </td></tr>
    <tr><td class="paramname">values_to_replace</td><td>The values to replace </td></tr>
    <tr><td class="paramname">replacement_values</td><td>The values to replace with </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Copy of <code>input_col</code> with specified values replaced  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2d059bf11972e2337fde993dbd2582b" name="ad2d059bf11972e2337fde993dbd2582b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d059bf11972e2337fde993dbd2582b">&#9670;&#160;</a></span>from_arrow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt; cudf::detail::from_arrow </td>
          <td>(</td>
          <td class="paramtype">arrow::Table const &amp;&#160;</td>
          <td class="paramname"><em>input_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94b63d8998a9b7eb5e1d4ae842f95a66" name="a94b63d8998a9b7eb5e1d4ae842f95a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94b63d8998a9b7eb5e1d4ae842f95a66">&#9670;&#160;</a></span>from_dlpack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt; cudf::detail::from_dlpack </td>
          <td>(</td>
          <td class="paramtype">DLManagedTensor const *&#160;</td>
          <td class="paramname"><em>managed_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a DLPack DLTensor into a cudf table   </p>
<p>The <code>device_type</code> of the DLTensor must be <code>kDLCPU</code>, <code>kDLCuda</code>, or <code>kDLCUDAHost</code>, and <code>device_id</code> must match the current device. The <code>ndim</code> must be set to 1 or 2. The <code>dtype</code> must have 1 lane and the bitsize must match a supported <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">cudf::data_type</a></code>.</p>
<dl class="section note"><dt>注解</dt><dd>The managed tensor is not deleted by this function.</dd></dl>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if the any of the DLTensor fields are unsupported</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">managed_tensor</td><td>a 1D or 2D column-major (Fortran order) tensor </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned table's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Table with a copy of the tensor data  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b23205b2ffc206924167683c00c48f5" name="a5b23205b2ffc206924167683c00c48f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b23205b2ffc206924167683c00c48f5">&#9670;&#160;</a></span>gather() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt; cudf::detail::gather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>source_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>gather_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__column__copy.html#gae3ba74951558bc7966aae86abc6af5df">out_of_bounds_policy</a>&#160;</td>
          <td class="paramname"><em>bounds_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf_1_1detail.html#a1c29a0e8458ffb159e91481c0f37b0f5">negative_index_policy</a>&#160;</td>
          <td class="paramname"><em>neg_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gathers the specified rows of a set of columns according to a gather map. </p>
<p>Gathers the rows of the source columns according to <code>gather_map</code> such that row "i" in the resulting table's columns will contain row "gather_map[i]" from the source columns. The number of rows in the result table will be equal to the number of elements in <code>gather_map</code>.</p>
<p>A negative value <code>i</code> in the <code>gather_map</code> is interpreted as <code>i+n</code>, where <code>n</code> is the number of rows in the <code>source_table</code>.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>check_bounds == true</code> and an index exists in <code>gather_map</code> outside the range <code>[-n, n)</code>, where <code>n</code> is the number of rows in the source table. If <code>check_bounds == false</code>, the behavior is undefined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source_table</td><td>The input columns whose rows will be gathered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gather_map</td><td>View into a non-nullable column of integral indices that maps the rows in the source columns to rows in the destination columns. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bounds_policy</td><td>How to treat out-of-bounds indices. <code>NULLIFY</code> coerces rows that correspond to out-of-bounds indices in the gather map to be null elements. For better performance, use <code>DONT_CHECK</code> when the <code>gather_map</code> is known to contain only valid indices. If <code>policy</code> is set to <code>DONT_CHECK</code> and there are out-of-bounds indices in <code>gather_map</code>, the behavior is undefined. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">negative_index_policy</td><td>Interpret each negative index <code>i</code> in the <code>gather_map</code> as the positive index <code>i+num_source_rows</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned table's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Result of the gather </dd></dl>

</div>
</div>
<a id="aef5dfc3e39242d68bd887f7e0b9fb373" name="aef5dfc3e39242d68bd887f7e0b9fb373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5dfc3e39242d68bd887f7e0b9fb373">&#9670;&#160;</a></span>gather() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt; cudf::detail::gather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>source_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt; const&#160;</td>
          <td class="paramname"><em>gather_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__column__copy.html#gae3ba74951558bc7966aae86abc6af5df">out_of_bounds_policy</a>&#160;</td>
          <td class="paramname"><em>bounds_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecudf_1_1detail.html#a1c29a0e8458ffb159e91481c0f37b0f5">negative_index_policy</a>&#160;</td>
          <td class="paramname"><em>neg_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>gather_map</code> span size is larger than max of <code>size_type</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67374a27ed17df376e445010d699fc62" name="a67374a27ed17df376e445010d699fc62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67374a27ed17df376e445010d699fc62">&#9670;&#160;</a></span>get_distinct_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rmm::device_uvector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; cudf::detail::get_distinct_indices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__reorder__compact.html#ga69091647ea1f9c9d4cdcf7c8876bea3a">duplicate_keep_option</a>&#160;</td>
          <td class="paramname"><em>keep</em> = <code><a class="el" href="group__reorder__compact.html#gga69091647ea1f9c9d4cdcf7c8876bea3aa0546025abe5830d9334bb82102420394">duplicate_keep_option::KEEP_ANY</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a>&#160;</td>
          <td class="paramname"><em>nulls_equal</em> = <code><a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44">null_equality::EQUAL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#gae9d1055c69c3089452794783c7c82f83">nan_equality</a>&#160;</td>
          <td class="paramname"><em>nans_equal</em> = <code><a class="el" href="group__utility__types.html#ggae9d1055c69c3089452794783c7c82f83acd6d9f766e6e2753da429d26078711d7">nan_equality::ALL_EQUAL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a column of indices of all distinct rows in the input table. </p>
<p>Given an <code>input</code> <a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a>, an output vector of all row indices of the distinct rows is generated. If there are duplicate rows, which index is kept depends on the <code>keep</code> parameter.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input table </td></tr>
    <tr><td class="paramname">keep</td><td>Get index of any, first, last, or none of the found duplicates </td></tr>
    <tr><td class="paramname">nulls_equal</td><td>Flag to specify whether null elements should be considered as equal </td></tr>
    <tr><td class="paramname">nans_equal</td><td>Flag to specify whether NaN elements should be considered as equal </td></tr>
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A device_uvector containing the result indices </dd></dl>

</div>
</div>
<a id="a6ca203cd4504a08ef2fd489410d6db95" name="a6ca203cd4504a08ef2fd489410d6db95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca203cd4504a08ef2fd489410d6db95">&#9670;&#160;</a></span>get_dremel_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1detail_1_1dremel__data.html">dremel_data</a> cudf::detail::get_dremel_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a>&#160;</td>
          <td class="paramname"><em>h_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint8_t &gt;&#160;</td>
          <td class="paramname"><em>nullability</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>output_as_byte_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the dremel offsets and repetition and definition levels for a LIST column </p>
<p>Dremel is a query system created by Google for ad hoc data analysis. The Dremel engine is described in depth in the paper "Dremel: Interactive Analysis of Web-Scale
Datasets" (<a href="https://research.google/pubs/pub36632/">https://research.google/pubs/pub36632/</a>). One of the key components of Dremel is an encoding that converts record-like data into a columnar store for efficient memory accesses. The Parquet file format uses Dremel encoding to handle nested data, so libcudf requires some facilities for working with this encoding. Furthermore, libcudf leverages Dremel encoding as a means for performing lexicographic comparisons of nested columns.</p>
<p>Dremel encoding is built around two concepts, the repetition and definition levels. Since describing them thoroughly is out of scope for this docstring, here are a couple of blogs that provide useful background:</p>
<p><a href="http://www.goldsborough.me/distributed-systems/2019/05/18/21-09-00-a_look_at_dremel/">http://www.goldsborough.me/distributed-systems/2019/05/18/21-09-00-a_look_at_dremel/</a> <a href="https://akshays-blog.medium.com/wrapping-head-around-repetition-and-definition-levels-in-dremel-powering-bigquery-c1a33c9695da">https://akshays-blog.medium.com/wrapping-head-around-repetition-and-definition-levels-in-dremel-powering-bigquery-c1a33c9695da</a> <a href="https://blog.twitter.com/engineering/en_us/a/2013/dremel-made-simple-with-parquet">https://blog.twitter.com/engineering/en_us/a/2013/dremel-made-simple-with-parquet</a></p>
<p>The remainder of this documentation assumes familiarity with the Dremel concepts.</p>
<p>Dremel offsets are the per row offsets into the repetition and definition level arrays for a column. Example: </p><div class="fragment"><div class="line">col            = {{1, 2, 3}, { }, {5, 6}}</div>
<div class="line">dremel_offsets = { 0,         3,   4,  6}</div>
<div class="line">rep_level      = { 0, 1, 1,   0,   0, 1}</div>
<div class="line">def_level      = { 1, 1, 1,   0,   1, 1}</div>
</div><!-- fragment --><p>The repetition and definition level values are ideally computed using a recursive call over a nested structure but in order to better utilize GPU resources, this function calculates them with a bottom up merge method.</p>
<p>Given a LIST column of type <code>List&lt;List&lt;int&gt;&gt;</code> like so: </p><div class="fragment"><div class="line">col = {</div>
<div class="line">   [],</div>
<div class="line">   [[], [1, 2, 3], [4, 5]],</div>
<div class="line">   [[]]</div>
<div class="line">}</div>
</div><!-- fragment --><p> We can represent it in cudf format with two level of offsets like this: </p><div class="fragment"><div class="line">Level 0 offsets = {0, 0, 3, 5, 6}</div>
<div class="line">Level 1 offsets = {0, 0, 3, 5, 5}</div>
<div class="line">Values          = {1, 2, 3, 4, 5}</div>
</div><!-- fragment --><p> The desired result of this function is the repetition and definition level values that correspond to the data values: </p><div class="fragment"><div class="line">col = {[], [[], [1, 2, 3], [4, 5]], [[]]}</div>
<div class="line">def = { 0    1,  2, 2, 2,   2, 2,     1 }</div>
<div class="line">rep = { 0,   0,  0, 2, 2,   1, 2,     0 }</div>
</div><!-- fragment --><p>Since repetition and definition levels arrays contain a value for each empty list, the size of the rep/def level array can be given by </p><div class="fragment"><div class="line">rep_level.size() = size of leaf <a class="code hl_class" href="classcudf_1_1column.html">column</a> + number of empty lists in level 0</div>
<div class="line">                                       + number of empty lists in level 1 ...</div>
<div class="ttc" id="aclasscudf_1_1column_html"><div class="ttname"><a href="classcudf_1_1column.html">cudf::column</a></div><div class="ttdoc">A container of nullable device data as a column of elements.</div><div class="ttdef"><b>Definition</b> <a href="column_8hpp_source.html#l00048">column.hpp:48</a></div></div>
</div><!-- fragment --><p>We start with finding the empty lists in the penultimate level and merging it with the indices of the leaf level. The values for the merge are the definition and repetition levels </p><div class="fragment"><div class="line">empties at level 1 = {0, 5}</div>
<div class="line">def values at 1    = {1, 1}</div>
<div class="line">rep values at 1    = {1, 1}</div>
<div class="line">indices at leaf    = {0, 1, 2, 3, 4}</div>
<div class="line">def values at leaf = {2, 2, 2, 2, 2}</div>
<div class="line">rep values at leaf = {2, 2, 2, 2, 2}</div>
</div><!-- fragment --><p>merged def values = {1, 2, 2, 2, 2, 2, 1} merged rep values = {1, 2, 2, 2, 2, 2, 1}</p>
<p>The size of the rep/def values is now larger than the leaf values and the offsets need to be adjusted in order to point to the correct start indices. We do this with an exclusive scan over the indices of offsets of empty lists and adding to existing offsets. </p><div class="fragment"><div class="line">Level 1 <span class="keyword">new</span> offsets = {0, 1, 4, 6, 7}</div>
</div><!-- fragment --><p> Repetition values at the beginning of a list need to be decremented. We use the new offsets to scatter the rep value. </p><div class="fragment"><div class="line">merged rep values  = {1, 2, 2, 2, 2, 2, 1}</div>
<div class="line"><a class="code hl_function" href="namespacecudf_1_1detail.html#ab0fafddc49374af3d9ab6815196d426f">scatter</a> (1, <span class="keyword">new</span> offsets)</div>
<div class="line"><span class="keyword">new</span> offsets        = {0, 1,       4,    6, 7}</div>
<div class="line"><span class="keyword">new</span> rep values     = {1, 1, 2, 2, 1, 2, 1}</div>
<div class="ttc" id="anamespacecudf_1_1detail_html_ab0fafddc49374af3d9ab6815196d426f"><div class="ttname"><a href="namespacecudf_1_1detail.html#ab0fafddc49374af3d9ab6815196d426f">cudf::detail::scatter</a></div><div class="ttdeci">std::unique_ptr&lt; table &gt; scatter(table_view const &amp;source, column_view const &amp;scatter_map, table_view const &amp;target, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</div><div class="ttdoc">Scatters the rows of the source table into a copy of the target table according to a scatter map.</div></div>
</div><!-- fragment --><p>Similarly we merge up all the way till level 0 offsets</p>
<p>STRUCT COLUMNS : In case of struct columns, we don't have to merge struct levels with their children because a struct is the same size as its children. e.g. for a column <code>struct&lt;int, float&gt;</code>, if the row <code>i</code> is null, then the children columns <code>int</code> and <code>float</code> are also null at <code>i</code>. They also have the null entry represented in their respective null masks. So for any case of strictly struct based nesting, we can get the definition levels merely by iterating over the nesting for the same row.</p>
<p>In case struct and lists are intermixed, the definition levels of all the contiguous struct levels can be constructed using the aforementioned iterative method. Only when we reach a list level, we need to do a merge with the subsequent level.</p>
<p>So, for a column like <code>struct&lt;list&lt;int&gt;&gt;</code>, we are going to merge between the levels <code>struct&lt;list</code> and <code>int</code>. For a column like <code>list&lt;struct&lt;int&gt;&gt;</code>, we are going to merge between <code>list</code> and <code>struct&lt;int&gt;</code>.</p>
<p>In general, one nesting level is the list level and any struct level that precedes it.</p>
<p>A few more examples to visualize the partitioning of column hierarchy into nesting levels: (L is list, S is struct, i is integer(leaf data level), angle brackets omitted) </p><div class="fragment"><div class="line">1. LSi     = L   Si</div>
<div class="line">             - | --</div>
<div class="line"> </div>
<div class="line">2. LLSi    = L   L   Si</div>
<div class="line">             - | - | --</div>
<div class="line"> </div>
<div class="line">3. SSLi    = SSL   i</div>
<div class="line">             --- | -</div>
<div class="line"> </div>
<div class="line">4. LLSLSSi = L   L   SL   SSi</div>
<div class="line">             - | - | -- | ---</div>
</div><!-- fragment --><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">col</td><td>Column of LIST type </td></tr>
    <tr><td class="paramname">level_nullability</td><td>Pre-determined nullability at each list level. Empty means infer from <code>col</code> </td></tr>
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A struct containing dremel data </dd></dl>

</div>
</div>
<a id="a84c26312d03ba6528aa4d28c9ec41a67" name="a84c26312d03ba6528aa4d28c9ec41a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84c26312d03ba6528aa4d28c9ec41a67">&#9670;&#160;</a></span>get_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt; cudf::detail::get_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the element at specified index from a column   </p>
<dl class="section warning"><dt>警告</dt><dd>This function is expensive (invokes a kernel launch). So, it is not recommended to be used in performance sensitive code or inside a loop.</dd></dl>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>index</code> is not within the range <code>[0, input.size())</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Column view to get the element from </td></tr>
    <tr><td class="paramname">index</td><td>Index into <code>input</code> to get the element at </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned scalar's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>std::unique_ptr&lt;scalar&gt; Scalar containing the single value  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee63ff93909aab1cf205625ee996236a" name="aee63ff93909aab1cf205625ee996236a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee63ff93909aab1cf205625ee996236a">&#9670;&#160;</a></span>has_nested_columns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cudf::detail::has_nested_columns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if any nested columns exist in a given table. </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>The input table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Whether nested columns exist in the input table </dd></dl>

</div>
</div>
<a id="a5758db52c9f99ddaab9a9de11fd25f4d" name="a5758db52c9f99ddaab9a9de11fd25f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5758db52c9f99ddaab9a9de11fd25f4d">&#9670;&#160;</a></span>has_nonempty_nulls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cudf::detail::has_nonempty_nulls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a column or its descendants have non-empty null rows   </p>
<dl class="section note"><dt>注解</dt><dd>This function is exact. If it returns <code>true</code>, there exists one or more non-empty null elements.</dd></dl>
<p>A LIST or STRING column might have non-empty rows that are marked as null. A STRUCT OR LIST column might have child columns that have non-empty null rows. Other types of columns are deemed incapable of having non-empty null rows. E.g. Fixed width columns have no concept of an "empty" row.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The column which is (and whose descendants are) to be checked for non-empty null rows. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>true If either the column or its descendants have non-empty null rows </dd>
<dd>
false If neither the column or its descendants have non-empty null rows  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac670d683b1e9e5c0682c3e2d23e79563" name="ac670d683b1e9e5c0682c3e2d23e79563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac670d683b1e9e5c0682c3e2d23e79563">&#9670;&#160;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::hash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__column__hash.html#gaced8b9d129825edd13d76e912e4413c3">hash_id</a>&#160;</td>
          <td class="paramname"><em>hash_function</em> = <code><a class="el" href="group__column__hash.html#ggaced8b9d129825edd13d76e912e4413c3ae9ec854e962136b1afcf108e5301c354">hash_id::HASH_MURMUR3</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code><a class="el" href="group__column__hash.html#ga68de1d04aa2c0ea2eeacfc73fd99a915">cudf::DEFAULT_HASH_SEED</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the hash value of each row in the input set of columns.   </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The table of columns to hash </td></tr>
    <tr><td class="paramname">hash_function</td><td>The hash function enum to use </td></tr>
    <tr><td class="paramname">seed</td><td>Optional seed value to use for the hash function </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A column where each row is the hash of a column from the input  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31fed6fb6d5421eadcf1516f8d4e4fe9" name="a31fed6fb6d5421eadcf1516f8d4e4fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31fed6fb6d5421eadcf1516f8d4e4fe9">&#9670;&#160;</a></span>hash_combine() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t cudf::detail::hash_combine </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combines two hash values into a single hash value. </p>
<p>Adapted from Boost hash_combine function and modified for 64-bit. <a href="https://www.boost.org/doc/libs/1_35_0/doc/html/boost/hash_combine_id241013.html">https://www.boost.org/doc/libs/1_35_0/doc/html/boost/hash_combine_id241013.html</a></p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first hash value </td></tr>
    <tr><td class="paramname">rhs</td><td>The second hash value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Combined hash value </dd></dl>

<p class="definition">在文件 <a class="el" href="detail_2hashing_8hpp_source.html">hashing.hpp</a> 第 <a class="el" href="detail_2hashing_8hpp_source.html#l00095">95</a> 行定义.</p>

</div>
</div>
<a id="afacc4b3c523b45ae3046691dcc061191" name="afacc4b3c523b45ae3046691dcc061191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afacc4b3c523b45ae3046691dcc061191">&#9670;&#160;</a></span>hash_combine() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint32_t cudf::detail::hash_combine </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combines two hash values into a single hash value. </p>
<p>Taken from the Boost hash_combine function. <a href="https://www.boost.org/doc/libs/1_35_0/doc/html/boost/hash_combine_id241013.html">https://www.boost.org/doc/libs/1_35_0/doc/html/boost/hash_combine_id241013.html</a></p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first hash value </td></tr>
    <tr><td class="paramname">rhs</td><td>The second hash value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Combined hash value </dd></dl>

<p class="definition">在文件 <a class="el" href="detail_2hashing_8hpp_source.html">hashing.hpp</a> 第 <a class="el" href="detail_2hashing_8hpp_source.html#l00074">74</a> 行定义.</p>

</div>
</div>
<a id="acc8016a38976fc8af9b8a9b3c23a08ae" name="acc8016a38976fc8af9b8a9b3c23a08ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc8016a38976fc8af9b8a9b3c23a08ae">&#9670;&#160;</a></span>inclusive_dense_rank_scan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::inclusive_dense_rank_scan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>order_by</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate row dense ranks for a column. </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">order_by</td><td>Input column to generate ranks for. </td></tr>
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>rank values. </dd></dl>

</div>
</div>
<a id="ab6f61e90d14f101f0f7da7f140649f80" name="ab6f61e90d14f101f0f7da7f140649f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6f61e90d14f101f0f7da7f140649f80">&#9670;&#160;</a></span>inclusive_one_normalized_percent_rank_scan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::inclusive_one_normalized_percent_rank_scan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>order_by</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate row ONE_NORMALIZED percent ranks for a column. Also, knowns as ANSI SQL PERCENT RANK. Calculated by (rank - 1) / (count - 1). </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">order_by</td><td>Input column to generate ranks for. </td></tr>
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>rank values. </dd></dl>

</div>
</div>
<a id="a2b644db01ab5c564aa3e2e865669b59d" name="a2b644db01ab5c564aa3e2e865669b59d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b644db01ab5c564aa3e2e865669b59d">&#9670;&#160;</a></span>inclusive_rank_scan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::inclusive_rank_scan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>order_by</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate row ranks for a column. </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">order_by</td><td>Input column to generate ranks for. </td></tr>
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>rank values. </dd></dl>

</div>
</div>
<a id="af99f371b8101fc545e0c64553e5d81a9" name="af99f371b8101fc545e0c64553e5d81a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af99f371b8101fc545e0c64553e5d81a9">&#9670;&#160;</a></span>inplace_bitmask_and()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a> cudf::detail::inplace_bitmask_and </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; <a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> &gt;&#160;</td>
          <td class="paramname"><em>dest_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> const *const &gt;&#160;</td>
          <td class="paramname"><em>masks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt;&#160;</td>
          <td class="paramname"><em>masks_begin_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>mask_size_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a bitwise AND of the specified bitmasks, and writes in place to destination </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest_mask</td><td>Destination to which the AND result is written </td></tr>
    <tr><td class="paramname">masks</td><td>The list of data pointers of the bitmasks to be ANDed </td></tr>
    <tr><td class="paramname">masks_begin_bits</td><td>The bit offsets from which each mask is to be ANDed </td></tr>
    <tr><td class="paramname">mask_size_bits</td><td>The number of bits to be ANDed in each mask </td></tr>
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Count of set bits </dd></dl>

</div>
</div>
<a id="a08a76bcdabba736bbb9948129f723028" name="a08a76bcdabba736bbb9948129f723028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a76bcdabba736bbb9948129f723028">&#9670;&#160;</a></span>interleave_columns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::interleave_columns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interleave columns of a table into a single column.   </p>
<p>Converts the column major table <code>input</code> into a row major column. Example: </p><div class="fragment"><div class="line">in     = [[A1, A2, A3], [B1, B2, B3]]</div>
<div class="line"><span class="keywordflow">return</span> = [A1, B1, A2, B2, A3, B3]</div>
</div><!-- fragment --><dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if input contains no columns. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if input columns dtypes are not identical.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Table containing columns to interleave </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The interleaved columns as a single column  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a342ee3e4fa47300f2b57966d0eb3405f" name="a342ee3e4fa47300f2b57966d0eb3405f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a342ee3e4fa47300f2b57966d0eb3405f">&#9670;&#160;</a></span>is_element_valid_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cudf::detail::is_element_valid_sync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>col_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>element_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return validity of a row </p>
<p>Retrieves the validity (NULL or non-NULL) of the specified row from device memory.</p>
<dl class="section note"><dt>注解</dt><dd>Synchronizes <code>stream</code>.</dd></dl>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>element_index &lt; 0 or &gt;= col_view.size()</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">col_view</td><td>The column to retrieve the validity from. </td></tr>
    <tr><td class="paramname">element_index</td><td>The index of the row to retrieve. </td></tr>
    <tr><td class="paramname">stream</td><td>The stream to use for copying the validity to the host. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Host boolean that indicates the validity of the row. </dd></dl>

</div>
</div>
<a id="a87fb076548c816c8477d213d3b56362a" name="a87fb076548c816c8477d213d3b56362a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87fb076548c816c8477d213d3b56362a">&#9670;&#160;</a></span>is_nan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::is_nan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a column of <code><a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd" title="Boolean using one byte per value, 0 == false, else true">type_id::BOOL8</a></code> elements indicating the presence of <code>NaN</code> values in a column of floating point values. The output element at row <code>i</code> is <code>true</code> if the element in <code>input</code> at row i is <code>NAN</code>, else <code>false</code>   </p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>input</code> is a non-floating point type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>A column of floating-point elements </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A non-nullable column of <code><a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd" title="Boolean using one byte per value, 0 == false, else true">type_id::BOOL8</a></code> elements with <code>true</code> representing <code>NAN</code> values  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab222fc99bdf3b292820aa2502058869" name="aab222fc99bdf3b292820aa2502058869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab222fc99bdf3b292820aa2502058869">&#9670;&#160;</a></span>is_not_nan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::is_not_nan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a column of <code><a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd" title="Boolean using one byte per value, 0 == false, else true">type_id::BOOL8</a></code> elements indicating the absence of <code>NaN</code> values in a column of floating point values. The output element at row <code>i</code> is <code>false</code> if the element in <code>input</code> at row i is <code>NAN</code>, else <code>true</code>   </p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>input</code> is a non-floating point type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>A column of floating-point elements </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A non-nullable column of <code><a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd" title="Boolean using one byte per value, 0 == false, else true">type_id::BOOL8</a></code> elements with <code>false</code> representing <code>NAN</code> values  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3723537389c05b4a90958589c304f2fb" name="a3723537389c05b4a90958589c304f2fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3723537389c05b4a90958589c304f2fb">&#9670;&#160;</a></span>is_relationally_comparable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TableView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cudf::detail::is_relationally_comparable </td>
          <td>(</td>
          <td class="paramtype">TableView const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TableView const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether respective columns in input tables are relationally comparable. </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first table </td></tr>
    <tr><td class="paramname">rhs</td><td>The second table (may be the same table as <code>lhs</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>true all of respective columns on <code>lhs</code> and 'rhs<code>tables are comparable. @return false any of respective columns on</code>lhs<code>and 'rhs</code> tables are not comparable. </dd></dl>

</div>
</div>
<a id="a8c566f1ff3c273be1518ca5f7d92d4cc" name="a8c566f1ff3c273be1518ca5f7d92d4cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c566f1ff3c273be1518ca5f7d92d4cc">&#9670;&#160;</a></span>is_shallow_equivalent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cudf::detail::is_shallow_equivalent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses only shallow state to determine if two <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code>s view equivalent columns </p>
<p>Two columns are equivalent if for any operation <code>F</code> then: </p><div class="fragment"><div class="line"><a class="code hl_function" href="namespacecudf_1_1detail.html#a8c566f1ff3c273be1518ca5f7d92d4cc">is_shallow_equivalent</a>(c0, c1) ==&gt; The results of F(c0) and F(c1) are equivalent</div>
<div class="ttc" id="anamespacecudf_1_1detail_html_a8c566f1ff3c273be1518ca5f7d92d4cc"><div class="ttname"><a href="namespacecudf_1_1detail.html#a8c566f1ff3c273be1518ca5f7d92d4cc">cudf::detail::is_shallow_equivalent</a></div><div class="ttdeci">bool is_shallow_equivalent(column_view const &amp;lhs, column_view const &amp;rhs)</div><div class="ttdoc">Uses only shallow state to determine if two column_views view equivalent columns</div></div>
</div><!-- fragment --><p> For any two non-empty columns, <code>is_shallow_equivalent(c0,c1)</code> is true only if they view the exact same physical column. In other words, two physically independent columns may have exactly equivalent elements but their shallow state would not be equivalent.</p>
<p>The complexity of this function is <code>O( min(count_descendants(lhs), count_descendants(rhs)) )</code>, i.e., it is independent of the number of elements in either column.</p>
<p>This function does <em>not</em> inspect the elements of <code>lhs</code> or <code>rhs</code> nor access any device memory nor launch any kernels.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> to compare </td></tr>
    <tr><td class="paramname">rhs</td><td>The right <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>If <code>lhs</code> and <code>rhs</code> have equivalent shallow state </dd></dl>

</div>
</div>
<a id="af8a7ba935c016e3b7c537937d88e038f" name="af8a7ba935c016e3b7c537937d88e038f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a7ba935c016e3b7c537937d88e038f">&#9670;&#160;</a></span>is_sum_product_agg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool cudf::detail::is_sum_product_agg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1aggregation.html#a83579ae3cab2fc3d1c3b377d1cfab24c">aggregation::Kind</a>&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">在文件 <a class="el" href="detail_2aggregation_2aggregation_8hpp_source.html">aggregation.hpp</a> 第 <a class="el" href="detail_2aggregation_2aggregation_8hpp_source.html#l01177">1177</a> 行定义.</p>

</div>
</div>
<a id="a79d87c0aa523a30c8ab5b806ab4bb62e" name="a79d87c0aa523a30c8ab5b806ab4bb62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79d87c0aa523a30c8ab5b806ab4bb62e">&#9670;&#160;</a></span>is_valid_aggregation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Source , <a class="el" href="classcudf_1_1aggregation.html#a83579ae3cab2fc3d1c3b377d1cfab24c">aggregation::Kind</a> k&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool cudf::detail::is_valid_aggregation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the specified aggregation <code>k</code> is valid to perform on the type <code>Source</code>. </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Source</td><td>Type on which the aggregation is performed </td></tr>
    <tr><td class="paramname">k</td><td>The aggregation to perform </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="detail_2aggregation_2aggregation_8hpp_source.html">aggregation.hpp</a> 第 <a class="el" href="detail_2aggregation_2aggregation_8hpp_source.html#l01537">1537</a> 行定义.</p>

</div>
</div>
<a id="a2e1ec5de7e8b76d00528c28ba90d8fc1" name="a2e1ec5de7e8b76d00528c28ba90d8fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e1ec5de7e8b76d00528c28ba90d8fc1">&#9670;&#160;</a></span>is_valid_aggregation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cudf::detail::is_valid_aggregation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1aggregation.html#a83579ae3cab2fc3d1c3b377d1cfab24c">aggregation::Kind</a>&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether the specified aggregation <code>k</code> is valid to perform on the <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> <code>source</code>. </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Source <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> on which the aggregation is performed </td></tr>
    <tr><td class="paramname">k</td><td>The aggregation to perform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45dd74287624f555fcfb232087bb16e6" name="a45dd74287624f555fcfb232087bb16e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45dd74287624f555fcfb232087bb16e6">&#9670;&#160;</a></span>lower_bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::lower_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>needles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>column_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>null_precedence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find smallest indices in a sorted table where values should be inserted to maintain order.   </p>
<p>For each row in <code>needles</code>, find the first index in <code>haystack</code> where inserting the row still maintains its sort order.</p>
<div class="fragment"><div class="line">Example:</div>
<div class="line"> </div>
<div class="line"> Single column:</div>
<div class="line">     idx        0   1   2   3   4</div>
<div class="line">  haystack = { 10, 20, 20, 30, 50 }</div>
<div class="line">  needles  = { 20 }</div>
<div class="line">  result   = {  1 }</div>
<div class="line"> </div>
<div class="line"> Multi Column:</div>
<div class="line">     idx          0    1    2    3    4</div>
<div class="line">  haystack = {{  10,  20,  20,  20,  20 },</div>
<div class="line">              { 5.0,  .5,  .5,  .7,  .7 },</div>
<div class="line">              {  90,  77,  78,  61,  61 }}</div>
<div class="line">  needles  = {{ 20 },</div>
<div class="line">              { .7 },</div>
<div class="line">              { 61 }}</div>
<div class="line">  result   = {   3 }</div>
</div><!-- fragment --><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>The table containing search space </td></tr>
    <tr><td class="paramname">needles</td><td>Values for which to find the insert locations in the search space </td></tr>
    <tr><td class="paramname">column_order</td><td>Vector of column sort order </td></tr>
    <tr><td class="paramname">null_precedence</td><td>Vector of null_precedence enums needles </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A non-nullable column of <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9" title="Row index type for columns and tables">cudf::size_type</a> elements containing the insertion points  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3025511800f795e70b22eba7fd0def7" name="ad3025511800f795e70b22eba7fd0def7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3025511800f795e70b22eba7fd0def7">&#9670;&#160;</a></span>make_device_uvector_async() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , std::enable_if_t&lt; std::is_convertible_v&lt; Container, <a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; typename Container::value_type const &gt; &gt; &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">rmm::device_uvector&lt; typename Container::value_type &gt; cudf::detail::make_device_uvector_async </td>
          <td>(</td>
          <td class="paramtype">Container const &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously construct a <code>device_uvector</code> containing a deep copy of data from a host container </p>
<p>Asynchronously construct a <code>device_uvector</code> containing a deep copy of data from a device container</p>
<dl class="section note"><dt>注解</dt><dd>This function does not synchronize <code>stream</code>.</dd></dl>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>The type of the container to copy from </td></tr>
    <tr><td class="paramname">T</td><td>The type of the data to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The input host container from which to copy </td></tr>
    <tr><td class="paramname">stream</td><td>The stream on which to allocate memory and perform the copy </td></tr>
    <tr><td class="paramname">mr</td><td>The memory resource to use for allocating the returned device_uvector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A device_uvector containing the copied data</dd></dl>
<dl class="section note"><dt>注解</dt><dd>This function does not synchronize <code>stream</code>.</dd></dl>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>The type of the container to copy from </td></tr>
    <tr><td class="paramname">T</td><td>The type of the data to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The input device container from which to copy </td></tr>
    <tr><td class="paramname">stream</td><td>The stream on which to allocate memory and perform the copy </td></tr>
    <tr><td class="paramname">mr</td><td>The memory resource to use for allocating the returned device_uvector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A device_uvector containing the copied data </dd></dl>

<p class="definition">在文件 <a class="el" href="vector__factories_8hpp_source.html">vector_factories.hpp</a> 第 <a class="el" href="vector__factories_8hpp_source.html#l00128">128</a> 行定义.</p>

</div>
</div>
<a id="a556dd2e77b79628c78ec6718935f565d" name="a556dd2e77b79628c78ec6718935f565d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a556dd2e77b79628c78ec6718935f565d">&#9670;&#160;</a></span>make_device_uvector_async() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">rmm::device_uvector&lt; T &gt; cudf::detail::make_device_uvector_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; T const &gt;&#160;</td>
          <td class="paramname"><em>source_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously construct a <code>device_uvector</code> containing a deep copy of data from a <code><a class="el" href="structcudf_1_1device__span.html" title="Device version of C++20 std::span with reduced feature set.">device_span</a></code> </p>
<dl class="section note"><dt>注解</dt><dd>This function does not synchronize <code>stream</code>.</dd></dl>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the data to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_data</td><td>The <a class="el" href="structcudf_1_1device__span.html" title="Device version of C++20 std::span with reduced feature set.">device_span</a> of data to deep copy </td></tr>
    <tr><td class="paramname">stream</td><td>The stream on which to allocate memory and perform the copy </td></tr>
    <tr><td class="paramname">mr</td><td>The memory resource to use for allocating the returned device_uvector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A device_uvector containing the copied data </dd></dl>

<p class="definition">在文件 <a class="el" href="vector__factories_8hpp_source.html">vector_factories.hpp</a> 第 <a class="el" href="vector__factories_8hpp_source.html#l00149">149</a> 行定义.</p>

</div>
</div>
<a id="af58212f43ad1509a309bf99b6abcabb3" name="af58212f43ad1509a309bf99b6abcabb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af58212f43ad1509a309bf99b6abcabb3">&#9670;&#160;</a></span>make_device_uvector_async() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">rmm::device_uvector&lt; T &gt; cudf::detail::make_device_uvector_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; T const &gt;&#160;</td>
          <td class="paramname"><em>source_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously construct a <code>device_uvector</code> containing a deep copy of data from a <code><a class="el" href="structcudf_1_1host__span.html" title="C++20 std::span with reduced feature set.">host_span</a></code> </p>
<dl class="section note"><dt>注解</dt><dd>This function does not synchronize <code>stream</code>.</dd></dl>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the data to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_data</td><td>The <a class="el" href="structcudf_1_1host__span.html" title="C++20 std::span with reduced feature set.">host_span</a> of data to deep copy </td></tr>
    <tr><td class="paramname">stream</td><td>The stream on which to allocate memory and perform the copy </td></tr>
    <tr><td class="paramname">mr</td><td>The memory resource to use for allocating the returned device_uvector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A device_uvector containing the copied data </dd></dl>

<p class="definition">在文件 <a class="el" href="vector__factories_8hpp_source.html">vector_factories.hpp</a> 第 <a class="el" href="vector__factories_8hpp_source.html#l00097">97</a> 行定义.</p>

</div>
</div>
<a id="a5f1c217de33d11bb490a51d1904361f9" name="a5f1c217de33d11bb490a51d1904361f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f1c217de33d11bb490a51d1904361f9">&#9670;&#160;</a></span>make_device_uvector_sync() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , std::enable_if_t&lt; std::is_convertible_v&lt; Container, <a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; typename Container::value_type const &gt; &gt; &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">rmm::device_uvector&lt; typename Container::value_type &gt; cudf::detail::make_device_uvector_sync </td>
          <td>(</td>
          <td class="paramtype">Container const &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously construct a <code>device_uvector</code> containing a deep copy of data from a host container </p>
<p>Synchronously construct a <code>device_uvector</code> containing a deep copy of data from a device container</p>
<dl class="section note"><dt>注解</dt><dd>This function synchronizes <code>stream</code>.</dd></dl>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>The type of the container to copy from </td></tr>
    <tr><td class="paramname">T</td><td>The type of the data to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The input host container from which to copy </td></tr>
    <tr><td class="paramname">stream</td><td>The stream on which to allocate memory and perform the copy </td></tr>
    <tr><td class="paramname">mr</td><td>The memory resource to use for allocating the returned device_uvector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A device_uvector containing the copied data</dd></dl>
<dl class="section note"><dt>注解</dt><dd>This function synchronizes <code>stream</code>.</dd></dl>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>The type of the container to copy from </td></tr>
    <tr><td class="paramname">T</td><td>The type of the data to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The input device container from which to copy </td></tr>
    <tr><td class="paramname">stream</td><td>The stream on which to allocate memory and perform the copy </td></tr>
    <tr><td class="paramname">mr</td><td>The memory resource to use for allocating the returned device_uvector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A device_uvector containing the copied data </dd></dl>

<p class="definition">在文件 <a class="el" href="vector__factories_8hpp_source.html">vector_factories.hpp</a> 第 <a class="el" href="vector__factories_8hpp_source.html#l00229">229</a> 行定义.</p>

</div>
</div>
<a id="a5a7fae42222fe71f2374141166c508cc" name="a5a7fae42222fe71f2374141166c508cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a7fae42222fe71f2374141166c508cc">&#9670;&#160;</a></span>make_device_uvector_sync() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">rmm::device_uvector&lt; T &gt; cudf::detail::make_device_uvector_sync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; T const &gt;&#160;</td>
          <td class="paramname"><em>source_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously construct a <code>device_uvector</code> containing a deep copy of data from a <code><a class="el" href="structcudf_1_1device__span.html" title="Device version of C++20 std::span with reduced feature set.">device_span</a></code> </p>
<dl class="section note"><dt>注解</dt><dd>This function synchronizes <code>stream</code>.</dd></dl>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the data to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_data</td><td>The <a class="el" href="structcudf_1_1device__span.html" title="Device version of C++20 std::span with reduced feature set.">device_span</a> of data to deep copy </td></tr>
    <tr><td class="paramname">stream</td><td>The stream on which to allocate memory and perform the copy </td></tr>
    <tr><td class="paramname">mr</td><td>The memory resource to use for allocating the returned device_uvector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A device_uvector containing the copied data </dd></dl>

<p class="definition">在文件 <a class="el" href="vector__factories_8hpp_source.html">vector_factories.hpp</a> 第 <a class="el" href="vector__factories_8hpp_source.html#l00250">250</a> 行定义.</p>

</div>
</div>
<a id="a567b65a608d7b1818cff9632b3dafde8" name="a567b65a608d7b1818cff9632b3dafde8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a567b65a608d7b1818cff9632b3dafde8">&#9670;&#160;</a></span>make_device_uvector_sync() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">rmm::device_uvector&lt; T &gt; cudf::detail::make_device_uvector_sync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; T const &gt;&#160;</td>
          <td class="paramname"><em>source_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously construct a <code>device_uvector</code> containing a deep copy of data from a <code><a class="el" href="structcudf_1_1host__span.html" title="C++20 std::span with reduced feature set.">host_span</a></code> </p>
<dl class="section note"><dt>注解</dt><dd>This function synchronizes <code>stream</code>.</dd></dl>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the data to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_data</td><td>The <a class="el" href="structcudf_1_1host__span.html" title="C++20 std::span with reduced feature set.">host_span</a> of data to deep copy </td></tr>
    <tr><td class="paramname">stream</td><td>The stream on which to allocate memory and perform the copy </td></tr>
    <tr><td class="paramname">mr</td><td>The memory resource to use for allocating the returned device_uvector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A device_uvector containing the copied data </dd></dl>

<p class="definition">在文件 <a class="el" href="vector__factories_8hpp_source.html">vector_factories.hpp</a> 第 <a class="el" href="vector__factories_8hpp_source.html#l00202">202</a> 行定义.</p>

</div>
</div>
<a id="ac8a6ec6815c3166045d3417e832d1601" name="ac8a6ec6815c3166045d3417e832d1601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8a6ec6815c3166045d3417e832d1601">&#9670;&#160;</a></span>make_host_vector_async() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , std::enable_if_t&lt; std::is_convertible_v&lt; Container, <a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; typename Container::value_type const &gt; &gt; &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">thrust::host_vector&lt; typename Container::value_type &gt; cudf::detail::make_host_vector_async </td>
          <td>(</td>
          <td class="paramtype">Container const &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously construct a <code>std::vector</code> containing a copy of data from a device container </p>
<dl class="section note"><dt>注解</dt><dd>This function synchronizes <code>stream</code>.</dd></dl>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>The type of the container to copy from </td></tr>
    <tr><td class="paramname">T</td><td>The type of the data to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The input device container from which to copy </td></tr>
    <tr><td class="paramname">stream</td><td>The stream on which to perform the copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The data copied to the host </dd></dl>

<p class="definition">在文件 <a class="el" href="vector__factories_8hpp_source.html">vector_factories.hpp</a> 第 <a class="el" href="vector__factories_8hpp_source.html#l00408">408</a> 行定义.</p>

</div>
</div>
<a id="a6a6bc114d57f9b4ebe7b1fd1c0debeb3" name="a6a6bc114d57f9b4ebe7b1fd1c0debeb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a6bc114d57f9b4ebe7b1fd1c0debeb3">&#9670;&#160;</a></span>make_host_vector_async() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">thrust::host_vector&lt; T &gt; cudf::detail::make_host_vector_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; T const &gt;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously construct a <code>thrust::host_vector</code> containing a copy of data from a <code><a class="el" href="structcudf_1_1device__span.html" title="Device version of C++20 std::span with reduced feature set.">device_span</a></code> </p>
<dl class="section note"><dt>注解</dt><dd>This function does not synchronize <code>stream</code>.</dd></dl>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the data to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_data</td><td>The device data to copy </td></tr>
    <tr><td class="paramname">stream</td><td>The stream on which to perform the copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The data copied to the host </dd></dl>

<p class="definition">在文件 <a class="el" href="vector__factories_8hpp_source.html">vector_factories.hpp</a> 第 <a class="el" href="vector__factories_8hpp_source.html#l00387">387</a> 行定义.</p>

</div>
</div>
<a id="a19a07077e71fffd39a9bae1ef7bfa379" name="a19a07077e71fffd39a9bae1ef7bfa379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a07077e71fffd39a9bae1ef7bfa379">&#9670;&#160;</a></span>make_host_vector_sync() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , std::enable_if_t&lt; std::is_convertible_v&lt; Container, <a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; typename Container::value_type const &gt; &gt; &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">thrust::host_vector&lt; typename Container::value_type &gt; cudf::detail::make_host_vector_sync </td>
          <td>(</td>
          <td class="paramtype">Container const &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously construct a <code>std::vector</code> containing a copy of data from a device container </p>
<dl class="section note"><dt>注解</dt><dd>This function synchronizes <code>stream</code>.</dd></dl>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>The type of the container to copy from </td></tr>
    <tr><td class="paramname">T</td><td>The type of the data to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The input device container from which to copy </td></tr>
    <tr><td class="paramname">stream</td><td>The stream on which to perform the copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The data copied to the host </dd></dl>

<p class="definition">在文件 <a class="el" href="vector__factories_8hpp_source.html">vector_factories.hpp</a> 第 <a class="el" href="vector__factories_8hpp_source.html#l00449">449</a> 行定义.</p>

</div>
</div>
<a id="ac324b531a3240ff154b04007561c9f34" name="ac324b531a3240ff154b04007561c9f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac324b531a3240ff154b04007561c9f34">&#9670;&#160;</a></span>make_host_vector_sync() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">thrust::host_vector&lt; T &gt; cudf::detail::make_host_vector_sync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; T const &gt;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously construct a <code>std::vector</code> containing a copy of data from a <code><a class="el" href="structcudf_1_1device__span.html" title="Device version of C++20 std::span with reduced feature set.">device_span</a></code> </p>
<dl class="section note"><dt>注解</dt><dd>This function does a synchronize on <code>stream</code>.</dd></dl>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the data to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_data</td><td>The device data to copy </td></tr>
    <tr><td class="paramname">stream</td><td>The stream on which to perform the copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The data copied to the host </dd></dl>

<p class="definition">在文件 <a class="el" href="vector__factories_8hpp_source.html">vector_factories.hpp</a> 第 <a class="el" href="vector__factories_8hpp_source.html#l00426">426</a> 行定义.</p>

</div>
</div>
<a id="af13119be3a169f0210957725db3d144d" name="af13119be3a169f0210957725db3d144d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af13119be3a169f0210957725db3d144d">&#9670;&#160;</a></span>make_std_vector_async() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , std::enable_if_t&lt; std::is_convertible_v&lt; Container, <a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; typename Container::value_type const &gt; &gt; &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename Container::value_type &gt; cudf::detail::make_std_vector_async </td>
          <td>(</td>
          <td class="paramtype">Container const &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously construct a <code>std::vector</code> containing a copy of data from a device container </p>
<dl class="section note"><dt>注解</dt><dd>This function synchronizes <code>stream</code>.</dd></dl>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>The type of the container to copy from </td></tr>
    <tr><td class="paramname">T</td><td>The type of the data to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The input device container from which to copy </td></tr>
    <tr><td class="paramname">stream</td><td>The stream on which to perform the copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The data copied to the host </dd></dl>

<p class="definition">在文件 <a class="el" href="vector__factories_8hpp_source.html">vector_factories.hpp</a> 第 <a class="el" href="vector__factories_8hpp_source.html#l00328">328</a> 行定义.</p>

</div>
</div>
<a id="a0f86869461e901b87a711c8fb331c17a" name="a0f86869461e901b87a711c8fb331c17a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f86869461e901b87a711c8fb331c17a">&#9670;&#160;</a></span>make_std_vector_async() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; cudf::detail::make_std_vector_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; T const &gt;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously construct a <code>std::vector</code> containing a copy of data from a <code><a class="el" href="structcudf_1_1device__span.html" title="Device version of C++20 std::span with reduced feature set.">device_span</a></code> </p>
<dl class="section note"><dt>注解</dt><dd>This function does not synchronize <code>stream</code>.</dd></dl>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the data to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_data</td><td>The device data to copy </td></tr>
    <tr><td class="paramname">stream</td><td>The stream on which to perform the copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The data copied to the host </dd></dl>

<p class="definition">在文件 <a class="el" href="vector__factories_8hpp_source.html">vector_factories.hpp</a> 第 <a class="el" href="vector__factories_8hpp_source.html#l00307">307</a> 行定义.</p>

</div>
</div>
<a id="a76e49334977092cc1447d12b3aad3b76" name="a76e49334977092cc1447d12b3aad3b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76e49334977092cc1447d12b3aad3b76">&#9670;&#160;</a></span>make_std_vector_sync() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , std::enable_if_t&lt; std::is_convertible_v&lt; Container, <a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; typename Container::value_type const &gt; &gt; &gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename Container::value_type &gt; cudf::detail::make_std_vector_sync </td>
          <td>(</td>
          <td class="paramtype">Container const &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously construct a <code>std::vector</code> containing a copy of data from a device container </p>
<dl class="section note"><dt>注解</dt><dd>This function synchronizes <code>stream</code>.</dd></dl>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>The type of the container to copy from </td></tr>
    <tr><td class="paramname">T</td><td>The type of the data to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The input device container from which to copy </td></tr>
    <tr><td class="paramname">stream</td><td>The stream on which to perform the copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The data copied to the host </dd></dl>

<p class="definition">在文件 <a class="el" href="vector__factories_8hpp_source.html">vector_factories.hpp</a> 第 <a class="el" href="vector__factories_8hpp_source.html#l00369">369</a> 行定义.</p>

</div>
</div>
<a id="aea3ae2fa6ca2edd73742c6e0ffcb8d49" name="aea3ae2fa6ca2edd73742c6e0ffcb8d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea3ae2fa6ca2edd73742c6e0ffcb8d49">&#9670;&#160;</a></span>make_std_vector_sync() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; cudf::detail::make_std_vector_sync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; T const &gt;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously construct a <code>std::vector</code> containing a copy of data from a <code><a class="el" href="structcudf_1_1device__span.html" title="Device version of C++20 std::span with reduced feature set.">device_span</a></code> </p>
<dl class="section note"><dt>注解</dt><dd>This function does a synchronize on <code>stream</code>.</dd></dl>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the data to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_data</td><td>The device data to copy </td></tr>
    <tr><td class="paramname">stream</td><td>The stream on which to perform the copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The data copied to the host </dd></dl>

<p class="definition">在文件 <a class="el" href="vector__factories_8hpp_source.html">vector_factories.hpp</a> 第 <a class="el" href="vector__factories_8hpp_source.html#l00346">346</a> 行定义.</p>

</div>
</div>
<a id="a0b73da63a9fe3fdc5f94d0095cb43c83" name="a0b73da63a9fe3fdc5f94d0095cb43c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b73da63a9fe3fdc5f94d0095cb43c83">&#9670;&#160;</a></span>make_vector_async()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename OutContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutContainer cudf::detail::make_vector_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; T const &gt;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">在文件 <a class="el" href="vector__factories_8hpp_source.html">vector_factories.hpp</a> 第 <a class="el" href="vector__factories_8hpp_source.html#l00287">287</a> 行定义.</p>

</div>
</div>
<a id="ab330bdc16d921431c949ade216386305" name="ab330bdc16d921431c949ade216386305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab330bdc16d921431c949ade216386305">&#9670;&#160;</a></span>make_zeroed_device_uvector_async()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">rmm::device_uvector&lt; T &gt; cudf::detail::make_zeroed_device_uvector_async </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously construct a <code>device_uvector</code> and set all elements to zero. </p>
<dl class="section note"><dt>注解</dt><dd>This function does not synchronize <code>stream</code>.</dd></dl>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the data to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The number of elements in the created vector </td></tr>
    <tr><td class="paramname">stream</td><td>The stream on which to allocate memory and perform the memset </td></tr>
    <tr><td class="paramname">mr</td><td>The memory resource to use for allocating the returned device_uvector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A device_uvector containing zeros </dd></dl>

<p class="definition">在文件 <a class="el" href="vector__factories_8hpp_source.html">vector_factories.hpp</a> 第 <a class="el" href="vector__factories_8hpp_source.html#l00051">51</a> 行定义.</p>

</div>
</div>
<a id="a1cbce3bdea9ae93c27fedd21b4177e4f" name="a1cbce3bdea9ae93c27fedd21b4177e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cbce3bdea9ae93c27fedd21b4177e4f">&#9670;&#160;</a></span>make_zeroed_device_uvector_sync()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">rmm::device_uvector&lt; T &gt; cudf::detail::make_zeroed_device_uvector_sync </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously construct a <code>device_uvector</code> and set all elements to zero. </p>
<dl class="section note"><dt>注解</dt><dd>This function synchronizes <code>stream</code>.</dd></dl>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the data to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The number of elements in the created vector </td></tr>
    <tr><td class="paramname">stream</td><td>The stream on which to allocate memory and perform the memset </td></tr>
    <tr><td class="paramname">mr</td><td>The memory resource to use for allocating the returned device_uvector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A device_uvector containing zeros </dd></dl>

<p class="definition">在文件 <a class="el" href="vector__factories_8hpp_source.html">vector_factories.hpp</a> 第 <a class="el" href="vector__factories_8hpp_source.html#l00073">73</a> 行定义.</p>

</div>
</div>
<a id="adcca95b53757f3fc776e4a53c762e318" name="adcca95b53757f3fc776e4a53c762e318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcca95b53757f3fc776e4a53c762e318">&#9670;&#160;</a></span>mask_to_bools()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::mask_to_bools </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> const *&#160;</td>
          <td class="paramname"><em>null_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>begin_bit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>end_bit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a boolean column from given bitmask.   </p>
<p>Returns a <code>bool</code> for each bit in <code>[begin_bit, end_bit)</code>. If bit <code>i</code> in least-significant bit numbering is set (1), then element <code>i</code> in the output is <code>true</code>, otherwise <code>false</code>.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>bitmask</code> is null and end_bit-begin_bit &gt; 0 </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if begin_bit &gt; end_bit</td></tr>
  </table>
  </dd>
</dl>
<p>Examples: </p><div class="fragment"><div class="line">input: {0b10101010}</div>
<div class="line">output: [{false, true, false, true, false, true, false, true}]</div>
</div><!-- fragment --><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmask</td><td>A device pointer to the bitmask which needs to be converted </td></tr>
    <tr><td class="paramname">begin_bit</td><td>position of the bit from which the conversion should start </td></tr>
    <tr><td class="paramname">end_bit</td><td>position of the bit before which the conversion should stop </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned columns' device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A boolean column representing the given mask from [begin_bit, end_bit)  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d9d7614373d0ef4f4538d1920c6d732" name="a0d9d7614373d0ef4f4538d1920c6d732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d9d7614373d0ef4f4538d1920c6d732">&#9670;&#160;</a></span>may_have_nonempty_nulls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cudf::detail::may_have_nonempty_nulls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Approximates if a column or its descendants <em>may</em> have non-empty null elements   </p>
<dl class="section note"><dt>注解</dt><dd>This function is approximate.<ul>
<li><code>true</code>: Non-empty null elements could exist</li>
<li><code>false</code>: Non-empty null elements definitely do not exist</li>
</ul>
</dd></dl>
<p>False positives are possible, but false negatives are not.</p>
<p>Compared to the exact <code><a class="el" href="namespacecudf_1_1detail.html#a5758db52c9f99ddaab9a9de11fd25f4d" title="Checks if a column or its descendants have non-empty null rows">has_nonempty_nulls()</a></code> function, this function is typically more efficient.</p>
<p>Complexity:</p><ul>
<li>Best case: <code>O(count_descendants(input))</code></li>
<li>Worst case: <code>O(count_descendants(input)) * m</code>, where <code>m</code> is the number of rows in the largest descendant</li>
</ul>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The column which is (and whose descendants are) to be checked for non-empty null rows </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>true If either the column or its descendants have null rows </dd>
<dd>
false If neither the column nor its descendants have null rows  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="affdf27f8bc86ce410050f009d8b9d894" name="affdf27f8bc86ce410050f009d8b9d894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affdf27f8bc86ce410050f009d8b9d894">&#9670;&#160;</a></span>md5_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::md5_hash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a349e2b28175e2d9ea71d7761fd9b03ce" name="a349e2b28175e2d9ea71d7761fd9b03ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a349e2b28175e2d9ea71d7761fd9b03ce">&#9670;&#160;</a></span>murmur_hash3_32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::murmur_hash3_32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code><a class="el" href="group__column__hash.html#ga68de1d04aa2c0ea2eeacfc73fd99a915">cudf::DEFAULT_HASH_SEED</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb7e1bd82e43f366a0455d2c606ff212" name="abb7e1bd82e43f366a0455d2c606ff212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb7e1bd82e43f366a0455d2c606ff212">&#9670;&#160;</a></span>nans_to_nulls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::unique_ptr&lt; rmm::device_buffer &gt;, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; cudf::detail::nans_to_nulls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a null_mask from <code>input</code> by converting <code>NaN</code> to null and preserving existing null values and also returns new null_count.   </p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>input.type()</code> is a non-floating type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>An immutable view of the input column of floating-point type </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned bitmask </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A pair containing a <code>device_buffer</code> with the new bitmask and it's null count obtained by replacing <code>NaN</code> in <code>input</code> with null.  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a841c17146b279d123c4d579ddd7e7f14" name="a841c17146b279d123c4d579ddd7e7f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a841c17146b279d123c4d579ddd7e7f14">&#9670;&#160;</a></span>normalize_nans_and_zeros()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::normalize_nans_and_zeros </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies from a column of floating-point elements and replaces <code>-NaN</code> and <code>-0.0</code> with <code>+NaN</code> and <code>+0.0</code>, respectively.   </p>
<p>Converts floating point values from <code>input</code> using the following rules: Convert -NaN -&gt; NaN Convert -0.0 -&gt; 0.0</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if column does not have floating point data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> of floating-point elements to copy and normalize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>device_memory_resource allocator for allocating output data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>new column with the modified data  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a289827dc5428527e139352669318e55f" name="a289827dc5428527e139352669318e55f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a289827dc5428527e139352669318e55f">&#9670;&#160;</a></span>null_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a> cudf::detail::null_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> const *&#160;</td>
          <td class="paramname"><em>bitmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>stop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a validity bitmask, counts the number of null elements (unset bits) in the range <code>[start, stop)</code>. </p>
<p>If <code>bitmask == nullptr</code>, all elements are assumed to be valid and the function returns ``.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>start &gt; stop</code> </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>start &lt; 0</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitmask</td><td>Validity bitmask residing in device memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>Index of the first bit to count (inclusive). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stop</td><td>Index of the last bit to count (exclusive). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The number of null elements in the specified range. </dd></dl>

</div>
</div>
<a id="ad30bc52a8dbe05164e2d5fc0b49e1844" name="ad30bc52a8dbe05164e2d5fc0b49e1844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad30bc52a8dbe05164e2d5fc0b49e1844">&#9670;&#160;</a></span>one_hot_encode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;, <a class="el" href="classcudf_1_1table__view.html">table_view</a> &gt; cudf::detail::one_hot_encode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>categories</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes <code>input</code> by generating a new column for each value in <code>categories</code> indicating the presence of that value in <code>input</code>.   </p>
<p>The resulting per-category columns are returned concatenated as a single column viewed by a <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code>.</p>
<p>The <code>i</code>th row of the <code>j</code>th column in the output table equals 1 if <code>input[i] == categories[j]</code>, and 0 otherwise.</p>
<p>The <code>i</code>th row of the <code>j</code>th column in the output table equals 1 if input[i] == categories[j], and 0 otherwise.</p>
<p>Examples: </p><div class="fragment"><div class="line">input: [{&#39;a&#39;, &#39;c&#39;, null, &#39;c&#39;, &#39;b&#39;}]</div>
<div class="line">categories: [&#39;c&#39;, null]</div>
<div class="line">output: [{0, 1, 0, 1, 0}, {0, 0, 1, 0, 0}]</div>
</div><!-- fragment --><dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if input and categories are of different types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Column containing values to be encoded </td></tr>
    <tr><td class="paramname">categories</td><td>Column containing categories </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned table's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A pair containing the owner to all encoded data and a table view into the data  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8fcbfc5ff5585cc426e609ab8da1720" name="ab8fcbfc5ff5585cc426e609ab8da1720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8fcbfc5ff5585cc426e609ab8da1720">&#9670;&#160;</a></span>pack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1packed__columns.html">packed_columns</a> cudf::detail::pack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deep-copy a <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> into a serialized contiguous memory format   </p>
<p>The metadata from the <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> is copied into a host vector of bytes and the data from the <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> is copied into a <code>device_buffer</code>. Pass the output of this function into <code><a class="el" href="group__column__copy.html#ga1d62a18c2e6f087a92289c63693762cc" title="Deserialize the result of cudf::pack">cudf::unpack</a></code> to deserialize.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">input</td><td>View of the table to pack </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Optional, The resource to use for all returned device allocations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><a class="el" href="structcudf_1_1packed__columns.html" title="Column data in a serialized format">packed_columns</a> A struct containing the serialized metadata and data in contiguous host and device memory respectively  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Optional CUDA stream on which to execute kernels </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a698c778a6399397c6013e7d45c835b4c" name="a698c778a6399397c6013e7d45c835b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a698c778a6399397c6013e7d45c835b4c">&#9670;&#160;</a></span>percentile_approx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::percentile_approx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1tdigest_1_1tdigest__column__view.html">tdigest::tdigest_column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>percentiles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aacc2fd111114777e8e4e26c3295ca04b" name="aacc2fd111114777e8e4e26c3295ca04b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc2fd111114777e8e4e26c3295ca04b">&#9670;&#160;</a></span>purge_nonempty_nulls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::purge_nonempty_nulls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy <code>input</code> into output while purging any non-empty null rows in the column or its descendants.   </p>
<p>If the input column is not of compound type (LIST/STRING/STRUCT/DICTIONARY), the output will be the same as input.</p>
<p>The purge operation only applies directly to LIST and STRING columns, but it applies indirectly to STRUCT/DICTIONARY columns as well, since these columns may have child columns that are LIST or STRING.</p>
<p>Examples:</p>
<div class="fragment"><div class="line">auto const lists   = lists_column_wrapper&lt;int32_t&gt;{ {0,1}, {2,3}, {4,5} }.release();</div>
<div class="line">cudf::detail::set_null_mask(lists-&gt;null_mask(), 1, 2, false);</div>
<div class="line"> </div>
<div class="line">lists[1] is now null, but the lists child column still stores `{2,3}`.</div>
<div class="line">The lists column contents will be:</div>
<div class="line">  Validity: 101</div>
<div class="line">  Offsets:  [0, 2, 4, 6]</div>
<div class="line">  Child:    [0, 1, 2, 3, 4, 5]</div>
<div class="line"> </div>
<div class="line">After purging the contents of the list&#39;s null rows, the column&#39;s contents will be:</div>
<div class="line">  Validity: 101</div>
<div class="line">  Offsets:  [0, 2, 2, 4]</div>
<div class="line">  Child:    [0, 1, 4, 5]</div>
</div><!-- fragment --><div class="fragment"><div class="line">auto const strings = strings_column_wrapper{ &quot;AB&quot;, &quot;CD&quot;, &quot;EF&quot; }.release();</div>
<div class="line">cudf::detail::set_null_mask(strings-&gt;null_mask(), 1, 2, false);</div>
<div class="line"> </div>
<div class="line">strings[1] is now null, but the strings column still stores `&quot;CD&quot;`.</div>
<div class="line">The lists column contents will be:</div>
<div class="line">  Validity: 101</div>
<div class="line">  Offsets:  [0, 2, 4, 6]</div>
<div class="line">  Child:    [A, B, C, D, E, F]</div>
<div class="line"> </div>
<div class="line">After purging the contents of the list&#39;s null rows, the column&#39;s contents</div>
<div class="line">will be:</div>
<div class="line">  Validity: 101</div>
<div class="line">  Offsets:  [0, 2, 2, 4]</div>
<div class="line">  Child:    [A, B, E, F]</div>
</div><!-- fragment --><div class="fragment"><div class="line">auto const lists   = lists_column_wrapper&lt;int32_t&gt;{ {0,1}, {2,3}, {4,5} };</div>
<div class="line">auto const structs = structs_column_wrapper{ {lists}, null_at(1) };</div>
<div class="line"> </div>
<div class="line">structs[1].child is now null, but the lists column still stores `{2,3}`.</div>
<div class="line">The lists column contents will be:</div>
<div class="line">  Validity: 101</div>
<div class="line">  Offsets:  [0, 2, 4, 6]</div>
<div class="line">  Child:    [0, 1, 2, 3, 4, 5]</div>
<div class="line"> </div>
<div class="line">After purging the contents of the list&#39;s null rows, the column&#39;s contents</div>
<div class="line">will be:</div>
<div class="line">  Validity: 101</div>
<div class="line">  Offsets:  [0, 2, 2, 4]</div>
<div class="line">  Child:    [0, 1, 4, 5]</div>
</div><!-- fragment --><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The column whose null rows are to be checked and purged </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A new column with equivalent contents to <code>input</code>, but with null rows purged  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f9e3cf937df8cb28860d3fc8e9843d7" name="a3f9e3cf937df8cb28860d3fc8e9843d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9e3cf937df8cb28860d3fc8e9843d7">&#9670;&#160;</a></span>quantile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::quantile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga9cd17c1cdf028ead9a4783f605276ab3">interpolation</a>&#160;</td>
          <td class="paramname"><em>interp</em> = <code><a class="el" href="group__utility__types.html#gga9cd17c1cdf028ead9a4783f605276ab3aaac544aacc3615aada24897a215f5046">interpolation::LINEAR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>ordered_indices</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exact</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes quantiles with interpolation.   </p>
<p>Computes the specified quantiles by interpolating values between which they lie, using the interpolation strategy specified in <code>interp</code>.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Column from which to compute quantile values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>Specified quantiles in range [0, 1] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interp</td><td>Strategy used to select between values adjacent to a specified quantile. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ordered_indices</td><td>Column containing the sorted order of <code>input</code>. If the column is empty, all <code>input</code> values are used in existing order. Indices must be in range [0, <code>input.size()</code>), but are not required to be unique. Values not indexed by this column will be ignored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exact</td><td>If true, returns doubles. If false, returns same type as input. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Column of specified quantiles, with nulls for indeterminable values  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9db69c255a5f64c2b3f9e4bc7e73caa9" name="a9db69c255a5f64c2b3f9e4bc7e73caa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db69c255a5f64c2b3f9e4bc7e73caa9">&#9670;&#160;</a></span>quantiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt; cudf::detail::quantiles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga9cd17c1cdf028ead9a4783f605276ab3">interpolation</a>&#160;</td>
          <td class="paramname"><em>interp</em> = <code><a class="el" href="group__utility__types.html#gga9cd17c1cdf028ead9a4783f605276ab3aad135772d7cf93dd0ccf9d2474b34e6a">interpolation::NEAREST</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#gab283c517931abd4152ffa62fec62425d">cudf::sorted</a>&#160;</td>
          <td class="paramname"><em>is_input_sorted</em> = <code><a class="el" href="group__utility__types.html#ggab283c517931abd4152ffa62fec62425dac2f3f489a00553e7a01d369c103c7251">sorted::NO</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>column_order</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>null_precedence</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the rows of the input corresponding to the requested quantiles.   </p>
<p>Quantiles are cut points that divide the range of a dataset into continuous intervals. e.g: quartiles are the three cut points that divide a dataset into four equal-sized groups. See <a href="https://en.wikipedia.org/wiki/Quantile">https://en.wikipedia.org/wiki/Quantile</a></p>
<p>The indices used to gather rows are computed by interpolating between the index on either side of the desired quantile. Since some columns may be non-arithmetic, interpolation between rows is limited to non-arithmetic strategies.</p>
<p>Non-arithmetic interpolation strategies include HIGHER, LOWER, and NEAREST.</p>
<p>quantiles <code>&lt;= 0</code> correspond to row <code>0</code>. (first) quantiles <code>&gt;= 1</code> correspond to row <code>input.size() - 1</code>. (last)</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Table used to compute quantile rows </td></tr>
    <tr><td class="paramname">q</td><td>Desired quantiles in range [0, 1] </td></tr>
    <tr><td class="paramname">interp</td><td>Strategy used to select between the two rows on either side of the desired quantile. </td></tr>
    <tr><td class="paramname">is_input_sorted</td><td>Indicates if the input has been pre-sorted </td></tr>
    <tr><td class="paramname">column_order</td><td>The desired sort order for each column </td></tr>
    <tr><td class="paramname">null_precedence</td><td>The desired order of null compared to other elements </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned table's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Table of specified quantiles, with nulls for indeterminable values </dd></dl>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>interp</code> is an arithmetic interpolation strategy </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>input</code> is empty  </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47a307e124575b78186601f1c689c05c" name="a47a307e124575b78186601f1c689c05c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47a307e124575b78186601f1c689c05c">&#9670;&#160;</a></span>repeat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt; cudf::detail::repeat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75705d38197681267f667733ef0c1be4" name="a75705d38197681267f667733ef0c1be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75705d38197681267f667733ef0c1be4">&#9670;&#160;</a></span>repeat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt; cudf::detail::repeat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Repeat rows of a Table.   </p>
<p>Creates a new table by repeating <code>count</code> times the rows of <code>input_table</code>. Example: </p><div class="fragment"><div class="line">in = [4,5,6]</div>
<div class="line">count = 2</div>
<div class="line"><span class="keywordflow">return</span> = [4,4,5,5,6,6]</div>
</div><!-- fragment --> <dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if the data type of <code>count</code> is not size_type. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>count</code> is invalid or <code>count</code> is negative. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>input_table.num_rows()</code> * <code>count</code> overflows size_type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_table</td><td>Input table </td></tr>
    <tr><td class="paramname">count</td><td>Number of repetitions </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned table's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The result table containing the repetitions  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade00a5854797478de85ef4f4735be57d" name="ade00a5854797478de85ef4f4735be57d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade00a5854797478de85ef4f4735be57d">&#9670;&#160;</a></span>replace_nans() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::replace_nans </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all NaN values in a column with corresponding values from another column   </p>
<p>If <code>input[i]</code> is NaN, then <code>output[i]</code> will contain <code>replacement[i]</code>. </p><div class="fragment"><div class="line">input        = {1.0, NaN, 4.0}</div>
<div class="line">replacement  = {3.0, 9.0, 7.0}</div>
<div class="line">output       = {1.0, 9.0, 4.0}</div>
</div><!-- fragment --><dl class="section note"><dt>注解</dt><dd>Nulls are not considered as NaN</dd></dl>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>If <code>input</code> and <code>replacement</code> are of different type or size. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>If <code>input</code> or <code>replacement</code> are not of floating-point dtype.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>A column whose NaN values will be replaced </td></tr>
    <tr><td class="paramname">replacement</td><td>A <a class="el" href="classcudf_1_1column.html" title="A container of nullable device data as a column of elements.">cudf::column</a> whose values will replace NaN values in input </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A copy of <code>input</code> with the NaN values replaced with corresponding values from <code>replacement</code>.  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0298a6133c943e5ef6107630fd267f1" name="ad0298a6133c943e5ef6107630fd267f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0298a6133c943e5ef6107630fd267f1">&#9670;&#160;</a></span>replace_nans() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::replace_nans </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all NaN values in a column with a scalar   </p>
<p>If <code>input[i]</code> is NaN, then <code>output[i]</code> will contain <code>replacement</code>. </p><div class="fragment"><div class="line">input        = {1.0, NaN, 4.0}</div>
<div class="line">replacement  = 7.0</div>
<div class="line">output       = {1.0, 7.0, 4.0}</div>
</div><!-- fragment --><dl class="section note"><dt>注解</dt><dd>Nulls are not considered as NaN</dd></dl>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>If <code>input</code> and <code>replacement</code> are of different type. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>If <code>input</code> or <code>replacement</code> are not of floating-point dtype.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>A column whose NaN values will be replaced </td></tr>
    <tr><td class="paramname">replacement</td><td>A <a class="el" href="classcudf_1_1scalar.html" title="An owning class to represent a singular value.">cudf::scalar</a> whose value will replace NaN values in input </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A copy of <code>input</code> with the NaN values replaced by <code>replacement</code>  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2782e7c057de7e1596841c366b471b3" name="aa2782e7c057de7e1596841c366b471b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2782e7c057de7e1596841c366b471b3">&#9670;&#160;</a></span>replace_nulls() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::replace_nulls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all null values in a column with corresponding values of another column   </p>
<p>If <code>input[i]</code> is NULL, then <code>output[i]</code> will contain <code>replacement[i]</code>. <code>input</code> and <code>replacement</code> must be of the same type and size.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>A column whose null values will be replaced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replacement</td><td>A <a class="el" href="classcudf_1_1column.html" title="A container of nullable device data as a column of elements.">cudf::column</a> whose values will replace null values in input </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate device memory of the returned column</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A copy of <code>input</code> with the null values replaced with corresponding values from <code>replacement</code>.  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c0b4a9cf791df1c239576b67b2d9255" name="a9c0b4a9cf791df1c239576b67b2d9255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c0b4a9cf791df1c239576b67b2d9255">&#9670;&#160;</a></span>replace_nulls() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::replace_nulls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__transformation__replace.html#ga7cdbc9bc3671930a743c86f36c38abf9">replace_policy</a> const &amp;&#160;</td>
          <td class="paramname"><em>replace_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all null values in a column with the first non-null value that precedes/follows.   </p>
<p>If <code>input[i]</code> is NULL, then <code>output[i]</code> will contain the first non-null value that precedes or follows the null value, based on <code>replace_policy</code>.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>A column whose null values will be replaced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replace_policy</td><td>Specify the position of replacement values relative to null values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate device memory of the returned column</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Copy of <code>input</code> with null values replaced based on <code>replace_policy</code>  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a089e06d35c8fc924a836da9e7fcce84e" name="a089e06d35c8fc924a836da9e7fcce84e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a089e06d35c8fc924a836da9e7fcce84e">&#9670;&#160;</a></span>replace_nulls() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::replace_nulls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all null values in a column with a scalar.   </p>
<p>If <code>input[i]</code> is NULL, then <code>output[i]</code> will contain <code>replacement</code>. <code>input</code> and <code>replacement</code> must have the same type.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>A column whose null values will be replaced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replacement</td><td>Scalar used to replace null values in <code>input</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate device memory of the returned column</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Copy of <code>input</code> with null values replaced by <code>replacement</code>  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a10e1b8f89952c1c18a574a822fa8c189" name="a10e1b8f89952c1c18a574a822fa8c189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10e1b8f89952c1c18a574a822fa8c189">&#9670;&#160;</a></span>rolling_window()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::rolling_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>preceding_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>following_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>min_periods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;&#160;</td>
          <td class="paramname"><em>agg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="group__aggregation__rolling.html#gaaed6574615700cec1d4bf5469fe28141" title="Applies a variable-size rolling window function to the values in a column.">rolling_window(           column_view const&amp; input,           column_view const&amp; preceding_window,           column_view const&amp; following_window,           size_type min_periods,           rolling_aggregation const&amp; agg,           rmm::mr::device_memory_resource* mr)</a> </p>
<p><a class="el" href="group__aggregation__rolling.html#gaaed6574615700cec1d4bf5469fe28141" title="Applies a variable-size rolling window function to the values in a column.">rolling_window(           column_view const&amp; input,           column_view const&amp; preceding_window,           column_view const&amp; following_window,           size_type min_periods,           rolling_aggregation const&amp; agg,           rmm::mr::device_memory_resource* mr)</a></p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8131d320d1ae7d8daea58311bc10ffeb" name="a8131d320d1ae7d8daea58311bc10ffeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8131d320d1ae7d8daea58311bc10ffeb">&#9670;&#160;</a></span>round()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::round </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>decimal_places</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__transformation__unaryops.html#ga02028fc18312cdb2f07159c6297e74bb">rounding_method</a>&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rounds all the values in a column to the specified number of decimal places.   </p>
<p><code><a class="el" href="group__transformation__unaryops.html#gaaf541a42981e9f31a32de8fdaa105d4b" title="Rounds all the values in a column to the specified number of decimal places.">cudf::round</a></code> currently supports HALF_UP and HALF_EVEN rounding for integer, floating point and <code>decimal32</code> and <code>decimal64</code> numbers. For <code>decimal32</code> and <code>decimal64</code> numbers, negated <code>numeric::scale</code> is equivalent to <code>decimal_places</code>.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacecudf.html">cudf</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classcudf_1_1column__view.html">column_view</a> a; <span class="comment">// contains { 1.729, 17.29, 172.9, 1729 };</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> result1 = <a class="code hl_function" href="namespacecudf_1_1detail.html#a8131d320d1ae7d8daea58311bc10ffeb">round</a>(a);     <span class="comment">// { 2,   17,   173,   1729 }</span></div>
<div class="line"><span class="keyword">auto</span> result2 = <a class="code hl_function" href="namespacecudf_1_1detail.html#a8131d320d1ae7d8daea58311bc10ffeb">round</a>(a, 1);  <span class="comment">// { 1.7, 17.3, 172.9, 1729 }</span></div>
<div class="line"><span class="keyword">auto</span> result3 = <a class="code hl_function" href="namespacecudf_1_1detail.html#a8131d320d1ae7d8daea58311bc10ffeb">round</a>(a, -1); <span class="comment">// { 0,   20,   170,   1730 }</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classcudf_1_1column__view.html">column_view</a> b; <span class="comment">// contains { 1.5, 2.5, 1.35, 1.45, 15, 25 };</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> result4 = <a class="code hl_function" href="namespacecudf_1_1detail.html#a8131d320d1ae7d8daea58311bc10ffeb">round</a>(b,  0, <a class="code hl_enumvalue" href="group__transformation__unaryops.html#gga02028fc18312cdb2f07159c6297e74bba29746b187c41c8e51b96a3104cbda3b6">rounding_method::HALF_EVEN</a>); <span class="comment">// { 2,   2,   1,   1,   15, 25};</span></div>
<div class="line"><span class="keyword">auto</span> result5 = <a class="code hl_function" href="namespacecudf_1_1detail.html#a8131d320d1ae7d8daea58311bc10ffeb">round</a>(b,  1, <a class="code hl_enumvalue" href="group__transformation__unaryops.html#gga02028fc18312cdb2f07159c6297e74bba29746b187c41c8e51b96a3104cbda3b6">rounding_method::HALF_EVEN</a>); <span class="comment">// { 1.5, 2.5, 1.4, 1.4, 15, 25};</span></div>
<div class="line"><span class="keyword">auto</span> result6 = <a class="code hl_function" href="namespacecudf_1_1detail.html#a8131d320d1ae7d8daea58311bc10ffeb">round</a>(b, -1, <a class="code hl_enumvalue" href="group__transformation__unaryops.html#gga02028fc18312cdb2f07159c6297e74bba29746b187c41c8e51b96a3104cbda3b6">rounding_method::HALF_EVEN</a>); <span class="comment">// { 0,   0,   0,   0,   20, 20};</span></div>
<div class="ttc" id="agroup__transformation__unaryops_html_gga02028fc18312cdb2f07159c6297e74bba29746b187c41c8e51b96a3104cbda3b6"><div class="ttname"><a href="group__transformation__unaryops.html#gga02028fc18312cdb2f07159c6297e74bba29746b187c41c8e51b96a3104cbda3b6">cudf::rounding_method::HALF_EVEN</a></div><div class="ttdeci">@ HALF_EVEN</div></div>
<div class="ttc" id="anamespacecudf_1_1detail_html_a8131d320d1ae7d8daea58311bc10ffeb"><div class="ttname"><a href="namespacecudf_1_1detail.html#a8131d320d1ae7d8daea58311bc10ffeb">cudf::detail::round</a></div><div class="ttdeci">std::unique_ptr&lt; column &gt; round(column_view const &amp;input, int32_t decimal_places, rounding_method method, rmm::cuda_stream_view stream, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</div><div class="ttdoc">Rounds all the values in a column to the specified number of decimal places.</div></div>
<div class="ttc" id="anamespacecudf_html"><div class="ttname"><a href="namespacecudf.html">cudf</a></div><div class="ttdoc">cuDF interfaces</div><div class="ttdef"><b>Definition</b> <a href="aggregation_8hpp_source.html#l00034">aggregation.hpp:34</a></div></div>
</div><!-- fragment --><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Column of values to be rounded </td></tr>
    <tr><td class="paramname">decimal_places</td><td>Number of decimal places to round to (default 0). If negative, this specifies the number of positions to the left of the decimal point. </td></tr>
    <tr><td class="paramname">method</td><td>Rounding method </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>std::unique_ptr&lt;column&gt; Column with each of the values rounded  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f65c99023599795be67aafb3c125b88" name="a6f65c99023599795be67aafb3c125b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f65c99023599795be67aafb3c125b88">&#9670;&#160;</a></span>row_bit_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::row_bit_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an approximate cumulative size in bits of all columns in the <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> for each row.   </p>
<p>This function counts bits instead of bytes to account for the null mask which only has one bit per row.</p>
<p>Each row in the returned column is the sum of the per-row size for each column in the table.</p>
<p>In some cases, this is an inexact approximation. Specifically, columns of lists and strings require N+1 offsets to represent N rows. It is up to the caller to calculate the small additional overhead of the terminating offset for any group of rows being considered.</p>
<p>This function returns the per-row sizes as the columns are currently formed. This can end up being larger than the number you would get by gathering the rows. Specifically, the push-down of struct column validity masks can nullify rows that contain data for string or list columns. In these cases, the size returned is conservative:</p>
<p>row_bit_count(column(x)) &gt;= row_bit_count(gather(column(x)))</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table view to perform the computation on </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned columns' device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A 32-bit integer column containing the per-row bit counts  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a082f6c019d5d3462414e341e949c02" name="a4a082f6c019d5d3462414e341e949c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a082f6c019d5d3462414e341e949c02">&#9670;&#160;</a></span>sample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt; cudf::detail::sample </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__column__copy.html#gae7607cde56cb602ab1b198b5bebf7cba">sample_with_replacement</a>&#160;</td>
          <td class="paramname"><em>replacement</em> = <code><a class="el" href="group__column__copy.html#ggae7607cde56cb602ab1b198b5bebf7cbaa946003f97ccc52d5d3b54ac0ec31bbfc">sample_with_replacement::FALSE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t const&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gather <code>n</code> samples from given <code>input</code> randomly   </p>
<div class="fragment"><div class="line">Example:</div>
<div class="line">input: {col1: {1, 2, 3, 4, 5}, col2: {6, 7, 8, 9, 10}}</div>
<div class="line">n: 3</div>
<div class="line">replacement: false</div>
<div class="line"> </div>
<div class="line">output:       {col1: {3, 1, 4}, col2: {8, 6, 9}}</div>
<div class="line"> </div>
<div class="line">replacement: true</div>
<div class="line"> </div>
<div class="line">output:       {col1: {3, 1, 1}, col2: {8, 6, 6}}</div>
</div><!-- fragment --><dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>n</code> &gt; <code>input.num_rows()</code> and <code>replacement</code> == FALSE. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>n</code> &lt; 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>View of a table to sample </td></tr>
    <tr><td class="paramname">n</td><td>non-negative number of samples expected from <code>input</code> </td></tr>
    <tr><td class="paramname">replacement</td><td>Allow or disallow sampling of the same row more than once </td></tr>
    <tr><td class="paramname">seed</td><td>Seed value to initiate random number generator </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned table's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>std::unique_ptr&lt;table&gt; Table containing samples from <code>input</code>  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9be538c2fe0b9e74c569460ecc65261" name="ac9be538c2fe0b9e74c569460ecc65261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9be538c2fe0b9e74c569460ecc65261">&#9670;&#160;</a></span>scan_exclusive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::scan_exclusive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scan__aggregation.html">scan_aggregation</a> const &amp;&#160;</td>
          <td class="paramname"><em>agg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a>&#160;</td>
          <td class="paramname"><em>null_handling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the exclusive scan of a column. </p>
<p>The null values are skipped for the operation, and if an input element at <code>i</code> is null, then the output element at <code>i</code> will also be null.</p>
<p>The identity value for the column type as per the aggregation type is used for the value of the first element in the output column.</p>
<p>Struct columns are allowed with aggregation types Min and Max.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if column <a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a> is not an arithmetic type or struct type but the <code>agg</code> is not Min or Max.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input column view for the scan. </td></tr>
    <tr><td class="paramname">agg</td><td>Aggregation operator applied by the scan </td></tr>
    <tr><td class="paramname">null_handling</td><td>Exclude null values when computing the result if <a class="el" href="group__utility__types.html#gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8" title="exclude null elements">null_policy::EXCLUDE</a>. Include nulls if <a class="el" href="group__utility__types.html#gga1b8cda4afb95a7c42c4679b4fae61009a04ff6a9583ba9957ebe1128d0f988ad8" title="include null elements">null_policy::INCLUDE</a>. Any operation with a null results in a null. </td></tr>
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned scalar's device memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Column with scan results. </dd></dl>

</div>
</div>
<a id="adc391e283f48ecd780dec6ceb2d0a6f9" name="adc391e283f48ecd780dec6ceb2d0a6f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc391e283f48ecd780dec6ceb2d0a6f9">&#9670;&#160;</a></span>scan_inclusive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::scan_inclusive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scan__aggregation.html">scan_aggregation</a> const &amp;&#160;</td>
          <td class="paramname"><em>agg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a>&#160;</td>
          <td class="paramname"><em>null_handling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the inclusive scan of a column. </p>
<p>The null values are skipped for the operation, and if an input element at <code>i</code> is null, then the output element at <code>i</code> will also be null.</p>
<p>String and struct columns are allowed with aggregation types Min and Max.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if column <a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a> is not an arithmetic type or string/struct types but the <code>agg</code> is not Min or Max.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input column view for the scan. </td></tr>
    <tr><td class="paramname">agg</td><td>Aggregation operator applied by the scan </td></tr>
    <tr><td class="paramname">null_handling</td><td>Exclude null values when computing the result if <a class="el" href="group__utility__types.html#gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8" title="exclude null elements">null_policy::EXCLUDE</a>. Include nulls if <a class="el" href="group__utility__types.html#gga1b8cda4afb95a7c42c4679b4fae61009a04ff6a9583ba9957ebe1128d0f988ad8" title="include null elements">null_policy::INCLUDE</a>. Any operation with a null results in a null. </td></tr>
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned scalar's device memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Column with scan results. </dd></dl>

</div>
</div>
<a id="a5bdf86f00fd97bb400afe50fe644af52" name="a5bdf86f00fd97bb400afe50fe644af52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bdf86f00fd97bb400afe50fe644af52">&#9670;&#160;</a></span>scatter() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt; cudf::detail::scatter </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scatters a row of scalar values into a copy of the target table according to a scatter map. </p>
<p>Scatters values from the source row into the target table out-of-place, returning a "destination table". The scatter is performed according to a scatter map such that row <code>scatter_map[i]</code> of the destination table is replaced by the source row. All other rows of the destination table equal corresponding rows of the target table.</p>
<p>The number of elements in source must match the number of columns in target and their corresponding datatypes must be the same.</p>
<p>If the same index appears more than once in the scatter map, the result is undefined.</p>
<p>If any values in <code>indices</code> are outside of the interval [-n, n) where <code>n</code> is the number of rows in the <code>target</code> table, behavior is undefined.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The input scalars containing values to be scattered into the target columns </td></tr>
    <tr><td class="paramname">indices</td><td>A non-nullable column of integral indices that indicate the rows in the target table to be replaced by source. </td></tr>
    <tr><td class="paramname">target</td><td>The set of columns into which values from the source_table are to be scattered </td></tr>
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned table's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Result of scattering values from source to target </dd></dl>

</div>
</div>
<a id="ab0fafddc49374af3d9ab6815196d426f" name="ab0fafddc49374af3d9ab6815196d426f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0fafddc49374af3d9ab6815196d426f">&#9670;&#160;</a></span>scatter() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt; cudf::detail::scatter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>scatter_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scatters the rows of the source table into a copy of the target table according to a scatter map. </p>
<p>Scatters values from the source table into the target table out-of-place, returning a "destination table". The scatter is performed according to a scatter map such that row <code>scatter_map[i]</code> of the destination table gets row <code>i</code> of the source table. All other rows of the destination table equal corresponding rows of the target table.</p>
<p>The number of columns in source must match the number of columns in target and their corresponding datatypes must be the same.</p>
<p>A negative value <code>i</code> in the <code>scatter_map</code> is interpreted as <code>i+n</code>, where <code>n</code> is the number of rows in the <code>target</code> table.</p>
<p>If the same index appears more than once in the scatter map, the result is undefined. If any values in <code>scatter_map</code> are outside of the interval [-n, n) where <code>n</code> is the number of rows in the <code>target</code> table, behavior is undefined.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The input columns containing values to be scattered into the target columns </td></tr>
    <tr><td class="paramname">scatter_map</td><td>A non-nullable column of integral indices that maps the rows in the source table to rows in the target table. The size must be equal to or less than the number of elements in the source columns. </td></tr>
    <tr><td class="paramname">target</td><td>The set of columns into which values from the source_table are to be scattered </td></tr>
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned table's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Result of scattering values from source to target </dd></dl>

</div>
</div>
<a id="a642afeffe44abb5382a4c44534503907" name="a642afeffe44abb5382a4c44534503907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642afeffe44abb5382a4c44534503907">&#9670;&#160;</a></span>scatter() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt; cudf::detail::scatter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt; const&#160;</td>
          <td class="paramname"><em>scatter_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>scatter_map</code> span size is larger than max of <code>size_type</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0568781207d7824429d333aa3a8e0870" name="a0568781207d7824429d333aa3a8e0870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0568781207d7824429d333aa3a8e0870">&#9670;&#160;</a></span>segmented_count_set_bits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; cudf::detail::segmented_count_set_bits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> const *&#160;</td>
          <td class="paramname"><em>bitmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a bitmask, counts the number of set (1) bits in every range <code>[indices[2*i], indices[(2*i)+1])</code> (where 0 &lt;= i &lt; indices.size() / 2). </p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>bitmask == nullptr</code> </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>indices.size() % 2 != 0</code> </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>indices[2*i] &lt; 0 or indices[2*i] &gt; indices[(2*i)+1]</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitmask</td><td>Bitmask residing in device memory whose bits will be counted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>A <a class="el" href="structcudf_1_1host__span.html" title="C++20 std::span with reduced feature set.">host_span</a> of indices specifying ranges to count the number of set bits. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A vector storing the number of non-zero bits in the specified ranges. </dd></dl>

</div>
</div>
<a id="aab0e7344544634b61fd1f48a0931b231" name="aab0e7344544634b61fd1f48a0931b231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab0e7344544634b61fd1f48a0931b231">&#9670;&#160;</a></span>segmented_count_unset_bits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; cudf::detail::segmented_count_unset_bits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> const *&#160;</td>
          <td class="paramname"><em>bitmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a bitmask, counts the number of unset (0) bits in every range <code>[indices[2*i], indices[(2*i)+1])</code> (where 0 &lt;= i &lt; indices.size() / 2). </p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>bitmask == nullptr</code> </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>indices.size() % 2 != 0</code> </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>indices[2*i] &lt; 0 or indices[2*i] &gt; indices[(2*i)+1]</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitmask</td><td>Bitmask residing in device memory whose bits will be counted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>A <a class="el" href="structcudf_1_1host__span.html" title="C++20 std::span with reduced feature set.">host_span</a> of indices specifying ranges to count the number of unset bits. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A vector storing the number of zero bits in the specified ranges. </dd></dl>

</div>
</div>
<a id="aee03027237bac182e4be6d37fa6c4f37" name="aee03027237bac182e4be6d37fa6c4f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee03027237bac182e4be6d37fa6c4f37">&#9670;&#160;</a></span>segmented_null_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; cudf::detail::segmented_null_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> const *&#160;</td>
          <td class="paramname"><em>bitmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a validity bitmask, counts the number of null elements (unset bits) in every range <code>[indices[2*i], indices[(2*i)+1])</code> (where 0 &lt;= i &lt; indices.size() / 2). </p>
<p>If <code>bitmask == nullptr</code>, all elements are assumed to be valid and a vector of length <code>indices.size()</code> containing all zeros is returned.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>indices.size() % 2 != 0</code> </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>indices[2*i] &lt; 0 or indices[2*i] &gt; indices[(2*i)+1]</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitmask</td><td>Validity bitmask residing in device memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>A <a class="el" href="structcudf_1_1host__span.html" title="C++20 std::span with reduced feature set.">host_span</a> of indices specifying ranges to count the number of null elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A vector storing the number of null elements in each specified range. </dd></dl>

</div>
</div>
<a id="a3da5b63902793d46d2048b2f5ccb2e41" name="a3da5b63902793d46d2048b2f5ccb2e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3da5b63902793d46d2048b2f5ccb2e41">&#9670;&#160;</a></span>segmented_shift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::segmented_shift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>segmented_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt;&#160;</td>
          <td class="paramname"><em>segment_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>fill_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs segmented shifts for specified values. </p>
<p>For each segment, <code>i</code>th element is determined by the <code>i - offset</code>th element of the segment. If <code>i - offset &lt; 0 or &gt;= segment_size</code>, the value is determined by <code>fill_value</code>.</p>
<p>Example: </p><div class="fragment"><div class="line">segmented_values: { 3 1 2 | 3 5 3 | 2 6 }</div>
<div class="line">segment_offsets: {0 3 6 8}</div>
<div class="line">offset: 2</div>
<div class="line">fill_value: @</div>
<div class="line">result: { @ @ 3 | @ @ 3 | @ @ }</div>
<div class="line">-------------------------------------------------</div>
<div class="line">segmented_values: { 3 1 2 | 3 5 3 | 2 6 }</div>
<div class="line">segment_offsets: {0 3 6 8}</div>
<div class="line">offset: -1</div>
<div class="line">fill_value: -1</div>
<div class="line">result: { 1 2 -1 | 5 3 -1 | 6 -1 }</div>
</div><!-- fragment --><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">segmented_values</td><td>Segmented column, specified by <code>segment_offsets</code> </td></tr>
    <tr><td class="paramname">segment_offsets</td><td>Each segment's offset of <code>segmented_values</code>. A list of offsets with size <code>num_segments + 1</code>. The size of each segment is <code>segment_offsets[i+1] - segment_offsets[i]</code>. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset by which to shift the input </td></tr>
    <tr><td class="paramname">fill_value</td><td>Fill value for indeterminable outputs </td></tr>
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned table and columns' device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>If <code>offset == 0</code>, a copy of <code>segmented_values</code> is returned. </dd></dl>

</div>
</div>
<a id="a0143b14fe58e9f453958200e4bd745b2" name="a0143b14fe58e9f453958200e4bd745b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0143b14fe58e9f453958200e4bd745b2">&#9670;&#160;</a></span>segmented_sort_by_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt; cudf::detail::segmented_sort_by_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>segment_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>column_order</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>null_precedence</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a lexicographic segmented sort of a table   </p>
<p>If segment_offsets contains values larger than the number of rows, the behavior is undefined. </p><dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>values.num_rows() != keys.num_rows()</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>segment_offsets</code> is not <code>size_type</code> column.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">Example:</div>
<div class="line">keys = { {9, 8, 7, 6, 5, 4, 3, 2, 1, 0} }</div>
<div class="line">values = { {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;} }</div>
<div class="line">offsets = {0, 3, 7, 10}</div>
<div class="line">result = cudf::segmented_sort_by_key(keys, values, offsets);</div>
<div class="line">result is { &#39;c&#39;,&#39;b&#39;,&#39;a&#39;, &#39;g&#39;,&#39;f&#39;,&#39;e&#39;,&#39;d&#39;, &#39;j&#39;,&#39;i&#39;,&#39;h&#39; }</div>
</div><!-- fragment --><p>If segment_offsets is empty or contains a single index, no values are sorted and the result is a copy of the values.</p>
<p>The segment_offsets are not required to include all indices. Any indices outside the specified segments will not be sorted.</p>
<div class="fragment"><div class="line">Example: (offsets do not cover all indices)</div>
<div class="line">keys = { {9, 8, 7, 6, 5, 4, 3, 2, 1, 0} }</div>
<div class="line">values = { {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;} }</div>
<div class="line">offsets = {3, 7}</div>
<div class="line">result = cudf::segmented_sort_by_key(keys, values, offsets);</div>
<div class="line">result is { &#39;a&#39;,&#39;b&#39;,&#39;c&#39;, &#39;g&#39;,&#39;f&#39;,&#39;e&#39;,&#39;d&#39;, &#39;h&#39;,&#39;i&#39;,&#39;j&#39; }</div>
</div><!-- fragment --><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>The table to reorder </td></tr>
    <tr><td class="paramname">keys</td><td>The table that determines the ordering of elements in each segment </td></tr>
    <tr><td class="paramname">segment_offsets</td><td>The column of <code>size_type</code> type containing start offset index for each contiguous segment. </td></tr>
    <tr><td class="paramname">column_order</td><td>The desired order for each column in <code>keys</code>. Size must be equal to <code>keys.num_columns()</code> or empty. If empty, all columns are sorted in ascending order. </td></tr>
    <tr><td class="paramname">null_precedence</td><td>The desired order of a null element compared to other elements for each column in <code>keys</code>. Size must be equal to <code>keys.num_columns()</code> or empty. If empty, all columns will be sorted with <code><a class="el" href="group__utility__types.html#gga058e6d6e8a21583ce0e85ee73e5abb31a3525317285c6126ce3b62a8df8c00b07" title="NULL values ordered before all other values">null_order::BEFORE</a></code>. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource to allocate any returned objects </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>table with elements in each segment sorted  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ee83cd6aa2e87076b5f8c39fbf08719" name="a5ee83cd6aa2e87076b5f8c39fbf08719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee83cd6aa2e87076b5f8c39fbf08719">&#9670;&#160;</a></span>segmented_sorted_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::segmented_sorted_order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>segment_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>column_order</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>null_precedence</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns sorted order after sorting each segment in the table.   </p>
<p>If segment_offsets contains values larger than the number of rows, the behavior is undefined. </p><dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>segment_offsets</code> is not <code>size_type</code> column.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">Example:</div>
<div class="line">keys = { {9, 8, 7, 6, 5, 4, 3, 2, 1, 0} }</div>
<div class="line">offsets = {0, 3, 7, 10}</div>
<div class="line">result = cudf::segmented_sorted_order(keys, offsets);</div>
<div class="line">result is { 2,1,0, 6,5,4,3, 9,8,7 }</div>
</div><!-- fragment --><p>If segment_offsets is empty or contains a single index, no values are sorted and the result is a sequence of integers from 0 to keys.size()-1.</p>
<p>The segment_offsets are not required to include all indices. Any indices outside the specified segments will not be sorted.</p>
<div class="fragment"><div class="line">Example: (offsets do not cover all indices)</div>
<div class="line">keys = { {9, 8, 7, 6, 5, 4, 3, 2, 1, 0} }</div>
<div class="line">offsets = {3, 7}</div>
<div class="line">result = cudf::segmented_sorted_order(keys, offsets);</div>
<div class="line">result is { 0,1,2, 6,5,4,3, 7,8,9 }</div>
</div><!-- fragment --><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>The table that determines the ordering of elements in each segment </td></tr>
    <tr><td class="paramname">segment_offsets</td><td>The column of <code>size_type</code> type containing start offset index for each contiguous segment. </td></tr>
    <tr><td class="paramname">column_order</td><td>The desired order for each column in <code>keys</code>. Size must be equal to <code>keys.num_columns()</code> or empty. If empty, all columns are sorted in ascending order. </td></tr>
    <tr><td class="paramname">null_precedence</td><td>The desired order of a null element compared to other elements for each column in <code>keys</code>. Size must be equal to <code>keys.num_columns()</code> or empty. If empty, all columns will be sorted with <code><a class="el" href="group__utility__types.html#gga058e6d6e8a21583ce0e85ee73e5abb31a3525317285c6126ce3b62a8df8c00b07" title="NULL values ordered before all other values">null_order::BEFORE</a></code>. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource to allocate any returned objects </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>sorted order of the segment sorted table  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35145843e5dd4a43853838b02241881f" name="a35145843e5dd4a43853838b02241881f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35145843e5dd4a43853838b02241881f">&#9670;&#160;</a></span>segmented_valid_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; cudf::detail::segmented_valid_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> const *&#160;</td>
          <td class="paramname"><em>bitmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a validity bitmask, counts the number of valid elements (set bits) in every range <code>[indices[2*i], indices[(2*i)+1])</code> (where 0 &lt;= i &lt; indices.size() / 2). </p>
<p>If <code>bitmask == nullptr</code>, all elements are assumed to be valid and a vector of length <code>indices.size()</code> containing segment lengths is returned.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>indices.size() % 2 != 0</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>indices[2*i] &lt; 0 or indices[2*i] &gt; indices[(2*i)+1]</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitmask</td><td>Validity bitmask residing in device memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>A <a class="el" href="structcudf_1_1host__span.html" title="C++20 std::span with reduced feature set.">host_span</a> of indices specifying ranges to count the number of valid elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A vector storing the number of valid elements in each specified range. </dd></dl>

</div>
</div>
<a id="a4de28f6150ae69e92bb463bdb86c94e3" name="a4de28f6150ae69e92bb463bdb86c94e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de28f6150ae69e92bb463bdb86c94e3">&#9670;&#160;</a></span>sequence() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::sequence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills a column with a sequence of value specified by an initial value and a step of 1.   </p>
<p>Creates a new column and fills with <code>size</code> values starting at <code>init</code> and incrementing by 1, generating the sequence [ init, init+1, init+2, ... init + (size - 1)]</p>
<div class="fragment"><div class="line">size = 3</div>
<div class="line">init = 0</div>
<div class="line"><span class="keywordflow">return</span> = [0, 1, 2]</div>
</div><!-- fragment --> <dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>init</code> is not numeric. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>size</code> is &lt; 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size of the output column </td></tr>
    <tr><td class="paramname">init</td><td>First value in the sequence </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The result column containing the generated sequence  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acaed9837e40ff8bcba1cb84806e191f3" name="acaed9837e40ff8bcba1cb84806e191f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaed9837e40ff8bcba1cb84806e191f3">&#9670;&#160;</a></span>sequence() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::sequence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills a column with a sequence of value specified by an initial value and a step.   </p>
<p>Creates a new column and fills with <code>size</code> values starting at <code>init</code> and incrementing by <code>step</code>, generating the sequence [ init, init+step, init+2*step, ... init + (size - 1)*step]</p>
<div class="fragment"><div class="line">size = 3</div>
<div class="line">init = 0</div>
<div class="line">step = 2</div>
<div class="line"><span class="keywordflow">return</span> = [0, 2, 4]</div>
</div><!-- fragment --> <dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>init</code> and <code>step</code> are not the same type. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if scalar types are not numeric. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>size</code> is &lt; 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size of the output column </td></tr>
    <tr><td class="paramname">init</td><td>First value in the sequence </td></tr>
    <tr><td class="paramname">step</td><td>Increment value </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The result column containing the generated sequence  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a522f5649cb74a11dba58378f96e40f01" name="a522f5649cb74a11dba58378f96e40f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a522f5649cb74a11dba58378f96e40f01">&#9670;&#160;</a></span>set_null_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudf::detail::set_null_mask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> *&#160;</td>
          <td class="paramname"><em>bitmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>begin_bit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>end_bit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>valid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a pre-allocated bitmask buffer to a given state in the range <code>[begin_bit, end_bit)</code>   </p>
<p>Sets <code>[begin_bit, end_bit)</code> bits of bitmask to valid if <code>valid==true</code> or null otherwise.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmask</td><td>Pointer to bitmask (e.g. returned by <code>column_viewnull_mask()</code>) </td></tr>
    <tr><td class="paramname">begin_bit</td><td>Index of the first bit to set (inclusive) </td></tr>
    <tr><td class="paramname">end_bit</td><td>Index of the last bit to set (exclusive) </td></tr>
    <tr><td class="paramname">valid</td><td>If true set all entries to valid; otherwise, set all to null  </td></tr>
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a560407ec1815ec2aff96a7c792f53428" name="a560407ec1815ec2aff96a7c792f53428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a560407ec1815ec2aff96a7c792f53428">&#9670;&#160;</a></span>shallow_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t cudf::detail::shallow_hash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a hash value from the shallow state of the specified column </p>
<p>For any two columns, if <code>is_shallow_equivalent(c0,c1)</code> then <code>shallow_hash(c0) == shallow_hash(c1)</code>.</p>
<p>The complexity of computing the hash value of <code>input</code> is <code>O( count_descendants(input) )</code>, i.e., it is independent of the number of elements in the column.</p>
<p>This function does <em>not</em> inspect the elements of <code>input</code> nor access any device memory or launch any kernels.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> to compute hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The hash value derived from the shallow state of <code>input</code>. </dd></dl>

</div>
</div>
<a id="a659e6bad07531f73e44b0e87e7a59449" name="a659e6bad07531f73e44b0e87e7a59449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a659e6bad07531f73e44b0e87e7a59449">&#9670;&#160;</a></span>shift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::shift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>fill_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new column by shifting all values by an offset.   </p>
<p>Elements will be determined by <code>output[idx] = input[idx - offset]</code>. Some elements in the output may be indeterminable from the input. For those elements, the value will be determined by <code>fill_values</code>.</p>
<div class="fragment"><div class="line">Examples</div>
<div class="line">-------------------------------------------------</div>
<div class="line">input       = [0, 1, 2, 3, 4]</div>
<div class="line">offset      = 3</div>
<div class="line">fill_values = @</div>
<div class="line">return      = [@, @, @, 0, 1]</div>
<div class="line">-------------------------------------------------</div>
<div class="line">input       = [5, 4, 3, 2, 1]</div>
<div class="line">offset      = -2</div>
<div class="line">fill_values = 7</div>
<div class="line">return      = [3, 2, 1, 7, 7]</div>
</div><!-- fragment --><dl class="section note"><dt>注解</dt><dd>if the input is nullable, the output will be nullable. </dd>
<dd>
if the fill value is null, the output will be nullable.</dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Column to be shifted </td></tr>
    <tr><td class="paramname">offset</td><td>The offset by which to shift the input </td></tr>
    <tr><td class="paramname">fill_value</td><td>Fill value for indeterminable outputs </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned result's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>input</code> dtype is neither fixed-width nor string type </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>fill_value</code> dtype does not match <code>input</code> dtype.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The shifted column  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a84962657d1071313a0e63f3c05a4c26a" name="a84962657d1071313a0e63f3c05a4c26a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84962657d1071313a0e63f3c05a4c26a">&#9670;&#160;</a></span>size_in_bits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="types_8hpp.html#adc4a74f3fb4b327ed43b31d0fca65ba3">CUDF_HOST_DEVICE</a> std::size_t cudf::detail::size_in_bits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of bits the given type can hold. </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd><code>sizeof(T)</code> in bits </dd></dl>

<p class="definition">在文件 <a class="el" href="bit_8hpp_source.html">bit.hpp</a> 第 <a class="el" href="bit_8hpp_source.html#l00053">53</a> 行定义.</p>

</div>
</div>
<a id="a49deebc29b5e46589239ef45caadf78d" name="a49deebc29b5e46589239ef45caadf78d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49deebc29b5e46589239ef45caadf78d">&#9670;&#160;</a></span>slice() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classcudf_1_1column__view.html">column_view</a> &gt; cudf::detail::slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slices a <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> into a set of <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code>s according to a set of indices.   </p>
<p>The returned views of <code>input</code> are constructed from an even number indices where the <code>i</code>th returned <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> views the elements in <code>input</code> indicated by the range <code>[indices[2*i], indices[(2*i)+1])</code>.</p>
<p>For all <code>i</code> it is expected <code>indices[i] &lt;= input.size()</code> For all <code>i%2==0</code>, it is expected that <code>indices[i] &lt;= indices[i+1]</code></p>
<dl class="section note"><dt>注解</dt><dd>It is the caller's responsibility to ensure that the returned views do not outlive the viewed device memory.</dd></dl>
<div class="fragment"><div class="line">input:   {10, 12, 14, 16, 18, 20, 22, 24, 26, 28}</div>
<div class="line">indices: {1, 3, 5, 9, 2, 4, 8, 8}</div>
<div class="line">output:  {{12, 14}, {20, 22, 24, 26}, {14, 16}, {}}</div>
</div><!-- fragment --><dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>indices</code> size is not even. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>When the values in the pair are strictly decreasing. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>When any of the values in the pair don't belong to the range [0, input.size()).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>View of column to slice </td></tr>
    <tr><td class="paramname">indices</td><td>Indices used to take slices of <code>input</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Vector of views of <code>input</code> indicated by the ranges in <code>indices</code>  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa31cc81e8ff79807da425b06808628a3" name="aa31cc81e8ff79807da425b06808628a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa31cc81e8ff79807da425b06808628a3">&#9670;&#160;</a></span>slice() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classcudf_1_1column__view.html">column_view</a> &gt; cudf::detail::slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Slices a <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> into a set of <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code>s according to a set of indices.  </p>
<p>The returned views of <code>input</code> are constructed from an even number indices where the <code>i</code>th returned <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> views the elements in <code>input</code> indicated by the range <code>[indices[2*i], indices[(2*i)+1])</code>.</p>
<p>For all <code>i</code> it is expected <code>indices[i] &lt;= input.size()</code> For all <code>i%2==0</code>, it is expected that <code>indices[i] &lt;= indices[i+1]</code></p>
<dl class="section note"><dt>注解</dt><dd>It is the caller's responsibility to ensure that the returned views do not outlive the viewed device memory.</dd></dl>
<div class="fragment"><div class="line">input:   {10, 12, 14, 16, 18, 20, 22, 24, 26, 28}</div>
<div class="line">indices: {1, 3, 5, 9, 2, 4, 8, 8}</div>
<div class="line">output:  {{12, 14}, {20, 22, 24, 26}, {14, 16}, {}}</div>
</div><!-- fragment --><dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>indices</code> size is not even. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>When the values in the pair are strictly decreasing. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>When any of the values in the pair don't belong to the range [0, input.size()).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>View of column to slice </td></tr>
    <tr><td class="paramname">indices</td><td>Indices used to take slices of <code>input</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Vector of views of <code>input</code> indicated by the ranges in <code>indices</code>    </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="accad26dd1e34404dea7ab68735bf8d64" name="accad26dd1e34404dea7ab68735bf8d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accad26dd1e34404dea7ab68735bf8d64">&#9670;&#160;</a></span>slice() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ColumnView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ColumnView cudf::detail::slice </td>
          <td>(</td>
          <td class="paramtype">ColumnView const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a>&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a zero-copy <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code>/<code><a class="el" href="classcudf_1_1mutable__column__view.html" title="A non-owning, mutable view of device data as a column of elements, some of which may be null as indic...">mutable_column_view</a></code> of the elements in the range <code>[begin,end)</code> in <code>input</code>. </p>
<dl class="section note"><dt>注解</dt><dd>It is the caller's responsibility to ensure that the returned view does not outlive the viewed device memory.</dd></dl>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>begin &lt; 0</code>, <code>end &lt; begin</code> or <code>end &gt; input.size()</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>View of input column to slice </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin</td><td>Index of the first desired element in the slice (inclusive). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>Index of the last desired element in the slice (exclusive).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>ColumnView View of the elements <code>[begin,end)</code> from <code>input</code>. </dd></dl>

<p class="definition">在文件 <a class="el" href="copy_8hpp_source.html">copy.hpp</a> 第 <a class="el" href="copy_8hpp_source.html#l00049">49</a> 行定义.</p>

</div>
</div>
<a id="a5910f60027c0a5ed39ae6d3400504a4c" name="a5910f60027c0a5ed39ae6d3400504a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5910f60027c0a5ed39ae6d3400504a4c">&#9670;&#160;</a></span>slice() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classcudf_1_1table__view.html">table_view</a> &gt; cudf::detail::slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slices a <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> into a set of <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code>s according to a set of indices.   </p>
<p>The returned views of <code>input</code> are constructed from an even number indices where the <code>i</code>th returned <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> views the elements in <code>input</code> indicated by the range <code>[indices[2*i], indices[(2*i)+1])</code>.</p>
<p>For all <code>i</code> it is expected <code>indices[i] &lt;= input.size()</code> For all <code>i%2==0</code>, it is expected that <code>indices[i] &lt;= indices[i+1]</code></p>
<dl class="section note"><dt>注解</dt><dd>It is the caller's responsibility to ensure that the returned views do not outlive the viewed device memory.</dd></dl>
<div class="fragment"><div class="line">input:   [{10, 12, 14, 16, 18, 20, 22, 24, 26, 28},</div>
<div class="line">          {50, 52, 54, 56, 58, 60, 62, 64, 66, 68}]</div>
<div class="line">indices: {1, 3, 5, 9, 2, 4, 8, 8}</div>
<div class="line">output:  [{{12, 14}, {20, 22, 24, 26}, {14, 16}, {}},</div>
<div class="line">          {{52, 54}, {60, 22, 24, 26}, {14, 16}, {}}]</div>
</div><!-- fragment --><dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>indices</code> size is not even. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>When the values in the pair are strictly decreasing. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>When any of the values in the pair don't belong to the range [0, input.size()).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>View of table to slice </td></tr>
    <tr><td class="paramname">indices</td><td>Indices used to take slices of <code>input</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Vector of views of <code>input</code> indicated by the ranges in <code>indices</code>  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a981d0804d0e1b53e77bcb4b495effdd2" name="a981d0804d0e1b53e77bcb4b495effdd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981d0804d0e1b53e77bcb4b495effdd2">&#9670;&#160;</a></span>slice() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classcudf_1_1table__view.html">table_view</a> &gt; cudf::detail::slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Slices a <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> into a set of <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code>s according to a set of indices.  </p>
<p>The returned views of <code>input</code> are constructed from an even number indices where the <code>i</code>th returned <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> views the elements in <code>input</code> indicated by the range <code>[indices[2*i], indices[(2*i)+1])</code>.</p>
<p>For all <code>i</code> it is expected <code>indices[i] &lt;= input.size()</code> For all <code>i%2==0</code>, it is expected that <code>indices[i] &lt;= indices[i+1]</code></p>
<dl class="section note"><dt>注解</dt><dd>It is the caller's responsibility to ensure that the returned views do not outlive the viewed device memory.</dd></dl>
<div class="fragment"><div class="line">input:   [{10, 12, 14, 16, 18, 20, 22, 24, 26, 28},</div>
<div class="line">          {50, 52, 54, 56, 58, 60, 62, 64, 66, 68}]</div>
<div class="line">indices: {1, 3, 5, 9, 2, 4, 8, 8}</div>
<div class="line">output:  [{{12, 14}, {20, 22, 24, 26}, {14, 16}, {}},</div>
<div class="line">          {{52, 54}, {60, 22, 24, 26}, {14, 16}, {}}]</div>
</div><!-- fragment --><dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>indices</code> size is not even. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>When the values in the pair are strictly decreasing. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>When any of the values in the pair don't belong to the range [0, input.size()).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>View of table to slice </td></tr>
    <tr><td class="paramname">indices</td><td>Indices used to take slices of <code>input</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Vector of views of <code>input</code> indicated by the ranges in <code>indices</code>    </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ecb769bcadd1469d96dab94bc9fb92c" name="a6ecb769bcadd1469d96dab94bc9fb92c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ecb769bcadd1469d96dab94bc9fb92c">&#9670;&#160;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt; cudf::detail::sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>column_order</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>null_precedence</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a lexicographic sort of the rows of a table   </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The table to sort </td></tr>
    <tr><td class="paramname">column_order</td><td>The desired order for each column. Size must be equal to <code>input.num_columns()</code> or empty. If empty, all columns are sorted in ascending order. </td></tr>
    <tr><td class="paramname">null_precedence</td><td>The desired order of a null element compared to other elements for each column in <code>input</code>. Size must be equal to <code>input.num_columns()</code> or empty. If empty, all columns will be sorted with <code><a class="el" href="group__utility__types.html#gga058e6d6e8a21583ce0e85ee73e5abb31a3525317285c6126ce3b62a8df8c00b07" title="NULL values ordered before all other values">null_order::BEFORE</a></code>. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned table's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>New table containing the desired sorted order of <code>input</code>  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ef04bcc6a371c3a2ecdd1a24d413b06" name="a8ef04bcc6a371c3a2ecdd1a24d413b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef04bcc6a371c3a2ecdd1a24d413b06">&#9670;&#160;</a></span>sort_by_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt; cudf::detail::sort_by_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>column_order</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>null_precedence</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a key-value sort.   </p>
<p>Creates a new table that reorders the rows of <code>values</code> according to the lexicographic ordering of the rows of <code>keys</code>.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>values.num_rows() != keys.num_rows()</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>The table to reorder </td></tr>
    <tr><td class="paramname">keys</td><td>The table that determines the ordering </td></tr>
    <tr><td class="paramname">column_order</td><td>The desired order for each column in <code>keys</code>. Size must be equal to <code>keys.num_columns()</code> or empty. If empty, all columns are sorted in ascending order. </td></tr>
    <tr><td class="paramname">null_precedence</td><td>The desired order of a null element compared to other elements for each column in <code>keys</code>. Size must be equal to <code>keys.num_columns()</code> or empty. If empty, all columns will be sorted with <code><a class="el" href="group__utility__types.html#gga058e6d6e8a21583ce0e85ee73e5abb31a3525317285c6126ce3b62a8df8c00b07" title="NULL values ordered before all other values">null_order::BEFORE</a></code>. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned table's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The reordering of <code>values</code> determined by the lexicographic order of the rows of <code>keys</code>.  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02dc7ba3e6b64741911634d22f34fa91" name="a02dc7ba3e6b64741911634d22f34fa91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02dc7ba3e6b64741911634d22f34fa91">&#9670;&#160;</a></span>sorted_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::sorted_order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>column_order</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>null_precedence</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the row indices that would produce <code>input</code> in a lexicographical sorted order.   </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The table to sort </td></tr>
    <tr><td class="paramname">column_order</td><td>The desired sort order for each column. Size must be equal to <code>input.num_columns()</code> or empty. If empty, all columns will be sorted in ascending order. </td></tr>
    <tr><td class="paramname">null_precedence</td><td>The desired order of null compared to other elements for each column. Size must be equal to <code>input.num_columns()</code> or empty. If empty, all columns will be sorted in <code><a class="el" href="group__utility__types.html#gga058e6d6e8a21583ce0e85ee73e5abb31a3525317285c6126ce3b62a8df8c00b07" title="NULL values ordered before all other values">null_order::BEFORE</a></code>. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A non-nullable column of <code>size_type</code> elements containing the permuted row indices of <code>input</code> if it were sorted  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19d4598400aec3bb414a475b0e67588a" name="a19d4598400aec3bb414a475b0e67588a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d4598400aec3bb414a475b0e67588a">&#9670;&#160;</a></span>spark_murmur_hash3_32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::spark_murmur_hash3_32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code><a class="el" href="group__column__hash.html#ga68de1d04aa2c0ea2eeacfc73fd99a915">cudf::DEFAULT_HASH_SEED</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac92c0388c1c85c792be08da6986b8bed" name="ac92c0388c1c85c792be08da6986b8bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac92c0388c1c85c792be08da6986b8bed">&#9670;&#160;</a></span>split() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classcudf_1_1column__view.html">column_view</a> &gt; cudf::detail::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt;&#160;</td>
          <td class="paramname"><em>splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> into a set of <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code>s according to a set of indices derived from expected splits.   </p>
<p>The returned view's of <code>input</code> are constructed from vector of splits, which indicates where the split should occur. The <code>i</code>th returned <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> is sliced as <code>[0, splits[i])</code> if <code>i</code>=0, else <code>[splits[i], input.size())</code> if <code>i</code> is the last view and <code>[splits[i-1], splits[i]]</code> otherwise.</p>
<p>For all <code>i</code> it is expected <code>splits[i] &lt;= splits[i+1] &lt;= input.size()</code> For a <code>splits</code> size N, there will always be N+1 splits in the output</p>
<dl class="section note"><dt>注解</dt><dd>It is the caller's responsibility to ensure that the returned views do not outlive the viewed device memory.</dd></dl>
<div class="fragment"><div class="line">Example:</div>
<div class="line">input:   {10, 12, 14, 16, 18, 20, 22, 24, 26, 28}</div>
<div class="line">splits:  {2, 5, 9}</div>
<div class="line">output:  {{10, 12}, {14, 16, 18}, {20, 22, 24, 26}, {28}}</div>
</div><!-- fragment --><dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>splits</code> has end index &gt; size of <code>input</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>When the value in <code>splits</code> is not in the range [0, input.size()). </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>When the values in the <code>splits</code> are 'strictly decreasing'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>View of column to split </td></tr>
    <tr><td class="paramname">splits</td><td>Indices where the view will be split </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The set of requested views of <code>input</code> indicated by the <code>splits</code>  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2bbfdd769874212ba1918473509e8d62" name="a2bbfdd769874212ba1918473509e8d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bbfdd769874212ba1918473509e8d62">&#9670;&#160;</a></span>split() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classcudf_1_1column__view.html">column_view</a> &gt; cudf::detail::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt;&#160;</td>
          <td class="paramname"><em>splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Splits a <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> into a set of <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code>s according to a set of indices derived from expected splits.  </p>
<p>The returned view's of <code>input</code> are constructed from vector of splits, which indicates where the split should occur. The <code>i</code>th returned <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> is sliced as <code>[0, splits[i])</code> if <code>i</code>=0, else <code>[splits[i], input.size())</code> if <code>i</code> is the last view and <code>[splits[i-1], splits[i]]</code> otherwise.</p>
<p>For all <code>i</code> it is expected <code>splits[i] &lt;= splits[i+1] &lt;= input.size()</code> For a <code>splits</code> size N, there will always be N+1 splits in the output</p>
<dl class="section note"><dt>注解</dt><dd>It is the caller's responsibility to ensure that the returned views do not outlive the viewed device memory.</dd></dl>
<div class="fragment"><div class="line">Example:</div>
<div class="line">input:   {10, 12, 14, 16, 18, 20, 22, 24, 26, 28}</div>
<div class="line">splits:  {2, 5, 9}</div>
<div class="line">output:  {{10, 12}, {14, 16, 18}, {20, 22, 24, 26}, {28}}</div>
</div><!-- fragment --><dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>splits</code> has end index &gt; size of <code>input</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>When the value in <code>splits</code> is not in the range [0, input.size()). </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>When the values in the <code>splits</code> are 'strictly decreasing'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>View of column to split </td></tr>
    <tr><td class="paramname">splits</td><td>Indices where the view will be split </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The set of requested views of <code>input</code> indicated by the <code>splits</code>    </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c75abac479c304fa7ddd5e472489229" name="a5c75abac479c304fa7ddd5e472489229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c75abac479c304fa7ddd5e472489229">&#9670;&#160;</a></span>split() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classcudf_1_1table__view.html">table_view</a> &gt; cudf::detail::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt;&#160;</td>
          <td class="paramname"><em>splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> into a set of <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code>s according to a set of indices derived from expected splits.   </p>
<p>The returned views of <code>input</code> are constructed from vector of splits, which indicates where the split should occur. The <code>i</code>th returned <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> is sliced as <code>[0, splits[i])</code> if <code>i</code>=0, else <code>[splits[i], input.size())</code> if <code>i</code> is the last view and <code>[splits[i-1], splits[i]]</code> otherwise.</p>
<p>For all <code>i</code> it is expected <code>splits[i] &lt;= splits[i+1] &lt;= input.size()</code> For a <code>splits</code> size N, there will always be N+1 splits in the output</p>
<dl class="section note"><dt>注解</dt><dd>It is the caller's responsibility to ensure that the returned views do not outlive the viewed device memory.</dd></dl>
<div class="fragment"><div class="line">Example:</div>
<div class="line">input:   [{10, 12, 14, 16, 18, 20, 22, 24, 26, 28},</div>
<div class="line">          {50, 52, 54, 56, 58, 60, 62, 64, 66, 68}]</div>
<div class="line">splits:  {2, 5, 9}</div>
<div class="line">output:  [{{10, 12}, {14, 16, 18}, {20, 22, 24, 26}, {28}},</div>
<div class="line">          {{50, 52}, {54, 56, 58}, {60, 62, 64, 66}, {68}}]</div>
</div><!-- fragment --><dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>splits</code> has end index &gt; size of <code>input</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>When the value in <code>splits</code> is not in the range [0, input.size()). </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>When the values in the <code>splits</code> are 'strictly decreasing'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>View of a table to split </td></tr>
    <tr><td class="paramname">splits</td><td>Indices where the view will be split </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The set of requested views of <code>input</code> indicated by the <code>splits</code>  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e6bf2b8a180ce938904811ecb3fca6e" name="a1e6bf2b8a180ce938904811ecb3fca6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e6bf2b8a180ce938904811ecb3fca6e">&#9670;&#160;</a></span>split() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classcudf_1_1table__view.html">table_view</a> &gt; cudf::detail::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt;&#160;</td>
          <td class="paramname"><em>splits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Splits a <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> into a set of <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code>s according to a set of indices derived from expected splits.  </p>
<p>The returned views of <code>input</code> are constructed from vector of splits, which indicates where the split should occur. The <code>i</code>th returned <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> is sliced as <code>[0, splits[i])</code> if <code>i</code>=0, else <code>[splits[i], input.size())</code> if <code>i</code> is the last view and <code>[splits[i-1], splits[i]]</code> otherwise.</p>
<p>For all <code>i</code> it is expected <code>splits[i] &lt;= splits[i+1] &lt;= input.size()</code> For a <code>splits</code> size N, there will always be N+1 splits in the output</p>
<dl class="section note"><dt>注解</dt><dd>It is the caller's responsibility to ensure that the returned views do not outlive the viewed device memory.</dd></dl>
<div class="fragment"><div class="line">Example:</div>
<div class="line">input:   [{10, 12, 14, 16, 18, 20, 22, 24, 26, 28},</div>
<div class="line">          {50, 52, 54, 56, 58, 60, 62, 64, 66, 68}]</div>
<div class="line">splits:  {2, 5, 9}</div>
<div class="line">output:  [{{10, 12}, {14, 16, 18}, {20, 22, 24, 26}, {28}},</div>
<div class="line">          {{50, 52}, {54, 56, 58}, {60, 62, 64, 66}, {68}}]</div>
</div><!-- fragment --><dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>splits</code> has end index &gt; size of <code>input</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>When the value in <code>splits</code> is not in the range [0, input.size()). </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>When the values in the <code>splits</code> are 'strictly decreasing'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>View of a table to split </td></tr>
    <tr><td class="paramname">splits</td><td>Indices where the view will be split </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The set of requested views of <code>input</code> indicated by the <code>splits</code>    </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae447240ab710451b66b73e15b19e50f4" name="ae447240ab710451b66b73e15b19e50f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae447240ab710451b66b73e15b19e50f4">&#9670;&#160;</a></span>stable_distinct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt; cudf::detail::stable_distinct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__reorder__compact.html#ga69091647ea1f9c9d4cdcf7c8876bea3a">duplicate_keep_option</a>&#160;</td>
          <td class="paramname"><em>keep</em> = <code><a class="el" href="group__reorder__compact.html#gga69091647ea1f9c9d4cdcf7c8876bea3aa0546025abe5830d9334bb82102420394">duplicate_keep_option::KEEP_ANY</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a>&#160;</td>
          <td class="paramname"><em>nulls_equal</em> = <code><a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44">null_equality::EQUAL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#gae9d1055c69c3089452794783c7c82f83">nan_equality</a>&#160;</td>
          <td class="paramname"><em>nans_equal</em> = <code><a class="el" href="group__utility__types.html#ggae9d1055c69c3089452794783c7c82f83acd6d9f766e6e2753da429d26078711d7">nan_equality::ALL_EQUAL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new table without duplicate rows. </p>
<p>Given an <code>input</code> <a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a>, each row is copied to the output table to create a set of distinct rows. The row order is guaranteed to be preserved as in the input.</p>
<p>If there are duplicate rows, which row to be copied depends on the specified value of the <code>keep</code> parameter.</p>
<p>This API produces exactly the same set of output rows as <code><a class="el" href="group__reorder__compact.html#ga201195610929658c5d383fa99434ef9c" title="Create a new table without duplicate rows.">cudf::distinct</a></code>.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input table </td></tr>
    <tr><td class="paramname">keys</td><td>Vector of indices indicating key columns in the <code>input</code> table </td></tr>
    <tr><td class="paramname">keep</td><td>Copy any, first, last, or none of the found duplicates </td></tr>
    <tr><td class="paramname">nulls_equal</td><td>Flag to specify whether null elements should be considered as equal </td></tr>
    <tr><td class="paramname">nans_equal</td><td>Flag to specify whether NaN elements should be considered as equal </td></tr>
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A table containing the resulting distinct rows </dd></dl>

</div>
</div>
<a id="a617cf9daf1ccb662f23d1751d8e9eef1" name="a617cf9daf1ccb662f23d1751d8e9eef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a617cf9daf1ccb662f23d1751d8e9eef1">&#9670;&#160;</a></span>stable_segmented_sort_by_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt; cudf::detail::stable_segmented_sort_by_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>segment_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>column_order</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>null_precedence</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a stably lexicographic segmented sort of a table   </p>
<p>Performs a lexicographic segmented sort of a table  </p>
<p>If segment_offsets contains values larger than the number of rows, the behavior is undefined. </p><dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>values.num_rows() != keys.num_rows()</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>segment_offsets</code> is not <code>size_type</code> column.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">Example:</div>
<div class="line">keys = { {9, 8, 7, 6, 5, 4, 3, 2, 1, 0} }</div>
<div class="line">values = { {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;} }</div>
<div class="line">offsets = {0, 3, 7, 10}</div>
<div class="line">result = cudf::segmented_sort_by_key(keys, values, offsets);</div>
<div class="line">result is { &#39;c&#39;,&#39;b&#39;,&#39;a&#39;, &#39;g&#39;,&#39;f&#39;,&#39;e&#39;,&#39;d&#39;, &#39;j&#39;,&#39;i&#39;,&#39;h&#39; }</div>
</div><!-- fragment --><p>If segment_offsets is empty or contains a single index, no values are sorted and the result is a copy of the values.</p>
<p>The segment_offsets are not required to include all indices. Any indices outside the specified segments will not be sorted.</p>
<div class="fragment"><div class="line">Example: (offsets do not cover all indices)</div>
<div class="line">keys = { {9, 8, 7, 6, 5, 4, 3, 2, 1, 0} }</div>
<div class="line">values = { {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;} }</div>
<div class="line">offsets = {3, 7}</div>
<div class="line">result = cudf::segmented_sort_by_key(keys, values, offsets);</div>
<div class="line">result is { &#39;a&#39;,&#39;b&#39;,&#39;c&#39;, &#39;g&#39;,&#39;f&#39;,&#39;e&#39;,&#39;d&#39;, &#39;h&#39;,&#39;i&#39;,&#39;j&#39; }</div>
</div><!-- fragment --><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>The table to reorder </td></tr>
    <tr><td class="paramname">keys</td><td>The table that determines the ordering of elements in each segment </td></tr>
    <tr><td class="paramname">segment_offsets</td><td>The column of <code>size_type</code> type containing start offset index for each contiguous segment. </td></tr>
    <tr><td class="paramname">column_order</td><td>The desired order for each column in <code>keys</code>. Size must be equal to <code>keys.num_columns()</code> or empty. If empty, all columns are sorted in ascending order. </td></tr>
    <tr><td class="paramname">null_precedence</td><td>The desired order of a null element compared to other elements for each column in <code>keys</code>. Size must be equal to <code>keys.num_columns()</code> or empty. If empty, all columns will be sorted with <code><a class="el" href="group__utility__types.html#gga058e6d6e8a21583ce0e85ee73e5abb31a3525317285c6126ce3b62a8df8c00b07" title="NULL values ordered before all other values">null_order::BEFORE</a></code>. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource to allocate any returned objects </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>table with elements in each segment sorted    </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f2457ab266f3c83ee1803af46d40431" name="a9f2457ab266f3c83ee1803af46d40431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f2457ab266f3c83ee1803af46d40431">&#9670;&#160;</a></span>stable_segmented_sorted_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::stable_segmented_sorted_order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>segment_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>column_order</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>null_precedence</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns sorted order after stably sorting each segment in the table.   </p>
<p>Returns sorted order after sorting each segment in the table.  </p>
<p>If segment_offsets contains values larger than the number of rows, the behavior is undefined. </p><dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>segment_offsets</code> is not <code>size_type</code> column.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">Example:</div>
<div class="line">keys = { {9, 8, 7, 6, 5, 4, 3, 2, 1, 0} }</div>
<div class="line">offsets = {0, 3, 7, 10}</div>
<div class="line">result = cudf::segmented_sorted_order(keys, offsets);</div>
<div class="line">result is { 2,1,0, 6,5,4,3, 9,8,7 }</div>
</div><!-- fragment --><p>If segment_offsets is empty or contains a single index, no values are sorted and the result is a sequence of integers from 0 to keys.size()-1.</p>
<p>The segment_offsets are not required to include all indices. Any indices outside the specified segments will not be sorted.</p>
<div class="fragment"><div class="line">Example: (offsets do not cover all indices)</div>
<div class="line">keys = { {9, 8, 7, 6, 5, 4, 3, 2, 1, 0} }</div>
<div class="line">offsets = {3, 7}</div>
<div class="line">result = cudf::segmented_sorted_order(keys, offsets);</div>
<div class="line">result is { 0,1,2, 6,5,4,3, 7,8,9 }</div>
</div><!-- fragment --><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>The table that determines the ordering of elements in each segment </td></tr>
    <tr><td class="paramname">segment_offsets</td><td>The column of <code>size_type</code> type containing start offset index for each contiguous segment. </td></tr>
    <tr><td class="paramname">column_order</td><td>The desired order for each column in <code>keys</code>. Size must be equal to <code>keys.num_columns()</code> or empty. If empty, all columns are sorted in ascending order. </td></tr>
    <tr><td class="paramname">null_precedence</td><td>The desired order of a null element compared to other elements for each column in <code>keys</code>. Size must be equal to <code>keys.num_columns()</code> or empty. If empty, all columns will be sorted with <code><a class="el" href="group__utility__types.html#gga058e6d6e8a21583ce0e85ee73e5abb31a3525317285c6126ce3b62a8df8c00b07" title="NULL values ordered before all other values">null_order::BEFORE</a></code>. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource to allocate any returned objects </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>sorted order of the segment sorted table    </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8ef84bbffe708df280ab3edd030a761" name="af8ef84bbffe708df280ab3edd030a761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ef84bbffe708df280ab3edd030a761">&#9670;&#160;</a></span>stable_sort_by_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt; cudf::detail::stable_sort_by_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>column_order</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>null_precedence</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a key-value stable sort.   </p>
<p>Creates a new table that reorders the rows of <code>values</code> according to the lexicographic ordering of the rows of <code>keys</code>.</p>
<p>The order of equivalent elements is guaranteed to be preserved.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>values.num_rows() != keys.num_rows()</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>The table to reorder </td></tr>
    <tr><td class="paramname">keys</td><td>The table that determines the ordering </td></tr>
    <tr><td class="paramname">column_order</td><td>The desired order for each column in <code>keys</code>. Size must be equal to <code>keys.num_columns()</code> or empty. If empty, all columns are sorted in ascending order. </td></tr>
    <tr><td class="paramname">null_precedence</td><td>The desired order of a null element compared to other elements for each column in <code>keys</code>. Size must be equal to <code>keys.num_columns()</code> or empty. If empty, all columns will be sorted with <code><a class="el" href="group__utility__types.html#gga058e6d6e8a21583ce0e85ee73e5abb31a3525317285c6126ce3b62a8df8c00b07" title="NULL values ordered before all other values">null_order::BEFORE</a></code>. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned table's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The reordering of <code>values</code> determined by the lexicographic order of the rows of <code>keys</code>.  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7eacf26ccb873b752827c9316f858ca9" name="a7eacf26ccb873b752827c9316f858ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eacf26ccb873b752827c9316f858ca9">&#9670;&#160;</a></span>stable_sorted_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::stable_sorted_order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>column_order</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>null_precedence</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the row indices that would produce <code>input</code> in a stable lexicographical sorted order.   </p>
<p>The order of equivalent elements is guaranteed to be preserved.</p>
<p>Computes the row indices that would produce <code>input</code> in a lexicographical sorted order.  </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The table to sort </td></tr>
    <tr><td class="paramname">column_order</td><td>The desired sort order for each column. Size must be equal to <code>input.num_columns()</code> or empty. If empty, all columns will be sorted in ascending order. </td></tr>
    <tr><td class="paramname">null_precedence</td><td>The desired order of null compared to other elements for each column. Size must be equal to <code>input.num_columns()</code> or empty. If empty, all columns will be sorted in <code><a class="el" href="group__utility__types.html#gga058e6d6e8a21583ce0e85ee73e5abb31a3525317285c6126ce3b62a8df8c00b07" title="NULL values ordered before all other values">null_order::BEFORE</a></code>. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A non-nullable column of <code>size_type</code> elements containing the permuted row indices of <code>input</code> if it were sorted    </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6afca7c4d88ca63b0e0903ac5c09ae0" name="ab6afca7c4d88ca63b0e0903ac5c09ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6afca7c4d88ca63b0e0903ac5c09ae0">&#9670;&#160;</a></span>table_to_linked_columns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecudf_1_1detail.html#a627e116400c1bed3d5f2b3ab78661fe8">LinkedColVector</a> cudf::detail::table_to_linked_columns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts all column_views of a table into linked_column_views </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>table of columns to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Vector of converted linked_column_views </dd></dl>

<p class="definition">在文件 <a class="el" href="linked__column_8hpp_source.html">linked_column.hpp</a> 第 <a class="el" href="linked__column_8hpp_source.html#l00073">73</a> 行定义.</p>

</div>
</div>
<a id="a57278828a4e7e978f90c08968d9dec55" name="a57278828a4e7e978f90c08968d9dec55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57278828a4e7e978f90c08968d9dec55">&#9670;&#160;</a></span>target_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcudf_1_1data__type.html">data_type</a> cudf::detail::target_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>source_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1aggregation.html#a83579ae3cab2fc3d1c3b377d1cfab24c">aggregation::Kind</a>&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the target <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> for the specified aggregation k performed on elements of type source_type. </p>
<p>aram source_type The element type to be aggregated aram k The aggregation </p><dl class="section return"><dt>返回</dt><dd><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a> The target_type of k performed on source_type elements </dd></dl>

</div>
</div>
<a id="a0390f62b7fcc7ea895d0ca910e6403c7" name="a0390f62b7fcc7ea895d0ca910e6403c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0390f62b7fcc7ea895d0ca910e6403c7">&#9670;&#160;</a></span>tile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt; cudf::detail::tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Repeats the rows from <code>input</code> table <code>count</code> times to form a new table.   </p>
<p><code>output.num_columns() == input.num_columns()</code> <code>output.num_rows() == input.num_rows() * count</code></p>
<div class="fragment"><div class="line">input  = [[8, 4, 7], [5, 2, 3]]</div>
<div class="line">count  = 2</div>
<div class="line"><span class="keywordflow">return</span> = [[8, 4, 7, 8, 4, 7], [5, 2, 3, 5, 2, 3]]</div>
</div><!-- fragment --><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Table containing rows to be repeated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of times to tile "rows". Must be non-negative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned table's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The table containing the tiled "rows"  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69fbe0566c564337747a5ba0c30f7813" name="a69fbe0566c564337747a5ba0c30f7813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69fbe0566c564337747a5ba0c30f7813">&#9670;&#160;</a></span>to_arrow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; arrow::Table &gt; cudf::detail::to_arrow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structcudf_1_1column__metadata.html">column_metadata</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>metadata</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arrow::MemoryPool *&#160;</td>
          <td class="paramname"><em>ar_mr</em> = <code>arrow::default_memory_pool()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <code>arrow::Table</code> from cudf table <code>input</code>   </p>
<p>Converts the <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">cudf::table_view</a></code> to <code>arrow::Table</code> with the provided metadata <code>column_names</code>.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>column_names</code> size doesn't match with number of columns.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a> that needs to be converted to arrow Table </td></tr>
    <tr><td class="paramname">metadata</td><td>Contains hierarchy of names of columns and children </td></tr>
    <tr><td class="paramname">ar_mr</td><td>arrow memory pool to allocate memory for arrow Table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>arrow Table generated from <code>input</code>  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65b402cf23474cf91d987693ebfdeaa9" name="a65b402cf23474cf91d987693ebfdeaa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65b402cf23474cf91d987693ebfdeaa9">&#9670;&#160;</a></span>to_arrow_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; arrow::Array &gt; cudf::detail::to_arrow_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#gadf077607da617d1dadcc5417e2783539">cudf::type_id</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">在文件 <a class="el" href="detail_2interop_8hpp_source.html">interop.hpp</a> 第 <a class="el" href="detail_2interop_8hpp_source.html#l00058">58</a> 行定义.</p>

</div>
</div>
<a id="a93794af21ad050c5390d6ccd97783c52" name="a93794af21ad050c5390d6ccd97783c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93794af21ad050c5390d6ccd97783c52">&#9670;&#160;</a></span>to_dlpack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DLManagedTensor * cudf::detail::to_dlpack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a cudf table into a DLPack DLTensor   </p>
<p>All columns must have the same data type and this type must be numeric. The columns may be nullable, but the null count must be zero. If the input table is empty or has zero rows, the result will be nullptr.</p>
<dl class="section note"><dt>注解</dt><dd>The <code>deleter</code> method of the returned <code>DLManagedTensor</code> must be used to free the memory allocated for the tensor.</dd></dl>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if the data types are not equal or not numeric, or if any of columns have non-zero null count</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Table to convert to DLPack </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned DLPack tensor's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>1D or 2D DLPack tensor with a copy of the table data, or nullptr  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8dea2d4015483abd8062b4f3e8c49ecf" name="a8dea2d4015483abd8062b4f3e8c49ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dea2d4015483abd8062b4f3e8c49ecf">&#9670;&#160;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>unary_udf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>output_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_ptx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new column by applying a unary function against every element of an input column.   </p>
<p>Computes: <code>out[i] = F(in[i])</code></p>
<p>The output null mask is the same is the input null mask so if input[i] is null then output[i] is also null</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>An immutable view of the input column to transform </td></tr>
    <tr><td class="paramname">unary_udf</td><td>The PTX/CUDA string of the unary function to apply </td></tr>
    <tr><td class="paramname">output_type</td><td>The output type that is compatible with the output type in the UDF </td></tr>
    <tr><td class="paramname">is_ptx</td><td>true: the UDF is treated as PTX code; false: the UDF is treated as CUDA code </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The column resulting from applying the unary function to every element of the input  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5fe789c6b4148db15bad46557ad89d1" name="ac5fe789c6b4148db15bad46557ad89d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5fe789c6b4148db15bad46557ad89d1">&#9670;&#160;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;, <a class="el" href="classcudf_1_1table__view.html">table_view</a> &gt; cudf::detail::transpose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transposes a table.   </p>
<p>Stores output in a contiguous column, exposing the transposed table as a <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code>.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if column types are non-homogeneous </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if column types are non-fixed-width</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>A table (M cols x N rows) to be transposed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the device memory of returned value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The transposed input (N cols x M rows) as a <code>column</code> and <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code>, representing the owner and transposed table, respectively.  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0e1aa6f630065804422ba95e76da8f2" name="ac0e1aa6f630065804422ba95e76da8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e1aa6f630065804422ba95e76da8f2">&#9670;&#160;</a></span>true_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::true_if </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a column of <code><a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd" title="Boolean using one byte per value, 0 == false, else true">type_id::BOOL8</a></code> elements by applying a predicate to every element between [<code>begin,</code>end<code>)</code>true<code>indicates the value is satisfies the predicate and</code>false` indicates it doesn't. </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td>Iterator type for <code>begin</code> and <code>end</code> </td></tr>
    <tr><td class="paramname">Predicate</td><td>A predicator type which will be evaluated </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Beginning of the sequence of elements </td></tr>
    <tr><td class="paramname">end</td><td>End of the sequence of elements </td></tr>
    <tr><td class="paramname">p</td><td>Predicate to be applied to each element in <code>[begin,end)</code> </td></tr>
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A column of type <code><a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd" title="Boolean using one byte per value, 0 == false, else true">type_id::BOOL8</a>,</code> with <code>true</code> representing predicate is satisfied. </dd></dl>

<p class="definition">在文件 <a class="el" href="detail_2unary_8hpp_source.html">unary.hpp</a> 第 <a class="el" href="detail_2unary_8hpp_source.html#l00048">48</a> 行定义.</p>

</div>
</div>
<a id="acc1d1df6733679d2f522bd838eae342a" name="acc1d1df6733679d2f522bd838eae342a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc1d1df6733679d2f522bd838eae342a">&#9670;&#160;</a></span>unary_operation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt; cudf::detail::unary_operation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__transformation__unaryops.html#ga030e62f30b296602f398e70d1ca657c4">cudf::unary_operator</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs unary op on all values in column   </p>
<p>Note: For <code>decimal32</code> and <code>decimal64</code>, only <code>ABS</code>, <code>CEIL</code> and <code>FLOOR</code> are supported.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>A <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> as input </td></tr>
    <tr><td class="paramname">op</td><td>operation to perform </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Column of same size as <code>input</code> containing result of the operation  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a641f75ce86d28e459d73c6afe246f43c" name="a641f75ce86d28e459d73c6afe246f43c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641f75ce86d28e459d73c6afe246f43c">&#9670;&#160;</a></span>unique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt; cudf::detail::unique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__reorder__compact.html#ga69091647ea1f9c9d4cdcf7c8876bea3a">duplicate_keep_option</a>&#160;</td>
          <td class="paramname"><em>keep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a>&#160;</td>
          <td class="paramname"><em>nulls_equal</em> = <code><a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44">null_equality::EQUAL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new table with consecutive duplicate rows removed.   </p>
<p>Given an <code>input</code> <a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a>, each row is copied to the output table to create a set of distinct rows. If there are duplicate rows, which row is copied depends on the <code>keep</code> parameter.</p>
<p>The order of rows in the output table remains the same as in the input.</p>
<p>A row is distinct if there are no equivalent rows in the table. A row is unique if there is no adjacent equivalent row. That is, keeping distinct rows removes all duplicates in the table/column, while keeping unique rows only removes duplicates from consecutive groupings.</p>
<p>Performance hint: if the input is pre-sorted, <code><a class="el" href="group__reorder__compact.html#ga87352ad4f282dd17365d4c9929d5c644" title="Create a new table with consecutive duplicate rows removed.">cudf::unique</a></code> can produce an equivalent result (i.e., same set of output rows) but with less running time than <code><a class="el" href="group__reorder__compact.html#ga201195610929658c5d383fa99434ef9c" title="Create a new table without duplicate rows.">cudf::distinct</a></code>.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if the <code>keys</code> column indices are out of bounds in the <code>input</code> table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>input <a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a> to copy only unique rows </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td>vector of indices representing key columns from <code>input</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keep</td><td>keep any, first, last, or none of the found duplicates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nulls_equal</td><td>flag to denote nulls are equal if <a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44" title="nulls compare equal">null_equality::EQUAL</a>, nulls are not equal if <a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771ac0df9e531f39895029236b71d0d1c0ac" title="nulls compare unequal">null_equality::UNEQUAL</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned table's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Table with unique rows from each sequence of equivalent rows as specified by <code>keep</code>  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98e8b391af43f65454777fb93ac1810b" name="a98e8b391af43f65454777fb93ac1810b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e8b391af43f65454777fb93ac1810b">&#9670;&#160;</a></span>unique_count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a> cudf::detail::unique_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a>&#160;</td>
          <td class="paramname"><em>null_handling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga74641d3dfd6d96d0939b492ecf9b9cc8">nan_policy</a>&#160;</td>
          <td class="paramname"><em>nan_handling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of consecutive groups of equivalent rows in a column.   </p>
<p>If <code>null_handling</code> is <a class="el" href="group__utility__types.html#gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8" title="exclude null elements">null_policy::EXCLUDE</a> and <code>nan_handling</code> is <a class="el" href="group__utility__types.html#gga74641d3dfd6d96d0939b492ecf9b9cc8aeed6bbfa0697c54960c7e0baa97313f4" title="treat nans as null elements">nan_policy::NAN_IS_NULL</a>, both <code>NaN</code> and <code>null</code> values are ignored. If <code>null_handling</code> is <a class="el" href="group__utility__types.html#gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8" title="exclude null elements">null_policy::EXCLUDE</a> and <code>nan_handling</code> is <a class="el" href="group__utility__types.html#gga74641d3dfd6d96d0939b492ecf9b9cc8a27adbe26caa2eb99976344933c281a77" title="treat nans as valid elements (non-null)">nan_policy::NAN_IS_VALID</a>, only <code>null</code> is ignored, <code>NaN</code> is considered in count.</p>
<p><code>null</code>s are handled as equal.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a> whose consecutive groups of equivalent rows will be counted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">null_handling</td><td>flag to include or ignore <code>null</code> while counting </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nan_handling</td><td>flag to consider <code>NaN==null</code> or not</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>number of consecutive groups of equivalent rows in the column  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a310da6da06499f366f5df272a540182e" name="a310da6da06499f366f5df272a540182e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a310da6da06499f366f5df272a540182e">&#9670;&#160;</a></span>unique_count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a> cudf::detail::unique_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a>&#160;</td>
          <td class="paramname"><em>nulls_equal</em> = <code><a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44">null_equality::EQUAL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of consecutive groups of equivalent rows in a table.   </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>Table whose consecutive groups of equivalent rows will be counted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nulls_equal</td><td>flag to denote if null elements should be considered equal nulls are not equal if <a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771ac0df9e531f39895029236b71d0d1c0ac" title="nulls compare unequal">null_equality::UNEQUAL</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>number of consecutive groups of equivalent rows in the column  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5c2375ffd17459ecf1ef510fe8c2ea2" name="ad5c2375ffd17459ecf1ef510fe8c2ea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c2375ffd17459ecf1ef510fe8c2ea2">&#9670;&#160;</a></span>upper_bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::detail::upper_bound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>haystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>needles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>column_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>null_precedence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find largest indices in a sorted table where values should be inserted to maintain order.   </p>
<p>For each row in <code>needles</code>, find the last index in <code>haystack</code> where inserting the row still maintains its sort order.</p>
<div class="fragment"><div class="line">Example:</div>
<div class="line"> </div>
<div class="line"> Single Column:</div>
<div class="line">     idx        0   1   2   3   4</div>
<div class="line">  haystack = { 10, 20, 20, 30, 50 }</div>
<div class="line">  needles  = { 20 }</div>
<div class="line">  result   = {  3 }</div>
<div class="line"> </div>
<div class="line"> Multi Column:</div>
<div class="line">     idx          0    1    2    3    4</div>
<div class="line">  haystack = {{  10,  20,  20,  20,  20 },</div>
<div class="line">              { 5.0,  .5,  .5,  .7,  .7 },</div>
<div class="line">              {  90,  77,  78,  61,  61 }}</div>
<div class="line">  needles  = {{ 20 },</div>
<div class="line">              { .7 },</div>
<div class="line">              { 61 }}</div>
<div class="line">  result =     { 5 }</div>
</div><!-- fragment --><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">haystack</td><td>The table containing search space </td></tr>
    <tr><td class="paramname">needles</td><td>Values for which to find the insert locations in the search space </td></tr>
    <tr><td class="paramname">column_order</td><td>Vector of column sort order </td></tr>
    <tr><td class="paramname">null_precedence</td><td>Vector of null_precedence enums needles </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A non-nullable column of <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9" title="Row index type for columns and tables">cudf::size_type</a> elements containing the insertion points  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a052b9cabb17b4fc2ef27e00a6414c707" name="a052b9cabb17b4fc2ef27e00a6414c707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a052b9cabb17b4fc2ef27e00a6414c707">&#9670;&#160;</a></span>valid_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a> cudf::detail::valid_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> const *&#160;</td>
          <td class="paramname"><em>bitmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>stop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a validity bitmask, counts the number of valid elements (set bits) in the range <code>[start, stop)</code>. </p>
<p>If <code>bitmask == nullptr</code>, all elements are assumed to be valid and the function returns <code>stop-start</code>.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>start &gt; stop</code> </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>start &lt; 0</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bitmask</td><td>Validity bitmask residing in device memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>Index of the first bit to count (inclusive). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stop</td><td>Index of the last bit to count (exclusive). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The number of valid elements in the specified range. </dd></dl>

</div>
</div>
<a id="a3e5582c4cfcb5c5c104088fb0d03596c" name="a3e5582c4cfcb5c5c104088fb0d03596c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e5582c4cfcb5c5c104088fb0d03596c">&#9670;&#160;</a></span>visitor_overload()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcudf_1_1detail_1_1visitor__overload.html">cudf::detail::visitor_overload</a> </td>
          <td>(</td>
          <td class="paramtype">Ts...&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structcudf_1_1detail_1_1visitor__overload.html">visitor_overload</a>&lt; Ts... &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">变量说明</h2>
<a id="a6696755213d5d4098e2057a314205f9c" name="a6696755213d5d4098e2057a314205f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6696755213d5d4098e2057a314205f9c">&#9670;&#160;</a></span>ARGMAX_SENTINEL</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> cudf::detail::ARGMAX_SENTINEL {-1}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sentinel value used for <code>ARGMAX</code> aggregation. </p>
<p>The output column for an <code>ARGMAX</code> aggregation is initialized with the sentinel value to indicate an unused element. </p>

<p class="definition">在文件 <a class="el" href="detail_2aggregation_2aggregation_8hpp_source.html">aggregation.hpp</a> 第 <a class="el" href="detail_2aggregation_2aggregation_8hpp_source.html#l01100">1100</a> 行定义.</p>

</div>
</div>
<a id="a0ccf176241d88b7575d0e1f72d00c6c6" name="a0ccf176241d88b7575d0e1f72d00c6c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ccf176241d88b7575d0e1f72d00c6c6">&#9670;&#160;</a></span>ARGMIN_SENTINEL</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> cudf::detail::ARGMIN_SENTINEL {-1}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sentinel value used for <code>ARGMIN</code> aggregation. </p>
<p>The output column for an <code>ARGMIN</code> aggregation is initialized with the sentinel value to indicate an unused element. </p>

<p class="definition">在文件 <a class="el" href="detail_2aggregation_2aggregation_8hpp_source.html">aggregation.hpp</a> 第 <a class="el" href="detail_2aggregation_2aggregation_8hpp_source.html#l01108">1108</a> 行定义.</p>

</div>
</div>
<a id="ab5aa2bb950ef46c1f618dfa206142597" name="ab5aa2bb950ef46c1f618dfa206142597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5aa2bb950ef46c1f618dfa206142597">&#9670;&#160;</a></span>DEFAULT_JOIN_CG_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int cudf::detail::DEFAULT_JOIN_CG_SIZE = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">在文件 <a class="el" href="detail_2join_8hpp_source.html">join.hpp</a> 第 <a class="el" href="detail_2join_8hpp_source.html#l00043">43</a> 行定义.</p>

</div>
</div>
<a id="a1dea3cc353c312e3683f15e4a01cf752" name="a1dea3cc353c312e3683f15e4a01cf752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dea3cc353c312e3683f15e4a01cf752">&#9670;&#160;</a></span>default_stream_value</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rmm::cuda_stream_view const cudf::detail::default_stream_value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default stream for cudf </p>
<p>Use this value to ensure the correct stream is used when compiled with per thread default stream. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecudf.html">cudf</a></li><li class="navelem"><a class="el" href="namespacecudf_1_1detail.html">detail</a></li>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
