<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Aggregation_rolling</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__aggregation__rolling.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#files">文件</a> &#124;
<a href="#nested-classes">类</a> &#124;
<a href="#func-members">函数</a>  </div>
  <div class="headertitle"><div class="title">Aggregation_rolling</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
文件</h2></td></tr>
<tr class="memitem:rolling_8hpp"><td class="memItemLeft" align="right" valign="top">文件 &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rolling_8hpp.html">rolling.hpp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
类</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1window__bounds.html">cudf::window_bounds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstraction for window boundary sizes  <a href="structcudf_1_1window__bounds.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
函数</h2></td></tr>
<tr class="memitem:ga0dfc1f001d211212169ead998d484845"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__rolling.html#ga0dfc1f001d211212169ead998d484845">cudf::rolling_window</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> preceding_window, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> following_window, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> min_periods, <a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;agg, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga0dfc1f001d211212169ead998d484845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a fixed-size rolling window function to the values in a column.  <br /></td></tr>
<tr class="separator:ga0dfc1f001d211212169ead998d484845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga350324e8e9ab0d4969d8de7597f2a242"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__rolling.html#ga350324e8e9ab0d4969d8de7597f2a242">cudf::rolling_window</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;default_outputs, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> preceding_window, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> following_window, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> min_periods, <a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;agg, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga350324e8e9ab0d4969d8de7597f2a242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a fixed-size rolling window function to the values in a column.    <br /></td></tr>
<tr class="separator:ga350324e8e9ab0d4969d8de7597f2a242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d431c50f9d34e8bf6beda13f693bd69"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__rolling.html#ga0d431c50f9d34e8bf6beda13f693bd69">cudf::grouped_rolling_window</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;group_keys, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> preceding_window, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> following_window, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> min_periods, <a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;aggr, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga0d431c50f9d34e8bf6beda13f693bd69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a grouping-aware, fixed-size rolling window function to the values in a column.  <br /></td></tr>
<tr class="separator:ga0d431c50f9d34e8bf6beda13f693bd69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd62060125be568902bf4a4eef397fa8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__rolling.html#gabd62060125be568902bf4a4eef397fa8">cudf::grouped_rolling_window</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;group_keys, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="structcudf_1_1window__bounds.html">window_bounds</a> preceding_window, <a class="el" href="structcudf_1_1window__bounds.html">window_bounds</a> following_window, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> min_periods, <a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;aggr, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gabd62060125be568902bf4a4eef397fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a grouping-aware, fixed-size rolling window function to the values in a column.    <br /></td></tr>
<tr class="separator:gabd62060125be568902bf4a4eef397fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae00c7ff150e9bbdd9cb51b5fb4216081"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__rolling.html#gae00c7ff150e9bbdd9cb51b5fb4216081">cudf::grouped_rolling_window</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;group_keys, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;default_outputs, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> preceding_window, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> following_window, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> min_periods, <a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;aggr, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gae00c7ff150e9bbdd9cb51b5fb4216081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a grouping-aware, fixed-size rolling window function to the values in a column.    <br /></td></tr>
<tr class="separator:gae00c7ff150e9bbdd9cb51b5fb4216081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf7ec568b0cab23f44af22ea3600075b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__rolling.html#gacf7ec568b0cab23f44af22ea3600075b">cudf::grouped_rolling_window</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;group_keys, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;default_outputs, <a class="el" href="structcudf_1_1window__bounds.html">window_bounds</a> preceding_window, <a class="el" href="structcudf_1_1window__bounds.html">window_bounds</a> following_window, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> min_periods, <a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;aggr, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gacf7ec568b0cab23f44af22ea3600075b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a grouping-aware, fixed-size rolling window function to the values in a column.    <br /></td></tr>
<tr class="separator:gacf7ec568b0cab23f44af22ea3600075b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga167a23498c3e82313df80f653b3c48b1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__rolling.html#ga167a23498c3e82313df80f653b3c48b1">cudf::grouped_time_range_rolling_window</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;group_keys, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;timestamp_column, <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">cudf::order</a> const &amp;timestamp_order, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> preceding_window_in_days, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> following_window_in_days, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> min_periods, <a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;aggr, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga167a23498c3e82313df80f653b3c48b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a grouping-aware, timestamp-based rolling window function to the values in a column.  <br /></td></tr>
<tr class="separator:ga167a23498c3e82313df80f653b3c48b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f53b18345a094351160b187b263b746"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__rolling.html#ga7f53b18345a094351160b187b263b746">cudf::grouped_time_range_rolling_window</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;group_keys, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;timestamp_column, <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">cudf::order</a> const &amp;timestamp_order, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="structcudf_1_1window__bounds.html">window_bounds</a> preceding_window_in_days, <a class="el" href="structcudf_1_1window__bounds.html">window_bounds</a> following_window_in_days, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> min_periods, <a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;aggr, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga7f53b18345a094351160b187b263b746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a grouping-aware, timestamp-based rolling window function to the values in a column,.  <br /></td></tr>
<tr class="separator:ga7f53b18345a094351160b187b263b746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga595d27d939a1af9d00d2b6bea3b5623c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__rolling.html#ga595d27d939a1af9d00d2b6bea3b5623c">cudf::grouped_range_rolling_window</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;group_keys, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;orderby_column, <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">cudf::order</a> const &amp;<a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a>, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="structcudf_1_1range__window__bounds.html">range_window_bounds</a> const &amp;preceding, <a class="el" href="structcudf_1_1range__window__bounds.html">range_window_bounds</a> const &amp;following, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> min_periods, <a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;aggr, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga595d27d939a1af9d00d2b6bea3b5623c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a grouping-aware, value range-based rolling window function to the values in a column.  <br /></td></tr>
<tr class="separator:ga595d27d939a1af9d00d2b6bea3b5623c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaed6574615700cec1d4bf5469fe28141"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__rolling.html#gaaed6574615700cec1d4bf5469fe28141">cudf::rolling_window</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;preceding_window, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;following_window, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> min_periods, <a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;agg, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gaaed6574615700cec1d4bf5469fe28141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a variable-size rolling window function to the values in a column.  <br /></td></tr>
<tr class="separator:gaaed6574615700cec1d4bf5469fe28141"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<h2 class="groupheader">函数说明</h2>
<a id="ga595d27d939a1af9d00d2b6bea3b5623c" name="ga595d27d939a1af9d00d2b6bea3b5623c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga595d27d939a1af9d00d2b6bea3b5623c">&#9670;&#160;</a></span>grouped_range_rolling_window()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::grouped_range_rolling_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>group_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>orderby_column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">cudf::order</a> const &amp;&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1range__window__bounds.html">range_window_bounds</a> const &amp;&#160;</td>
          <td class="paramname"><em>preceding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1range__window__bounds.html">range_window_bounds</a> const &amp;&#160;</td>
          <td class="paramname"><em>following</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>min_periods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;&#160;</td>
          <td class="paramname"><em>aggr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a grouping-aware, value range-based rolling window function to the values in a column. </p>
<p>This function aggregates rows in a window around each element of a specified <code>input</code> column. The window is determined based on the values of an ordered <code>orderby</code> column, and on the values of a <code>preceding</code> and <code>following</code> scalar representing an inclusive range of orderby column values.</p>
<ol type="1">
<li>The elements of the <code>input</code> column are grouped into distinct groups (e.g. the result of a groupby), determined by the corresponding values of the columns under <code>group_keys</code>. The window-aggregation cannot cross the group boundaries.</li>
<li>Within a group, with all rows sorted by the <code>orderby</code> column, the aggregation window for a row at index <code>i</code> is determined as follows: a) If <code>orderby</code> is ASCENDING, aggregation window for row <code>i</code> includes all <code>input</code> rows at index <code>j</code> such that: <div class="fragment"><div class="line">(orderby[i] - preceding) &lt;= orderby[j] &lt;= orderby[i] + following</div>
</div><!-- fragment --> b) If <code>orderby</code> is DESCENDING, aggregation window for row <code>i</code> includes all <code>input</code> rows at index <code>j</code> such that: <div class="fragment"><div class="line">(orderby[i] + preceding) &gt;= orderby[j] &gt;= orderby[i] - following</div>
</div><!-- fragment --></li>
</ol>
<p>Note: This method requires that the rows are presorted by the group keys and orderby column values.</p>
<p>The window intervals are specified as scalar values appropriate for the orderby column. Currently, only the following combinations of <code>orderby</code> column type and range types are supported:</p><ol type="1">
<li>If <code>orderby</code> column is a TIMESTAMP, the <code>preceding</code>/<code>following</code> windows are specified in terms of <code>DURATION</code> scalars of the same resolution. E.g. For <code>orderby</code> column of type <code>TIMESTAMP_SECONDS</code>, the intervals may only be <code>DURATION_SECONDS</code>. Durations of higher resolution (e.g. <code>DURATION_NANOSECONDS</code>) or lower (e.g. <code>DURATION_DAYS</code>) cannot be used.</li>
<li>If the <code>orderby</code> column is an integral type (e.g. <code>INT32</code>), the <code>preceding</code>/<code>following</code> should be the exact same type (<code>INT32</code>).</li>
</ol>
<div class="fragment"><div class="line">Example: Consider a motor-racing statistics dataset, containing the following columns:</div>
<div class="line">  1. driver_name:   (STRING) Name of the car driver</div>
<div class="line">  2. num_overtakes: (INT32)  Number of times the driver overtook another car in a lap</div>
<div class="line">  3. lap_number:    (INT32)  The number of the lap</div>
<div class="line"> </div>
<div class="line">The `group_range_rolling_window()` function allows one to calculate the total number of overtakes</div>
<div class="line">each driver made within any 3 lap window of each entry:</div>
<div class="line">  1. Group/partition the dataset by `driver_id` (This is the group_keys argument.)</div>
<div class="line">  2. Sort each group by the `lap_number` (i.e. This is the orderby_column.)</div>
<div class="line">  3. Calculate the SUM(num_overtakes) over a window (preceding=1, following=1)</div>
<div class="line"> </div>
<div class="line">For the following input:</div>
<div class="line"> </div>
<div class="line"> [ // driver_name,  num_overtakes,  lap_number</div>
<div class="line">   {   &quot;bottas&quot;,        1,            1        },</div>
<div class="line">   {   &quot;hamilton&quot;,      2,            1        },</div>
<div class="line">   {   &quot;bottas&quot;,        2,            2        },</div>
<div class="line">   {   &quot;bottas&quot;,        1,            3        },</div>
<div class="line">   {   &quot;hamilton&quot;,      3,            1        },</div>
<div class="line">   {   &quot;hamilton&quot;,      8,            2        },</div>
<div class="line">   {   &quot;bottas&quot;,        5,            7        },</div>
<div class="line">   {   &quot;bottas&quot;,        6,            8        },</div>
<div class="line">   {   &quot;hamilton&quot;,      4,            4        }</div>
<div class="line"> ]</div>
<div class="line"> </div>
<div class="line">Partitioning (grouping) by `driver_name`, and ordering by `lap_number` yields the following</div>
<div class="line">`num_overtakes` vector (with 2 groups, one for each distinct `driver_name`):</div>
<div class="line"> </div>
<div class="line">lap_number:      [ 1,  2,  3,  7,  8,   1,  1,   2,  4 ]</div>
<div class="line">num_overtakes:   [ 1,  2,  1,  5,  6,   2,  3,   8,  4 ]</div>
<div class="line">                   &lt;-----bottas------&gt;|&lt;----hamilton---&gt;</div>
<div class="line"> </div>
<div class="line">The SUM aggregation is applied, with 1 preceding, and 1 following, with a minimum of 1</div>
<div class="line">period. The aggregation window is thus 3 (laps) wide, yielding the following output column:</div>
<div class="line"> </div>
<div class="line"> Results:        [ 3,  4,  3,  11, 11,  13, 13,  13,  4 ]</div>
</div><!-- fragment --><p>Note: The number of rows participating in each window might vary, based on the index within the group, datestamp, and <code>min_periods</code>. Apropos:</p><ol type="1">
<li>results[0] considers 2 values, because it is at the beginning of its group, and has no preceding values.</li>
<li>results[5] considers 3 values, despite being at the beginning of its group. It must include 2 following values, based on its orderby_column value.</li>
</ol>
<p>Each aggregation operation cannot cross group boundaries.</p>
<p>The type of the returned column depends on the input column type <code>T</code>, and the aggregation:</p><ol type="1">
<li>COUNT returns <code>INT32</code> columns</li>
<li>MIN/MAX returns <code>T</code> columns</li>
<li>SUM returns the promoted type for T. Sum on <code>INT32</code> yields <code>INT64</code>.</li>
<li>MEAN returns FLOAT64 columns</li>
<li>COLLECT returns columns of type <code>LIST&lt;T&gt;</code>.</li>
</ol>
<p>LEAD/LAG/ROW_NUMBER are undefined for range queries.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">group_keys</td><td>The (pre-sorted) grouping columns </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orderby_column</td><td>The (pre-sorted) order-by column, for range comparisons </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>The order (ASCENDING/DESCENDING) in which the order-by column is sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input column (to be aggregated) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preceding</td><td>The interval value in the backward direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">following</td><td>The interval value in the forward direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_periods</td><td>Minimum number of observations in window required to have a value, otherwise element <code>i</code> is null. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aggr</td><td>The rolling window aggregation type (SUM, MAX, MIN, etc.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A nullable output column containing the rolling window results </dd></dl>

</div>
</div>
<a id="gae00c7ff150e9bbdd9cb51b5fb4216081" name="gae00c7ff150e9bbdd9cb51b5fb4216081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae00c7ff150e9bbdd9cb51b5fb4216081">&#9670;&#160;</a></span>grouped_rolling_window() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::grouped_rolling_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>group_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>default_outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>preceding_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>following_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>min_periods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;&#160;</td>
          <td class="paramname"><em>aggr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a grouping-aware, fixed-size rolling window function to the values in a column.   </p>
<p>Like <code><a class="el" href="group__aggregation__rolling.html#ga0dfc1f001d211212169ead998d484845" title="Applies a fixed-size rolling window function to the values in a column.">rolling_window()</a></code>, this function aggregates values in a window around each element of a specified <code>input</code> column. It differs from <code><a class="el" href="group__aggregation__rolling.html#ga0dfc1f001d211212169ead998d484845" title="Applies a fixed-size rolling window function to the values in a column.">rolling_window()</a></code> in that elements of the <code>input</code> column are grouped into distinct groups (e.g. the result of a groupby). The window aggregation cannot cross the group boundaries. For a row <code>i</code> of <code>input</code>, the group is determined from the corresponding (i.e. i-th) values of the columns under <code>group_keys</code>.</p>
<p>Note: This method requires that the rows are presorted by the <code>group_key</code> values.</p>
<div class="fragment"><div class="line">Example: Consider a user-sales dataset, where the rows look as follows:</div>
<div class="line">{ &quot;user_id&quot;, sales_amt, day }</div>
<div class="line"> </div>
<div class="line">The `grouped_rolling_window()` method enables windowing queries such as grouping a dataset by</div>
<div class="line">`user_id`, and summing up the `sales_amt` column over a window of 3 rows (2 preceding (including</div>
<div class="line">current row), 1 row following).</div>
<div class="line"> </div>
<div class="line">In this example,</div>
<div class="line">   1. `group_keys == [ user_id ]`</div>
<div class="line">   2. `input == sales_amt`</div>
<div class="line">The data are grouped by `user_id`, and ordered by `day`-string. The aggregation</div>
<div class="line">(SUM) is then calculated for a window of 3 values around (and including) each row.</div>
<div class="line"> </div>
<div class="line">For the following input:</div>
<div class="line"> </div>
<div class="line"> [ // user,  sales_amt</div>
<div class="line">   { &quot;user1&quot;,   10      },</div>
<div class="line">   { &quot;user2&quot;,   20      },</div>
<div class="line">   { &quot;user1&quot;,   20      },</div>
<div class="line">   { &quot;user1&quot;,   10      },</div>
<div class="line">   { &quot;user2&quot;,   30      },</div>
<div class="line">   { &quot;user2&quot;,   80      },</div>
<div class="line">   { &quot;user1&quot;,   50      },</div>
<div class="line">   { &quot;user1&quot;,   60      },</div>
<div class="line">   { &quot;user2&quot;,   40      }</div>
<div class="line"> ]</div>
<div class="line"> </div>
<div class="line">Partitioning (grouping) by `user_id` yields the following `sales_amt` vector</div>
<div class="line">(with 2 groups, one for each distinct `user_id`):</div>
<div class="line"> </div>
<div class="line">   [ 10,  20,  10,  50,  60,  20,  30,  80,  40 ]</div>
<div class="line">     &lt;-------user1--------&gt;|&lt;------user2-------&gt;</div>
<div class="line"> </div>
<div class="line">The SUM aggregation is applied with 1 preceding and 1 following</div>
<div class="line">row, with a minimum of 1 period. The aggregation window is thus 3 rows wide,</div>
<div class="line">yielding the following column:</div>
<div class="line"> </div>
<div class="line">   [ 30, 40,  80, 120, 110,  50, 130, 150, 120 ]</div>
<div class="line"> </div>
<div class="line">Note: The SUMs calculated at the group boundaries (i.e. indices 0, 4, 5, and 8)</div>
<div class="line">consider only 2 values each, in spite of the window-size being 3.</div>
<div class="line">Each aggregation operation cannot cross group boundaries.</div>
</div><!-- fragment --><p>The returned column for <code>op == COUNT</code> always has <code>INT32</code> type. All other operators return a column of the same type as the input. Therefore it is suggested to convert integer column types (especially low-precision integers) to <code>FLOAT32</code> or <code>FLOAT64</code> before doing a rolling <code>MEAN</code>.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">group_keys</td><td>The (pre-sorted) grouping columns </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input column (to be aggregated) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preceding_window</td><td>The static rolling window size in the backward direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">following_window</td><td>The static rolling window size in the forward direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_periods</td><td>Minimum number of observations in window required to have a value, otherwise element <code>i</code> is null. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aggr</td><td>The rolling window aggregation type (SUM, MAX, MIN, etc.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A nullable output column containing the rolling window results  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">default_outputs</td><td>A column of per-row default values to be returned instead of nulls. Used for LEAD()/LAG(), if the row offset crosses the boundaries of the column or group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacf7ec568b0cab23f44af22ea3600075b" name="gacf7ec568b0cab23f44af22ea3600075b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf7ec568b0cab23f44af22ea3600075b">&#9670;&#160;</a></span>grouped_rolling_window() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::grouped_rolling_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>group_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>default_outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1window__bounds.html">window_bounds</a>&#160;</td>
          <td class="paramname"><em>preceding_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1window__bounds.html">window_bounds</a>&#160;</td>
          <td class="paramname"><em>following_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>min_periods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;&#160;</td>
          <td class="paramname"><em>aggr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a grouping-aware, fixed-size rolling window function to the values in a column.   </p>
<p>Like <code><a class="el" href="group__aggregation__rolling.html#ga0dfc1f001d211212169ead998d484845" title="Applies a fixed-size rolling window function to the values in a column.">rolling_window()</a></code>, this function aggregates values in a window around each element of a specified <code>input</code> column. It differs from <code><a class="el" href="group__aggregation__rolling.html#ga0dfc1f001d211212169ead998d484845" title="Applies a fixed-size rolling window function to the values in a column.">rolling_window()</a></code> in that elements of the <code>input</code> column are grouped into distinct groups (e.g. the result of a groupby). The window aggregation cannot cross the group boundaries. For a row <code>i</code> of <code>input</code>, the group is determined from the corresponding (i.e. i-th) values of the columns under <code>group_keys</code>.</p>
<p>Note: This method requires that the rows are presorted by the <code>group_key</code> values.</p>
<div class="fragment"><div class="line">Example: Consider a user-sales dataset, where the rows look as follows:</div>
<div class="line">{ &quot;user_id&quot;, sales_amt, day }</div>
<div class="line"> </div>
<div class="line">The `grouped_rolling_window()` method enables windowing queries such as grouping a dataset by</div>
<div class="line">`user_id`, and summing up the `sales_amt` column over a window of 3 rows (2 preceding (including</div>
<div class="line">current row), 1 row following).</div>
<div class="line"> </div>
<div class="line">In this example,</div>
<div class="line">   1. `group_keys == [ user_id ]`</div>
<div class="line">   2. `input == sales_amt`</div>
<div class="line">The data are grouped by `user_id`, and ordered by `day`-string. The aggregation</div>
<div class="line">(SUM) is then calculated for a window of 3 values around (and including) each row.</div>
<div class="line"> </div>
<div class="line">For the following input:</div>
<div class="line"> </div>
<div class="line"> [ // user,  sales_amt</div>
<div class="line">   { &quot;user1&quot;,   10      },</div>
<div class="line">   { &quot;user2&quot;,   20      },</div>
<div class="line">   { &quot;user1&quot;,   20      },</div>
<div class="line">   { &quot;user1&quot;,   10      },</div>
<div class="line">   { &quot;user2&quot;,   30      },</div>
<div class="line">   { &quot;user2&quot;,   80      },</div>
<div class="line">   { &quot;user1&quot;,   50      },</div>
<div class="line">   { &quot;user1&quot;,   60      },</div>
<div class="line">   { &quot;user2&quot;,   40      }</div>
<div class="line"> ]</div>
<div class="line"> </div>
<div class="line">Partitioning (grouping) by `user_id` yields the following `sales_amt` vector</div>
<div class="line">(with 2 groups, one for each distinct `user_id`):</div>
<div class="line"> </div>
<div class="line">   [ 10,  20,  10,  50,  60,  20,  30,  80,  40 ]</div>
<div class="line">     &lt;-------user1--------&gt;|&lt;------user2-------&gt;</div>
<div class="line"> </div>
<div class="line">The SUM aggregation is applied with 1 preceding and 1 following</div>
<div class="line">row, with a minimum of 1 period. The aggregation window is thus 3 rows wide,</div>
<div class="line">yielding the following column:</div>
<div class="line"> </div>
<div class="line">   [ 30, 40,  80, 120, 110,  50, 130, 150, 120 ]</div>
<div class="line"> </div>
<div class="line">Note: The SUMs calculated at the group boundaries (i.e. indices 0, 4, 5, and 8)</div>
<div class="line">consider only 2 values each, in spite of the window-size being 3.</div>
<div class="line">Each aggregation operation cannot cross group boundaries.</div>
</div><!-- fragment --><p>The returned column for <code>op == COUNT</code> always has <code>INT32</code> type. All other operators return a column of the same type as the input. Therefore it is suggested to convert integer column types (especially low-precision integers) to <code>FLOAT32</code> or <code>FLOAT64</code> before doing a rolling <code>MEAN</code>.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">group_keys</td><td>The (pre-sorted) grouping columns </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input column (to be aggregated) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preceding_window</td><td>The static rolling window size in the backward direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">following_window</td><td>The static rolling window size in the forward direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_periods</td><td>Minimum number of observations in window required to have a value, otherwise element <code>i</code> is null. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aggr</td><td>The rolling window aggregation type (SUM, MAX, MIN, etc.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A nullable output column containing the rolling window results  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">default_outputs</td><td>A column of per-row default values to be returned instead of nulls. Used for LEAD()/LAG(), if the row offset crosses the boundaries of the column or group.   </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0d431c50f9d34e8bf6beda13f693bd69" name="ga0d431c50f9d34e8bf6beda13f693bd69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d431c50f9d34e8bf6beda13f693bd69">&#9670;&#160;</a></span>grouped_rolling_window() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::grouped_rolling_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>group_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>preceding_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>following_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>min_periods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;&#160;</td>
          <td class="paramname"><em>aggr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a grouping-aware, fixed-size rolling window function to the values in a column. </p>
<p>Like <code><a class="el" href="group__aggregation__rolling.html#ga0dfc1f001d211212169ead998d484845" title="Applies a fixed-size rolling window function to the values in a column.">rolling_window()</a></code>, this function aggregates values in a window around each element of a specified <code>input</code> column. It differs from <code><a class="el" href="group__aggregation__rolling.html#ga0dfc1f001d211212169ead998d484845" title="Applies a fixed-size rolling window function to the values in a column.">rolling_window()</a></code> in that elements of the <code>input</code> column are grouped into distinct groups (e.g. the result of a groupby). The window aggregation cannot cross the group boundaries. For a row <code>i</code> of <code>input</code>, the group is determined from the corresponding (i.e. i-th) values of the columns under <code>group_keys</code>.</p>
<p>Note: This method requires that the rows are presorted by the <code>group_key</code> values.</p>
<div class="fragment"><div class="line">Example: Consider a user-sales dataset, where the rows look as follows:</div>
<div class="line">{ &quot;user_id&quot;, sales_amt, day }</div>
<div class="line"> </div>
<div class="line">The `grouped_rolling_window()` method enables windowing queries such as grouping a dataset by</div>
<div class="line">`user_id`, and summing up the `sales_amt` column over a window of 3 rows (2 preceding (including</div>
<div class="line">current row), 1 row following).</div>
<div class="line"> </div>
<div class="line">In this example,</div>
<div class="line">   1. `group_keys == [ user_id ]`</div>
<div class="line">   2. `input == sales_amt`</div>
<div class="line">The data are grouped by `user_id`, and ordered by `day`-string. The aggregation</div>
<div class="line">(SUM) is then calculated for a window of 3 values around (and including) each row.</div>
<div class="line"> </div>
<div class="line">For the following input:</div>
<div class="line"> </div>
<div class="line"> [ // user,  sales_amt</div>
<div class="line">   { &quot;user1&quot;,   10      },</div>
<div class="line">   { &quot;user2&quot;,   20      },</div>
<div class="line">   { &quot;user1&quot;,   20      },</div>
<div class="line">   { &quot;user1&quot;,   10      },</div>
<div class="line">   { &quot;user2&quot;,   30      },</div>
<div class="line">   { &quot;user2&quot;,   80      },</div>
<div class="line">   { &quot;user1&quot;,   50      },</div>
<div class="line">   { &quot;user1&quot;,   60      },</div>
<div class="line">   { &quot;user2&quot;,   40      }</div>
<div class="line"> ]</div>
<div class="line"> </div>
<div class="line">Partitioning (grouping) by `user_id` yields the following `sales_amt` vector</div>
<div class="line">(with 2 groups, one for each distinct `user_id`):</div>
<div class="line"> </div>
<div class="line">   [ 10,  20,  10,  50,  60,  20,  30,  80,  40 ]</div>
<div class="line">     &lt;-------user1--------&gt;|&lt;------user2-------&gt;</div>
<div class="line"> </div>
<div class="line">The SUM aggregation is applied with 1 preceding and 1 following</div>
<div class="line">row, with a minimum of 1 period. The aggregation window is thus 3 rows wide,</div>
<div class="line">yielding the following column:</div>
<div class="line"> </div>
<div class="line">   [ 30, 40,  80, 120, 110,  50, 130, 150, 120 ]</div>
<div class="line"> </div>
<div class="line">Note: The SUMs calculated at the group boundaries (i.e. indices 0, 4, 5, and 8)</div>
<div class="line">consider only 2 values each, in spite of the window-size being 3.</div>
<div class="line">Each aggregation operation cannot cross group boundaries.</div>
</div><!-- fragment --><p>The returned column for <code>op == COUNT</code> always has <code>INT32</code> type. All other operators return a column of the same type as the input. Therefore it is suggested to convert integer column types (especially low-precision integers) to <code>FLOAT32</code> or <code>FLOAT64</code> before doing a rolling <code>MEAN</code>.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">group_keys</td><td>The (pre-sorted) grouping columns </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input column (to be aggregated) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preceding_window</td><td>The static rolling window size in the backward direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">following_window</td><td>The static rolling window size in the forward direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_periods</td><td>Minimum number of observations in window required to have a value, otherwise element <code>i</code> is null. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aggr</td><td>The rolling window aggregation type (SUM, MAX, MIN, etc.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A nullable output column containing the rolling window results </dd></dl>

</div>
</div>
<a id="gabd62060125be568902bf4a4eef397fa8" name="gabd62060125be568902bf4a4eef397fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd62060125be568902bf4a4eef397fa8">&#9670;&#160;</a></span>grouped_rolling_window() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::grouped_rolling_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>group_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1window__bounds.html">window_bounds</a>&#160;</td>
          <td class="paramname"><em>preceding_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1window__bounds.html">window_bounds</a>&#160;</td>
          <td class="paramname"><em>following_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>min_periods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;&#160;</td>
          <td class="paramname"><em>aggr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a grouping-aware, fixed-size rolling window function to the values in a column.   </p>
<p>Like <code><a class="el" href="group__aggregation__rolling.html#ga0dfc1f001d211212169ead998d484845" title="Applies a fixed-size rolling window function to the values in a column.">rolling_window()</a></code>, this function aggregates values in a window around each element of a specified <code>input</code> column. It differs from <code><a class="el" href="group__aggregation__rolling.html#ga0dfc1f001d211212169ead998d484845" title="Applies a fixed-size rolling window function to the values in a column.">rolling_window()</a></code> in that elements of the <code>input</code> column are grouped into distinct groups (e.g. the result of a groupby). The window aggregation cannot cross the group boundaries. For a row <code>i</code> of <code>input</code>, the group is determined from the corresponding (i.e. i-th) values of the columns under <code>group_keys</code>.</p>
<p>Note: This method requires that the rows are presorted by the <code>group_key</code> values.</p>
<div class="fragment"><div class="line">Example: Consider a user-sales dataset, where the rows look as follows:</div>
<div class="line">{ &quot;user_id&quot;, sales_amt, day }</div>
<div class="line"> </div>
<div class="line">The `grouped_rolling_window()` method enables windowing queries such as grouping a dataset by</div>
<div class="line">`user_id`, and summing up the `sales_amt` column over a window of 3 rows (2 preceding (including</div>
<div class="line">current row), 1 row following).</div>
<div class="line"> </div>
<div class="line">In this example,</div>
<div class="line">   1. `group_keys == [ user_id ]`</div>
<div class="line">   2. `input == sales_amt`</div>
<div class="line">The data are grouped by `user_id`, and ordered by `day`-string. The aggregation</div>
<div class="line">(SUM) is then calculated for a window of 3 values around (and including) each row.</div>
<div class="line"> </div>
<div class="line">For the following input:</div>
<div class="line"> </div>
<div class="line"> [ // user,  sales_amt</div>
<div class="line">   { &quot;user1&quot;,   10      },</div>
<div class="line">   { &quot;user2&quot;,   20      },</div>
<div class="line">   { &quot;user1&quot;,   20      },</div>
<div class="line">   { &quot;user1&quot;,   10      },</div>
<div class="line">   { &quot;user2&quot;,   30      },</div>
<div class="line">   { &quot;user2&quot;,   80      },</div>
<div class="line">   { &quot;user1&quot;,   50      },</div>
<div class="line">   { &quot;user1&quot;,   60      },</div>
<div class="line">   { &quot;user2&quot;,   40      }</div>
<div class="line"> ]</div>
<div class="line"> </div>
<div class="line">Partitioning (grouping) by `user_id` yields the following `sales_amt` vector</div>
<div class="line">(with 2 groups, one for each distinct `user_id`):</div>
<div class="line"> </div>
<div class="line">   [ 10,  20,  10,  50,  60,  20,  30,  80,  40 ]</div>
<div class="line">     &lt;-------user1--------&gt;|&lt;------user2-------&gt;</div>
<div class="line"> </div>
<div class="line">The SUM aggregation is applied with 1 preceding and 1 following</div>
<div class="line">row, with a minimum of 1 period. The aggregation window is thus 3 rows wide,</div>
<div class="line">yielding the following column:</div>
<div class="line"> </div>
<div class="line">   [ 30, 40,  80, 120, 110,  50, 130, 150, 120 ]</div>
<div class="line"> </div>
<div class="line">Note: The SUMs calculated at the group boundaries (i.e. indices 0, 4, 5, and 8)</div>
<div class="line">consider only 2 values each, in spite of the window-size being 3.</div>
<div class="line">Each aggregation operation cannot cross group boundaries.</div>
</div><!-- fragment --><p>The returned column for <code>op == COUNT</code> always has <code>INT32</code> type. All other operators return a column of the same type as the input. Therefore it is suggested to convert integer column types (especially low-precision integers) to <code>FLOAT32</code> or <code>FLOAT64</code> before doing a rolling <code>MEAN</code>.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">group_keys</td><td>The (pre-sorted) grouping columns </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input column (to be aggregated) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preceding_window</td><td>The static rolling window size in the backward direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">following_window</td><td>The static rolling window size in the forward direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_periods</td><td>Minimum number of observations in window required to have a value, otherwise element <code>i</code> is null. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aggr</td><td>The rolling window aggregation type (SUM, MAX, MIN, etc.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A nullable output column containing the rolling window results   </dd></dl>

</div>
</div>
<a id="ga167a23498c3e82313df80f653b3c48b1" name="ga167a23498c3e82313df80f653b3c48b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga167a23498c3e82313df80f653b3c48b1">&#9670;&#160;</a></span>grouped_time_range_rolling_window() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::grouped_time_range_rolling_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>group_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>timestamp_column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">cudf::order</a> const &amp;&#160;</td>
          <td class="paramname"><em>timestamp_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>preceding_window_in_days</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>following_window_in_days</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>min_periods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;&#160;</td>
          <td class="paramname"><em>aggr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a grouping-aware, timestamp-based rolling window function to the values in a column. </p>
<p>Like <code><a class="el" href="group__aggregation__rolling.html#ga0dfc1f001d211212169ead998d484845" title="Applies a fixed-size rolling window function to the values in a column.">rolling_window()</a></code>, this function aggregates values in a window around each element of a specified <code>input</code> column. It differs from <code><a class="el" href="group__aggregation__rolling.html#ga0dfc1f001d211212169ead998d484845" title="Applies a fixed-size rolling window function to the values in a column.">rolling_window()</a></code> in two respects:</p><ol type="1">
<li>The elements of the <code>input</code> column are grouped into distinct groups (e.g. the result of a groupby), determined by the corresponding values of the columns under <code>group_keys</code>. The window-aggregation cannot cross the group boundaries.</li>
<li>Within a group, the aggregation window is calculated based on a time interval (e.g. number of days preceding/following the current row). The timestamps for the input data are specified by the <code>timestamp_column</code> argument.</li>
</ol>
<p>Note: This method requires that the rows are presorted by the group keys and timestamp values.</p>
<div class="fragment"><div class="line">  Example: Consider a user-sales dataset, where the rows look as follows:</div>
<div class="line">   { &quot;user_id&quot;, sales_amt, date }</div>
<div class="line"> </div>
<div class="line">  This method enables windowing queries such as grouping a dataset by `user_id`, sorting by</div>
<div class="line">  increasing `date`, and summing up the `sales_amt` column over a window of 3 days (1 preceding</div>
<div class="line">*day, the current day, and 1 following day).</div>
<div class="line"> </div>
<div class="line">  In this example,</div>
<div class="line">     1. `group_keys == [ user_id ]`</div>
<div class="line">     2. `timestamp_column == date`</div>
<div class="line">     3. `input == sales_amt`</div>
<div class="line">  The data are grouped by `user_id`, and ordered by `date`. The aggregation</div>
<div class="line">  (SUM) is then calculated for a window of 3 days around (and including) each row.</div>
<div class="line"> </div>
<div class="line">  For the following input:</div>
<div class="line"> </div>
<div class="line">   [ // user,  sales_amt,  YYYYMMDD (date)</div>
<div class="line">     { &quot;user1&quot;,   10,      20200101    },</div>
<div class="line">     { &quot;user2&quot;,   20,      20200101    },</div>
<div class="line">     { &quot;user1&quot;,   20,      20200102    },</div>
<div class="line">     { &quot;user1&quot;,   10,      20200103    },</div>
<div class="line">     { &quot;user2&quot;,   30,      20200101    },</div>
<div class="line">     { &quot;user2&quot;,   80,      20200102    },</div>
<div class="line">     { &quot;user1&quot;,   50,      20200107    },</div>
<div class="line">     { &quot;user1&quot;,   60,      20200107    },</div>
<div class="line">     { &quot;user2&quot;,   40,      20200104    }</div>
<div class="line">   ]</div>
<div class="line"> </div>
<div class="line">  Partitioning (grouping) by `user_id`, and ordering by `date` yields the following `sales_amt`</div>
<div class="line">  vector (with 2 groups, one for each distinct `user_id`):</div>
<div class="line"> </div>
<div class="line">  Date :(202001-)  [ 01,  02,  03,  07,  07,    01,   01,   02,  04 ]</div>
<div class="line">  Input:           [ 10,  20,  10,  50,  60,    20,   30,   80,  40 ]</div>
<div class="line">                     &lt;-------user1--------&gt;|&lt;---------user2---------&gt;</div>
<div class="line"> </div>
<div class="line">  The SUM aggregation is applied, with 1 day preceding, and 1 day following, with a minimum of 1</div>
<div class="line">  period. The aggregation window is thus 3 *days* wide, yielding the following output column:</div>
<div class="line"> </div>
<div class="line">   Results:        [ 30,  40,  30,  110, 110,  130,  130,  130,  40 ]</div>
</div><!-- fragment --><p>Note: The number of rows participating in each window might vary, based on the index within the group, datestamp, and <code>min_periods</code>. Apropos:</p><ol type="1">
<li>results[0] considers 2 values, because it is at the beginning of its group, and has no preceding values.</li>
<li>results[5] considers 3 values, despite being at the beginning of its group. It must include 2 following values, based on its datestamp.</li>
</ol>
<p>Each aggregation operation cannot cross group boundaries.</p>
<p>The returned column for <code>op == COUNT</code> always has <code>INT32</code> type. All other operators return a column of the same type as the input. Therefore it is suggested to convert integer column types (especially low-precision integers) to <code>FLOAT32</code> or <code>FLOAT64</code> before doing a rolling <code>MEAN</code>.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">group_keys</td><td>The (pre-sorted) grouping columns </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timestamp_column</td><td>The (pre-sorted) timestamps for each row </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timestamp_order</td><td>The order (ASCENDING/DESCENDING) in which the timestamps are sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input column (to be aggregated) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preceding_window_in_days</td><td>The rolling window time-interval in the backward direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">following_window_in_days</td><td>The rolling window time-interval in the forward direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_periods</td><td>Minimum number of observations in window required to have a value, otherwise element <code>i</code> is null. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aggr</td><td>The rolling window aggregation type (SUM, MAX, MIN, etc.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A nullable output column containing the rolling window results </dd></dl>

</div>
</div>
<a id="ga7f53b18345a094351160b187b263b746" name="ga7f53b18345a094351160b187b263b746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f53b18345a094351160b187b263b746">&#9670;&#160;</a></span>grouped_time_range_rolling_window() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::grouped_time_range_rolling_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>group_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>timestamp_column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">cudf::order</a> const &amp;&#160;</td>
          <td class="paramname"><em>timestamp_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1window__bounds.html">window_bounds</a>&#160;</td>
          <td class="paramname"><em>preceding_window_in_days</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1window__bounds.html">window_bounds</a>&#160;</td>
          <td class="paramname"><em>following_window_in_days</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>min_periods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;&#160;</td>
          <td class="paramname"><em>aggr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a grouping-aware, timestamp-based rolling window function to the values in a column,. </p>
<p>Like <code><a class="el" href="group__aggregation__rolling.html#ga0dfc1f001d211212169ead998d484845" title="Applies a fixed-size rolling window function to the values in a column.">rolling_window()</a></code>, this function aggregates values in a window around each element of a specified <code>input</code> column. It differs from <code><a class="el" href="group__aggregation__rolling.html#ga0dfc1f001d211212169ead998d484845" title="Applies a fixed-size rolling window function to the values in a column.">rolling_window()</a></code> in two respects:</p><ol type="1">
<li>The elements of the <code>input</code> column are grouped into distinct groups (e.g. the result of a groupby), determined by the corresponding values of the columns under <code>group_keys</code>. The window-aggregation cannot cross the group boundaries.</li>
<li>Within a group, the aggregation window is calculated based on a time interval (e.g. number of days preceding/following the current row). The timestamps for the input data are specified by the <code>timestamp_column</code> argument.</li>
</ol>
<p>Note: This method requires that the rows are presorted by the group keys and timestamp values.</p>
<div class="fragment"><div class="line">  Example: Consider a user-sales dataset, where the rows look as follows:</div>
<div class="line">   { &quot;user_id&quot;, sales_amt, date }</div>
<div class="line"> </div>
<div class="line">  This method enables windowing queries such as grouping a dataset by `user_id`, sorting by</div>
<div class="line">  increasing `date`, and summing up the `sales_amt` column over a window of 3 days (1 preceding</div>
<div class="line">*day, the current day, and 1 following day).</div>
<div class="line"> </div>
<div class="line">  In this example,</div>
<div class="line">     1. `group_keys == [ user_id ]`</div>
<div class="line">     2. `timestamp_column == date`</div>
<div class="line">     3. `input == sales_amt`</div>
<div class="line">  The data are grouped by `user_id`, and ordered by `date`. The aggregation</div>
<div class="line">  (SUM) is then calculated for a window of 3 days around (and including) each row.</div>
<div class="line"> </div>
<div class="line">  For the following input:</div>
<div class="line"> </div>
<div class="line">   [ // user,  sales_amt,  YYYYMMDD (date)</div>
<div class="line">     { &quot;user1&quot;,   10,      20200101    },</div>
<div class="line">     { &quot;user2&quot;,   20,      20200101    },</div>
<div class="line">     { &quot;user1&quot;,   20,      20200102    },</div>
<div class="line">     { &quot;user1&quot;,   10,      20200103    },</div>
<div class="line">     { &quot;user2&quot;,   30,      20200101    },</div>
<div class="line">     { &quot;user2&quot;,   80,      20200102    },</div>
<div class="line">     { &quot;user1&quot;,   50,      20200107    },</div>
<div class="line">     { &quot;user1&quot;,   60,      20200107    },</div>
<div class="line">     { &quot;user2&quot;,   40,      20200104    }</div>
<div class="line">   ]</div>
<div class="line"> </div>
<div class="line">  Partitioning (grouping) by `user_id`, and ordering by `date` yields the following `sales_amt`</div>
<div class="line">  vector (with 2 groups, one for each distinct `user_id`):</div>
<div class="line"> </div>
<div class="line">  Date :(202001-)  [ 01,  02,  03,  07,  07,    01,   01,   02,  04 ]</div>
<div class="line">  Input:           [ 10,  20,  10,  50,  60,    20,   30,   80,  40 ]</div>
<div class="line">                     &lt;-------user1--------&gt;|&lt;---------user2---------&gt;</div>
<div class="line"> </div>
<div class="line">  The SUM aggregation is applied, with 1 day preceding, and 1 day following, with a minimum of 1</div>
<div class="line">  period. The aggregation window is thus 3 *days* wide, yielding the following output column:</div>
<div class="line"> </div>
<div class="line">   Results:        [ 30,  40,  30,  110, 110,  130,  130,  130,  40 ]</div>
</div><!-- fragment --><p>Note: The number of rows participating in each window might vary, based on the index within the group, datestamp, and <code>min_periods</code>. Apropos:</p><ol type="1">
<li>results[0] considers 2 values, because it is at the beginning of its group, and has no preceding values.</li>
<li>results[5] considers 3 values, despite being at the beginning of its group. It must include 2 following values, based on its datestamp.</li>
</ol>
<p>Each aggregation operation cannot cross group boundaries.</p>
<p>The returned column for <code>op == COUNT</code> always has <code>INT32</code> type. All other operators return a column of the same type as the input. Therefore it is suggested to convert integer column types (especially low-precision integers) to <code>FLOAT32</code> or <code>FLOAT64</code> before doing a rolling <code>MEAN</code>.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">group_keys</td><td>The (pre-sorted) grouping columns </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timestamp_column</td><td>The (pre-sorted) timestamps for each row </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timestamp_order</td><td>The order (ASCENDING/DESCENDING) in which the timestamps are sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input column (to be aggregated) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preceding_window_in_days</td><td>The rolling window time-interval in the backward direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">following_window_in_days</td><td>The rolling window time-interval in the forward direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_periods</td><td>Minimum number of observations in window required to have a value, otherwise element <code>i</code> is null. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aggr</td><td>The rolling window aggregation type (SUM, MAX, MIN, etc.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A nullable output column containing the rolling window results  </dd></dl>
<p>The <code>preceding_window_in_days</code> and <code>following_window_in_days</code> are specified as a <code><a class="el" href="structcudf_1_1window__bounds.html" title="Abstraction for window boundary sizes">window_bounds</a></code> and supports "unbounded" windows, if set to <code><a class="el" href="structcudf_1_1window__bounds.html#a2e188fd2bd683e913dd86f082ee1ffa0" title="Construct unbounded window boundary.">window_bounds::unbounded()</a></code>. </p>

</div>
</div>
<a id="ga350324e8e9ab0d4969d8de7597f2a242" name="ga350324e8e9ab0d4969d8de7597f2a242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga350324e8e9ab0d4969d8de7597f2a242">&#9670;&#160;</a></span>rolling_window() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::rolling_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>default_outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>preceding_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>following_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>min_periods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;&#160;</td>
          <td class="paramname"><em>agg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a fixed-size rolling window function to the values in a column.   </p>
<p>This function aggregates values in a window around each element i of the input column, and invalidates the bit mask for element i if there are not enough observations. The window size is static (the same for each element). This matches Pandas' API for DataFrame.rolling with a few notable differences:</p><ul>
<li>instead of the center flag it uses a two-part window to allow for more flexible windows. The total window size = <code>preceding_window + following_window</code>. Element <code>i</code> uses elements <code>[i-preceding_window+1, i+following_window]</code> to do the window computation.</li>
<li>instead of storing NA/NaN for output rows that do not meet the minimum number of observations this function updates the valid bitmask of the column to indicate which elements are valid.</li>
</ul>
<p>Notes on return column types:</p><ul>
<li>The returned column for count aggregation always has <code>INT32</code> type.</li>
<li>The returned column for VARIANCE/STD aggregations always has <code>FLOAT64</code> type.</li>
<li>All other operators return a column of the same type as the input. Therefore it is suggested to convert integer column types (especially low-precision integers) to <code>FLOAT32</code> or <code>FLOAT64</code> before doing a rolling <code>MEAN</code>.</li>
</ul>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preceding_window</td><td>The static rolling window size in the backward direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">following_window</td><td>The static rolling window size in the forward direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_periods</td><td>Minimum number of observations in window required to have a value, otherwise element <code>i</code> is null. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">agg</td><td>The rolling window aggregation type (SUM, MAX, MIN, etc.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A nullable output column containing the rolling window results  </dd></dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">default_outputs</td><td>A column of per-row default values to be returned instead of nulls. Used for LEAD()/LAG(), if the row offset crosses the boundaries of the column. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaed6574615700cec1d4bf5469fe28141" name="gaaed6574615700cec1d4bf5469fe28141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaed6574615700cec1d4bf5469fe28141">&#9670;&#160;</a></span>rolling_window() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::rolling_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>preceding_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>following_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>min_periods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;&#160;</td>
          <td class="paramname"><em>agg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a variable-size rolling window function to the values in a column. </p>
<p>This function aggregates values in a window around each element i of the input column, and invalidates the bit mask for element i if there are not enough observations. The window size is dynamic (varying for each element). This matches Pandas' API for DataFrame.rolling with a few notable differences:</p><ul>
<li>instead of the center flag it uses a two-part window to allow for more flexible windows. The total window size = <code>preceding_window + following_window</code>. Element <code>i</code> uses elements <code>[i-preceding_window+1, i+following_window]</code> to do the window computation.</li>
<li>instead of storing NA/NaN for output rows that do not meet the minimum number of observations this function updates the valid bitmask of the column to indicate which elements are valid.</li>
<li>support for dynamic rolling windows, i.e. window size can be specified for each element using an additional array.</li>
</ul>
<p>The returned column for count aggregation always has INT32 type. All other operators return a column of the same type as the input. Therefore it is suggested to convert integer column types (especially low-precision integers) to <code>FLOAT32</code> or <code>FLOAT64</code> before doing a rolling <code>MEAN</code>.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if window column type is not INT32</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preceding_window</td><td>A non-nullable column of INT32 window sizes in the forward direction. <code>preceding_window[i]</code> specifies preceding window size for element <code>i</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">following_window</td><td>A non-nullable column of INT32 window sizes in the backward direction. <code>following_window[i]</code> specifies following window size for element <code>i</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_periods</td><td>Minimum number of observations in window required to have a value, otherwise element <code>i</code> is null. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">agg</td><td>The rolling window aggregation type (sum, max, min, etc.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A nullable output column containing the rolling window results </dd></dl>

</div>
</div>
<a id="ga0dfc1f001d211212169ead998d484845" name="ga0dfc1f001d211212169ead998d484845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0dfc1f001d211212169ead998d484845">&#9670;&#160;</a></span>rolling_window() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::rolling_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>preceding_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>following_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>min_periods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;&#160;</td>
          <td class="paramname"><em>agg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a fixed-size rolling window function to the values in a column. </p>
<p>This function aggregates values in a window around each element i of the input column, and invalidates the bit mask for element i if there are not enough observations. The window size is static (the same for each element). This matches Pandas' API for DataFrame.rolling with a few notable differences:</p><ul>
<li>instead of the center flag it uses a two-part window to allow for more flexible windows. The total window size = <code>preceding_window + following_window</code>. Element <code>i</code> uses elements <code>[i-preceding_window+1, i+following_window]</code> to do the window computation.</li>
<li>instead of storing NA/NaN for output rows that do not meet the minimum number of observations this function updates the valid bitmask of the column to indicate which elements are valid.</li>
</ul>
<p>Notes on return column types:</p><ul>
<li>The returned column for count aggregation always has <code>INT32</code> type.</li>
<li>The returned column for VARIANCE/STD aggregations always has <code>FLOAT64</code> type.</li>
<li>All other operators return a column of the same type as the input. Therefore it is suggested to convert integer column types (especially low-precision integers) to <code>FLOAT32</code> or <code>FLOAT64</code> before doing a rolling <code>MEAN</code>.</li>
</ul>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input column </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">preceding_window</td><td>The static rolling window size in the backward direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">following_window</td><td>The static rolling window size in the forward direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_periods</td><td>Minimum number of observations in window required to have a value, otherwise element <code>i</code> is null. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">agg</td><td>The rolling window aggregation type (SUM, MAX, MIN, etc.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A nullable output column containing the rolling window results </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
