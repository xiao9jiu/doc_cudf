<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: cudf 命名空间参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacecudf.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">命名空间</a> &#124;
<a href="#nested-classes">类</a> &#124;
<a href="#typedef-members">类型定义</a> &#124;
<a href="#enum-members">枚举</a> &#124;
<a href="#func-members">函数</a> &#124;
<a href="#var-members">变量</a>  </div>
  <div class="headertitle"><div class="title">cudf 命名空间参考<div class="ingroups"><a class="el" href="group__utility__error.html">Utility_error</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>cuDF interfaces  
<a href="namespacecudf.html#details">更多...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
命名空间</h2></td></tr>
<tr class="memitem:namespacecudf_1_1ast"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1ast.html">ast</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecudf_1_1binops"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1binops.html">binops</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecudf_1_1datetime"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1datetime.html">datetime</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecudf_1_1detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1detail.html">detail</a></td></tr>
<tr class="memdesc:namespacecudf_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inner interfaces and implementations <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecudf_1_1dictionary"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1dictionary.html">dictionary</a></td></tr>
<tr class="memdesc:namespacecudf_1_1dictionary"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dictionary column APIs. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecudf_1_1groupby"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1groupby.html">groupby</a></td></tr>
<tr class="memdesc:namespacecudf_1_1groupby"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>groupby</code> APIs <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecudf_1_1io"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1io.html">io</a></td></tr>
<tr class="memdesc:namespacecudf_1_1io"><td class="mdescLeft">&#160;</td><td class="mdescRight">IO interfaces <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecudf_1_1lists"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1lists.html">lists</a></td></tr>
<tr class="memdesc:namespacecudf_1_1lists"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists column APIs <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecudf_1_1reduction"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1reduction.html">reduction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecudf_1_1strings"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1strings.html">strings</a></td></tr>
<tr class="memdesc:namespacecudf_1_1strings"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strings column APIs <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecudf_1_1structs"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1structs.html">structs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecudf_1_1tdigest"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1tdigest.html">tdigest</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecudf_1_1util"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1util.html">util</a></td></tr>
<tr class="memdesc:namespacecudf_1_1util"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility functions <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
类</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1aggregation.html">aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for specifying the desired aggregation in an <code>aggregation_request</code>.  <a href="classcudf_1_1aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1chrono__scalar.html">chrono_scalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An owning class to represent a timestamp/duration value in device memory.  <a href="classcudf_1_1chrono__scalar.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1column.html">column</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container of nullable device data as a column of elements.  <a href="classcudf_1_1column.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1column__metadata.html">column_metadata</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detailed metadata information for arrow array.  <a href="structcudf_1_1column__metadata.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1column__view.html">column_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-owning, immutable view of device data as a column of elements, some of which may be null as indicated by a bitmask.  <a href="classcudf_1_1column__view.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1cuda__error.html">cuda_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when a CUDA error is encountered.  <a href="structcudf_1_1cuda__error.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1data__type.html">data_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicator for the logical data type of an element in a column.  <a href="classcudf_1_1data__type.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1device__span.html">device_span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device version of C++20 std::span with reduced feature set.  <a href="structcudf_1_1device__span.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1dictionary__column__view.html">dictionary_column_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper class for operations on a dictionary column.  <a href="classcudf_1_1dictionary__column__view.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1dictionary__wrapper.html">dictionary_wrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A strongly typed wrapper for indices in a DICTIONARY type column.  <a href="structcudf_1_1dictionary__wrapper.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1dispatch__storage__type.html">dispatch_storage_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this specialization on <code>type_dispatcher</code> whenever you only need to operate on the underlying stored type.  <a href="structcudf_1_1dispatch__storage__type.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1duration__scalar.html">duration_scalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An owning class to represent a duration value in device memory.  <a href="classcudf_1_1duration__scalar.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1duration__scalar__device__view.html">duration_scalar_device_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1fatal__cuda__error.html">fatal_cuda_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1fixed__point__scalar.html">fixed_point_scalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An owning class to represent a fixed_point number in device memory.  <a href="classcudf_1_1fixed__point__scalar.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1fixed__point__scalar__device__view.html">fixed_point_scalar_device_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1groupby__aggregation.html">groupby_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class intended for groupby specific aggregation usage.  <a href="classcudf_1_1groupby__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1groupby__scan__aggregation.html">groupby_scan_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class intended for groupby specific scan usage.  <a href="classcudf_1_1groupby__scan__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1hash__join.html">hash_join</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash join that builds hash table in creation and probes results in subsequent <code>*_join</code> member functions.  <a href="classcudf_1_1hash__join.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1host__span.html">host_span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++20 std::span with reduced feature set.  <a href="structcudf_1_1host__span.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1id__to__type__impl.html">id_to_type_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1is__convertible.html">is_convertible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1is__convertible_3_01cudf_1_1detail_1_1timestamp_3_01_duration1_01_4_00_01cudf_1_1daa0b9b43387383cde2e3c74f3ffafc24.html">is_convertible&lt; cudf::detail::timestamp&lt; Duration1 &gt;, cudf::detail::timestamp&lt; Duration2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1is__device__span__supported__container.html">is_device_span_supported_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1is__device__span__supported__container_3_01rmm_1_1device__uvector_3_01_t_01_4_01_4.html">is_device_span_supported_container&lt; rmm::device_uvector&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1is__device__span__supported__container_3_01rmm_1_1device__vector_3_01_t_01_4_01_4.html">is_device_span_supported_container&lt; rmm::device_vector&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1is__device__span__supported__container_3_01thrust_1_1device__vector_3_01_t_00_01_alloc_01_4_01_4.html">is_device_span_supported_container&lt; thrust::device_vector&lt; T, Alloc &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1is__host__span__supported__container.html">is_host_span_supported_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1is__host__span__supported__container_3_01std_1_1basic__string_3_01_t_00_01std_1_1c61bc91e581171fc0cf8b4a95db4a7c39.html">is_host_span_supported_container&lt; std::basic_string&lt; T, std::char_traits&lt; T &gt;, Alloc &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1is__host__span__supported__container_3_01std_1_1vector_3_01_t_00_01_alloc_01_4_01_4.html">is_host_span_supported_container&lt; std::vector&lt; T, Alloc &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1is__host__span__supported__container_3_01thrust_1_1host__vector_3_01_t_00_01_alloc_01_4_01_4.html">is_host_span_supported_container&lt; thrust::host_vector&lt; T, Alloc &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1libcudf__domain.html">libcudf_domain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type for libcudf's NVTX domain.  <a href="structcudf_1_1libcudf__domain.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1list__scalar.html">list_scalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An owning class to represent a list value in device memory.  <a href="classcudf_1_1list__scalar.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1list__view.html">list_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-owning, immutable view of device data that represents a list of elements of arbitrary type (including further nested lists).  <a href="classcudf_1_1list__view.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1lists__column__view.html">lists_column_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a column-view of lists type, an instance of this class provides a wrapper on this compound column for list operations.  <a href="classcudf_1_1lists__column__view.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1logic__error.html">logic_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when logical precondition is violated.  <a href="structcudf_1_1logic__error.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1mutable__column__view.html">mutable_column_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-owning, mutable view of device data as a column of elements, some of which may be null as indicated by a bitmask.  <a href="classcudf_1_1mutable__column__view.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1mutable__table__view.html">mutable_table_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of <code><a class="el" href="classcudf_1_1mutable__column__view.html" title="A non-owning, mutable view of device data as a column of elements, some of which may be null as indic...">mutable_column_view</a></code>s of the same size.  <a href="classcudf_1_1mutable__table__view.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1numeric__scalar.html">numeric_scalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An owning class to represent a numerical value in device memory.  <a href="classcudf_1_1numeric__scalar.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1numeric__scalar__device__view.html">numeric_scalar_device_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1order__info.html">order_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates how a collection of values has been ordered.  <a href="structcudf_1_1order__info.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1packed__columns.html">packed_columns</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column data in a serialized format  <a href="structcudf_1_1packed__columns.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1packed__table.html">packed_table</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result(s) of a <a class="el" href="group__column__copy.html#gab171e877b57253d521eb8f6d3c7d7c4a" title="Performs a deep-copy split of a table_view into a set of table_views into a single contiguous block o...">cudf::contiguous_split</a>  <a href="structcudf_1_1packed__table.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1range__window__bounds.html">range_window_bounds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstraction for window boundary sizes, to be used with <code><a class="el" href="group__aggregation__rolling.html#ga595d27d939a1af9d00d2b6bea3b5623c" title="Applies a grouping-aware, value range-based rolling window function to the values in a column.">grouped_range_rolling_window()</a></code>.  <a href="structcudf_1_1range__window__bounds.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1reduce__aggregation.html">reduce_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class intended for reduction usage.  <a href="classcudf_1_1reduce__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class intended for rolling_window specific aggregation usage.  <a href="classcudf_1_1rolling__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1scalar.html">scalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An owning class to represent a singular value.  <a href="classcudf_1_1scalar.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1scan__aggregation.html">scan_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class intended for scan usage.  <a href="classcudf_1_1scan__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1segmented__reduce__aggregation.html">segmented_reduce_aggregation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived class intended for segmented reduction usage.  <a href="classcudf_1_1segmented__reduce__aggregation.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1string__scalar.html">string_scalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An owning class to represent a string in device memory.  <a href="classcudf_1_1string__scalar.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1string__view.html">string_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-owning, immutable view of device data that is a variable length char array representing a UTF-8 string.  <a href="classcudf_1_1string__view.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a column-view of strings type, an instance of this class provides a wrapper on this compound column for strings operations.  <a href="classcudf_1_1strings__column__view.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1struct__scalar.html">struct_scalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An owning class to represent a struct value in device memory.  <a href="classcudf_1_1struct__scalar.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1struct__view.html">struct_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-owning, immutable view of device data that represents a struct with fields of arbitrary types (including primitives, lists, and other structs)  <a href="classcudf_1_1struct__view.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1structs__column__view.html">structs_column_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a column view of struct type, an instance of this class provides a wrapper on this compound column for struct operations.  <a href="classcudf_1_1structs__column__view.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1table.html">table</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of <a class="el" href="classcudf_1_1column.html" title="A container of nullable device data as a column of elements.">cudf::column</a>'s of the same size.  <a href="classcudf_1_1table.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1table__view.html">table_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">cudf::column_view</a>'s of the same size.  <a href="classcudf_1_1table__view.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1timestamp__scalar.html">timestamp_scalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An owning class to represent a timestamp value in device memory.  <a href="classcudf_1_1timestamp__scalar.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1timestamp__scalar__device__view.html">timestamp_scalar_device_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1type__to__name.html">type_to_name</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a <code><a class="el" href="group__utility__types.html#gadf077607da617d1dadcc5417e2783539" title="Identifies a column&#39;s logical element type">cudf::type_id</a></code> types to it's corresponding C++ type name string  <a href="structcudf_1_1type__to__name.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1type__to__scalar__type__impl.html">type_to_scalar_type_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1type__to__scalar__type__impl_3_01cudf_1_1dictionary32_01_4.html">type_to_scalar_type_impl&lt; cudf::dictionary32 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1type__to__scalar__type__impl_3_01cudf_1_1list__view_01_4.html">type_to_scalar_type_impl&lt; cudf::list_view &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1type__to__scalar__type__impl_3_01cudf_1_1string__view_01_4.html">type_to_scalar_type_impl&lt; cudf::string_view &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1type__to__scalar__type__impl_3_01cudf_1_1struct__view_01_4.html">type_to_scalar_type_impl&lt; cudf::struct_view &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1type__to__scalar__type__impl_3_01numeric_1_1decimal128_01_4.html">type_to_scalar_type_impl&lt; numeric::decimal128 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1type__to__scalar__type__impl_3_01numeric_1_1decimal32_01_4.html">type_to_scalar_type_impl&lt; numeric::decimal32 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1type__to__scalar__type__impl_3_01numeric_1_1decimal64_01_4.html">type_to_scalar_type_impl&lt; numeric::decimal64 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1type__to__scalar__type__impl_3_01std_1_1string_01_4.html">type_to_scalar_type_impl&lt; std::string &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1window__bounds.html">window_bounds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstraction for window boundary sizes  <a href="structcudf_1_1window__bounds.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
类型定义</h2></td></tr>
<tr class="memitem:aff73bd537f5aa6cb5eaea205ddad27d1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aff73bd537f5aa6cb5eaea205ddad27d1">thread_range</a> = <a class="el" href="classnvtx3_1_1domain__thread__range.html">::nvtx3::domain_thread_range</a>&lt; <a class="el" href="structcudf_1_1libcudf__domain.html">libcudf_domain</a> &gt;</td></tr>
<tr class="memdesc:aff73bd537f5aa6cb5eaea205ddad27d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for an NVTX range in the libcudf domain.  <br /></td></tr>
<tr class="separator:aff73bd537f5aa6cb5eaea205ddad27d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b5509c0aeedbdb5bce4dc3b6869f26"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a98b5509c0aeedbdb5bce4dc3b6869f26">hash_value_type</a> = uint32_t</td></tr>
<tr class="memdesc:a98b5509c0aeedbdb5bce4dc3b6869f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of hash value  <br /></td></tr>
<tr class="separator:a98b5509c0aeedbdb5bce4dc3b6869f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f547550d24ad068f9f8ad75886af56"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#af4f547550d24ad068f9f8ad75886af56">char_utf8</a> = uint32_t</td></tr>
<tr class="memdesc:af4f547550d24ad068f9f8ad75886af56"><td class="mdescLeft">&#160;</td><td class="mdescRight">UTF-8 characters are 1-4 bytes  <br /></td></tr>
<tr class="separator:af4f547550d24ad068f9f8ad75886af56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aff16b2db009d92300befaca11827e9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> = int32_t</td></tr>
<tr class="memdesc:ga0aff16b2db009d92300befaca11827e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row index type for columns and tables  <br /></td></tr>
<tr class="separator:ga0aff16b2db009d92300befaca11827e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d17001baf070a639c3a5e8ed8c46d34"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> = uint32_t</td></tr>
<tr class="memdesc:ga1d17001baf070a639c3a5e8ed8c46d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitmask type stored as 32-bit unsigned integer  <br /></td></tr>
<tr class="separator:ga1d17001baf070a639c3a5e8ed8c46d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b06145972e36cd6b4d72ad20dd10ac1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga9b06145972e36cd6b4d72ad20dd10ac1">valid_type</a> = uint8_t</td></tr>
<tr class="memdesc:ga9b06145972e36cd6b4d72ad20dd10ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Valid type in host memory  <br /></td></tr>
<tr class="separator:ga9b06145972e36cd6b4d72ad20dd10ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3391e2df0069d3e7a07f0ec96cd2473e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga3391e2df0069d3e7a07f0ec96cd2473e">offset_type</a> = int32_t</td></tr>
<tr class="memdesc:ga3391e2df0069d3e7a07f0ec96cd2473e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offset type for column offsets  <br /></td></tr>
<tr class="separator:ga3391e2df0069d3e7a07f0ec96cd2473e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7291486dc8f7911dffca95ee8ea3aa7c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga7291486dc8f7911dffca95ee8ea3aa7c">thread_index_type</a> = int64_t</td></tr>
<tr class="memdesc:ga7291486dc8f7911dffca95ee8ea3aa7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread index type in kernels  <br /></td></tr>
<tr class="separator:ga7291486dc8f7911dffca95ee8ea3aa7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9130d674f5ef432c1405fadd304a8c26"><td class="memTemplParams" colspan="2">template&lt;typename... &gt; </td></tr>
<tr class="memitem:ga9130d674f5ef432c1405fadd304a8c26"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga9130d674f5ef432c1405fadd304a8c26">void_t</a> = void</td></tr>
<tr class="memdesc:ga9130d674f5ef432c1405fadd304a8c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility metafunction that maps a sequence of any types to the type void.  <br /></td></tr>
<tr class="separator:ga9130d674f5ef432c1405fadd304a8c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cc1c1fe68e5031f9865b4d9114a2491"><td class="memTemplParams" colspan="2">template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ga6cc1c1fe68e5031f9865b4d9114a2491"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga6cc1c1fe68e5031f9865b4d9114a2491">less_comparable</a> = decltype(std::declval&lt; L &gt;()&lt; std::declval&lt; R &gt;())</td></tr>
<tr class="memdesc:ga6cc1c1fe68e5031f9865b4d9114a2491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two types are comparable using less operator (i.e. &lt;).  <br /></td></tr>
<tr class="separator:ga6cc1c1fe68e5031f9865b4d9114a2491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19a5866cc4b46bbff21bf863130d2f81"><td class="memTemplParams" colspan="2">template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ga19a5866cc4b46bbff21bf863130d2f81"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga19a5866cc4b46bbff21bf863130d2f81">greater_comparable</a> = decltype(std::declval&lt; L &gt;() &gt; std::declval&lt; R &gt;())</td></tr>
<tr class="memdesc:ga19a5866cc4b46bbff21bf863130d2f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two types are comparable using greater operator (i.e. &gt;).  <br /></td></tr>
<tr class="separator:ga19a5866cc4b46bbff21bf863130d2f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33f2db79a6c26d5d69a3c05cd057cee0"><td class="memTemplParams" colspan="2">template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ga33f2db79a6c26d5d69a3c05cd057cee0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga33f2db79a6c26d5d69a3c05cd057cee0">equality_comparable</a> = decltype(std::declval&lt; L &gt;()==std::declval&lt; R &gt;())</td></tr>
<tr class="memdesc:ga33f2db79a6c26d5d69a3c05cd057cee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two types are comparable using equality operator (i.e. ==).  <br /></td></tr>
<tr class="separator:ga33f2db79a6c26d5d69a3c05cd057cee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d6f7d2e962d0063973334a901bd5381"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ga3d6f7d2e962d0063973334a901bd5381"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga3d6f7d2e962d0063973334a901bd5381">has_common_type</a> = typename <a class="el" href="structcudf_1_1detail_1_1has__common__type__impl.html">detail::has_common_type_impl</a>&lt; void, Ts... &gt;::type</td></tr>
<tr class="memdesc:ga3d6f7d2e962d0063973334a901bd5381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if types have a common type  <br /></td></tr>
<tr class="separator:ga3d6f7d2e962d0063973334a901bd5381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafab27b9e2451d4b930739368788b79c8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gafab27b9e2451d4b930739368788b79c8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#gafab27b9e2451d4b930739368788b79c8">is_timestamp_t</a> = cuda::std::disjunction&lt; std::is_same&lt; <a class="el" href="group__timestamp__classes.html#ga4658424aa55596e2f3b6b42a9260f736">cudf::timestamp_D</a>, T &gt;, std::is_same&lt; <a class="el" href="group__timestamp__classes.html#ga44668df4b32894904fb68f13a5f0fdab">cudf::timestamp_s</a>, T &gt;, std::is_same&lt; <a class="el" href="group__timestamp__classes.html#ga24fdf63531f7998ef3122a5d0885e949">cudf::timestamp_ms</a>, T &gt;, std::is_same&lt; <a class="el" href="group__timestamp__classes.html#gabc5dd6cc3229f57af772e06f8c0bd828">cudf::timestamp_us</a>, T &gt;, std::is_same&lt; <a class="el" href="group__timestamp__classes.html#gae2aef2b10c32caf1889ef2a6575b531a">cudf::timestamp_ns</a>, T &gt; &gt;</td></tr>
<tr class="memdesc:gafab27b9e2451d4b930739368788b79c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a type is a timestamp type.  <br /></td></tr>
<tr class="separator:gafab27b9e2451d4b930739368788b79c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb8bb6a0673998a47423aca482d5b5ee"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gafb8bb6a0673998a47423aca482d5b5ee"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#gafb8bb6a0673998a47423aca482d5b5ee">is_duration_t</a> = cuda::std::disjunction&lt; std::is_same&lt; <a class="el" href="group__timestamp__classes.html#ga6a45112033b50dfa4988d71a0817131c">cudf::duration_D</a>, T &gt;, std::is_same&lt; <a class="el" href="group__timestamp__classes.html#gae344db373c1568bd20e914cb74426519">cudf::duration_s</a>, T &gt;, std::is_same&lt; <a class="el" href="group__timestamp__classes.html#ga70b6b95d45de41529211d95531fa3f86">cudf::duration_ms</a>, T &gt;, std::is_same&lt; <a class="el" href="group__timestamp__classes.html#gab8e261e3e2a11e8464efb2a251c107d7">cudf::duration_us</a>, T &gt;, std::is_same&lt; <a class="el" href="group__timestamp__classes.html#ga4efdb8225ec7e415ab3c660c066aa3ee">cudf::duration_ns</a>, T &gt; &gt;</td></tr>
<tr class="memdesc:gafb8bb6a0673998a47423aca482d5b5ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a type is a duration type.  <br /></td></tr>
<tr class="separator:gafb8bb6a0673998a47423aca482d5b5ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7e12b8accf60e7c0e500294e1ee8536"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__utility__types.html#gadf077607da617d1dadcc5417e2783539">cudf::type_id</a> Id&gt; </td></tr>
<tr class="memitem:gad7e12b8accf60e7c0e500294e1ee8536"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__dispatcher.html#gad7e12b8accf60e7c0e500294e1ee8536">id_to_type</a> = typename <a class="el" href="structcudf_1_1id__to__type__impl.html">id_to_type_impl</a>&lt; Id &gt;::type</td></tr>
<tr class="memdesc:gad7e12b8accf60e7c0e500294e1ee8536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a <code><a class="el" href="group__utility__types.html#gadf077607da617d1dadcc5417e2783539" title="Identifies a column&#39;s logical element type">cudf::type_id</a></code> to it's corresponding concrete C++ type  <br /></td></tr>
<tr class="separator:gad7e12b8accf60e7c0e500294e1ee8536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7811a3ca2cd4f1c558093dbbdda53b30"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7811a3ca2cd4f1c558093dbbdda53b30"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__dispatcher.html#ga7811a3ca2cd4f1c558093dbbdda53b30">device_storage_type_t</a> = std::conditional_t&lt; std::is_same_v&lt; <a class="el" href="group__fixed__point__classes.html#ga74f28c0e58f5105d5a67b658d839ffa0">numeric::decimal32</a>, T &gt;, int32_t, std::conditional_t&lt; std::is_same_v&lt; <a class="el" href="group__fixed__point__classes.html#ga85be3b2e76e27778378832af34cf88a5">numeric::decimal64</a>, T &gt;, int64_t, std::conditional_t&lt; std::is_same_v&lt; <a class="el" href="group__fixed__point__classes.html#ga9f2da6ca14cb6371184004c5aac343a0">numeric::decimal128</a>, T &gt;, __int128_t, T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga7811a3ca2cd4f1c558093dbbdda53b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Returns" the corresponding type that is stored on the device when using <code><a class="el" href="classcudf_1_1column.html" title="A container of nullable device data as a column of elements.">cudf::column</a></code>  <br /></td></tr>
<tr class="separator:ga7811a3ca2cd4f1c558093dbbdda53b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9446c2558fd01c19f5fb5fa33927586f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9446c2558fd01c19f5fb5fa33927586f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__dispatcher.html#ga9446c2558fd01c19f5fb5fa33927586f">scalar_type_t</a> = typename <a class="el" href="structcudf_1_1type__to__scalar__type__impl.html">type_to_scalar_type_impl</a>&lt; T &gt;::ScalarType</td></tr>
<tr class="memdesc:ga9446c2558fd01c19f5fb5fa33927586f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a C++ type to the scalar type required to hold its value  <br /></td></tr>
<tr class="separator:ga9446c2558fd01c19f5fb5fa33927586f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78eb25a7ce2c9e19a0193cdf14855d9b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga78eb25a7ce2c9e19a0193cdf14855d9b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__dispatcher.html#ga78eb25a7ce2c9e19a0193cdf14855d9b">scalar_device_type_t</a> = typename <a class="el" href="structcudf_1_1type__to__scalar__type__impl.html">type_to_scalar_type_impl</a>&lt; T &gt;::ScalarDeviceType</td></tr>
<tr class="memdesc:ga78eb25a7ce2c9e19a0193cdf14855d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a C++ type to the scalar device type required to hold its value  <br /></td></tr>
<tr class="separator:ga78eb25a7ce2c9e19a0193cdf14855d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f61b43ec5ca88c8a4ad40e09b4d58f6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dictionary__classes.html#ga9f61b43ec5ca88c8a4ad40e09b4d58f6">dictionary32</a> = <a class="el" href="structcudf_1_1dictionary__wrapper.html">dictionary_wrapper</a>&lt; int32_t &gt;</td></tr>
<tr class="memdesc:ga9f61b43ec5ca88c8a4ad40e09b4d58f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit integer indexed dictionary wrapper  <br /></td></tr>
<tr class="separator:ga9f61b43ec5ca88c8a4ad40e09b4d58f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a45112033b50dfa4988d71a0817131c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timestamp__classes.html#ga6a45112033b50dfa4988d71a0817131c">duration_D</a> = cuda::std::chrono::duration&lt; int32_t, cuda::std::chrono::days::period &gt;</td></tr>
<tr class="memdesc:ga6a45112033b50dfa4988d71a0817131c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias representing an int32_t duration of days.  <br /></td></tr>
<tr class="separator:ga6a45112033b50dfa4988d71a0817131c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac9f5a62b5d8bc39e808918f94cbc9ff"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timestamp__classes.html#gaac9f5a62b5d8bc39e808918f94cbc9ff">duration_h</a> = cuda::std::chrono::duration&lt; int32_t, cuda::std::chrono::hours::period &gt;</td></tr>
<tr class="memdesc:gaac9f5a62b5d8bc39e808918f94cbc9ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias representing an int32_t duration of hours.  <br /></td></tr>
<tr class="separator:gaac9f5a62b5d8bc39e808918f94cbc9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02e8e6d4f16f2007e5994dd26adf6171"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timestamp__classes.html#ga02e8e6d4f16f2007e5994dd26adf6171">duration_m</a> = cuda::std::chrono::duration&lt; int32_t, cuda::std::chrono::minutes::period &gt;</td></tr>
<tr class="memdesc:ga02e8e6d4f16f2007e5994dd26adf6171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias representing an int32_t duration of minutes.  <br /></td></tr>
<tr class="separator:ga02e8e6d4f16f2007e5994dd26adf6171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae344db373c1568bd20e914cb74426519"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timestamp__classes.html#gae344db373c1568bd20e914cb74426519">duration_s</a> = cuda::std::chrono::duration&lt; int64_t, cuda::std::chrono::seconds::period &gt;</td></tr>
<tr class="memdesc:gae344db373c1568bd20e914cb74426519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias representing an int64_t duration of seconds.  <br /></td></tr>
<tr class="separator:gae344db373c1568bd20e914cb74426519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70b6b95d45de41529211d95531fa3f86"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timestamp__classes.html#ga70b6b95d45de41529211d95531fa3f86">duration_ms</a> = cuda::std::chrono::duration&lt; int64_t, cuda::std::chrono::milliseconds::period &gt;</td></tr>
<tr class="memdesc:ga70b6b95d45de41529211d95531fa3f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias representing an int64_t duration of milliseconds.  <br /></td></tr>
<tr class="separator:ga70b6b95d45de41529211d95531fa3f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8e261e3e2a11e8464efb2a251c107d7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timestamp__classes.html#gab8e261e3e2a11e8464efb2a251c107d7">duration_us</a> = cuda::std::chrono::duration&lt; int64_t, cuda::std::chrono::microseconds::period &gt;</td></tr>
<tr class="memdesc:gab8e261e3e2a11e8464efb2a251c107d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias representing an int64_t duration of microseconds.  <br /></td></tr>
<tr class="separator:gab8e261e3e2a11e8464efb2a251c107d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4efdb8225ec7e415ab3c660c066aa3ee"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timestamp__classes.html#ga4efdb8225ec7e415ab3c660c066aa3ee">duration_ns</a> = cuda::std::chrono::duration&lt; int64_t, cuda::std::chrono::nanoseconds::period &gt;</td></tr>
<tr class="memdesc:ga4efdb8225ec7e415ab3c660c066aa3ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias representing an int64_t duration of nanoseconds.  <br /></td></tr>
<tr class="separator:ga4efdb8225ec7e415ab3c660c066aa3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4658424aa55596e2f3b6b42a9260f736"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timestamp__classes.html#ga4658424aa55596e2f3b6b42a9260f736">timestamp_D</a> = <a class="el" href="namespacecudf_1_1detail.html#a3128cb15ed7da5bb5e926bb24a419262">detail::timestamp</a>&lt; <a class="el" href="group__timestamp__classes.html#ga6a45112033b50dfa4988d71a0817131c">cudf::duration_D</a> &gt;</td></tr>
<tr class="memdesc:ga4658424aa55596e2f3b6b42a9260f736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias representing a <a class="el" href="group__timestamp__classes.html#ga6a45112033b50dfa4988d71a0817131c" title="Type alias representing an int32_t duration of days.">cudf::duration_D</a> (int32_t) since the unix epoch.  <br /></td></tr>
<tr class="separator:ga4658424aa55596e2f3b6b42a9260f736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b55dd23383d1c37b7bdc0274ded9191"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timestamp__classes.html#ga8b55dd23383d1c37b7bdc0274ded9191">timestamp_h</a> = <a class="el" href="namespacecudf_1_1detail.html#a3128cb15ed7da5bb5e926bb24a419262">detail::timestamp</a>&lt; <a class="el" href="group__timestamp__classes.html#gaac9f5a62b5d8bc39e808918f94cbc9ff">cudf::duration_h</a> &gt;</td></tr>
<tr class="memdesc:ga8b55dd23383d1c37b7bdc0274ded9191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias representing a <a class="el" href="group__timestamp__classes.html#gaac9f5a62b5d8bc39e808918f94cbc9ff" title="Type alias representing an int32_t duration of hours.">cudf::duration_h</a> (int32_t) since the unix epoch.  <br /></td></tr>
<tr class="separator:ga8b55dd23383d1c37b7bdc0274ded9191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52883e4379d120186e9750158f1458b9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timestamp__classes.html#ga52883e4379d120186e9750158f1458b9">timestamp_m</a> = <a class="el" href="namespacecudf_1_1detail.html#a3128cb15ed7da5bb5e926bb24a419262">detail::timestamp</a>&lt; <a class="el" href="group__timestamp__classes.html#ga02e8e6d4f16f2007e5994dd26adf6171">cudf::duration_m</a> &gt;</td></tr>
<tr class="memdesc:ga52883e4379d120186e9750158f1458b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias representing a <a class="el" href="group__timestamp__classes.html#ga02e8e6d4f16f2007e5994dd26adf6171" title="Type alias representing an int32_t duration of minutes.">cudf::duration_m</a> (int32_t) since the unix epoch.  <br /></td></tr>
<tr class="separator:ga52883e4379d120186e9750158f1458b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44668df4b32894904fb68f13a5f0fdab"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timestamp__classes.html#ga44668df4b32894904fb68f13a5f0fdab">timestamp_s</a> = <a class="el" href="namespacecudf_1_1detail.html#a3128cb15ed7da5bb5e926bb24a419262">detail::timestamp</a>&lt; <a class="el" href="group__timestamp__classes.html#gae344db373c1568bd20e914cb74426519">cudf::duration_s</a> &gt;</td></tr>
<tr class="memdesc:ga44668df4b32894904fb68f13a5f0fdab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias representing a <a class="el" href="group__timestamp__classes.html#gae344db373c1568bd20e914cb74426519" title="Type alias representing an int64_t duration of seconds.">cudf::duration_s</a> (int64_t) since the unix epoch.  <br /></td></tr>
<tr class="separator:ga44668df4b32894904fb68f13a5f0fdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24fdf63531f7998ef3122a5d0885e949"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timestamp__classes.html#ga24fdf63531f7998ef3122a5d0885e949">timestamp_ms</a> = <a class="el" href="namespacecudf_1_1detail.html#a3128cb15ed7da5bb5e926bb24a419262">detail::timestamp</a>&lt; <a class="el" href="group__timestamp__classes.html#ga70b6b95d45de41529211d95531fa3f86">cudf::duration_ms</a> &gt;</td></tr>
<tr class="memdesc:ga24fdf63531f7998ef3122a5d0885e949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias representing a <a class="el" href="group__timestamp__classes.html#ga70b6b95d45de41529211d95531fa3f86" title="Type alias representing an int64_t duration of milliseconds.">cudf::duration_ms</a> (int64_t) since the unix epoch.  <br /></td></tr>
<tr class="separator:ga24fdf63531f7998ef3122a5d0885e949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc5dd6cc3229f57af772e06f8c0bd828"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timestamp__classes.html#gabc5dd6cc3229f57af772e06f8c0bd828">timestamp_us</a> = <a class="el" href="namespacecudf_1_1detail.html#a3128cb15ed7da5bb5e926bb24a419262">detail::timestamp</a>&lt; <a class="el" href="group__timestamp__classes.html#gab8e261e3e2a11e8464efb2a251c107d7">cudf::duration_us</a> &gt;</td></tr>
<tr class="memdesc:gabc5dd6cc3229f57af772e06f8c0bd828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias representing a <a class="el" href="group__timestamp__classes.html#gab8e261e3e2a11e8464efb2a251c107d7" title="Type alias representing an int64_t duration of microseconds.">cudf::duration_us</a> (int64_t) since the unix epoch.  <br /></td></tr>
<tr class="separator:gabc5dd6cc3229f57af772e06f8c0bd828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2aef2b10c32caf1889ef2a6575b531a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__timestamp__classes.html#gae2aef2b10c32caf1889ef2a6575b531a">timestamp_ns</a> = <a class="el" href="namespacecudf_1_1detail.html#a3128cb15ed7da5bb5e926bb24a419262">detail::timestamp</a>&lt; <a class="el" href="group__timestamp__classes.html#ga4efdb8225ec7e415ab3c660c066aa3ee">cudf::duration_ns</a> &gt;</td></tr>
<tr class="memdesc:gae2aef2b10c32caf1889ef2a6575b531a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias representing a <a class="el" href="group__timestamp__classes.html#ga4efdb8225ec7e415ab3c660c066aa3ee" title="Type alias representing an int64_t duration of nanoseconds.">cudf::duration_ns</a> (int64_t) since the unix epoch.  <br /></td></tr>
<tr class="separator:gae2aef2b10c32caf1889ef2a6575b531a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
枚举</h2></td></tr>
<tr class="memitem:gac8975ec1273372f6ccae83a85bee71ce"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__sort.html#gac8975ec1273372f6ccae83a85bee71ce">rank_method</a> : int32_t { <br />
&#160;&#160;<a class="el" href="group__column__sort.html#ggac8975ec1273372f6ccae83a85bee71cea2c2624a5059934a947d6e25fe8332ade">rank_method::FIRST</a>
, <a class="el" href="group__column__sort.html#ggac8975ec1273372f6ccae83a85bee71cea16de38737a9f8366e9b2042b4e9b6290">rank_method::AVERAGE</a>
, <a class="el" href="group__column__sort.html#ggac8975ec1273372f6ccae83a85bee71ceace31e2a082d17e038fcc6e3006166653">rank_method::MIN</a>
, <a class="el" href="group__column__sort.html#ggac8975ec1273372f6ccae83a85bee71cea26a4b44a837bf97b972628509912b4a5">rank_method::MAX</a>
, <br />
&#160;&#160;<a class="el" href="group__column__sort.html#ggac8975ec1273372f6ccae83a85bee71cea0706fbbd929bd8abc4de386c53d439ff">rank_method::DENSE</a>
<br />
 }</td></tr>
<tr class="memdesc:gac8975ec1273372f6ccae83a85bee71ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tie-breaker method to use for ranking the column.  <a href="group__column__sort.html#gac8975ec1273372f6ccae83a85bee71ce">更多...</a><br /></td></tr>
<tr class="separator:gac8975ec1273372f6ccae83a85bee71ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3701f066cd6ad8bad2a70fbfcef93071"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga3701f066cd6ad8bad2a70fbfcef93071">rank_percentage</a> : int32_t { <a class="el" href="group__aggregation__factories.html#gga3701f066cd6ad8bad2a70fbfcef93071ab50339a10e1de285ac99d4c3990b8693">rank_percentage::NONE</a>
, <a class="el" href="group__aggregation__factories.html#gga3701f066cd6ad8bad2a70fbfcef93071a90fa47f34fe7e9926f52e5eb144c798d">rank_percentage::ZERO_NORMALIZED</a>
, <a class="el" href="group__aggregation__factories.html#gga3701f066cd6ad8bad2a70fbfcef93071a552e99f7f1cb96081c640e1756f137b6">rank_percentage::ONE_NORMALIZED</a>
 }</td></tr>
<tr class="memdesc:ga3701f066cd6ad8bad2a70fbfcef93071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether returned rank should be percentage or not and mention the type of percentage normalization.  <a href="group__aggregation__factories.html#ga3701f066cd6ad8bad2a70fbfcef93071">更多...</a><br /></td></tr>
<tr class="separator:ga3701f066cd6ad8bad2a70fbfcef93071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2e43a487f20c968b2474a5cb980527e"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gad2e43a487f20c968b2474a5cb980527e">udf_type</a> : bool { <a class="el" href="group__aggregation__factories.html#ggad2e43a487f20c968b2474a5cb980527eaa33b7755e5f9b504d2d038eaca4ff28d">udf_type::CUDA</a>
, <a class="el" href="group__aggregation__factories.html#ggad2e43a487f20c968b2474a5cb980527eae3c5ca6a28ee215e0adfb1a014d9d7ab">udf_type::PTX</a>
 }</td></tr>
<tr class="memdesc:gad2e43a487f20c968b2474a5cb980527e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of code in the user defined function string.  <a href="group__aggregation__factories.html#gad2e43a487f20c968b2474a5cb980527e">更多...</a><br /></td></tr>
<tr class="separator:gad2e43a487f20c968b2474a5cb980527e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dc83597d5b1e9cf752fc20fcdd77d40"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga1dc83597d5b1e9cf752fc20fcdd77d40">correlation_type</a> : int32_t { <a class="el" href="group__aggregation__factories.html#gga1dc83597d5b1e9cf752fc20fcdd77d40a04e79da97aad2da56010b0f681b8c7a2">correlation_type::PEARSON</a>
, <a class="el" href="group__aggregation__factories.html#gga1dc83597d5b1e9cf752fc20fcdd77d40a4ea5bfb1deff9aacbc55d3345c77d9ae">correlation_type::KENDALL</a>
, <a class="el" href="group__aggregation__factories.html#gga1dc83597d5b1e9cf752fc20fcdd77d40a17f4b051a83b72b0232e6c77c2bc4943">correlation_type::SPEARMAN</a>
 }</td></tr>
<tr class="memdesc:ga1dc83597d5b1e9cf752fc20fcdd77d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of correlation method.  <a href="group__aggregation__factories.html#ga1dc83597d5b1e9cf752fc20fcdd77d40">更多...</a><br /></td></tr>
<tr class="separator:ga1dc83597d5b1e9cf752fc20fcdd77d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00ed76601b6db662550f6826cfd99edc"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__binaryops.html#ga00ed76601b6db662550f6826cfd99edc">binary_operator</a> : int32_t { <br />
&#160;&#160;<a class="el" href="group__transformation__binaryops.html#gga00ed76601b6db662550f6826cfd99edca9eeb52badb613229884838847294b90d">binary_operator::ADD</a>
, <a class="el" href="group__transformation__binaryops.html#gga00ed76601b6db662550f6826cfd99edca241dd841abade20fcb27b8a9f494e1eb">binary_operator::SUB</a>
, <a class="el" href="group__transformation__binaryops.html#gga00ed76601b6db662550f6826cfd99edca2cdf52a55876063ec93b7d18bc741f6c">binary_operator::MUL</a>
, <a class="el" href="group__transformation__binaryops.html#gga00ed76601b6db662550f6826cfd99edca29bbf66f7f8529ec47e394fb5a36c646">binary_operator::DIV</a>
, <br />
&#160;&#160;<a class="el" href="group__transformation__binaryops.html#gga00ed76601b6db662550f6826cfd99edcaa14fdfc1aa76e925151b566a67c99406">binary_operator::TRUE_DIV</a>
, <a class="el" href="group__transformation__binaryops.html#gga00ed76601b6db662550f6826cfd99edca77811fd0ec3d3ed2711a923332e8e69f">binary_operator::FLOOR_DIV</a>
, <a class="el" href="group__transformation__binaryops.html#gga00ed76601b6db662550f6826cfd99edcac5a28f4b35a2884fa3277150ac5d0967">binary_operator::MOD</a>
, <a class="el" href="group__transformation__binaryops.html#gga00ed76601b6db662550f6826cfd99edcaaf5a744d55583fdb1af0f280f12c9ab1">binary_operator::PMOD</a>
, <br />
&#160;&#160;<a class="el" href="group__transformation__binaryops.html#gga00ed76601b6db662550f6826cfd99edca36aaf571a1008bd43f47509344cd13ad">binary_operator::PYMOD</a>
, <a class="el" href="group__transformation__binaryops.html#gga00ed76601b6db662550f6826cfd99edca17faf4e999b8cee4c36915c1f54ccffe">binary_operator::POW</a>
, <a class="el" href="group__transformation__binaryops.html#gga00ed76601b6db662550f6826cfd99edcad41167c344e1771b57cbbf5df6633a90">binary_operator::INT_POW</a>
, <a class="el" href="group__transformation__binaryops.html#gga00ed76601b6db662550f6826cfd99edca21fb6e241507492d75c488a9c65d12fe">binary_operator::LOG_BASE</a>
, <br />
&#160;&#160;<a class="el" href="group__transformation__binaryops.html#gga00ed76601b6db662550f6826cfd99edcaf8d5f387d3ac8f7084ae44566b32acb2">binary_operator::ATAN2</a>
, <a class="el" href="group__transformation__binaryops.html#gga00ed76601b6db662550f6826cfd99edcab11947742cdeb1e9d0b493239416e885">binary_operator::SHIFT_LEFT</a>
, <a class="el" href="group__transformation__binaryops.html#gga00ed76601b6db662550f6826cfd99edcaf07939cca8bcd94dfa7356d96e4b1ebb">binary_operator::SHIFT_RIGHT</a>
, <a class="el" href="group__transformation__binaryops.html#gga00ed76601b6db662550f6826cfd99edcaa41bd9a635ce48d786cde49d803446e1">binary_operator::SHIFT_RIGHT_UNSIGNED</a>
, <br />
&#160;&#160;<a class="el" href="group__transformation__binaryops.html#gga00ed76601b6db662550f6826cfd99edcaaa5f2eafabf8fa18cbb708c657f37245">binary_operator::BITWISE_AND</a>
, <a class="el" href="group__transformation__binaryops.html#gga00ed76601b6db662550f6826cfd99edca0d89cfe1f2f7f0c2deb3d35455783ab9">binary_operator::BITWISE_OR</a>
, <a class="el" href="group__transformation__binaryops.html#gga00ed76601b6db662550f6826cfd99edca6d7cca7c0f0f278c56131a25e77c4a5c">binary_operator::BITWISE_XOR</a>
, <a class="el" href="group__transformation__binaryops.html#gga00ed76601b6db662550f6826cfd99edcaa770916377f618641eccd6783b13503a">binary_operator::LOGICAL_AND</a>
, <br />
&#160;&#160;<a class="el" href="group__transformation__binaryops.html#gga00ed76601b6db662550f6826cfd99edca0d0389dd347e259ac16a47fc9db81c18">binary_operator::LOGICAL_OR</a>
, <a class="el" href="group__transformation__binaryops.html#gga00ed76601b6db662550f6826cfd99edca969f331a87d8c958473c32b4d0e61a44">binary_operator::EQUAL</a>
, <a class="el" href="group__transformation__binaryops.html#gga00ed76601b6db662550f6826cfd99edca4ea2d378cdec20f59330f113297bc1ce">binary_operator::NOT_EQUAL</a>
, <a class="el" href="group__transformation__binaryops.html#gga00ed76601b6db662550f6826cfd99edca1798e8c3621ca53d9e3a80d257306000">binary_operator::LESS</a>
, <br />
&#160;&#160;<a class="el" href="group__transformation__binaryops.html#gga00ed76601b6db662550f6826cfd99edcae7e72355289e404b762d4cf88824d23b">binary_operator::GREATER</a>
, <a class="el" href="group__transformation__binaryops.html#gga00ed76601b6db662550f6826cfd99edca8b4a5cd69b217bf93b054ada7f49abd4">binary_operator::LESS_EQUAL</a>
, <a class="el" href="group__transformation__binaryops.html#gga00ed76601b6db662550f6826cfd99edca87e6b203bf40967d37a33f9a4438561a">binary_operator::GREATER_EQUAL</a>
, <a class="el" href="group__transformation__binaryops.html#gga00ed76601b6db662550f6826cfd99edcacb8d87e20fe7c6f3786fb063814420e5">binary_operator::NULL_EQUALS</a>
, <br />
&#160;&#160;<a class="el" href="group__transformation__binaryops.html#gga00ed76601b6db662550f6826cfd99edcaf96f1246ae59f3f396dd304c4e3efb2f">binary_operator::NULL_MAX</a>
, <a class="el" href="group__transformation__binaryops.html#gga00ed76601b6db662550f6826cfd99edcadb8b769d7a9c9d41242eb4b721228c50">binary_operator::NULL_MIN</a>
, <a class="el" href="group__transformation__binaryops.html#gga00ed76601b6db662550f6826cfd99edca8949d722159e21bb5941af5b0e92aeb5">binary_operator::GENERIC_BINARY</a>
, <a class="el" href="group__transformation__binaryops.html#gga00ed76601b6db662550f6826cfd99edca0b0eecbb7754f87b05d19490f50ddd4f">binary_operator::NULL_LOGICAL_AND</a>
, <br />
&#160;&#160;<a class="el" href="group__transformation__binaryops.html#gga00ed76601b6db662550f6826cfd99edca009adecefebadfcd26e7fad3b046104b">binary_operator::NULL_LOGICAL_OR</a>
, <a class="el" href="group__transformation__binaryops.html#gga00ed76601b6db662550f6826cfd99edca0b010d84b45dcb367a81c7c029d3f5bb">binary_operator::INVALID_BINARY</a>
<br />
 }</td></tr>
<tr class="memdesc:ga00ed76601b6db662550f6826cfd99edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of binary operations that can be performed on data.  <a href="group__transformation__binaryops.html#ga00ed76601b6db662550f6826cfd99edc">更多...</a><br /></td></tr>
<tr class="separator:ga00ed76601b6db662550f6826cfd99edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3ba74951558bc7966aae86abc6af5df"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gae3ba74951558bc7966aae86abc6af5df">out_of_bounds_policy</a> : bool { <a class="el" href="group__column__copy.html#ggae3ba74951558bc7966aae86abc6af5dfacac2cdaff9b4ab3bcda3b538a86f9edb">out_of_bounds_policy::NULLIFY</a>
, <a class="el" href="group__column__copy.html#ggae3ba74951558bc7966aae86abc6af5dfa12c1109487cf9a6a336b1dfe462bfd2d">out_of_bounds_policy::DONT_CHECK</a>
 }</td></tr>
<tr class="memdesc:gae3ba74951558bc7966aae86abc6af5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy to account for possible out-of-bounds indices  <a href="group__column__copy.html#gae3ba74951558bc7966aae86abc6af5df">更多...</a><br /></td></tr>
<tr class="separator:gae3ba74951558bc7966aae86abc6af5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga267e03474dcfd85242d2fdc6e5846ec6"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a> { <a class="el" href="group__column__copy.html#gga267e03474dcfd85242d2fdc6e5846ec6a443475558f0168dff92ecde26b98ae5a">mask_allocation_policy::NEVER</a>
, <a class="el" href="group__column__copy.html#gga267e03474dcfd85242d2fdc6e5846ec6a47e9136fa770199f6a8a9727b6173eb4">mask_allocation_policy::RETAIN</a>
, <a class="el" href="group__column__copy.html#gga267e03474dcfd85242d2fdc6e5846ec6af3fc827ade4b968e50406496907ef962">mask_allocation_policy::ALWAYS</a>
 }</td></tr>
<tr class="memdesc:ga267e03474dcfd85242d2fdc6e5846ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates when to allocate a mask, based on an existing mask.  <a href="group__column__copy.html#ga267e03474dcfd85242d2fdc6e5846ec6">更多...</a><br /></td></tr>
<tr class="separator:ga267e03474dcfd85242d2fdc6e5846ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7607cde56cb602ab1b198b5bebf7cba"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gae7607cde56cb602ab1b198b5bebf7cba">sample_with_replacement</a> : bool { <a class="el" href="group__column__copy.html#ggae7607cde56cb602ab1b198b5bebf7cbaa946003f97ccc52d5d3b54ac0ec31bbfc">sample_with_replacement::FALSE</a>
, <a class="el" href="group__column__copy.html#ggae7607cde56cb602ab1b198b5bebf7cbaac0d83f0b82a6b30de8811e69e6d95c61">sample_with_replacement::TRUE</a>
 }</td></tr>
<tr class="memdesc:gae7607cde56cb602ab1b198b5bebf7cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether a row can be sampled more than once.  <a href="group__column__copy.html#gae7607cde56cb602ab1b198b5bebf7cba">更多...</a><br /></td></tr>
<tr class="separator:gae7607cde56cb602ab1b198b5bebf7cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaced8b9d129825edd13d76e912e4413c3"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__hash.html#gaced8b9d129825edd13d76e912e4413c3">hash_id</a> { <a class="el" href="group__column__hash.html#ggaced8b9d129825edd13d76e912e4413c3a87c5fdaedd591de89dc6528979fad559">hash_id::HASH_IDENTITY</a> = 0
, <a class="el" href="group__column__hash.html#ggaced8b9d129825edd13d76e912e4413c3ae9ec854e962136b1afcf108e5301c354">hash_id::HASH_MURMUR3</a>
, <a class="el" href="group__column__hash.html#ggaced8b9d129825edd13d76e912e4413c3a86e5d77c8925733c14f2ead71e800939">hash_id::HASH_SPARK_MURMUR3</a>
, <a class="el" href="group__column__hash.html#ggaced8b9d129825edd13d76e912e4413c3a1b39e06b1e490bb4792c0076b2733a45">hash_id::HASH_MD5</a>
 }</td></tr>
<tr class="memdesc:gaced8b9d129825edd13d76e912e4413c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies the hash function to be used  <a href="group__column__hash.html#gaced8b9d129825edd13d76e912e4413c3">更多...</a><br /></td></tr>
<tr class="separator:gaced8b9d129825edd13d76e912e4413c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabadbffbcb403fac1ff712330ea10f2b3"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__label__bins.html#gabadbffbcb403fac1ff712330ea10f2b3">inclusive</a> { <a class="el" href="group__label__bins.html#ggabadbffbcb403fac1ff712330ea10f2b3a7469a286259799e5b37e5db9296f00b3">inclusive::YES</a>
, <a class="el" href="group__label__bins.html#ggabadbffbcb403fac1ff712330ea10f2b3ac2f3f489a00553e7a01d369c103c7251">inclusive::NO</a>
 }</td></tr>
<tr class="memdesc:gabadbffbcb403fac1ff712330ea10f2b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum used to define whether or not bins include their boundary points.  <a href="group__label__bins.html#gabadbffbcb403fac1ff712330ea10f2b3">更多...</a><br /></td></tr>
<tr class="separator:gabadbffbcb403fac1ff712330ea10f2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga269c5a531bd3bb4da9ebe4590db028af"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__reduction.html#ga269c5a531bd3bb4da9ebe4590db028af">scan_type</a> : bool { <a class="el" href="group__aggregation__reduction.html#gga269c5a531bd3bb4da9ebe4590db028afa572d795e2d044f895cc511e5c05030e5">scan_type::INCLUSIVE</a>
, <a class="el" href="group__aggregation__reduction.html#gga269c5a531bd3bb4da9ebe4590db028afaf45c3a0bb3687ed8e221253b3fd4a2ce">scan_type::EXCLUSIVE</a>
 }</td></tr>
<tr class="memdesc:ga269c5a531bd3bb4da9ebe4590db028af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to describe scan operation type  <a href="group__aggregation__reduction.html#ga269c5a531bd3bb4da9ebe4590db028af">更多...</a><br /></td></tr>
<tr class="separator:ga269c5a531bd3bb4da9ebe4590db028af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cdbc9bc3671930a743c86f36c38abf9"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__replace.html#ga7cdbc9bc3671930a743c86f36c38abf9">replace_policy</a> : bool { <a class="el" href="group__transformation__replace.html#gga7cdbc9bc3671930a743c86f36c38abf9ab807500d0d02793339457f52b1914b90">replace_policy::PRECEDING</a>
, <a class="el" href="group__transformation__replace.html#gga7cdbc9bc3671930a743c86f36c38abf9ac172d52647d4fd6f81a2c3110d150c6a">replace_policy::FOLLOWING</a>
 }</td></tr>
<tr class="memdesc:ga7cdbc9bc3671930a743c86f36c38abf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy to specify the position of replacement values relative to null rows  <a href="group__transformation__replace.html#ga7cdbc9bc3671930a743c86f36c38abf9">更多...</a><br /></td></tr>
<tr class="separator:ga7cdbc9bc3671930a743c86f36c38abf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fd286bca11d008f7945aaa6ecbab2e0"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__reshape.html#ga1fd286bca11d008f7945aaa6ecbab2e0">flip_endianness</a> : bool { <a class="el" href="group__column__reshape.html#gga1fd286bca11d008f7945aaa6ecbab2e0ac2f3f489a00553e7a01d369c103c7251">flip_endianness::NO</a>
, <a class="el" href="group__column__reshape.html#gga1fd286bca11d008f7945aaa6ecbab2e0a7469a286259799e5b37e5db9296f00b3">flip_endianness::YES</a>
 }</td></tr>
<tr class="memdesc:ga1fd286bca11d008f7945aaa6ecbab2e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures whether byte casting flips endianness  <a href="group__column__reshape.html#ga1fd286bca11d008f7945aaa6ecbab2e0">更多...</a><br /></td></tr>
<tr class="separator:ga1fd286bca11d008f7945aaa6ecbab2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02028fc18312cdb2f07159c6297e74bb"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__unaryops.html#ga02028fc18312cdb2f07159c6297e74bb">rounding_method</a> : int32_t { <a class="el" href="group__transformation__unaryops.html#gga02028fc18312cdb2f07159c6297e74bbae184ac539927e7effd9eae762e9f1904">rounding_method::HALF_UP</a>
, <a class="el" href="group__transformation__unaryops.html#gga02028fc18312cdb2f07159c6297e74bba29746b187c41c8e51b96a3104cbda3b6">rounding_method::HALF_EVEN</a>
 }</td></tr>
<tr class="memdesc:ga02028fc18312cdb2f07159c6297e74bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different rounding methods for <code><a class="el" href="group__transformation__unaryops.html#gaaf541a42981e9f31a32de8fdaa105d4b" title="Rounds all the values in a column to the specified number of decimal places.">cudf::round</a></code>  <a href="group__transformation__unaryops.html#ga02028fc18312cdb2f07159c6297e74bb">更多...</a><br /></td></tr>
<tr class="separator:ga02028fc18312cdb2f07159c6297e74bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69091647ea1f9c9d4cdcf7c8876bea3a"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reorder__compact.html#ga69091647ea1f9c9d4cdcf7c8876bea3a">duplicate_keep_option</a> { <a class="el" href="group__reorder__compact.html#gga69091647ea1f9c9d4cdcf7c8876bea3aa0546025abe5830d9334bb82102420394">duplicate_keep_option::KEEP_ANY</a> = 0
, <a class="el" href="group__reorder__compact.html#gga69091647ea1f9c9d4cdcf7c8876bea3aa5968b12bf2e72e702a998c7fa6c83b1e">duplicate_keep_option::KEEP_FIRST</a>
, <a class="el" href="group__reorder__compact.html#gga69091647ea1f9c9d4cdcf7c8876bea3aa4583fc151efe5098dd96eeec8cf74699">duplicate_keep_option::KEEP_LAST</a>
, <a class="el" href="group__reorder__compact.html#gga69091647ea1f9c9d4cdcf7c8876bea3aa40c4abe57c2fda3e580eee916b9e0558">duplicate_keep_option::KEEP_NONE</a>
 }</td></tr>
<tr class="memdesc:ga69091647ea1f9c9d4cdcf7c8876bea3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choices for drop_duplicates API for retainment of duplicate rows  <a href="group__reorder__compact.html#ga69091647ea1f9c9d4cdcf7c8876bea3a">更多...</a><br /></td></tr>
<tr class="separator:ga69091647ea1f9c9d4cdcf7c8876bea3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga750f02016b046079f7062d334890b4fc"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> : bool { <a class="el" href="group__utility__types.html#gga750f02016b046079f7062d334890b4fca83ec681a20197326c163ea3b39ef7c32">order::ASCENDING</a>
, <a class="el" href="group__utility__types.html#gga750f02016b046079f7062d334890b4fcacff818f0ae4cef845577e39283886a53">order::DESCENDING</a>
 }</td></tr>
<tr class="memdesc:ga750f02016b046079f7062d334890b4fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the order in which elements should be sorted.  <a href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">更多...</a><br /></td></tr>
<tr class="separator:ga750f02016b046079f7062d334890b4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b8cda4afb95a7c42c4679b4fae61009"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a> : bool { <a class="el" href="group__utility__types.html#gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8">null_policy::EXCLUDE</a>
, <a class="el" href="group__utility__types.html#gga1b8cda4afb95a7c42c4679b4fae61009a04ff6a9583ba9957ebe1128d0f988ad8">null_policy::INCLUDE</a>
 }</td></tr>
<tr class="memdesc:ga1b8cda4afb95a7c42c4679b4fae61009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to specify whether to include nulls or exclude nulls  <a href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">更多...</a><br /></td></tr>
<tr class="separator:ga1b8cda4afb95a7c42c4679b4fae61009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74641d3dfd6d96d0939b492ecf9b9cc8"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga74641d3dfd6d96d0939b492ecf9b9cc8">nan_policy</a> : bool { <a class="el" href="group__utility__types.html#gga74641d3dfd6d96d0939b492ecf9b9cc8aeed6bbfa0697c54960c7e0baa97313f4">nan_policy::NAN_IS_NULL</a>
, <a class="el" href="group__utility__types.html#gga74641d3dfd6d96d0939b492ecf9b9cc8a27adbe26caa2eb99976344933c281a77">nan_policy::NAN_IS_VALID</a>
 }</td></tr>
<tr class="memdesc:ga74641d3dfd6d96d0939b492ecf9b9cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to treat NaN floating point value as null or non-null element  <a href="group__utility__types.html#ga74641d3dfd6d96d0939b492ecf9b9cc8">更多...</a><br /></td></tr>
<tr class="separator:ga74641d3dfd6d96d0939b492ecf9b9cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9d1055c69c3089452794783c7c82f83"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#gae9d1055c69c3089452794783c7c82f83">nan_equality</a> { <a class="el" href="group__utility__types.html#ggae9d1055c69c3089452794783c7c82f83acd6d9f766e6e2753da429d26078711d7">nan_equality::ALL_EQUAL</a>
, <a class="el" href="group__utility__types.html#ggae9d1055c69c3089452794783c7c82f83ac0df9e531f39895029236b71d0d1c0ac">nan_equality::UNEQUAL</a>
 }</td></tr>
<tr class="memdesc:gae9d1055c69c3089452794783c7c82f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to consider different elements (of floating point types) holding NaN value as equal or unequal  <a href="group__utility__types.html#gae9d1055c69c3089452794783c7c82f83">更多...</a><br /></td></tr>
<tr class="separator:gae9d1055c69c3089452794783c7c82f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08a672308cd0f61562410d106b377771"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a> : bool { <a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44">null_equality::EQUAL</a>
, <a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771ac0df9e531f39895029236b71d0d1c0ac">null_equality::UNEQUAL</a>
 }</td></tr>
<tr class="memdesc:ga08a672308cd0f61562410d106b377771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to consider two nulls as equal or unequal  <a href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">更多...</a><br /></td></tr>
<tr class="separator:ga08a672308cd0f61562410d106b377771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga058e6d6e8a21583ce0e85ee73e5abb31"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> : bool { <a class="el" href="group__utility__types.html#gga058e6d6e8a21583ce0e85ee73e5abb31ac130fda0cb93540bf1574912e78964fb">null_order::AFTER</a>
, <a class="el" href="group__utility__types.html#gga058e6d6e8a21583ce0e85ee73e5abb31a3525317285c6126ce3b62a8df8c00b07">null_order::BEFORE</a>
 }</td></tr>
<tr class="memdesc:ga058e6d6e8a21583ce0e85ee73e5abb31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates how null values compare against all other values.  <a href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">更多...</a><br /></td></tr>
<tr class="separator:ga058e6d6e8a21583ce0e85ee73e5abb31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab283c517931abd4152ffa62fec62425d"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#gab283c517931abd4152ffa62fec62425d">sorted</a> : bool { <a class="el" href="group__utility__types.html#ggab283c517931abd4152ffa62fec62425dac2f3f489a00553e7a01d369c103c7251">sorted::NO</a>
, <a class="el" href="group__utility__types.html#ggab283c517931abd4152ffa62fec62425da7469a286259799e5b37e5db9296f00b3">sorted::YES</a>
 }</td></tr>
<tr class="memdesc:gab283c517931abd4152ffa62fec62425d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether a collection of values is known to be sorted.  <a href="group__utility__types.html#gab283c517931abd4152ffa62fec62425d">更多...</a><br /></td></tr>
<tr class="separator:gab283c517931abd4152ffa62fec62425d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4daf20c000ab374d76f4d56f0ddb7b26"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga4daf20c000ab374d76f4d56f0ddb7b26">mask_state</a> : int32_t { <a class="el" href="group__utility__types.html#gga4daf20c000ab374d76f4d56f0ddb7b26a628732521c22dcf8a24bf1a0326bde80">mask_state::UNALLOCATED</a>
, <a class="el" href="group__utility__types.html#gga4daf20c000ab374d76f4d56f0ddb7b26add652546039b18970b8dcf2cff824268">mask_state::UNINITIALIZED</a>
, <a class="el" href="group__utility__types.html#gga4daf20c000ab374d76f4d56f0ddb7b26a00a0fd1f61b5bd5c53628de693967e08">mask_state::ALL_VALID</a>
, <a class="el" href="group__utility__types.html#gga4daf20c000ab374d76f4d56f0ddb7b26ab8a690c8c67b400079b43eb5a2146753">mask_state::ALL_NULL</a>
 }</td></tr>
<tr class="memdesc:ga4daf20c000ab374d76f4d56f0ddb7b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls the allocation/initialization of a null mask.  <a href="group__utility__types.html#ga4daf20c000ab374d76f4d56f0ddb7b26">更多...</a><br /></td></tr>
<tr class="separator:ga4daf20c000ab374d76f4d56f0ddb7b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cd17c1cdf028ead9a4783f605276ab3"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga9cd17c1cdf028ead9a4783f605276ab3">interpolation</a> : int32_t { <br />
&#160;&#160;<a class="el" href="group__utility__types.html#gga9cd17c1cdf028ead9a4783f605276ab3aaac544aacc3615aada24897a215f5046">interpolation::LINEAR</a>
, <a class="el" href="group__utility__types.html#gga9cd17c1cdf028ead9a4783f605276ab3aa7c48ba367e019d004bfb0239b85f2b3">interpolation::LOWER</a>
, <a class="el" href="group__utility__types.html#gga9cd17c1cdf028ead9a4783f605276ab3a5bc0a7ce2c77ccd49169277e9289e5d1">interpolation::HIGHER</a>
, <a class="el" href="group__utility__types.html#gga9cd17c1cdf028ead9a4783f605276ab3aafa8fd4b90a3f8123b4bd30446518a7e">interpolation::MIDPOINT</a>
, <br />
&#160;&#160;<a class="el" href="group__utility__types.html#gga9cd17c1cdf028ead9a4783f605276ab3aad135772d7cf93dd0ccf9d2474b34e6a">interpolation::NEAREST</a>
<br />
 }</td></tr>
<tr class="memdesc:ga9cd17c1cdf028ead9a4783f605276ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolation method to use when the desired quantile lies between two data points i and j  <a href="group__utility__types.html#ga9cd17c1cdf028ead9a4783f605276ab3">更多...</a><br /></td></tr>
<tr class="separator:ga9cd17c1cdf028ead9a4783f605276ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf077607da617d1dadcc5417e2783539"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#gadf077607da617d1dadcc5417e2783539">type_id</a> : int32_t { <br />
&#160;&#160;<a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539aba2b45bdc11e2a4a6e86aab2ac693cbb">type_id::EMPTY</a>
, <a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539aee9d73311ff0658494edfff14c3ec1e3">type_id::INT8</a>
, <a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a5f90af42814c0a419d715d43ae54fd7a">type_id::INT16</a>
, <a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a6495adba09844fac8eeb0aba86e6f1bf">type_id::INT32</a>
, <br />
&#160;&#160;<a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a4e866b275c85fbb439f6484251cfb31c">type_id::INT64</a>
, <a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539aecfc091ed2a607335524c8389cfa41b5">type_id::UINT8</a>
, <a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a48d8f1a723d44ff4a87db1bb6c551c62">type_id::UINT16</a>
, <a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a17266551181f69a1b4a3ad5c9e270afc">type_id::UINT32</a>
, <br />
&#160;&#160;<a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a6de7acf711860176ba606e9aa2b85d5f">type_id::UINT64</a>
, <a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a967d280b5c16d95f2947647dd2ca6cc2">type_id::FLOAT32</a>
, <a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a139882c654db8a57f7c3092de1dd0b02">type_id::FLOAT64</a>
, <a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd">type_id::BOOL8</a>
, <br />
&#160;&#160;<a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539acf04253e348544a8e841a76dfecef3f6">type_id::TIMESTAMP_DAYS</a>
, <a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539ac46dfe2dc12b66ab3bf6deac3cd1a945">type_id::TIMESTAMP_SECONDS</a>
, <a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a6244bf5dfcbc1adc3f9b4ccad8333f3c">type_id::TIMESTAMP_MILLISECONDS</a>
, <a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a7053796e0238a00cf12b96beb273ba30">type_id::TIMESTAMP_MICROSECONDS</a>
, <br />
&#160;&#160;<a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539ac62360a52ed83eda03975a09f092d7b0">type_id::TIMESTAMP_NANOSECONDS</a>
, <a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a6bafb97dd1ba2c7b2ffee4fece104ec7">type_id::DURATION_DAYS</a>
, <a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a77029488e6452eca1a908121589d7fd9">type_id::DURATION_SECONDS</a>
, <a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a446364d0c90ab0072e9fa60cd7c32c3d">type_id::DURATION_MILLISECONDS</a>
, <br />
&#160;&#160;<a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a7e68d3150eeefe2afcb2d2c138be4d15">type_id::DURATION_MICROSECONDS</a>
, <a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a628d57b49cb66c1d14ce8db33be558ce">type_id::DURATION_NANOSECONDS</a>
, <a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539af7ed36b67626ecf59c497f2fdf990b64">type_id::DICTIONARY32</a>
, <a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a63b588d5559f64f89a416e656880b949">type_id::STRING</a>
, <br />
&#160;&#160;<a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a298cb25408234de02baf2085803a464a">type_id::LIST</a>
, <a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539ad75c2c4bd60fd3b76d4cef6e8352b269">type_id::DECIMAL32</a>
, <a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539ad43431506a21dcfd2ada4cd4c28f8f56">type_id::DECIMAL64</a>
, <a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a5e45eca83b8190615a1491aecd3edc21">type_id::DECIMAL128</a>
, <br />
&#160;&#160;<a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539ab8223be2455e0ea5a0e63e8f018d6fc3">type_id::STRUCT</a>
, <a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a44b418588ffa2779aaf862dc7aa81f8a">type_id::NUM_TYPE_IDS</a>
<br />
 }</td></tr>
<tr class="memdesc:gadf077607da617d1dadcc5417e2783539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies a column's logical element type  <a href="group__utility__types.html#gadf077607da617d1dadcc5417e2783539">更多...</a><br /></td></tr>
<tr class="separator:gadf077607da617d1dadcc5417e2783539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga030e62f30b296602f398e70d1ca657c4"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__unaryops.html#ga030e62f30b296602f398e70d1ca657c4">unary_operator</a> : int32_t { <br />
&#160;&#160;<a class="el" href="group__transformation__unaryops.html#gga030e62f30b296602f398e70d1ca657c4a5b001d63db54e7383587771eeb2018a1">unary_operator::SIN</a>
, <a class="el" href="group__transformation__unaryops.html#gga030e62f30b296602f398e70d1ca657c4aef23ef1d426ae1a73a7eed399cef707d">unary_operator::COS</a>
, <a class="el" href="group__transformation__unaryops.html#gga030e62f30b296602f398e70d1ca657c4a71211c96ad35b40178446956e22be10e">unary_operator::TAN</a>
, <a class="el" href="group__transformation__unaryops.html#gga030e62f30b296602f398e70d1ca657c4a607033bf57b9868026629e1fa23de7bf">unary_operator::ARCSIN</a>
, <br />
&#160;&#160;<a class="el" href="group__transformation__unaryops.html#gga030e62f30b296602f398e70d1ca657c4a7358c3fa47a9b546fe7ecbc961e82338">unary_operator::ARCCOS</a>
, <a class="el" href="group__transformation__unaryops.html#gga030e62f30b296602f398e70d1ca657c4a5a616b9bee92b5cd20f9940febeb3006">unary_operator::ARCTAN</a>
, <a class="el" href="group__transformation__unaryops.html#gga030e62f30b296602f398e70d1ca657c4ab387e847a769f9ef3794a3f559afcf69">unary_operator::SINH</a>
, <a class="el" href="group__transformation__unaryops.html#gga030e62f30b296602f398e70d1ca657c4ac8766c03013c3464d6bfd8e3c11b867d">unary_operator::COSH</a>
, <br />
&#160;&#160;<a class="el" href="group__transformation__unaryops.html#gga030e62f30b296602f398e70d1ca657c4a143c8c6f51b9bb893ce71e38702e3cc1">unary_operator::TANH</a>
, <a class="el" href="group__transformation__unaryops.html#gga030e62f30b296602f398e70d1ca657c4a3552954f5164c200a2c5f5a272294c90">unary_operator::ARCSINH</a>
, <a class="el" href="group__transformation__unaryops.html#gga030e62f30b296602f398e70d1ca657c4ad3242488948e86c0277590cd15cad984">unary_operator::ARCCOSH</a>
, <a class="el" href="group__transformation__unaryops.html#gga030e62f30b296602f398e70d1ca657c4a846a1dd5ab0418346548bb9f0f423a52">unary_operator::ARCTANH</a>
, <br />
&#160;&#160;<a class="el" href="group__transformation__unaryops.html#gga030e62f30b296602f398e70d1ca657c4a8c670f8c37b95e1ed14a0ce414b049c7">unary_operator::EXP</a>
, <a class="el" href="group__transformation__unaryops.html#gga030e62f30b296602f398e70d1ca657c4a4b5ffcdaf38ce4d463171f5c977c5ab3">unary_operator::LOG</a>
, <a class="el" href="group__transformation__unaryops.html#gga030e62f30b296602f398e70d1ca657c4a36875f2500a09ee35d0bb7eb8c0b91b0">unary_operator::SQRT</a>
, <a class="el" href="group__transformation__unaryops.html#gga030e62f30b296602f398e70d1ca657c4a2bda33a56a02768cfc002866aa4fb63a">unary_operator::CBRT</a>
, <br />
&#160;&#160;<a class="el" href="group__transformation__unaryops.html#gga030e62f30b296602f398e70d1ca657c4a5bdce8e6d9dc3efbbd31e90a8a181dff">unary_operator::CEIL</a>
, <a class="el" href="group__transformation__unaryops.html#gga030e62f30b296602f398e70d1ca657c4a56c1e354d36beb85b0d881c5b2e24cbe">unary_operator::FLOOR</a>
, <a class="el" href="group__transformation__unaryops.html#gga030e62f30b296602f398e70d1ca657c4a7d8a220d2262f9d6c658d549ee12cf2c">unary_operator::ABS</a>
, <a class="el" href="group__transformation__unaryops.html#gga030e62f30b296602f398e70d1ca657c4a6229a93c327259c59cd09415090f5c00">unary_operator::RINT</a>
, <br />
&#160;&#160;<a class="el" href="group__transformation__unaryops.html#gga030e62f30b296602f398e70d1ca657c4a66827fa9f30435250f1e887f466b3c40">unary_operator::BIT_INVERT</a>
, <a class="el" href="group__transformation__unaryops.html#gga030e62f30b296602f398e70d1ca657c4a10df3d67626099df882920ba6552f16d">unary_operator::NOT</a>
<br />
 }</td></tr>
<tr class="memdesc:ga030e62f30b296602f398e70d1ca657c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of unary operations that can be performed on data.  <a href="group__transformation__unaryops.html#ga030e62f30b296602f398e70d1ca657c4">更多...</a><br /></td></tr>
<tr class="separator:ga030e62f30b296602f398e70d1ca657c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
函数</h2></td></tr>
<tr class="memitem:gae5b74d72237dce180b58e72b9c2c4df5"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gae5b74d72237dce180b58e72b9c2c4df5"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gae5b74d72237dce180b58e72b9c2c4df5">make_sum_aggregation</a> ()</td></tr>
<tr class="separator:gae5b74d72237dce180b58e72b9c2c4df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb80c911d8fd6b7c99386e4ee0c19528"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gafb80c911d8fd6b7c99386e4ee0c19528"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gafb80c911d8fd6b7c99386e4ee0c19528">make_product_aggregation</a> ()</td></tr>
<tr class="separator:gafb80c911d8fd6b7c99386e4ee0c19528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96fff41e453f8042dba3e8e3929dee3c"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga96fff41e453f8042dba3e8e3929dee3c"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga96fff41e453f8042dba3e8e3929dee3c">make_min_aggregation</a> ()</td></tr>
<tr class="separator:ga96fff41e453f8042dba3e8e3929dee3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf676fa44ede8206ef658ba6f3c2c493"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gadf676fa44ede8206ef658ba6f3c2c493"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gadf676fa44ede8206ef658ba6f3c2c493">make_max_aggregation</a> ()</td></tr>
<tr class="separator:gadf676fa44ede8206ef658ba6f3c2c493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42dad49568d0804fd536d8b3c7fad589"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga42dad49568d0804fd536d8b3c7fad589"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga42dad49568d0804fd536d8b3c7fad589">make_count_aggregation</a> (<a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a> null_handling=<a class="el" href="group__utility__types.html#gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8">null_policy::EXCLUDE</a>)</td></tr>
<tr class="memdesc:ga42dad49568d0804fd536d8b3c7fad589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a COUNT aggregation  <br /></td></tr>
<tr class="separator:ga42dad49568d0804fd536d8b3c7fad589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga997b177576ffde84ada7258dcb46eacb"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga997b177576ffde84ada7258dcb46eacb"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga997b177576ffde84ada7258dcb46eacb">make_any_aggregation</a> ()</td></tr>
<tr class="separator:ga997b177576ffde84ada7258dcb46eacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8466bb2dbb0a11b1343d2c8721bd9295"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga8466bb2dbb0a11b1343d2c8721bd9295"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga8466bb2dbb0a11b1343d2c8721bd9295">make_all_aggregation</a> ()</td></tr>
<tr class="separator:ga8466bb2dbb0a11b1343d2c8721bd9295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a40c987b02d5daa60cb8bc3b4b92978"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga6a40c987b02d5daa60cb8bc3b4b92978"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga6a40c987b02d5daa60cb8bc3b4b92978">make_sum_of_squares_aggregation</a> ()</td></tr>
<tr class="separator:ga6a40c987b02d5daa60cb8bc3b4b92978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5d94f062b4e6da50362a18957f21b78"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gae5d94f062b4e6da50362a18957f21b78"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gae5d94f062b4e6da50362a18957f21b78">make_mean_aggregation</a> ()</td></tr>
<tr class="separator:gae5d94f062b4e6da50362a18957f21b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6409efbd5fac20862b76065d17e3423"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gad6409efbd5fac20862b76065d17e3423"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gad6409efbd5fac20862b76065d17e3423">make_m2_aggregation</a> ()</td></tr>
<tr class="memdesc:gad6409efbd5fac20862b76065d17e3423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a M2 aggregation  <br /></td></tr>
<tr class="separator:gad6409efbd5fac20862b76065d17e3423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9abb4c17f90c15712c5edba57c4b67d8"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga9abb4c17f90c15712c5edba57c4b67d8"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga9abb4c17f90c15712c5edba57c4b67d8">make_variance_aggregation</a> (<a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> ddof=1)</td></tr>
<tr class="memdesc:ga9abb4c17f90c15712c5edba57c4b67d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a VARIANCE aggregation  <br /></td></tr>
<tr class="separator:ga9abb4c17f90c15712c5edba57c4b67d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f3e8c7b8d395d160fed784479186412"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga4f3e8c7b8d395d160fed784479186412"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga4f3e8c7b8d395d160fed784479186412">make_std_aggregation</a> (<a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> ddof=1)</td></tr>
<tr class="memdesc:ga4f3e8c7b8d395d160fed784479186412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a STD aggregation  <br /></td></tr>
<tr class="separator:ga4f3e8c7b8d395d160fed784479186412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a96931dd2174dd158d7843e14c1e3e0"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga5a96931dd2174dd158d7843e14c1e3e0"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga5a96931dd2174dd158d7843e14c1e3e0">make_median_aggregation</a> ()</td></tr>
<tr class="separator:ga5a96931dd2174dd158d7843e14c1e3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2057553f0af67248aa9efd3607f9092"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gae2057553f0af67248aa9efd3607f9092"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gae2057553f0af67248aa9efd3607f9092">make_quantile_aggregation</a> (std::vector&lt; double &gt; const &amp;<a class="el" href="group__column__quantiles.html#ga5a7bfdd267148ba8038c50c3c27fa87a">quantiles</a>, <a class="el" href="group__utility__types.html#ga9cd17c1cdf028ead9a4783f605276ab3">interpolation</a> interp=<a class="el" href="group__utility__types.html#gga9cd17c1cdf028ead9a4783f605276ab3aaac544aacc3615aada24897a215f5046">interpolation::LINEAR</a>)</td></tr>
<tr class="memdesc:gae2057553f0af67248aa9efd3607f9092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a QUANTILE aggregation  <br /></td></tr>
<tr class="separator:gae2057553f0af67248aa9efd3607f9092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad99a06c2f1299bd11fa7e1c352b976de"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gad99a06c2f1299bd11fa7e1c352b976de"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gad99a06c2f1299bd11fa7e1c352b976de">make_argmax_aggregation</a> ()</td></tr>
<tr class="memdesc:gad99a06c2f1299bd11fa7e1c352b976de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create an ARGMAX aggregation  <br /></td></tr>
<tr class="separator:gad99a06c2f1299bd11fa7e1c352b976de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaf0438b1c84be2a9edecbc9f586593a"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gafaf0438b1c84be2a9edecbc9f586593a"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gafaf0438b1c84be2a9edecbc9f586593a">make_argmin_aggregation</a> ()</td></tr>
<tr class="memdesc:gafaf0438b1c84be2a9edecbc9f586593a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create an ARGMIN aggregation  <br /></td></tr>
<tr class="separator:gafaf0438b1c84be2a9edecbc9f586593a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacae54c114e7aefc438708bb5bbb391dc"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gacae54c114e7aefc438708bb5bbb391dc"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gacae54c114e7aefc438708bb5bbb391dc">make_nunique_aggregation</a> (<a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a> null_handling=<a class="el" href="group__utility__types.html#gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8">null_policy::EXCLUDE</a>)</td></tr>
<tr class="memdesc:gacae54c114e7aefc438708bb5bbb391dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a NUNIQUE aggregation  <br /></td></tr>
<tr class="separator:gacae54c114e7aefc438708bb5bbb391dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaeb94e5a4cdf3250298b2e475fc1a7ef"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gaaeb94e5a4cdf3250298b2e475fc1a7ef"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gaaeb94e5a4cdf3250298b2e475fc1a7ef">make_nth_element_aggregation</a> (<a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> n, <a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a> null_handling=<a class="el" href="group__utility__types.html#gga1b8cda4afb95a7c42c4679b4fae61009a04ff6a9583ba9957ebe1128d0f988ad8">null_policy::INCLUDE</a>)</td></tr>
<tr class="memdesc:gaaeb94e5a4cdf3250298b2e475fc1a7ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a NTH_ELEMENT aggregation  <br /></td></tr>
<tr class="separator:gaaeb94e5a4cdf3250298b2e475fc1a7ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac62f0cd24feeebf821f86d6d3daf03c1"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gac62f0cd24feeebf821f86d6d3daf03c1"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gac62f0cd24feeebf821f86d6d3daf03c1">make_row_number_aggregation</a> ()</td></tr>
<tr class="separator:gac62f0cd24feeebf821f86d6d3daf03c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8459759dcad222d9e3376be39644e034"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga8459759dcad222d9e3376be39644e034"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga8459759dcad222d9e3376be39644e034">make_rank_aggregation</a> (<a class="el" href="group__column__sort.html#gac8975ec1273372f6ccae83a85bee71ce">rank_method</a> method, <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> column_order=<a class="el" href="group__utility__types.html#gga750f02016b046079f7062d334890b4fca83ec681a20197326c163ea3b39ef7c32">order::ASCENDING</a>, <a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a> null_handling=<a class="el" href="group__utility__types.html#gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8">null_policy::EXCLUDE</a>, <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> null_precedence=<a class="el" href="group__utility__types.html#gga058e6d6e8a21583ce0e85ee73e5abb31ac130fda0cb93540bf1574912e78964fb">null_order::AFTER</a>, <a class="el" href="group__aggregation__factories.html#ga3701f066cd6ad8bad2a70fbfcef93071">rank_percentage</a> percentage=<a class="el" href="group__aggregation__factories.html#gga3701f066cd6ad8bad2a70fbfcef93071ab50339a10e1de285ac99d4c3990b8693">rank_percentage::NONE</a>)</td></tr>
<tr class="memdesc:ga8459759dcad222d9e3376be39644e034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a RANK aggregation  <br /></td></tr>
<tr class="separator:ga8459759dcad222d9e3376be39644e034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3990aa8b1b93f589b59da40bb2db3a92"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga3990aa8b1b93f589b59da40bb2db3a92"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga3990aa8b1b93f589b59da40bb2db3a92">make_collect_list_aggregation</a> (<a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a> null_handling=<a class="el" href="group__utility__types.html#gga1b8cda4afb95a7c42c4679b4fae61009a04ff6a9583ba9957ebe1128d0f988ad8">null_policy::INCLUDE</a>)</td></tr>
<tr class="memdesc:ga3990aa8b1b93f589b59da40bb2db3a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a COLLECT_LIST aggregation  <br /></td></tr>
<tr class="separator:ga3990aa8b1b93f589b59da40bb2db3a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5f717838c0e644888ee6d6fb277369c"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gaa5f717838c0e644888ee6d6fb277369c"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gaa5f717838c0e644888ee6d6fb277369c">make_collect_set_aggregation</a> (<a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a> null_handling=<a class="el" href="group__utility__types.html#gga1b8cda4afb95a7c42c4679b4fae61009a04ff6a9583ba9957ebe1128d0f988ad8">null_policy::INCLUDE</a>, <a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a> nulls_equal=<a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44">null_equality::EQUAL</a>, <a class="el" href="group__utility__types.html#gae9d1055c69c3089452794783c7c82f83">nan_equality</a> nans_equal=<a class="el" href="group__utility__types.html#ggae9d1055c69c3089452794783c7c82f83acd6d9f766e6e2753da429d26078711d7">nan_equality::ALL_EQUAL</a>)</td></tr>
<tr class="memdesc:gaa5f717838c0e644888ee6d6fb277369c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a COLLECT_SET aggregation  <br /></td></tr>
<tr class="separator:gaa5f717838c0e644888ee6d6fb277369c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f7d7d2810366fb16dfa5beeb6ac558d"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga4f7d7d2810366fb16dfa5beeb6ac558d"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga4f7d7d2810366fb16dfa5beeb6ac558d">make_lag_aggregation</a> (<a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> offset)</td></tr>
<tr class="memdesc:ga4f7d7d2810366fb16dfa5beeb6ac558d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a LAG aggregation  <br /></td></tr>
<tr class="separator:ga4f7d7d2810366fb16dfa5beeb6ac558d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae667d46023c348924a5bf6375b035d16"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gae667d46023c348924a5bf6375b035d16"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gae667d46023c348924a5bf6375b035d16">make_lead_aggregation</a> (<a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> offset)</td></tr>
<tr class="memdesc:gae667d46023c348924a5bf6375b035d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a LEAD aggregation  <br /></td></tr>
<tr class="separator:gae667d46023c348924a5bf6375b035d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacffa15e505b5c0be97fcac800b1b6e4a"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gacffa15e505b5c0be97fcac800b1b6e4a"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gacffa15e505b5c0be97fcac800b1b6e4a">make_udf_aggregation</a> (<a class="el" href="group__aggregation__factories.html#gad2e43a487f20c968b2474a5cb980527e">udf_type</a> type, std::string const &amp;user_defined_aggregator, <a class="el" href="classcudf_1_1data__type.html">data_type</a> output_type)</td></tr>
<tr class="memdesc:gacffa15e505b5c0be97fcac800b1b6e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create an aggregation base on UDF for PTX or CUDA  <br /></td></tr>
<tr class="separator:gacffa15e505b5c0be97fcac800b1b6e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga289507baeaaa23c86bd0d7a13927fd7f"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga289507baeaaa23c86bd0d7a13927fd7f"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga289507baeaaa23c86bd0d7a13927fd7f">make_merge_lists_aggregation</a> ()</td></tr>
<tr class="memdesc:ga289507baeaaa23c86bd0d7a13927fd7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a MERGE_LISTS aggregation.  <br /></td></tr>
<tr class="separator:ga289507baeaaa23c86bd0d7a13927fd7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe6648e29d5c2043be76299c089e0e20"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:gabe6648e29d5c2043be76299c089e0e20"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#gabe6648e29d5c2043be76299c089e0e20">make_merge_sets_aggregation</a> (<a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a> nulls_equal=<a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44">null_equality::EQUAL</a>, <a class="el" href="group__utility__types.html#gae9d1055c69c3089452794783c7c82f83">nan_equality</a> nans_equal=<a class="el" href="group__utility__types.html#ggae9d1055c69c3089452794783c7c82f83acd6d9f766e6e2753da429d26078711d7">nan_equality::ALL_EQUAL</a>)</td></tr>
<tr class="memdesc:gabe6648e29d5c2043be76299c089e0e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a MERGE_SETS aggregation.  <br /></td></tr>
<tr class="separator:gabe6648e29d5c2043be76299c089e0e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39e2d507b2d0ea78658c5c2c76313b62"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga39e2d507b2d0ea78658c5c2c76313b62"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga39e2d507b2d0ea78658c5c2c76313b62">make_merge_m2_aggregation</a> ()</td></tr>
<tr class="memdesc:ga39e2d507b2d0ea78658c5c2c76313b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a MERGE_M2 aggregation  <br /></td></tr>
<tr class="separator:ga39e2d507b2d0ea78658c5c2c76313b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93c7e22dc9ee73c06fdda6a592a240b3"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga93c7e22dc9ee73c06fdda6a592a240b3"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga93c7e22dc9ee73c06fdda6a592a240b3">make_covariance_aggregation</a> (<a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> min_periods=1, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> ddof=1)</td></tr>
<tr class="memdesc:ga93c7e22dc9ee73c06fdda6a592a240b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a COVARIANCE aggregation  <br /></td></tr>
<tr class="separator:ga93c7e22dc9ee73c06fdda6a592a240b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga484a5d1daa12445e816036e72bfa1154"><td class="memTemplParams" colspan="2">template&lt;typename Base  = aggregation&gt; </td></tr>
<tr class="memitem:ga484a5d1daa12445e816036e72bfa1154"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga484a5d1daa12445e816036e72bfa1154">make_correlation_aggregation</a> (<a class="el" href="group__aggregation__factories.html#ga1dc83597d5b1e9cf752fc20fcdd77d40">correlation_type</a> type, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> min_periods=1)</td></tr>
<tr class="memdesc:ga484a5d1daa12445e816036e72bfa1154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a CORRELATION aggregation  <br /></td></tr>
<tr class="separator:ga484a5d1daa12445e816036e72bfa1154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92a39b05abcbb6fb8ceff7d28e36477b"><td class="memTemplParams" colspan="2">template&lt;typename Base &gt; </td></tr>
<tr class="memitem:ga92a39b05abcbb6fb8ceff7d28e36477b"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga92a39b05abcbb6fb8ceff7d28e36477b">make_tdigest_aggregation</a> (int max_centroids=1000)</td></tr>
<tr class="memdesc:ga92a39b05abcbb6fb8ceff7d28e36477b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a TDIGEST aggregation  <br /></td></tr>
<tr class="separator:ga92a39b05abcbb6fb8ceff7d28e36477b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6541f64eed15c1ce29fdf27f67f31330"><td class="memTemplParams" colspan="2">template&lt;typename Base &gt; </td></tr>
<tr class="memitem:ga6541f64eed15c1ce29fdf27f67f31330"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__aggregation__factories.html#ga6541f64eed15c1ce29fdf27f67f31330">make_merge_tdigest_aggregation</a> (int max_centroids=1000)</td></tr>
<tr class="memdesc:ga6541f64eed15c1ce29fdf27f67f31330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory to create a MERGE_TDIGEST aggregation  <br /></td></tr>
<tr class="separator:ga6541f64eed15c1ce29fdf27f67f31330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff4f1be08dc3f02b429f4899b2eacbbf"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__binaryops.html#gaff4f1be08dc3f02b429f4899b2eacbbf">binary_operation</a> (<a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;lhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;rhs, <a class="el" href="group__transformation__binaryops.html#ga00ed76601b6db662550f6826cfd99edc">binary_operator</a> op, <a class="el" href="classcudf_1_1data__type.html">data_type</a> output_type, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gaff4f1be08dc3f02b429f4899b2eacbbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary operation between a scalar and a column.  <br /></td></tr>
<tr class="separator:gaff4f1be08dc3f02b429f4899b2eacbbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga226c33874fc97e5e3122522425f3072b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__binaryops.html#ga226c33874fc97e5e3122522425f3072b">binary_operation</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;lhs, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;rhs, <a class="el" href="group__transformation__binaryops.html#ga00ed76601b6db662550f6826cfd99edc">binary_operator</a> op, <a class="el" href="classcudf_1_1data__type.html">data_type</a> output_type, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga226c33874fc97e5e3122522425f3072b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary operation between a column and a scalar.  <br /></td></tr>
<tr class="separator:ga226c33874fc97e5e3122522425f3072b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43558085c43d054937158b9de88b689d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__binaryops.html#ga43558085c43d054937158b9de88b689d">binary_operation</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;lhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;rhs, <a class="el" href="group__transformation__binaryops.html#ga00ed76601b6db662550f6826cfd99edc">binary_operator</a> op, <a class="el" href="classcudf_1_1data__type.html">data_type</a> output_type, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga43558085c43d054937158b9de88b689d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary operation between two columns.  <br /></td></tr>
<tr class="separator:ga43558085c43d054937158b9de88b689d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab106aa46f902ec1266feb4eb5f0fef6b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__binaryops.html#gab106aa46f902ec1266feb4eb5f0fef6b">binary_operation</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;lhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;rhs, std::string const &amp;ptx, <a class="el" href="classcudf_1_1data__type.html">data_type</a> output_type, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gab106aa46f902ec1266feb4eb5f0fef6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary operation between two columns using a user-defined PTX function.  <br /></td></tr>
<tr class="separator:gab106aa46f902ec1266feb4eb5f0fef6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76c84637bf4ca70809860a6135bb301a"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__binaryops.html#ga76c84637bf4ca70809860a6135bb301a">binary_operation_fixed_point_scale</a> (<a class="el" href="group__transformation__binaryops.html#ga00ed76601b6db662550f6826cfd99edc">binary_operator</a> op, int32_t left_scale, int32_t right_scale)</td></tr>
<tr class="memdesc:ga76c84637bf4ca70809860a6135bb301a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the <code>scale</code> for a <code>fixed_point</code> number based on given binary operator <code>op</code>  <br /></td></tr>
<tr class="separator:ga76c84637bf4ca70809860a6135bb301a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga065bbc22dc02e3f4dd04a904c094acca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcudf_1_1data__type.html">cudf::data_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__binaryops.html#ga065bbc22dc02e3f4dd04a904c094acca">binary_operation_fixed_point_output_type</a> (<a class="el" href="group__transformation__binaryops.html#ga00ed76601b6db662550f6826cfd99edc">binary_operator</a> op, <a class="el" href="classcudf_1_1data__type.html">cudf::data_type</a> const &amp;lhs, <a class="el" href="classcudf_1_1data__type.html">cudf::data_type</a> const &amp;rhs)</td></tr>
<tr class="memdesc:ga065bbc22dc02e3f4dd04a904c094acca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> for a <code>fixed_point</code> number based on given binary operator <code>op</code>  <br /></td></tr>
<tr class="separator:ga065bbc22dc02e3f4dd04a904c094acca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa80de7d88a408ab660541a4a3b214ead"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__factories.html#gaa80de7d88a408ab660541a4a3b214ead">make_empty_column</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:gaa80de7d88a408ab660541a4a3b214ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty column of the specified <code>type</code>  <br /></td></tr>
<tr class="separator:gaa80de7d88a408ab660541a4a3b214ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga890d1519f4d245dca1f33d09b90f7ca5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__factories.html#ga890d1519f4d245dca1f33d09b90f7ca5">make_empty_column</a> (<a class="el" href="group__utility__types.html#gadf077607da617d1dadcc5417e2783539">type_id</a> id)</td></tr>
<tr class="memdesc:ga890d1519f4d245dca1f33d09b90f7ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty column of the specified type.  <br /></td></tr>
<tr class="separator:ga890d1519f4d245dca1f33d09b90f7ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84a9f9deecdbac612cb79cec10a1cff6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__factories.html#ga84a9f9deecdbac612cb79cec10a1cff6">make_numeric_column</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> size, <a class="el" href="group__utility__types.html#ga4daf20c000ab374d76f4d56f0ddb7b26">mask_state</a> state=<a class="el" href="group__utility__types.html#gga4daf20c000ab374d76f4d56f0ddb7b26a628732521c22dcf8a24bf1a0326bde80">mask_state::UNALLOCATED</a>, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga84a9f9deecdbac612cb79cec10a1cff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified numeric <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with an optional null mask.  <br /></td></tr>
<tr class="separator:ga84a9f9deecdbac612cb79cec10a1cff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad908ea3b27809643a5459d191e52ac91"><td class="memTemplParams" colspan="2">template&lt;typename B &gt; </td></tr>
<tr class="memitem:gad908ea3b27809643a5459d191e52ac91"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__column__factories.html#gad908ea3b27809643a5459d191e52ac91">make_numeric_column</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> size, B &amp;&amp;null_mask, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> null_count=<a class="el" href="group__utility__types.html#ga0eece3f40ff89fe8f1117097d86913b7">cudf::UNKNOWN_NULL_COUNT</a>, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gad908ea3b27809643a5459d191e52ac91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified numeric <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with a null mask.  <br /></td></tr>
<tr class="separator:gad908ea3b27809643a5459d191e52ac91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9329fc1ef9d96f36d71eab418926c206"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__factories.html#ga9329fc1ef9d96f36d71eab418926c206">make_fixed_point_column</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> size, <a class="el" href="group__utility__types.html#ga4daf20c000ab374d76f4d56f0ddb7b26">mask_state</a> state=<a class="el" href="group__utility__types.html#gga4daf20c000ab374d76f4d56f0ddb7b26a628732521c22dcf8a24bf1a0326bde80">mask_state::UNALLOCATED</a>, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga9329fc1ef9d96f36d71eab418926c206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified <code>fixed_point</code> <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with an optional null mask.  <br /></td></tr>
<tr class="separator:ga9329fc1ef9d96f36d71eab418926c206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae70cbf7bed0d8e08087cbef612d0affb"><td class="memTemplParams" colspan="2">template&lt;typename B &gt; </td></tr>
<tr class="memitem:gae70cbf7bed0d8e08087cbef612d0affb"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__column__factories.html#gae70cbf7bed0d8e08087cbef612d0affb">make_fixed_point_column</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> size, B &amp;&amp;null_mask, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> null_count=<a class="el" href="group__utility__types.html#ga0eece3f40ff89fe8f1117097d86913b7">cudf::UNKNOWN_NULL_COUNT</a>, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gae70cbf7bed0d8e08087cbef612d0affb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified <code>fixed_point</code> <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with a null mask.  <br /></td></tr>
<tr class="separator:gae70cbf7bed0d8e08087cbef612d0affb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3dd1ff4b11ca9c70322004ea72fdf0d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__factories.html#gad3dd1ff4b11ca9c70322004ea72fdf0d">make_timestamp_column</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> size, <a class="el" href="group__utility__types.html#ga4daf20c000ab374d76f4d56f0ddb7b26">mask_state</a> state=<a class="el" href="group__utility__types.html#gga4daf20c000ab374d76f4d56f0ddb7b26a628732521c22dcf8a24bf1a0326bde80">mask_state::UNALLOCATED</a>, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gad3dd1ff4b11ca9c70322004ea72fdf0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified timestamp <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with an optional null mask.  <br /></td></tr>
<tr class="separator:gad3dd1ff4b11ca9c70322004ea72fdf0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82d67ff8acbde7370b6dfa4eeaf63893"><td class="memTemplParams" colspan="2">template&lt;typename B &gt; </td></tr>
<tr class="memitem:ga82d67ff8acbde7370b6dfa4eeaf63893"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__column__factories.html#ga82d67ff8acbde7370b6dfa4eeaf63893">make_timestamp_column</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> size, B &amp;&amp;null_mask, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> null_count=<a class="el" href="group__utility__types.html#ga0eece3f40ff89fe8f1117097d86913b7">cudf::UNKNOWN_NULL_COUNT</a>, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga82d67ff8acbde7370b6dfa4eeaf63893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified timestamp <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with a null mask.  <br /></td></tr>
<tr class="separator:ga82d67ff8acbde7370b6dfa4eeaf63893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b83c4013e49cc28c0a2a74569853228"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__factories.html#ga7b83c4013e49cc28c0a2a74569853228">make_duration_column</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> size, <a class="el" href="group__utility__types.html#ga4daf20c000ab374d76f4d56f0ddb7b26">mask_state</a> state=<a class="el" href="group__utility__types.html#gga4daf20c000ab374d76f4d56f0ddb7b26a628732521c22dcf8a24bf1a0326bde80">mask_state::UNALLOCATED</a>, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga7b83c4013e49cc28c0a2a74569853228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified duration <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with an optional null mask.  <br /></td></tr>
<tr class="separator:ga7b83c4013e49cc28c0a2a74569853228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0720e031f009c728943536a1cc9d361d"><td class="memTemplParams" colspan="2">template&lt;typename B &gt; </td></tr>
<tr class="memitem:ga0720e031f009c728943536a1cc9d361d"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__column__factories.html#ga0720e031f009c728943536a1cc9d361d">make_duration_column</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> size, B &amp;&amp;null_mask, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> null_count=<a class="el" href="group__utility__types.html#ga0eece3f40ff89fe8f1117097d86913b7">cudf::UNKNOWN_NULL_COUNT</a>, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga0720e031f009c728943536a1cc9d361d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified duration <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with a null mask.  <br /></td></tr>
<tr class="separator:ga0720e031f009c728943536a1cc9d361d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac251edf105c64ee963df5e53eeffd091"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__factories.html#gac251edf105c64ee963df5e53eeffd091">make_fixed_width_column</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> size, <a class="el" href="group__utility__types.html#ga4daf20c000ab374d76f4d56f0ddb7b26">mask_state</a> state=<a class="el" href="group__utility__types.html#gga4daf20c000ab374d76f4d56f0ddb7b26a628732521c22dcf8a24bf1a0326bde80">mask_state::UNALLOCATED</a>, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gac251edf105c64ee963df5e53eeffd091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified fixed width <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with an optional null mask.  <br /></td></tr>
<tr class="separator:gac251edf105c64ee963df5e53eeffd091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe7756d1ac2c1027c2d1403054f482cb"><td class="memTemplParams" colspan="2">template&lt;typename B &gt; </td></tr>
<tr class="memitem:gabe7756d1ac2c1027c2d1403054f482cb"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__column__factories.html#gabe7756d1ac2c1027c2d1403054f482cb">make_fixed_width_column</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> size, B &amp;&amp;null_mask, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> null_count=<a class="el" href="group__utility__types.html#ga0eece3f40ff89fe8f1117097d86913b7">cudf::UNKNOWN_NULL_COUNT</a>, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gabe7756d1ac2c1027c2d1403054f482cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified fixed width <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with a null mask.  <br /></td></tr>
<tr class="separator:gabe7756d1ac2c1027c2d1403054f482cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b4c7323b0728830bccaf9fd8785ce18"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__factories.html#ga1b4c7323b0728830bccaf9fd8785ce18">make_strings_column</a> (<a class="el" href="structcudf_1_1device__span.html">cudf::device_span</a>&lt; thrust::pair&lt; const char *, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; const &gt; strings, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga1b4c7323b0728830bccaf9fd8785ce18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a STRING type column given a device span of pointer/size pairs.  <br /></td></tr>
<tr class="separator:ga1b4c7323b0728830bccaf9fd8785ce18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac63c5f712a69911f57e1a25ea19aa4b9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__factories.html#gac63c5f712a69911f57e1a25ea19aa4b9">make_strings_column</a> (<a class="el" href="structcudf_1_1device__span.html">cudf::device_span</a>&lt; <a class="el" href="classcudf_1_1string__view.html">string_view</a> const &gt; string_views, const <a class="el" href="classcudf_1_1string__view.html">string_view</a> null_placeholder, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gac63c5f712a69911f57e1a25ea19aa4b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a STRING type column given a device span of <a class="el" href="classcudf_1_1string__view.html" title="A non-owning, immutable view of device data that is a variable length char array representing a UTF-8...">string_view</a>.  <br /></td></tr>
<tr class="separator:gac63c5f712a69911f57e1a25ea19aa4b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga344b235a4e1cbecd985858e64d8b2075"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__factories.html#ga344b235a4e1cbecd985858e64d8b2075">make_strings_column</a> (<a class="el" href="structcudf_1_1device__span.html">cudf::device_span</a>&lt; char const &gt; strings, <a class="el" href="structcudf_1_1device__span.html">cudf::device_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt; offsets, <a class="el" href="structcudf_1_1device__span.html">cudf::device_span</a>&lt; <a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> const &gt; null_mask={}, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> null_count=<a class="el" href="group__utility__types.html#ga0eece3f40ff89fe8f1117097d86913b7">cudf::UNKNOWN_NULL_COUNT</a>, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga344b235a4e1cbecd985858e64d8b2075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a STRING type column given a device span of chars encoded as UTF-8, a device span of byte offsets identifying individual strings within the char vector, and an optional null bitmask.  <br /></td></tr>
<tr class="separator:ga344b235a4e1cbecd985858e64d8b2075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace1c51569535b5ea5d23805470cfe8b7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__factories.html#gace1c51569535b5ea5d23805470cfe8b7">make_strings_column</a> (<a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> num_strings, std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; offsets_column, std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; chars_column, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> null_count, rmm::device_buffer &amp;&amp;null_mask)</td></tr>
<tr class="memdesc:gace1c51569535b5ea5d23805470cfe8b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a STRING type column given offsets column, chars columns, and null mask and null count.  <br /></td></tr>
<tr class="separator:gace1c51569535b5ea5d23805470cfe8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12fdea6621b2945532151737c740a368"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__factories.html#ga12fdea6621b2945532151737c740a368">make_strings_column</a> (<a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> num_strings, rmm::device_uvector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; &amp;&amp;offsets, rmm::device_uvector&lt; char &gt; &amp;&amp;chars, rmm::device_buffer &amp;&amp;null_mask={}, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> null_count=<a class="el" href="group__utility__types.html#ga0eece3f40ff89fe8f1117097d86913b7">cudf::UNKNOWN_NULL_COUNT</a>)</td></tr>
<tr class="memdesc:ga12fdea6621b2945532151737c740a368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a STRING type column given offsets, columns, and optional null count and null mask.  <br /></td></tr>
<tr class="separator:ga12fdea6621b2945532151737c740a368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedfbe8e49523fcea96952534c6fa44b2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__factories.html#gaedfbe8e49523fcea96952534c6fa44b2">make_lists_column</a> (<a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> num_rows, std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; offsets_column, std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; child_column, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> null_count, rmm::device_buffer &amp;&amp;null_mask, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gaedfbe8e49523fcea96952534c6fa44b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a LIST type column given offsets column, child column, null mask and null count.  <br /></td></tr>
<tr class="separator:gaedfbe8e49523fcea96952534c6fa44b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca4580640fa3c0304fe22377b5ef1d3b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__factories.html#gaca4580640fa3c0304fe22377b5ef1d3b">make_structs_column</a> (<a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> num_rows, std::vector&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; &gt; &amp;&amp;child_columns, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> null_count, rmm::device_buffer &amp;&amp;null_mask, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gaca4580640fa3c0304fe22377b5ef1d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a STRUCT column using specified child columns as members.  <br /></td></tr>
<tr class="separator:gaca4580640fa3c0304fe22377b5ef1d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf402ec1007ea53418b2d5800daae8041"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__factories.html#gaf402ec1007ea53418b2d5800daae8041">make_column_from_scalar</a> (<a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;s, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> size, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gaf402ec1007ea53418b2d5800daae8041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a column with size elements that are all equal to the given scalar.  <br /></td></tr>
<tr class="separator:gaf402ec1007ea53418b2d5800daae8041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4cb6e1340b0b96386142f25a0126fb6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__factories.html#gae4cb6e1340b0b96386142f25a0126fb6">make_dictionary_from_scalar</a> (<a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;s, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> size, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gae4cb6e1340b0b96386142f25a0126fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a dictionary column with size elements that are all equal to the given scalar.  <br /></td></tr>
<tr class="separator:gae4cb6e1340b0b96386142f25a0126fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef675a9c75a848ab796ae9b2b51c4238"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#aef675a9c75a848ab796ae9b2b51c4238">count_descendants</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> parent)</td></tr>
<tr class="memdesc:aef675a9c75a848ab796ae9b2b51c4238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of descendants of the specified parent.  <br /></td></tr>
<tr class="separator:aef675a9c75a848ab796ae9b2b51c4238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd44b61ff4585b5278f2d2203c909b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcudf_1_1column__view.html">column_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a8bd44b61ff4585b5278f2d2203c909b7">bit_cast</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:a8bd44b61ff4585b5278f2d2203c909b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero-copy cast between types with the same size and compatible underlying representations.  <br /></td></tr>
<tr class="separator:a8bd44b61ff4585b5278f2d2203c909b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312e4e0407f66456946bf14c6713f54b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcudf_1_1mutable__column__view.html">mutable_column_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a312e4e0407f66456946bf14c6713f54b">bit_cast</a> (<a class="el" href="classcudf_1_1mutable__column__view.html">mutable_column_view</a> const &amp;input, <a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:a312e4e0407f66456946bf14c6713f54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero-copy cast between types with the same size and compatible underlying representations.  <br /></td></tr>
<tr class="separator:a312e4e0407f66456946bf14c6713f54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91c9bef36c0e9ae6499f8a7076fe23b2"><td class="memItemLeft" align="right" valign="top">rmm::device_buffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__copy__concatenate.html#ga91c9bef36c0e9ae6499f8a7076fe23b2">concatenate_masks</a> (<a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &gt; views, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga91c9bef36c0e9ae6499f8a7076fe23b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates <code>views[i]</code>'s bitmask from the bits <code>[views[i].offset(), views[i].offset() + views[i].size())</code> for all elements views[i] in views into a <code>device_buffer</code>  <br /></td></tr>
<tr class="separator:ga91c9bef36c0e9ae6499f8a7076fe23b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae7c224600919f3760c0edf1b17d0320"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__copy__concatenate.html#gaae7c224600919f3760c0edf1b17d0320">concatenate</a> (<a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &gt; columns_to_concat, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gaae7c224600919f3760c0edf1b17d0320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates multiple columns into a single column.  <br /></td></tr>
<tr class="separator:gaae7c224600919f3760c0edf1b17d0320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72494daf53a1677fe373ce6d4d7470a1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__copy__concatenate.html#ga72494daf53a1677fe373ce6d4d7470a1">concatenate</a> (<a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &gt; tables_to_concat, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga72494daf53a1677fe373ce6d4d7470a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Columns of <code>tables_to_concat</code> are concatenated vertically to return a single table  <br /></td></tr>
<tr class="separator:ga72494daf53a1677fe373ce6d4d7470a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19ea162e7794e6cbbc2faba70fbd91aa"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga19ea162e7794e6cbbc2faba70fbd91aa">gather</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;source_table, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;gather_map, <a class="el" href="group__column__copy.html#gae3ba74951558bc7966aae86abc6af5df">out_of_bounds_policy</a> bounds_policy=<a class="el" href="group__column__copy.html#ggae3ba74951558bc7966aae86abc6af5dfa12c1109487cf9a6a336b1dfe462bfd2d">out_of_bounds_policy::DONT_CHECK</a>, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga19ea162e7794e6cbbc2faba70fbd91aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers the specified rows (including null values) of a set of columns.  <br /></td></tr>
<tr class="separator:ga19ea162e7794e6cbbc2faba70fbd91aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbbf4a02a5108cbcd9368ce31efc7f2a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gafbbf4a02a5108cbcd9368ce31efc7f2a">reverse</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;source_table, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gafbbf4a02a5108cbcd9368ce31efc7f2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the rows within a table.  <br /></td></tr>
<tr class="separator:gafbbf4a02a5108cbcd9368ce31efc7f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f6bd5517ff6f32a20b20d66a22616a7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga6f6bd5517ff6f32a20b20d66a22616a7">reverse</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;source_column, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga6f6bd5517ff6f32a20b20d66a22616a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the elements of a column  <br /></td></tr>
<tr class="separator:ga6f6bd5517ff6f32a20b20d66a22616a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd90ba38ea2655ce3b435d2a4f199358"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gabd90ba38ea2655ce3b435d2a4f199358">scatter</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;source, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;scatter_map, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;target, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gabd90ba38ea2655ce3b435d2a4f199358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatters the rows of the source table into a copy of the target table according to a scatter map.  <br /></td></tr>
<tr class="separator:gabd90ba38ea2655ce3b435d2a4f199358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga474f55905324aea8ed00ff8e3e3fecea"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga474f55905324aea8ed00ff8e3e3fecea">scatter</a> (std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt; &gt; const &amp;source, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;indices, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;target, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga474f55905324aea8ed00ff8e3e3fecea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatters a row of scalar values into a copy of the target table according to a scatter map.  <br /></td></tr>
<tr class="separator:ga474f55905324aea8ed00ff8e3e3fecea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62eff2fcac7ff377df316c7ef37ee4fd"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga62eff2fcac7ff377df316c7ef37ee4fd">empty_like</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input)</td></tr>
<tr class="memdesc:ga62eff2fcac7ff377df316c7ef37ee4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes and returns an empty column of the same type as the <code>input</code>.  <br /></td></tr>
<tr class="separator:ga62eff2fcac7ff377df316c7ef37ee4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf190ab1fe40049bc95bf7aebad93450"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gadf190ab1fe40049bc95bf7aebad93450">empty_like</a> (<a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;input)</td></tr>
<tr class="memdesc:gadf190ab1fe40049bc95bf7aebad93450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes and returns an empty column of the same type as the <code>input</code>.  <br /></td></tr>
<tr class="separator:gadf190ab1fe40049bc95bf7aebad93450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5aa629d9ff2157990e7187b9e1552df"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gab5aa629d9ff2157990e7187b9e1552df">allocate_like</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="group__column__copy.html#ga267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a> mask_alloc=<a class="el" href="group__column__copy.html#gga267e03474dcfd85242d2fdc6e5846ec6a47e9136fa770199f6a8a9727b6173eb4">mask_allocation_policy::RETAIN</a>, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gab5aa629d9ff2157990e7187b9e1552df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an uninitialized new column of the same size and type as the <code>input</code>.  <br /></td></tr>
<tr class="separator:gab5aa629d9ff2157990e7187b9e1552df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c1552cc6c2d49d1a74b907bd4bb2baa"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga9c1552cc6c2d49d1a74b907bd4bb2baa">allocate_like</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> size, <a class="el" href="group__column__copy.html#ga267e03474dcfd85242d2fdc6e5846ec6">mask_allocation_policy</a> mask_alloc=<a class="el" href="group__column__copy.html#gga267e03474dcfd85242d2fdc6e5846ec6a47e9136fa770199f6a8a9727b6173eb4">mask_allocation_policy::RETAIN</a>, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga9c1552cc6c2d49d1a74b907bd4bb2baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an uninitialized new column of the specified size and same type as the <code>input</code>.  <br /></td></tr>
<tr class="separator:ga9c1552cc6c2d49d1a74b907bd4bb2baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf51eaa0bed9085f857e8edbcb4141d76"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gaf51eaa0bed9085f857e8edbcb4141d76">empty_like</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input_table)</td></tr>
<tr class="memdesc:gaf51eaa0bed9085f857e8edbcb4141d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a table of empty columns with the same types as the <code>input_table</code>  <br /></td></tr>
<tr class="separator:gaf51eaa0bed9085f857e8edbcb4141d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7453a32aa49fd9a55287a776f2b4b2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gaf7453a32aa49fd9a55287a776f2b4b2f">copy_range_in_place</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;source, <a class="el" href="classcudf_1_1mutable__column__view.html">mutable_column_view</a> &amp;target, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> source_begin, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> source_end, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> target_begin)</td></tr>
<tr class="memdesc:gaf7453a32aa49fd9a55287a776f2b4b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a range of elements in-place from one column to another.  <br /></td></tr>
<tr class="separator:gaf7453a32aa49fd9a55287a776f2b4b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9358e7f2ed4d47e3ee03f24ef711e402"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga9358e7f2ed4d47e3ee03f24ef711e402">copy_range</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;source, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;target, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> source_begin, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> source_end, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> target_begin, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga9358e7f2ed4d47e3ee03f24ef711e402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a range of elements out-of-place from one column to another.  <br /></td></tr>
<tr class="separator:ga9358e7f2ed4d47e3ee03f24ef711e402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80b6ccd43dbb2359d520a3f3ea100e8e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga80b6ccd43dbb2359d520a3f3ea100e8e">shift</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> offset, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;fill_value, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga80b6ccd43dbb2359d520a3f3ea100e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new column by shifting all values by an offset.  <br /></td></tr>
<tr class="separator:ga80b6ccd43dbb2359d520a3f3ea100e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52223b0ef6807f9a2454f7395b5425d4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcudf_1_1column__view.html">column_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga52223b0ef6807f9a2454f7395b5425d4">slice</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt; indices)</td></tr>
<tr class="memdesc:ga52223b0ef6807f9a2454f7395b5425d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slices a <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> into a set of <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code>s according to a set of indices.  <br /></td></tr>
<tr class="separator:ga52223b0ef6807f9a2454f7395b5425d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77b1d2c6579fa0ad8da690c8cd4c3192"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcudf_1_1column__view.html">column_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga77b1d2c6579fa0ad8da690c8cd4c3192">slice</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, std::initializer_list&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; indices)</td></tr>
<tr class="separator:ga77b1d2c6579fa0ad8da690c8cd4c3192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61a6785244331834b458545e084b7017"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcudf_1_1table__view.html">table_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga61a6785244331834b458545e084b7017">slice</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, <a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt; indices)</td></tr>
<tr class="memdesc:ga61a6785244331834b458545e084b7017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slices a <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> into a set of <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code>s according to a set of indices.  <br /></td></tr>
<tr class="separator:ga61a6785244331834b458545e084b7017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadc72fabae41e8187065211ebe7d6cce"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcudf_1_1table__view.html">table_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gaadc72fabae41e8187065211ebe7d6cce">slice</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, std::initializer_list&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; indices)</td></tr>
<tr class="separator:gaadc72fabae41e8187065211ebe7d6cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95ac220988903ef24d698ff49c683bfc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcudf_1_1column__view.html">column_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga95ac220988903ef24d698ff49c683bfc">split</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt; splits)</td></tr>
<tr class="memdesc:ga95ac220988903ef24d698ff49c683bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> into a set of <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code>s according to a set of indices derived from expected splits.  <br /></td></tr>
<tr class="separator:ga95ac220988903ef24d698ff49c683bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fb87b85cb2fedb682a6f4103414f97f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcudf_1_1column__view.html">column_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga5fb87b85cb2fedb682a6f4103414f97f">split</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, std::initializer_list&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; splits)</td></tr>
<tr class="separator:ga5fb87b85cb2fedb682a6f4103414f97f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72d5748fbf4bd848295769dce8a80979"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcudf_1_1table__view.html">table_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga72d5748fbf4bd848295769dce8a80979">split</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, <a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt; splits)</td></tr>
<tr class="memdesc:ga72d5748fbf4bd848295769dce8a80979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> into a set of <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code>s according to a set of indices derived from expected splits.  <br /></td></tr>
<tr class="separator:ga72d5748fbf4bd848295769dce8a80979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94277c977c86ac93ebb279f562906aa0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcudf_1_1table__view.html">table_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga94277c977c86ac93ebb279f562906aa0">split</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, std::initializer_list&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; splits)</td></tr>
<tr class="separator:ga94277c977c86ac93ebb279f562906aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab171e877b57253d521eb8f6d3c7d7c4a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structcudf_1_1packed__table.html">packed_table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gab171e877b57253d521eb8f6d3c7d7c4a">contiguous_split</a> (<a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;input, std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; const &amp;splits, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gab171e877b57253d521eb8f6d3c7d7c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a deep-copy split of a <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> into a set of <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code>s into a single contiguous block of memory.  <br /></td></tr>
<tr class="separator:gab171e877b57253d521eb8f6d3c7d7c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb39dd8301fb76bfec9e777820bda3f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1packed__columns.html">packed_columns</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gaeb39dd8301fb76bfec9e777820bda3f2">pack</a> (<a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;input, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gaeb39dd8301fb76bfec9e777820bda3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep-copy a <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> into a serialized contiguous memory format  <br /></td></tr>
<tr class="separator:gaeb39dd8301fb76bfec9e777820bda3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab28fc2d2294f2840df37814e7a4aa582"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcudf_1_1packed__columns_1_1metadata.html">packed_columns::metadata</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gab28fc2d2294f2840df37814e7a4aa582">pack_metadata</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;<a class="el" href="classcudf_1_1table.html">table</a>, uint8_t const *contiguous_buffer, size_t buffer_size)</td></tr>
<tr class="memdesc:gab28fc2d2294f2840df37814e7a4aa582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce the metadata used for packing a table stored in a contiguous buffer.  <br /></td></tr>
<tr class="separator:gab28fc2d2294f2840df37814e7a4aa582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d62a18c2e6f087a92289c63693762cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcudf_1_1table__view.html">table_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga1d62a18c2e6f087a92289c63693762cc">unpack</a> (<a class="el" href="structcudf_1_1packed__columns.html">packed_columns</a> const &amp;input)</td></tr>
<tr class="memdesc:ga1d62a18c2e6f087a92289c63693762cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize the result of <code><a class="el" href="group__column__copy.html#gaeb39dd8301fb76bfec9e777820bda3f2" title="Deep-copy a table_view into a serialized contiguous memory format">cudf::pack</a></code>  <br /></td></tr>
<tr class="separator:ga1d62a18c2e6f087a92289c63693762cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaebfb6742c09cccda8fb8a78e19fbd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcudf_1_1table__view.html">table_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gaaaebfb6742c09cccda8fb8a78e19fbd6">unpack</a> (uint8_t const *metadata, uint8_t const *gpu_data)</td></tr>
<tr class="memdesc:gaaaebfb6742c09cccda8fb8a78e19fbd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize the result of <code><a class="el" href="group__column__copy.html#gaeb39dd8301fb76bfec9e777820bda3f2" title="Deep-copy a table_view into a serialized contiguous memory format">cudf::pack</a></code>  <br /></td></tr>
<tr class="separator:gaaaebfb6742c09cccda8fb8a78e19fbd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20a8a274e5efd32f012ada60ed20fbf1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga20a8a274e5efd32f012ada60ed20fbf1">copy_if_else</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;lhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;rhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;boolean_mask, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga20a8a274e5efd32f012ada60ed20fbf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>  <br /></td></tr>
<tr class="separator:ga20a8a274e5efd32f012ada60ed20fbf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9419155faa6145c567bc10f4a9022b2f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga9419155faa6145c567bc10f4a9022b2f">copy_if_else</a> (<a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;lhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;rhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;boolean_mask, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga9419155faa6145c567bc10f4a9022b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>  <br /></td></tr>
<tr class="separator:ga9419155faa6145c567bc10f4a9022b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ef360d8b66500f7da10f9cb8298e079"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga0ef360d8b66500f7da10f9cb8298e079">copy_if_else</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;lhs, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;rhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;boolean_mask, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga0ef360d8b66500f7da10f9cb8298e079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>  <br /></td></tr>
<tr class="separator:ga0ef360d8b66500f7da10f9cb8298e079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f5e9508f27672af7450bbfc7a4acdb4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga5f5e9508f27672af7450bbfc7a4acdb4">copy_if_else</a> (<a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;lhs, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;rhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;boolean_mask, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga5f5e9508f27672af7450bbfc7a4acdb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new column, where each element is selected from either <code>lhs</code> or <code>rhs</code> based on the value of the corresponding element in <code>boolean_mask</code>  <br /></td></tr>
<tr class="separator:ga5f5e9508f27672af7450bbfc7a4acdb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5cc9b107359c2666847a4586d07ef70"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#gae5cc9b107359c2666847a4586d07ef70">boolean_mask_scatter</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;target, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;boolean_mask, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gae5cc9b107359c2666847a4586d07ef70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatters rows from the input table to rows of the output corresponding to true values in a boolean mask.  <br /></td></tr>
<tr class="separator:gae5cc9b107359c2666847a4586d07ef70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7945f25673f72c65e1bf60821fa579e7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga7945f25673f72c65e1bf60821fa579e7">boolean_mask_scatter</a> (std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt; &gt; const &amp;input, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;target, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;boolean_mask, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga7945f25673f72c65e1bf60821fa579e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scatters scalar values to rows of the output corresponding to true values in a boolean mask.  <br /></td></tr>
<tr class="separator:ga7945f25673f72c65e1bf60821fa579e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c310958af4e031737d80ba8015452b6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga3c310958af4e031737d80ba8015452b6">get_element</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> index, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga3c310958af4e031737d80ba8015452b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the element at specified index from a column  <br /></td></tr>
<tr class="separator:ga3c310958af4e031737d80ba8015452b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29e76351f1ae5bd91dc922ad24243b1f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga29e76351f1ae5bd91dc922ad24243b1f">sample</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const n, <a class="el" href="group__column__copy.html#gae7607cde56cb602ab1b198b5bebf7cba">sample_with_replacement</a> replacement=<a class="el" href="group__column__copy.html#ggae7607cde56cb602ab1b198b5bebf7cbaa946003f97ccc52d5d3b54ac0ec31bbfc">sample_with_replacement::FALSE</a>, int64_t const seed=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga29e76351f1ae5bd91dc922ad24243b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather <code>n</code> samples from given <code>input</code> randomly  <br /></td></tr>
<tr class="separator:ga29e76351f1ae5bd91dc922ad24243b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c61528cb588874f9c07c6f766f232db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga0c61528cb588874f9c07c6f766f232db">has_nonempty_nulls</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input)</td></tr>
<tr class="memdesc:ga0c61528cb588874f9c07c6f766f232db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a column or its descendants have non-empty null rows  <br /></td></tr>
<tr class="separator:ga0c61528cb588874f9c07c6f766f232db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a9c46582ed07509d4bfe24e50d59bf2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga9a9c46582ed07509d4bfe24e50d59bf2">may_have_nonempty_nulls</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input)</td></tr>
<tr class="memdesc:ga9a9c46582ed07509d4bfe24e50d59bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximates if a column or its descendants <em>may</em> have non-empty null elements  <br /></td></tr>
<tr class="separator:ga9a9c46582ed07509d4bfe24e50d59bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga387d2221ad89e737e89270bf8c56dfa5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__copy.html#ga387d2221ad89e737e89270bf8c56dfa5">purge_nonempty_nulls</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga387d2221ad89e737e89270bf8c56dfa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy <code>input</code> into output while purging any non-empty null rows in the column or its descendants.  <br /></td></tr>
<tr class="separator:ga387d2221ad89e737e89270bf8c56dfa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96e5dd80377177bcd78b9db9f28c86af"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__factories.html#ga96e5dd80377177bcd78b9db9f28c86af">make_dictionary_column</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;keys_column, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;indices_column, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga96e5dd80377177bcd78b9db9f28c86af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a dictionary column by copying the provided <code>keys</code> and <code>indices</code>.  <br /></td></tr>
<tr class="separator:ga96e5dd80377177bcd78b9db9f28c86af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e8ca4d0362868416149924d42a0bd4f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__factories.html#ga7e8ca4d0362868416149924d42a0bd4f">make_dictionary_column</a> (std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; keys_column, std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; indices_column, rmm::device_buffer &amp;&amp;null_mask, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> null_count)</td></tr>
<tr class="memdesc:ga7e8ca4d0362868416149924d42a0bd4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a dictionary column by taking ownership of the provided keys and indices columns.  <br /></td></tr>
<tr class="separator:ga7e8ca4d0362868416149924d42a0bd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad227b50d9a2903d17ee4cf2ee2dd5887"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__factories.html#gad227b50d9a2903d17ee4cf2ee2dd5887">make_dictionary_column</a> (std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; keys_column, std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; indices_column, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gad227b50d9a2903d17ee4cf2ee2dd5887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a dictionary column by taking ownership of the provided keys and indices columns.  <br /></td></tr>
<tr class="separator:gad227b50d9a2903d17ee4cf2ee2dd5887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53223e7585a8a507802815201a4eb5ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__fill.html#ga53223e7585a8a507802815201a4eb5ba">fill_in_place</a> (<a class="el" href="classcudf_1_1mutable__column__view.html">mutable_column_view</a> &amp;destination, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> begin, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> end, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;value)</td></tr>
<tr class="memdesc:ga53223e7585a8a507802815201a4eb5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a range of elements in-place in a column with a scalar value.  <br /></td></tr>
<tr class="separator:ga53223e7585a8a507802815201a4eb5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06c5a274e53d68a38151ab402492ebe8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__fill.html#ga06c5a274e53d68a38151ab402492ebe8">fill</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> begin, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> end, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;value, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga06c5a274e53d68a38151ab402492ebe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a range of elements in a column out-of-place with a scalar value.  <br /></td></tr>
<tr class="separator:ga06c5a274e53d68a38151ab402492ebe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ae5112e1a07cb1cadfcdb3d3a03f096"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__fill.html#ga0ae5112e1a07cb1cadfcdb3d3a03f096">repeat</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input_table, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;count, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga0ae5112e1a07cb1cadfcdb3d3a03f096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeat rows of a Table.  <br /></td></tr>
<tr class="separator:ga0ae5112e1a07cb1cadfcdb3d3a03f096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a7108024c5faef011b8a4cbf411e196"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__fill.html#ga3a7108024c5faef011b8a4cbf411e196">repeat</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input_table, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> count, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga3a7108024c5faef011b8a4cbf411e196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeat rows of a Table.  <br /></td></tr>
<tr class="separator:ga3a7108024c5faef011b8a4cbf411e196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac846399ac2ee0729e1bdfaedbf3b7735"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__fill.html#gac846399ac2ee0729e1bdfaedbf3b7735">sequence</a> (<a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> size, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;init, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;step, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gac846399ac2ee0729e1bdfaedbf3b7735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a column with a sequence of value specified by an initial value and a step.  <br /></td></tr>
<tr class="separator:gac846399ac2ee0729e1bdfaedbf3b7735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08b5167ef67be7ad7fe9a07adc3de31b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__fill.html#ga08b5167ef67be7ad7fe9a07adc3de31b">sequence</a> (<a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> size, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;init, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga08b5167ef67be7ad7fe9a07adc3de31b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a column with a sequence of value specified by an initial value and a step of 1.  <br /></td></tr>
<tr class="separator:ga08b5167ef67be7ad7fe9a07adc3de31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0691c762ba0a3efb1b432b423e6fe60a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__fill.html#ga0691c762ba0a3efb1b432b423e6fe60a">calendrical_month_sequence</a> (<a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> size, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;init, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> months, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga0691c762ba0a3efb1b432b423e6fe60a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a sequence of timestamps beginning at <code>init</code> and incrementing by <code>months</code> for each successive element, i.e., <code>output[i] = init + i * months</code> for <code>i</code> in <code>[0, size)</code>.  <br /></td></tr>
<tr class="separator:ga0691c762ba0a3efb1b432b423e6fe60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga324d3e89c473ffe4810b14da49a6c1e7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__hash.html#ga324d3e89c473ffe4810b14da49a6c1e7">hash</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, <a class="el" href="group__column__hash.html#gaced8b9d129825edd13d76e912e4413c3">hash_id</a> hash_function=<a class="el" href="group__column__hash.html#ggaced8b9d129825edd13d76e912e4413c3ae9ec854e962136b1afcf108e5301c354">hash_id::HASH_MURMUR3</a>, uint32_t seed=<a class="el" href="group__column__hash.html#ga68de1d04aa2c0ea2eeacfc73fd99a915">DEFAULT_HASH_SEED</a>, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga324d3e89c473ffe4810b14da49a6c1e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hash value of each row in the input set of columns.  <br /></td></tr>
<tr class="separator:ga324d3e89c473ffe4810b14da49a6c1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabca779a75e0007c9310f8cefd3b481ff"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interop__dlpack.html#gabca779a75e0007c9310f8cefd3b481ff">from_dlpack</a> (DLManagedTensor const *managed_tensor, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gabca779a75e0007c9310f8cefd3b481ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a DLPack DLTensor into a cudf table  <br /></td></tr>
<tr class="separator:gabca779a75e0007c9310f8cefd3b481ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga303da0732ac5aade6bd2f1dcccdcd118"><td class="memItemLeft" align="right" valign="top">DLManagedTensor *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interop__dlpack.html#ga303da0732ac5aade6bd2f1dcccdcd118">to_dlpack</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga303da0732ac5aade6bd2f1dcccdcd118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a cudf table into a DLPack DLTensor  <br /></td></tr>
<tr class="separator:ga303da0732ac5aade6bd2f1dcccdcd118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72feccc6e06f2d73d91f8dca5cb01501"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; arrow::Table &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interop__arrow.html#ga72feccc6e06f2d73d91f8dca5cb01501">to_arrow</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> input, std::vector&lt; <a class="el" href="structcudf_1_1column__metadata.html">column_metadata</a> &gt; const &amp;metadata={}, arrow::MemoryPool *ar_mr=arrow::default_memory_pool())</td></tr>
<tr class="memdesc:ga72feccc6e06f2d73d91f8dca5cb01501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <code>arrow::Table</code> from cudf table <code>input</code>  <br /></td></tr>
<tr class="separator:ga72feccc6e06f2d73d91f8dca5cb01501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae29f5c6a2d2158b6bfd89fd7a5284383"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__interop__arrow.html#gae29f5c6a2d2158b6bfd89fd7a5284383">from_arrow</a> (arrow::Table const &amp;input, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gae29f5c6a2d2158b6bfd89fd7a5284383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <code><a class="el" href="classcudf_1_1table.html" title="A set of cudf::column&#39;s of the same size.">cudf::table</a></code> from given arrow Table input  <br /></td></tr>
<tr class="separator:gae29f5c6a2d2158b6bfd89fd7a5284383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaec6479cb2464d59cc29756420a3fe1c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; rmm::device_uvector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; &gt;, std::unique_ptr&lt; rmm::device_uvector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__join.html#gaaec6479cb2464d59cc29756420a3fe1c">inner_join</a> (<a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;left_keys, <a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;right_keys, <a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a> compare_nulls=<a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44">null_equality::EQUAL</a>, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gaaec6479cb2464d59cc29756420a3fe1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pair of row index vectors corresponding to an inner join between the specified tables.  <br /></td></tr>
<tr class="separator:gaaec6479cb2464d59cc29756420a3fe1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf40dc6e73a5aac3e0201dd7e5b939e3"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; rmm::device_uvector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; &gt;, std::unique_ptr&lt; rmm::device_uvector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__join.html#gaaf40dc6e73a5aac3e0201dd7e5b939e3">left_join</a> (<a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;left_keys, <a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;right_keys, <a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a> compare_nulls=<a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44">null_equality::EQUAL</a>, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gaaf40dc6e73a5aac3e0201dd7e5b939e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pair of row index vectors corresponding to a left join between the specified tables.  <br /></td></tr>
<tr class="separator:gaaf40dc6e73a5aac3e0201dd7e5b939e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a114dd54b0275e7d6a2f48c49be0764"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; rmm::device_uvector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; &gt;, std::unique_ptr&lt; rmm::device_uvector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__join.html#ga2a114dd54b0275e7d6a2f48c49be0764">full_join</a> (<a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;left_keys, <a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;right_keys, <a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a> compare_nulls=<a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44">null_equality::EQUAL</a>, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga2a114dd54b0275e7d6a2f48c49be0764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pair of row index vectors corresponding to a full join between the specified tables.  <br /></td></tr>
<tr class="separator:ga2a114dd54b0275e7d6a2f48c49be0764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc3566a24f282778bee1ca19012b37cb"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; rmm::device_uvector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__join.html#gacc3566a24f282778bee1ca19012b37cb">left_semi_join</a> (<a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;left_keys, <a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;right_keys, <a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a> compare_nulls=<a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44">null_equality::EQUAL</a>, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gacc3566a24f282778bee1ca19012b37cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of row indices corresponding to a left semi join between the specified tables.  <br /></td></tr>
<tr class="separator:gacc3566a24f282778bee1ca19012b37cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga959584969b3cc516888c6ceff655c15f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; rmm::device_uvector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__join.html#ga959584969b3cc516888c6ceff655c15f">left_anti_join</a> (<a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;left_keys, <a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;right_keys, <a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a> compare_nulls=<a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44">null_equality::EQUAL</a>, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga959584969b3cc516888c6ceff655c15f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of row indices corresponding to a left anti join between the specified tables.  <br /></td></tr>
<tr class="separator:ga959584969b3cc516888c6ceff655c15f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c5fdcd931efcd717433575cfe0a0485"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">cudf::table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__join.html#ga2c5fdcd931efcd717433575cfe0a0485">cross_join</a> (<a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;left, <a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;right, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga2c5fdcd931efcd717433575cfe0a0485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a cross join on two tables (<code>left</code>, <code>right</code>)  <br /></td></tr>
<tr class="separator:ga2c5fdcd931efcd717433575cfe0a0485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d44d1f83ccd6ef03903b19319e723eb"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; rmm::device_uvector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; &gt;, std::unique_ptr&lt; rmm::device_uvector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__join.html#ga1d44d1f83ccd6ef03903b19319e723eb">conditional_inner_join</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;left, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;right, <a class="el" href="structcudf_1_1ast_1_1expression.html">ast::expression</a> const &amp;binary_predicate, std::optional&lt; std::size_t &gt; output_size={}, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga1d44d1f83ccd6ef03903b19319e723eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pair of row index vectors corresponding to all pairs of rows between the specified tables where the predicate evaluates to true.  <br /></td></tr>
<tr class="separator:ga1d44d1f83ccd6ef03903b19319e723eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57db4d65964bae48621e71311bfeeef7"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; rmm::device_uvector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; &gt;, std::unique_ptr&lt; rmm::device_uvector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__join.html#ga57db4d65964bae48621e71311bfeeef7">conditional_left_join</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;left, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;right, <a class="el" href="structcudf_1_1ast_1_1expression.html">ast::expression</a> const &amp;binary_predicate, std::optional&lt; std::size_t &gt; output_size={}, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga57db4d65964bae48621e71311bfeeef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pair of row index vectors corresponding to all pairs of rows between the specified tables where the predicate evaluates to true, or null matches for rows in left that have no match in right.  <br /></td></tr>
<tr class="separator:ga57db4d65964bae48621e71311bfeeef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c44f3f46f804a8856b272f996805199"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; rmm::device_uvector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; &gt;, std::unique_ptr&lt; rmm::device_uvector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__join.html#ga3c44f3f46f804a8856b272f996805199">conditional_full_join</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;left, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;right, <a class="el" href="structcudf_1_1ast_1_1expression.html">ast::expression</a> const &amp;binary_predicate, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga3c44f3f46f804a8856b272f996805199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pair of row index vectors corresponding to all pairs of rows between the specified tables where the predicate evaluates to true, or null matches for rows in either table that have no match in the other.  <br /></td></tr>
<tr class="separator:ga3c44f3f46f804a8856b272f996805199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab11d54280732c3d0498ca66114ba3528"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; rmm::device_uvector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__join.html#gab11d54280732c3d0498ca66114ba3528">conditional_left_semi_join</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;left, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;right, <a class="el" href="structcudf_1_1ast_1_1expression.html">ast::expression</a> const &amp;binary_predicate, std::optional&lt; std::size_t &gt; output_size={}, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gab11d54280732c3d0498ca66114ba3528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an index vector corresponding to all rows in the left table for which there exists some row in the right table where the predicate evaluates to true.  <br /></td></tr>
<tr class="separator:gab11d54280732c3d0498ca66114ba3528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60d5de456b8ff180f07e1c5dfe30bc9b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; rmm::device_uvector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__join.html#ga60d5de456b8ff180f07e1c5dfe30bc9b">conditional_left_anti_join</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;left, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;right, <a class="el" href="structcudf_1_1ast_1_1expression.html">ast::expression</a> const &amp;binary_predicate, std::optional&lt; std::size_t &gt; output_size={}, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga60d5de456b8ff180f07e1c5dfe30bc9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an index vector corresponding to all rows in the left table for which there does not exist any row in the right table where the predicate evaluates to true.  <br /></td></tr>
<tr class="separator:ga60d5de456b8ff180f07e1c5dfe30bc9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dfa37f1888c32299c2195bb6d3a18a2"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; rmm::device_uvector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; &gt;, std::unique_ptr&lt; rmm::device_uvector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__join.html#ga8dfa37f1888c32299c2195bb6d3a18a2">mixed_inner_join</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;left_equality, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;right_equality, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;left_conditional, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;right_conditional, <a class="el" href="structcudf_1_1ast_1_1expression.html">ast::expression</a> const &amp;binary_predicate, <a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a> compare_nulls=<a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44">null_equality::EQUAL</a>, std::optional&lt; std::pair&lt; std::size_t, <a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt; &gt; &gt; output_size_data={}, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga8dfa37f1888c32299c2195bb6d3a18a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pair of row index vectors corresponding to all pairs of rows between the specified tables where the columns of the equality table are equal and the predicate evaluates to true on the conditional tables.  <br /></td></tr>
<tr class="separator:ga8dfa37f1888c32299c2195bb6d3a18a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5d3f1d5d22db234d64bf94ddf1ebf9f"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; rmm::device_uvector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; &gt;, std::unique_ptr&lt; rmm::device_uvector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__join.html#gaa5d3f1d5d22db234d64bf94ddf1ebf9f">mixed_left_join</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;left_equality, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;right_equality, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;left_conditional, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;right_conditional, <a class="el" href="structcudf_1_1ast_1_1expression.html">ast::expression</a> const &amp;binary_predicate, <a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a> compare_nulls=<a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44">null_equality::EQUAL</a>, std::optional&lt; std::pair&lt; std::size_t, <a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt; &gt; &gt; output_size_data={}, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gaa5d3f1d5d22db234d64bf94ddf1ebf9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pair of row index vectors corresponding to all pairs of rows between the specified tables where the columns of the equality table are equal and the predicate evaluates to true on the conditional tables, or null matches for rows in left that have no match in right.  <br /></td></tr>
<tr class="separator:gaa5d3f1d5d22db234d64bf94ddf1ebf9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86d03c65afa922c57dc09ef6c46d9863"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; rmm::device_uvector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; &gt;, std::unique_ptr&lt; rmm::device_uvector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__join.html#ga86d03c65afa922c57dc09ef6c46d9863">mixed_full_join</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;left_equality, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;right_equality, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;left_conditional, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;right_conditional, <a class="el" href="structcudf_1_1ast_1_1expression.html">ast::expression</a> const &amp;binary_predicate, <a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a> compare_nulls=<a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44">null_equality::EQUAL</a>, std::optional&lt; std::pair&lt; std::size_t, <a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt; &gt; &gt; output_size_data={}, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga86d03c65afa922c57dc09ef6c46d9863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pair of row index vectors corresponding to all pairs of rows between the specified tables where the columns of the equality table are equal and the predicate evaluates to true on the conditional tables, or null matches for rows in either pair of tables that have no matches in the other pair.  <br /></td></tr>
<tr class="separator:ga86d03c65afa922c57dc09ef6c46d9863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc4891543ed750a24df1ecf32c89d34a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; rmm::device_uvector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__join.html#gacc4891543ed750a24df1ecf32c89d34a">mixed_left_semi_join</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;left_equality, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;right_equality, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;left_conditional, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;right_conditional, <a class="el" href="structcudf_1_1ast_1_1expression.html">ast::expression</a> const &amp;binary_predicate, <a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a> compare_nulls=<a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44">null_equality::EQUAL</a>, std::optional&lt; std::pair&lt; std::size_t, <a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt; &gt; &gt; output_size_data={}, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gacc4891543ed750a24df1ecf32c89d34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an index vector corresponding to all rows in the left tables where the columns of the equality table are equal and the predicate evaluates to true on the conditional tables.  <br /></td></tr>
<tr class="separator:gacc4891543ed750a24df1ecf32c89d34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac97dffde787f3e34ca4fb70651dc0a3d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; rmm::device_uvector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__join.html#gac97dffde787f3e34ca4fb70651dc0a3d">mixed_left_anti_join</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;left_equality, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;right_equality, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;left_conditional, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;right_conditional, <a class="el" href="structcudf_1_1ast_1_1expression.html">ast::expression</a> const &amp;binary_predicate, <a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a> compare_nulls=<a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44">null_equality::EQUAL</a>, std::optional&lt; std::pair&lt; std::size_t, <a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt; &gt; &gt; output_size_data={}, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gac97dffde787f3e34ca4fb70651dc0a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an index vector corresponding to all rows in the left tables for which there is no row in the right tables where the columns of the equality table are equal and the predicate evaluates to true on the conditional tables.  <br /></td></tr>
<tr class="separator:gac97dffde787f3e34ca4fb70651dc0a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae7646ce51f06df36848a6c8369bbdbf"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::size_t, std::unique_ptr&lt; rmm::device_uvector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__join.html#gaae7646ce51f06df36848a6c8369bbdbf">mixed_inner_join_size</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;left_equality, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;right_equality, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;left_conditional, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;right_conditional, <a class="el" href="structcudf_1_1ast_1_1expression.html">ast::expression</a> const &amp;binary_predicate, <a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a> compare_nulls=<a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44">null_equality::EQUAL</a>, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gaae7646ce51f06df36848a6c8369bbdbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the exact number of matches (rows) when performing a mixed inner join between the specified tables where the columns of the equality table are equal and the predicate evaluates to true on the conditional tables.  <br /></td></tr>
<tr class="separator:gaae7646ce51f06df36848a6c8369bbdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50660ed5802b44c6c2d30b9af17748f1"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::size_t, std::unique_ptr&lt; rmm::device_uvector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__join.html#ga50660ed5802b44c6c2d30b9af17748f1">mixed_left_join_size</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;left_equality, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;right_equality, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;left_conditional, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;right_conditional, <a class="el" href="structcudf_1_1ast_1_1expression.html">ast::expression</a> const &amp;binary_predicate, <a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a> compare_nulls=<a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44">null_equality::EQUAL</a>, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga50660ed5802b44c6c2d30b9af17748f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the exact number of matches (rows) when performing a mixed left join between the specified tables where the columns of the equality table are equal and the predicate evaluates to true on the conditional tables.  <br /></td></tr>
<tr class="separator:ga50660ed5802b44c6c2d30b9af17748f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bb8ff36bf310bd8d0300efb5f246eaf"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::size_t, std::unique_ptr&lt; rmm::device_uvector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__join.html#ga4bb8ff36bf310bd8d0300efb5f246eaf">mixed_left_semi_join_size</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;left_equality, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;right_equality, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;left_conditional, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;right_conditional, <a class="el" href="structcudf_1_1ast_1_1expression.html">ast::expression</a> const &amp;binary_predicate, <a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a> compare_nulls=<a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44">null_equality::EQUAL</a>, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga4bb8ff36bf310bd8d0300efb5f246eaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the exact number of matches (rows) when performing a mixed left semi join between the specified tables where the columns of the equality table are equal and the predicate evaluates to true on the conditional tables.  <br /></td></tr>
<tr class="separator:ga4bb8ff36bf310bd8d0300efb5f246eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac1c30f857c0e1930946f5237333c932"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::size_t, std::unique_ptr&lt; rmm::device_uvector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__join.html#gaac1c30f857c0e1930946f5237333c932">mixed_left_anti_join_size</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;left_equality, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;right_equality, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;left_conditional, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;right_conditional, <a class="el" href="structcudf_1_1ast_1_1expression.html">ast::expression</a> const &amp;binary_predicate, <a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a> compare_nulls=<a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44">null_equality::EQUAL</a>, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gaac1c30f857c0e1930946f5237333c932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the exact number of matches (rows) when performing a mixed left anti join between the specified tables.  <br /></td></tr>
<tr class="separator:gaac1c30f857c0e1930946f5237333c932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac277e7cb56bd0f822bb0b9f5bcedd0e9"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__join.html#gac277e7cb56bd0f822bb0b9f5bcedd0e9">conditional_inner_join_size</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;left, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;right, <a class="el" href="structcudf_1_1ast_1_1expression.html">ast::expression</a> const &amp;binary_predicate, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gac277e7cb56bd0f822bb0b9f5bcedd0e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the exact number of matches (rows) when performing a conditional inner join between the specified tables where the predicate evaluates to true.  <br /></td></tr>
<tr class="separator:gac277e7cb56bd0f822bb0b9f5bcedd0e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f8addde02ded299a45f57eb769c587e"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__join.html#ga9f8addde02ded299a45f57eb769c587e">conditional_left_join_size</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;left, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;right, <a class="el" href="structcudf_1_1ast_1_1expression.html">ast::expression</a> const &amp;binary_predicate, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga9f8addde02ded299a45f57eb769c587e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the exact number of matches (rows) when performing a conditional left join between the specified tables where the predicate evaluates to true.  <br /></td></tr>
<tr class="separator:ga9f8addde02ded299a45f57eb769c587e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecfa4e8182521bb5630adf1bb0b609c2"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__join.html#gaecfa4e8182521bb5630adf1bb0b609c2">conditional_left_semi_join_size</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;left, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;right, <a class="el" href="structcudf_1_1ast_1_1expression.html">ast::expression</a> const &amp;binary_predicate, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gaecfa4e8182521bb5630adf1bb0b609c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the exact number of matches (rows) when performing a conditional left semi join between the specified tables where the predicate evaluates to true.  <br /></td></tr>
<tr class="separator:gaecfa4e8182521bb5630adf1bb0b609c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00b702723fd8953d5de802bc37965525"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__join.html#ga00b702723fd8953d5de802bc37965525">conditional_left_anti_join_size</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;left, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;right, <a class="el" href="structcudf_1_1ast_1_1expression.html">ast::expression</a> const &amp;binary_predicate, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga00b702723fd8953d5de802bc37965525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the exact number of matches (rows) when performing a conditional left anti join between the specified tables where the predicate evaluates to true.  <br /></td></tr>
<tr class="separator:ga00b702723fd8953d5de802bc37965525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3966ac541ff98cf79cde62747fdff30b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__label__bins.html#ga3966ac541ff98cf79cde62747fdff30b">label_bins</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;left_edges, <a class="el" href="group__label__bins.html#gabadbffbcb403fac1ff712330ea10f2b3">inclusive</a> left_inclusive, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;right_edges, <a class="el" href="group__label__bins.html#gabadbffbcb403fac1ff712330ea10f2b3">inclusive</a> right_inclusive, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga3966ac541ff98cf79cde62747fdff30b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Labels elements based on membership in the specified bins.  <br /></td></tr>
<tr class="separator:ga3966ac541ff98cf79cde62747fdff30b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga410a1a061880e0c23f8b5363b8848b77"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__reshape.html#ga410a1a061880e0c23f8b5363b8848b77">explode</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input_table, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> explode_column_idx, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga410a1a061880e0c23f8b5363b8848b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explodes a list column's elements.  <br /></td></tr>
<tr class="separator:ga410a1a061880e0c23f8b5363b8848b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaf540f670a5b6d194472b8b0bf07dc7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__reshape.html#gabaf540f670a5b6d194472b8b0bf07dc7">explode_position</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input_table, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> explode_column_idx, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gabaf540f670a5b6d194472b8b0bf07dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explodes a list column's elements and includes a position column.  <br /></td></tr>
<tr class="separator:gabaf540f670a5b6d194472b8b0bf07dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8553ff28b4712105c603673767f82efd"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__reshape.html#ga8553ff28b4712105c603673767f82efd">explode_outer</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input_table, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> explode_column_idx, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga8553ff28b4712105c603673767f82efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explodes a list column's elements retaining any null entries or empty lists inside.  <br /></td></tr>
<tr class="separator:ga8553ff28b4712105c603673767f82efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00d434c2efba8113e6e92c3b0b448968"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__reshape.html#ga00d434c2efba8113e6e92c3b0b448968">explode_outer_position</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input_table, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> explode_column_idx, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga00d434c2efba8113e6e92c3b0b448968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explodes a list column's elements retaining any null entries or empty lists and includes a position column.  <br /></td></tr>
<tr class="separator:ga00d434c2efba8113e6e92c3b0b448968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41e5427a85605a8ffa40025bf23baade"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">cudf::table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__merge.html#ga41e5427a85605a8ffa40025bf23baade">merge</a> (std::vector&lt; <a class="el" href="classcudf_1_1table__view.html">table_view</a> &gt; const &amp;tables_to_merge, std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a> &gt; const &amp;key_cols, std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">cudf::order</a> &gt; const &amp;column_order, std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">cudf::null_order</a> &gt; const &amp;null_precedence={}, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga41e5427a85605a8ffa40025bf23baade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge a set of sorted tables.  <br /></td></tr>
<tr class="separator:ga41e5427a85605a8ffa40025bf23baade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48561f1e899da3a79132c108463840de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__nullmask.html#ga48561f1e899da3a79132c108463840de">state_null_count</a> (<a class="el" href="group__utility__types.html#ga4daf20c000ab374d76f4d56f0ddb7b26">mask_state</a> state, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> size)</td></tr>
<tr class="memdesc:ga48561f1e899da3a79132c108463840de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the null count for a null mask of the specified <code>state</code> representing <code>size</code> elements.  <br /></td></tr>
<tr class="separator:ga48561f1e899da3a79132c108463840de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c26b8cbca80321602bc3f39ab6cce8d"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__nullmask.html#ga3c26b8cbca80321602bc3f39ab6cce8d">bitmask_allocation_size_bytes</a> (<a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> number_of_bits, std::size_t padding_boundary=64)</td></tr>
<tr class="memdesc:ga3c26b8cbca80321602bc3f39ab6cce8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the required bytes necessary to represent the specified number of bits with a given padding boundary.  <br /></td></tr>
<tr class="separator:ga3c26b8cbca80321602bc3f39ab6cce8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad62014db2c1d82cbd2f3e067d27088ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__nullmask.html#gad62014db2c1d82cbd2f3e067d27088ab">num_bitmask_words</a> (<a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> number_of_bits)</td></tr>
<tr class="memdesc:gad62014db2c1d82cbd2f3e067d27088ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of <code>bitmask_type</code> words required to represent the specified number of bits.  <br /></td></tr>
<tr class="separator:gad62014db2c1d82cbd2f3e067d27088ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c1ce0e8b880569dba8a60be84fea39a"><td class="memItemLeft" align="right" valign="top">rmm::device_buffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__nullmask.html#ga9c1ce0e8b880569dba8a60be84fea39a">create_null_mask</a> (<a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> size, <a class="el" href="group__utility__types.html#ga4daf20c000ab374d76f4d56f0ddb7b26">mask_state</a> state, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga9c1ce0e8b880569dba8a60be84fea39a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code>device_buffer</code> for use as a null value indicator bitmask of a <code>column</code>.  <br /></td></tr>
<tr class="separator:ga9c1ce0e8b880569dba8a60be84fea39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cad7543531c200e7da85096b889be9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__nullmask.html#ga0cad7543531c200e7da85096b889be9a">set_null_mask</a> (<a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> *bitmask, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> begin_bit, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> end_bit, bool valid)</td></tr>
<tr class="memdesc:ga0cad7543531c200e7da85096b889be9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a pre-allocated bitmask buffer to a given state in the range <code>[begin_bit, end_bit)</code>  <br /></td></tr>
<tr class="separator:ga0cad7543531c200e7da85096b889be9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga247e21104fff5f624ee739e25d8ebb60"><td class="memItemLeft" align="right" valign="top">rmm::device_buffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__nullmask.html#ga247e21104fff5f624ee739e25d8ebb60">copy_bitmask</a> (<a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> const *mask, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> begin_bit, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> end_bit, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga247e21104fff5f624ee739e25d8ebb60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code>device_buffer</code> from a slice of bitmask defined by a range of indices <code>[begin_bit, end_bit)</code>.  <br /></td></tr>
<tr class="separator:ga247e21104fff5f624ee739e25d8ebb60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16ab5fd032d0620ce51365ad1ed2b144"><td class="memItemLeft" align="right" valign="top">rmm::device_buffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__nullmask.html#ga16ab5fd032d0620ce51365ad1ed2b144">copy_bitmask</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;view, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga16ab5fd032d0620ce51365ad1ed2b144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies <code>view</code>'s bitmask from the bits <code>[view.offset(), view.offset() + view.size())</code> into a <code>device_buffer</code>  <br /></td></tr>
<tr class="separator:ga16ab5fd032d0620ce51365ad1ed2b144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e8326f26359dad43cddacdf24b77b4d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; rmm::device_buffer, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__nullmask.html#ga2e8326f26359dad43cddacdf24b77b4d">bitmask_and</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;view, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga2e8326f26359dad43cddacdf24b77b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs bitwise AND of the bitmasks of columns of a table. Returns a pair of resulting mask and count of unset bits.  <br /></td></tr>
<tr class="separator:ga2e8326f26359dad43cddacdf24b77b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab74baaf81e7b5f6efc2e68b24240399b"><td class="memItemLeft" align="right" valign="top">std::pair&lt; rmm::device_buffer, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__nullmask.html#gab74baaf81e7b5f6efc2e68b24240399b">bitmask_or</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;view, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gab74baaf81e7b5f6efc2e68b24240399b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs bitwise OR of the bitmasks of columns of a table. Returns a pair of resulting mask and count of unset bits.  <br /></td></tr>
<tr class="separator:gab74baaf81e7b5f6efc2e68b24240399b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac862ac3926d44c41e92e6d3a47c6d388"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;, std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reorder__partition.html#gac862ac3926d44c41e92e6d3a47c6d388">partition</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;t, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;partition_map, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> num_partitions, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gac862ac3926d44c41e92e6d3a47c6d388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partitions rows of <code>t</code> according to the mapping specified by <code>partition_map</code>.  <br /></td></tr>
<tr class="separator:gac862ac3926d44c41e92e6d3a47c6d388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5e2aad87e6f5f09fa4370f4cec3be17"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;, std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reorder__partition.html#gac5e2aad87e6f5f09fa4370f4cec3be17">hash_partition</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; const &amp;columns_to_hash, int num_partitions, <a class="el" href="group__column__hash.html#gaced8b9d129825edd13d76e912e4413c3">hash_id</a> hash_function=<a class="el" href="group__column__hash.html#ggaced8b9d129825edd13d76e912e4413c3ae9ec854e962136b1afcf108e5301c354">hash_id::HASH_MURMUR3</a>, uint32_t seed=<a class="el" href="group__column__hash.html#ga68de1d04aa2c0ea2eeacfc73fd99a915">DEFAULT_HASH_SEED</a>, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gac5e2aad87e6f5f09fa4370f4cec3be17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partitions rows from the input table into multiple output tables.  <br /></td></tr>
<tr class="separator:gac5e2aad87e6f5f09fa4370f4cec3be17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5db3c207f2be3f7659416122ba3a1fdb"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">cudf::table</a> &gt;, std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reorder__partition.html#ga5db3c207f2be3f7659416122ba3a1fdb">round_robin_partition</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a> num_partitions, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a> start_partition=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga5db3c207f2be3f7659416122ba3a1fdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round-robin partition.  <br /></td></tr>
<tr class="separator:ga5db3c207f2be3f7659416122ba3a1fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7d0d668dd96213645444c32fc6582a1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__quantiles.html#gac7d0d668dd96213645444c32fc6582a1">quantile</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, std::vector&lt; double &gt; const &amp;q, <a class="el" href="group__utility__types.html#ga9cd17c1cdf028ead9a4783f605276ab3">interpolation</a> interp=<a class="el" href="group__utility__types.html#gga9cd17c1cdf028ead9a4783f605276ab3aaac544aacc3615aada24897a215f5046">interpolation::LINEAR</a>, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;ordered_indices={}, bool exact=true, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gac7d0d668dd96213645444c32fc6582a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes quantiles with interpolation.  <br /></td></tr>
<tr class="separator:gac7d0d668dd96213645444c32fc6582a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a7bfdd267148ba8038c50c3c27fa87a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__quantiles.html#ga5a7bfdd267148ba8038c50c3c27fa87a">quantiles</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, std::vector&lt; double &gt; const &amp;q, <a class="el" href="group__utility__types.html#ga9cd17c1cdf028ead9a4783f605276ab3">interpolation</a> interp=<a class="el" href="group__utility__types.html#gga9cd17c1cdf028ead9a4783f605276ab3aad135772d7cf93dd0ccf9d2474b34e6a">interpolation::NEAREST</a>, <a class="el" href="group__utility__types.html#gab283c517931abd4152ffa62fec62425d">cudf::sorted</a> is_input_sorted=<a class="el" href="group__utility__types.html#ggab283c517931abd4152ffa62fec62425dac2f3f489a00553e7a01d369c103c7251">sorted::NO</a>, std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;column_order={}, std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;null_precedence={}, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga5a7bfdd267148ba8038c50c3c27fa87a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rows of the input corresponding to the requested quantiles.  <br /></td></tr>
<tr class="separator:ga5a7bfdd267148ba8038c50c3c27fa87a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac79832ed137f9001c00f6cfd5a0d87db"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__quantiles.html#gac79832ed137f9001c00f6cfd5a0d87db">percentile_approx</a> (<a class="el" href="classcudf_1_1tdigest_1_1tdigest__column__view.html">tdigest::tdigest_column_view</a> const &amp;input, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;percentiles, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gac79832ed137f9001c00f6cfd5a0d87db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate approximate percentiles on an input tdigest column.  <br /></td></tr>
<tr class="separator:gac79832ed137f9001c00f6cfd5a0d87db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b3faf704898312ede74e2eaf9e2c61d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__reduction.html#ga1b3faf704898312ede74e2eaf9e2c61d">reduce</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;col, <a class="el" href="classcudf_1_1reduce__aggregation.html">reduce_aggregation</a> const &amp;agg, <a class="el" href="classcudf_1_1data__type.html">data_type</a> output_dtype, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga1b3faf704898312ede74e2eaf9e2c61d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the reduction of the values in all rows of a column.  <br /></td></tr>
<tr class="separator:ga1b3faf704898312ede74e2eaf9e2c61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6af30addbb5627dc0b7015b666d23dc5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__reduction.html#ga6af30addbb5627dc0b7015b666d23dc5">reduce</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;col, <a class="el" href="classcudf_1_1reduce__aggregation.html">reduce_aggregation</a> const &amp;agg, <a class="el" href="classcudf_1_1data__type.html">data_type</a> output_dtype, std::optional&lt; std::reference_wrapper&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &gt; &gt; init, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga6af30addbb5627dc0b7015b666d23dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the reduction of the values in all rows of a column with an initial value. Only SUM, PRODUCT, MIN, MAX, ANY, and ALL aggregations are supported.  <br /></td></tr>
<tr class="separator:ga6af30addbb5627dc0b7015b666d23dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d869bccacd9721819dd30c389064fc4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__reduction.html#ga1d869bccacd9721819dd30c389064fc4">segmented_reduce</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;segmented_values, <a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt; offsets, <a class="el" href="classcudf_1_1segmented__reduce__aggregation.html">segmented_reduce_aggregation</a> const &amp;agg, <a class="el" href="classcudf_1_1data__type.html">data_type</a> output_dtype, <a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a> null_handling, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga1d869bccacd9721819dd30c389064fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute reduction of each segment in the input column  <br /></td></tr>
<tr class="separator:ga1d869bccacd9721819dd30c389064fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab64811026e57fa60c6b8d633713d30ac"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__reduction.html#gab64811026e57fa60c6b8d633713d30ac">segmented_reduce</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;segmented_values, <a class="el" href="structcudf_1_1device__span.html">device_span</a>&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> const &gt; offsets, <a class="el" href="classcudf_1_1segmented__reduce__aggregation.html">segmented_reduce_aggregation</a> const &amp;agg, <a class="el" href="classcudf_1_1data__type.html">data_type</a> output_dtype, <a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a> null_handling, std::optional&lt; std::reference_wrapper&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &gt; &gt; init, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gab64811026e57fa60c6b8d633713d30ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute reduction of each segment in the input column with an initial value. Only SUM, PRODUCT, MIN, MAX, ANY, and ALL aggregations are supported.  <br /></td></tr>
<tr class="separator:gab64811026e57fa60c6b8d633713d30ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6453517d2143254e33391a61a8d683e1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__reduction.html#ga6453517d2143254e33391a61a8d683e1">scan</a> (const <a class="el" href="classcudf_1_1column__view.html">column_view</a> &amp;input, <a class="el" href="classcudf_1_1scan__aggregation.html">scan_aggregation</a> const &amp;agg, <a class="el" href="group__aggregation__reduction.html#ga269c5a531bd3bb4da9ebe4590db028af">scan_type</a> <a class="el" href="group__label__bins.html#gabadbffbcb403fac1ff712330ea10f2b3">inclusive</a>, <a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a> null_handling=<a class="el" href="group__utility__types.html#gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8">null_policy::EXCLUDE</a>, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga6453517d2143254e33391a61a8d683e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the scan of a column.  <br /></td></tr>
<tr class="separator:ga6453517d2143254e33391a61a8d683e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4647f39dcd6c0e1bd10510ed27ec1b66"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt;, std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__reduction.html#ga4647f39dcd6c0e1bd10510ed27ec1b66">minmax</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;col, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga4647f39dcd6c0e1bd10510ed27ec1b66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the minimum and maximum values of a column.  <br /></td></tr>
<tr class="separator:ga4647f39dcd6c0e1bd10510ed27ec1b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebc49ddd15a8081dd2f99656de6f9d65"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__replace.html#gaebc49ddd15a8081dd2f99656de6f9d65">replace_nulls</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;replacement, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gaebc49ddd15a8081dd2f99656de6f9d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all null values in a column with corresponding values of another column  <br /></td></tr>
<tr class="separator:gaebc49ddd15a8081dd2f99656de6f9d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7795cfacadd6c1f100661afcfa0b63a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__replace.html#gae7795cfacadd6c1f100661afcfa0b63a">replace_nulls</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;replacement, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gae7795cfacadd6c1f100661afcfa0b63a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all null values in a column with a scalar.  <br /></td></tr>
<tr class="separator:gae7795cfacadd6c1f100661afcfa0b63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6240f27d9015ee38e957231c075ccb94"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__replace.html#ga6240f27d9015ee38e957231c075ccb94">replace_nulls</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="group__transformation__replace.html#ga7cdbc9bc3671930a743c86f36c38abf9">replace_policy</a> const &amp;<a class="el" href="group__transformation__replace.html#ga7cdbc9bc3671930a743c86f36c38abf9">replace_policy</a>, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga6240f27d9015ee38e957231c075ccb94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all null values in a column with the first non-null value that precedes/follows.  <br /></td></tr>
<tr class="separator:ga6240f27d9015ee38e957231c075ccb94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63c76ec5fe77cb120d7100885bcddc5a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__replace.html#ga63c76ec5fe77cb120d7100885bcddc5a">replace_nans</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;replacement, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga63c76ec5fe77cb120d7100885bcddc5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all NaN values in a column with corresponding values from another column  <br /></td></tr>
<tr class="separator:ga63c76ec5fe77cb120d7100885bcddc5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1276ab849fe5b0bef1024d0bcb4fc650"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__replace.html#ga1276ab849fe5b0bef1024d0bcb4fc650">replace_nans</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;replacement, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga1276ab849fe5b0bef1024d0bcb4fc650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all NaN values in a column with a scalar  <br /></td></tr>
<tr class="separator:ga1276ab849fe5b0bef1024d0bcb4fc650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga651a5fd9cf77f0ecaa9113715003fb7b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__replace.html#ga651a5fd9cf77f0ecaa9113715003fb7b">find_and_replace_all</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input_col, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;values_to_replace, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;replacement_values, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga651a5fd9cf77f0ecaa9113715003fb7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of <code>input_col</code> replacing any <code>values_to_replace[i]</code> found with <code>replacement_values[i]</code>.  <br /></td></tr>
<tr class="separator:ga651a5fd9cf77f0ecaa9113715003fb7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6469ac807630034caf052c9e424712c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__replace.html#gad6469ac807630034caf052c9e424712c">clamp</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;lo, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;lo_replace, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;hi, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;hi_replace, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gad6469ac807630034caf052c9e424712c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces values less than <code>lo</code> in <code>input</code> with <code>lo_replace</code>, and values greater than <code>hi</code> with <code>hi_replace</code>.  <br /></td></tr>
<tr class="separator:gad6469ac807630034caf052c9e424712c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66a4270774c8c677a191d3aae79bb918"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__replace.html#ga66a4270774c8c677a191d3aae79bb918">clamp</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;lo, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;hi, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga66a4270774c8c677a191d3aae79bb918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces values less than <code>lo</code> in <code>input</code> with <code>lo</code>, and values greater than <code>hi</code> with <code>hi</code>.  <br /></td></tr>
<tr class="separator:ga66a4270774c8c677a191d3aae79bb918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga476eec13cde16b1ab30950a56317e5f6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__replace.html#ga476eec13cde16b1ab30950a56317e5f6">normalize_nans_and_zeros</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga476eec13cde16b1ab30950a56317e5f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies from a column of floating-point elements and replaces <code>-NaN</code> and <code>-0.0</code> with <code>+NaN</code> and <code>+0.0</code>, respectively.  <br /></td></tr>
<tr class="separator:ga476eec13cde16b1ab30950a56317e5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2e8dd1b37b4175001b89219ab8ac96f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__replace.html#gab2e8dd1b37b4175001b89219ab8ac96f">normalize_nans_and_zeros</a> (<a class="el" href="classcudf_1_1mutable__column__view.html">mutable_column_view</a> &amp;in_out)</td></tr>
<tr class="memdesc:gab2e8dd1b37b4175001b89219ab8ac96f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies a column of floating-point elements to replace all <code>-NaN</code> and <code>-0.0</code> with <code>+NaN</code> and <code>+0.0</code>, respectively.  <br /></td></tr>
<tr class="separator:gab2e8dd1b37b4175001b89219ab8ac96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e7d0d4fe81ad51f337a538cd019df2f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__reshape.html#ga3e7d0d4fe81ad51f337a538cd019df2f">interleave_columns</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga3e7d0d4fe81ad51f337a538cd019df2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleave columns of a table into a single column.  <br /></td></tr>
<tr class="separator:ga3e7d0d4fe81ad51f337a538cd019df2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81245f60b1755f56e59c86291aebd7a0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__reshape.html#ga81245f60b1755f56e59c86291aebd7a0">tile</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> count, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga81245f60b1755f56e59c86291aebd7a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeats the rows from <code>input</code> table <code>count</code> times to form a new table.  <br /></td></tr>
<tr class="separator:ga81245f60b1755f56e59c86291aebd7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9912553b8cede8a16c86293e2c5a58d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__reshape.html#gaa9912553b8cede8a16c86293e2c5a58d">byte_cast</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input_column, <a class="el" href="group__column__reshape.html#ga1fd286bca11d008f7945aaa6ecbab2e0">flip_endianness</a> endian_configuration, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gaa9912553b8cede8a16c86293e2c5a58d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a column's elements to lists of bytes  <br /></td></tr>
<tr class="separator:gaa9912553b8cede8a16c86293e2c5a58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dfc1f001d211212169ead998d484845"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__rolling.html#ga0dfc1f001d211212169ead998d484845">rolling_window</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> preceding_window, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> following_window, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> min_periods, <a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;agg, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga0dfc1f001d211212169ead998d484845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a fixed-size rolling window function to the values in a column.  <br /></td></tr>
<tr class="separator:ga0dfc1f001d211212169ead998d484845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga350324e8e9ab0d4969d8de7597f2a242"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__rolling.html#ga350324e8e9ab0d4969d8de7597f2a242">rolling_window</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;default_outputs, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> preceding_window, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> following_window, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> min_periods, <a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;agg, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga350324e8e9ab0d4969d8de7597f2a242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a fixed-size rolling window function to the values in a column.    <br /></td></tr>
<tr class="separator:ga350324e8e9ab0d4969d8de7597f2a242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d431c50f9d34e8bf6beda13f693bd69"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__rolling.html#ga0d431c50f9d34e8bf6beda13f693bd69">grouped_rolling_window</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;group_keys, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> preceding_window, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> following_window, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> min_periods, <a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;aggr, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga0d431c50f9d34e8bf6beda13f693bd69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a grouping-aware, fixed-size rolling window function to the values in a column.  <br /></td></tr>
<tr class="separator:ga0d431c50f9d34e8bf6beda13f693bd69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd62060125be568902bf4a4eef397fa8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__rolling.html#gabd62060125be568902bf4a4eef397fa8">grouped_rolling_window</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;group_keys, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="structcudf_1_1window__bounds.html">window_bounds</a> preceding_window, <a class="el" href="structcudf_1_1window__bounds.html">window_bounds</a> following_window, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> min_periods, <a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;aggr, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gabd62060125be568902bf4a4eef397fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a grouping-aware, fixed-size rolling window function to the values in a column.    <br /></td></tr>
<tr class="separator:gabd62060125be568902bf4a4eef397fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae00c7ff150e9bbdd9cb51b5fb4216081"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__rolling.html#gae00c7ff150e9bbdd9cb51b5fb4216081">grouped_rolling_window</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;group_keys, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;default_outputs, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> preceding_window, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> following_window, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> min_periods, <a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;aggr, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gae00c7ff150e9bbdd9cb51b5fb4216081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a grouping-aware, fixed-size rolling window function to the values in a column.    <br /></td></tr>
<tr class="separator:gae00c7ff150e9bbdd9cb51b5fb4216081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf7ec568b0cab23f44af22ea3600075b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__rolling.html#gacf7ec568b0cab23f44af22ea3600075b">grouped_rolling_window</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;group_keys, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;default_outputs, <a class="el" href="structcudf_1_1window__bounds.html">window_bounds</a> preceding_window, <a class="el" href="structcudf_1_1window__bounds.html">window_bounds</a> following_window, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> min_periods, <a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;aggr, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gacf7ec568b0cab23f44af22ea3600075b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a grouping-aware, fixed-size rolling window function to the values in a column.    <br /></td></tr>
<tr class="separator:gacf7ec568b0cab23f44af22ea3600075b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga167a23498c3e82313df80f653b3c48b1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__rolling.html#ga167a23498c3e82313df80f653b3c48b1">grouped_time_range_rolling_window</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;group_keys, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;timestamp_column, <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">cudf::order</a> const &amp;timestamp_order, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> preceding_window_in_days, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> following_window_in_days, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> min_periods, <a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;aggr, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga167a23498c3e82313df80f653b3c48b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a grouping-aware, timestamp-based rolling window function to the values in a column.  <br /></td></tr>
<tr class="separator:ga167a23498c3e82313df80f653b3c48b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f53b18345a094351160b187b263b746"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__rolling.html#ga7f53b18345a094351160b187b263b746">grouped_time_range_rolling_window</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;group_keys, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;timestamp_column, <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">cudf::order</a> const &amp;timestamp_order, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="structcudf_1_1window__bounds.html">window_bounds</a> preceding_window_in_days, <a class="el" href="structcudf_1_1window__bounds.html">window_bounds</a> following_window_in_days, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> min_periods, <a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;aggr, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga7f53b18345a094351160b187b263b746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a grouping-aware, timestamp-based rolling window function to the values in a column,.  <br /></td></tr>
<tr class="separator:ga7f53b18345a094351160b187b263b746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga595d27d939a1af9d00d2b6bea3b5623c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__rolling.html#ga595d27d939a1af9d00d2b6bea3b5623c">grouped_range_rolling_window</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;group_keys, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;orderby_column, <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">cudf::order</a> const &amp;<a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a>, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="structcudf_1_1range__window__bounds.html">range_window_bounds</a> const &amp;preceding, <a class="el" href="structcudf_1_1range__window__bounds.html">range_window_bounds</a> const &amp;following, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> min_periods, <a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;aggr, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga595d27d939a1af9d00d2b6bea3b5623c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a grouping-aware, value range-based rolling window function to the values in a column.  <br /></td></tr>
<tr class="separator:ga595d27d939a1af9d00d2b6bea3b5623c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaed6574615700cec1d4bf5469fe28141"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aggregation__rolling.html#gaaed6574615700cec1d4bf5469fe28141">rolling_window</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;preceding_window, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;following_window, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> min_periods, <a class="el" href="classcudf_1_1rolling__aggregation.html">rolling_aggregation</a> const &amp;agg, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gaaed6574615700cec1d4bf5469fe28141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a variable-size rolling window function to the values in a column.  <br /></td></tr>
<tr class="separator:gaaed6574615700cec1d4bf5469fe28141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf541a42981e9f31a32de8fdaa105d4b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__unaryops.html#gaaf541a42981e9f31a32de8fdaa105d4b">round</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, int32_t decimal_places=0, <a class="el" href="group__transformation__unaryops.html#ga02028fc18312cdb2f07159c6297e74bb">rounding_method</a> method=<a class="el" href="group__transformation__unaryops.html#gga02028fc18312cdb2f07159c6297e74bbae184ac539927e7effd9eae762e9f1904">rounding_method::HALF_UP</a>, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gaaf541a42981e9f31a32de8fdaa105d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds all the values in a column to the specified number of decimal places.  <br /></td></tr>
<tr class="separator:gaaf541a42981e9f31a32de8fdaa105d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14516e1e7627fb303e07c9c4db6ea39c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scalar__factories.html#ga14516e1e7627fb303e07c9c4db6ea39c">make_numeric_scalar</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga14516e1e7627fb303e07c9c4db6ea39c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct scalar with uninitialized storage to hold a value of the specified numeric <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code>.  <br /></td></tr>
<tr class="separator:ga14516e1e7627fb303e07c9c4db6ea39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d94381981c21c2974191115e16e4ae2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scalar__factories.html#ga7d94381981c21c2974191115e16e4ae2">make_timestamp_scalar</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga7d94381981c21c2974191115e16e4ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct scalar with uninitialized storage to hold a value of the specified timestamp <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code>.  <br /></td></tr>
<tr class="separator:ga7d94381981c21c2974191115e16e4ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga046fc38c7ad3694215cdfe559b9eb850"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scalar__factories.html#ga046fc38c7ad3694215cdfe559b9eb850">make_duration_scalar</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga046fc38c7ad3694215cdfe559b9eb850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct scalar with uninitialized storage to hold a value of the specified duration <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code>.  <br /></td></tr>
<tr class="separator:ga046fc38c7ad3694215cdfe559b9eb850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f64cb3410b8fd49b053a36863cc0f40"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scalar__factories.html#ga5f64cb3410b8fd49b053a36863cc0f40">make_fixed_width_scalar</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga5f64cb3410b8fd49b053a36863cc0f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct scalar with uninitialized storage to hold a value of the specified fixed-width <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code>.  <br /></td></tr>
<tr class="separator:ga5f64cb3410b8fd49b053a36863cc0f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0a099793b3073a3b0717d536787e4aa"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scalar__factories.html#gaa0a099793b3073a3b0717d536787e4aa">make_string_scalar</a> (std::string const &amp;string, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gaa0a099793b3073a3b0717d536787e4aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct STRING type scalar given a <code>std::string</code>. The size of the <code>std::string</code> must not exceed the maximum size of size_type. The string characters are expected to be UTF-8 encoded sequence of char bytes.  <br /></td></tr>
<tr class="separator:gaa0a099793b3073a3b0717d536787e4aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c029f8ba744cc645005cc27a8f58b42"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scalar__factories.html#ga9c029f8ba744cc645005cc27a8f58b42">make_default_constructed_scalar</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga9c029f8ba744cc645005cc27a8f58b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs default constructed scalar of type <code>type</code>  <br /></td></tr>
<tr class="separator:ga9c029f8ba744cc645005cc27a8f58b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c8ad0f6cd813d687fa1374ee5ca0f29"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scalar__factories.html#ga2c8ad0f6cd813d687fa1374ee5ca0f29">make_empty_scalar_like</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga2c8ad0f6cd813d687fa1374ee5ca0f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty (invalid) scalar of the same type as the <code>input</code> <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a>.  <br /></td></tr>
<tr class="separator:ga2c8ad0f6cd813d687fa1374ee5ca0f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga397d17d9e989a9e4bb92ba4445f3dcb0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga397d17d9e989a9e4bb92ba4445f3dcb0"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__scalar__factories.html#ga397d17d9e989a9e4bb92ba4445f3dcb0">make_fixed_width_scalar</a> (T value, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga397d17d9e989a9e4bb92ba4445f3dcb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct scalar using the given value of fixed width type  <br /></td></tr>
<tr class="separator:ga397d17d9e989a9e4bb92ba4445f3dcb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef5b922072dedc8b71355641906cf4eb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaef5b922072dedc8b71355641906cf4eb"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__scalar__factories.html#gaef5b922072dedc8b71355641906cf4eb">make_fixed_point_scalar</a> (typename T::rep value, <a class="el" href="namespacenumeric.html#a86733f2294a22704e81208c5ee8082be">numeric::scale_type</a> scale, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gaef5b922072dedc8b71355641906cf4eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct scalar using the given value of fixed_point type  <br /></td></tr>
<tr class="separator:gaef5b922072dedc8b71355641906cf4eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d2bec966fe2ba328545ab4b09ab48c1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scalar__factories.html#ga1d2bec966fe2ba328545ab4b09ab48c1">make_list_scalar</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> elements, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga1d2bec966fe2ba328545ab4b09ab48c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct scalar using the given column of elements  <br /></td></tr>
<tr class="separator:ga1d2bec966fe2ba328545ab4b09ab48c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ae6c8c4a854b3a2668394ea230a4282"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scalar__factories.html#ga6ae6c8c4a854b3a2668394ea230a4282">make_struct_scalar</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;data, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga6ae6c8c4a854b3a2668394ea230a4282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a struct scalar using the given <a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a>.  <br /></td></tr>
<tr class="separator:ga6ae6c8c4a854b3a2668394ea230a4282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b9a329714d6a36d6711ebe9805f81d5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1scalar.html">scalar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__scalar__factories.html#ga0b9a329714d6a36d6711ebe9805f81d5">make_struct_scalar</a> (<a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &gt; data, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga0b9a329714d6a36d6711ebe9805f81d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a struct scalar using the given span of column views.  <br /></td></tr>
<tr class="separator:ga0b9a329714d6a36d6711ebe9805f81d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga858b67a25fd51b339eee1e3a02d46485"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__search.html#ga858b67a25fd51b339eee1e3a02d46485">lower_bound</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;haystack, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;needles, std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;column_order, std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;null_precedence, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga858b67a25fd51b339eee1e3a02d46485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find smallest indices in a sorted table where values should be inserted to maintain order.  <br /></td></tr>
<tr class="separator:ga858b67a25fd51b339eee1e3a02d46485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad59489c94927ed191ef9720e0026008a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__search.html#gad59489c94927ed191ef9720e0026008a">upper_bound</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;haystack, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;needles, std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;column_order, std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;null_precedence, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gad59489c94927ed191ef9720e0026008a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find largest indices in a sorted table where values should be inserted to maintain order.  <br /></td></tr>
<tr class="separator:gad59489c94927ed191ef9720e0026008a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga287ee5469bf49b45112b27ed87cdefd7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__search.html#ga287ee5469bf49b45112b27ed87cdefd7">contains</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;haystack, <a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;needle)</td></tr>
<tr class="memdesc:ga287ee5469bf49b45112b27ed87cdefd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given <code>needle</code> value exists in the <code>haystack</code> column.  <br /></td></tr>
<tr class="separator:ga287ee5469bf49b45112b27ed87cdefd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaada7019e9af242a3fd508726a3abe081"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__search.html#gaada7019e9af242a3fd508726a3abe081">contains</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;haystack, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;needles, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gaada7019e9af242a3fd508726a3abe081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given <code>needles</code> values exists in the <code>haystack</code> column.  <br /></td></tr>
<tr class="separator:gaada7019e9af242a3fd508726a3abe081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga141398c354cc1607bcfe9590d93e63f5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__sort.html#ga141398c354cc1607bcfe9590d93e63f5">sorted_order</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;column_order={}, std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;null_precedence={}, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga141398c354cc1607bcfe9590d93e63f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the row indices that would produce <code>input</code> in a lexicographical sorted order.  <br /></td></tr>
<tr class="separator:ga141398c354cc1607bcfe9590d93e63f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2db61bdd446ede1bdad2cf13ec4ab65d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__sort.html#ga2db61bdd446ede1bdad2cf13ec4ab65d">stable_sorted_order</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;column_order={}, std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;null_precedence={}, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga2db61bdd446ede1bdad2cf13ec4ab65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the row indices that would produce <code>input</code> in a stable lexicographical sorted order.  <br /></td></tr>
<tr class="separator:ga2db61bdd446ede1bdad2cf13ec4ab65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77f7f552aca16f21830817ccd088670e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__sort.html#ga77f7f552aca16f21830817ccd088670e">is_sorted</a> (<a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;<a class="el" href="classcudf_1_1table.html">table</a>, std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;column_order, std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;null_precedence)</td></tr>
<tr class="memdesc:ga77f7f552aca16f21830817ccd088670e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the rows of a <code>table</code> are sorted in a lexicographical order.  <br /></td></tr>
<tr class="separator:ga77f7f552aca16f21830817ccd088670e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga921f48f195936eb38dc205e8dfd2ae54"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__sort.html#ga921f48f195936eb38dc205e8dfd2ae54">sort</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;column_order={}, std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;null_precedence={}, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga921f48f195936eb38dc205e8dfd2ae54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a lexicographic sort of the rows of a table  <br /></td></tr>
<tr class="separator:ga921f48f195936eb38dc205e8dfd2ae54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb4d13cd3f1b4e9077011923422735a3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__sort.html#gafb4d13cd3f1b4e9077011923422735a3">sort_by_key</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;values, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;keys, std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;column_order={}, std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;null_precedence={}, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gafb4d13cd3f1b4e9077011923422735a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a key-value sort.  <br /></td></tr>
<tr class="separator:gafb4d13cd3f1b4e9077011923422735a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18ef8338c288288adfea62c9e12cbd9c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__sort.html#ga18ef8338c288288adfea62c9e12cbd9c">stable_sort_by_key</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;values, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;keys, std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;column_order={}, std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;null_precedence={}, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga18ef8338c288288adfea62c9e12cbd9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a key-value stable sort.  <br /></td></tr>
<tr class="separator:ga18ef8338c288288adfea62c9e12cbd9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5209c095d2b7cb1a8c69b33a2e3956f2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__sort.html#ga5209c095d2b7cb1a8c69b33a2e3956f2">rank</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="group__column__sort.html#gac8975ec1273372f6ccae83a85bee71ce">rank_method</a> method, <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> column_order, <a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a> null_handling, <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> null_precedence, bool percentage, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga5209c095d2b7cb1a8c69b33a2e3956f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the ranks of input column in sorted order.  <br /></td></tr>
<tr class="separator:ga5209c095d2b7cb1a8c69b33a2e3956f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe92e762f1eabd11c66eddf1cbc01eb7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__sort.html#gabe92e762f1eabd11c66eddf1cbc01eb7">segmented_sorted_order</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;keys, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;segment_offsets, std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;column_order={}, std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;null_precedence={}, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gabe92e762f1eabd11c66eddf1cbc01eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns sorted order after sorting each segment in the table.  <br /></td></tr>
<tr class="separator:gabe92e762f1eabd11c66eddf1cbc01eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2a305a2004c722983cb8a863067dbd0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__sort.html#gab2a305a2004c722983cb8a863067dbd0">stable_segmented_sorted_order</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;keys, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;segment_offsets, std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;column_order={}, std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;null_precedence={}, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gab2a305a2004c722983cb8a863067dbd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns sorted order after stably sorting each segment in the table.  <br /></td></tr>
<tr class="separator:gab2a305a2004c722983cb8a863067dbd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga362ef2bb477363f2314bf86e9fc52893"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__sort.html#ga362ef2bb477363f2314bf86e9fc52893">segmented_sort_by_key</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;values, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;keys, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;segment_offsets, std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;column_order={}, std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;null_precedence={}, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga362ef2bb477363f2314bf86e9fc52893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a lexicographic segmented sort of a table  <br /></td></tr>
<tr class="separator:ga362ef2bb477363f2314bf86e9fc52893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ddc75a2acfc4996bfc34c57050b1cfd"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__sort.html#ga1ddc75a2acfc4996bfc34c57050b1cfd">stable_segmented_sort_by_key</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;values, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;keys, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;segment_offsets, std::vector&lt; <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">order</a> &gt; const &amp;column_order={}, std::vector&lt; <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">null_order</a> &gt; const &amp;null_precedence={}, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga1ddc75a2acfc4996bfc34c57050b1cfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a stably lexicographic segmented sort of a table  <br /></td></tr>
<tr class="separator:ga1ddc75a2acfc4996bfc34c57050b1cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccf9b4b9eea838d724facc174df875a5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reorder__compact.html#gaccf9b4b9eea838d724facc174df875a5">drop_nulls</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; const &amp;keys, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a> keep_threshold, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gaccf9b4b9eea838d724facc174df875a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a table to remove null elements with threshold count.  <br /></td></tr>
<tr class="separator:gaccf9b4b9eea838d724facc174df875a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4213141aad40c18cf819324c0657fb13"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reorder__compact.html#ga4213141aad40c18cf819324c0657fb13">drop_nulls</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; const &amp;keys, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga4213141aad40c18cf819324c0657fb13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a table to remove null elements.  <br /></td></tr>
<tr class="separator:ga4213141aad40c18cf819324c0657fb13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfbe51626a833f0f4364b20fcb4b92db"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reorder__compact.html#gacfbe51626a833f0f4364b20fcb4b92db">drop_nans</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; const &amp;keys, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a> keep_threshold, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gacfbe51626a833f0f4364b20fcb4b92db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a table to remove NANs with threshold count.  <br /></td></tr>
<tr class="separator:gacfbe51626a833f0f4364b20fcb4b92db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac176247015532251d153376e64bc80a6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reorder__compact.html#gac176247015532251d153376e64bc80a6">drop_nans</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; const &amp;keys, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gac176247015532251d153376e64bc80a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters a table to remove NANs.  <br /></td></tr>
<tr class="separator:gac176247015532251d153376e64bc80a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fe0c9d15a7c744a87c8334453798b8d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reorder__compact.html#ga6fe0c9d15a7c744a87c8334453798b8d">apply_boolean_mask</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;boolean_mask, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga6fe0c9d15a7c744a87c8334453798b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters <code>input</code> using <code>boolean_mask</code> of boolean values as a mask.  <br /></td></tr>
<tr class="separator:ga6fe0c9d15a7c744a87c8334453798b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87352ad4f282dd17365d4c9929d5c644"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reorder__compact.html#ga87352ad4f282dd17365d4c9929d5c644">unique</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; const &amp;keys, <a class="el" href="group__reorder__compact.html#ga69091647ea1f9c9d4cdcf7c8876bea3a">duplicate_keep_option</a> keep, <a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a> nulls_equal=<a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44">null_equality::EQUAL</a>, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga87352ad4f282dd17365d4c9929d5c644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new table with consecutive duplicate rows removed.  <br /></td></tr>
<tr class="separator:ga87352ad4f282dd17365d4c9929d5c644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga201195610929658c5d383fa99434ef9c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reorder__compact.html#ga201195610929658c5d383fa99434ef9c">distinct</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; const &amp;keys, <a class="el" href="group__reorder__compact.html#ga69091647ea1f9c9d4cdcf7c8876bea3a">duplicate_keep_option</a> keep=<a class="el" href="group__reorder__compact.html#gga69091647ea1f9c9d4cdcf7c8876bea3aa0546025abe5830d9334bb82102420394">duplicate_keep_option::KEEP_ANY</a>, <a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a> nulls_equal=<a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44">null_equality::EQUAL</a>, <a class="el" href="group__utility__types.html#gae9d1055c69c3089452794783c7c82f83">nan_equality</a> nans_equal=<a class="el" href="group__utility__types.html#ggae9d1055c69c3089452794783c7c82f83acd6d9f766e6e2753da429d26078711d7">nan_equality::ALL_EQUAL</a>, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga201195610929658c5d383fa99434ef9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new table without duplicate rows.  <br /></td></tr>
<tr class="separator:ga201195610929658c5d383fa99434ef9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63e5defd9560fcd397ff6aa79022a56c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reorder__compact.html#ga63e5defd9560fcd397ff6aa79022a56c">unique_count</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a> null_handling, <a class="el" href="group__utility__types.html#ga74641d3dfd6d96d0939b492ecf9b9cc8">nan_policy</a> nan_handling)</td></tr>
<tr class="memdesc:ga63e5defd9560fcd397ff6aa79022a56c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of consecutive groups of equivalent rows in a column.  <br /></td></tr>
<tr class="separator:ga63e5defd9560fcd397ff6aa79022a56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad947e78a65b8c7eca69337c6bd3ad749"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reorder__compact.html#gad947e78a65b8c7eca69337c6bd3ad749">unique_count</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a> nulls_equal=<a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44">null_equality::EQUAL</a>)</td></tr>
<tr class="memdesc:gad947e78a65b8c7eca69337c6bd3ad749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of consecutive groups of equivalent rows in a table.  <br /></td></tr>
<tr class="separator:gad947e78a65b8c7eca69337c6bd3ad749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6e12738145f070878194502d8d5a1c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reorder__compact.html#gab6e12738145f070878194502d8d5a1c9">distinct_count</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">null_policy</a> null_handling, <a class="el" href="group__utility__types.html#ga74641d3dfd6d96d0939b492ecf9b9cc8">nan_policy</a> nan_handling)</td></tr>
<tr class="memdesc:gab6e12738145f070878194502d8d5a1c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the distinct elements in the <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a>.  <br /></td></tr>
<tr class="separator:gab6e12738145f070878194502d8d5a1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad861920389b600bb3310ecb22e307316"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reorder__compact.html#gad861920389b600bb3310ecb22e307316">distinct_count</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">null_equality</a> nulls_equal=<a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44">null_equality::EQUAL</a>)</td></tr>
<tr class="memdesc:gad861920389b600bb3310ecb22e307316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the distinct rows in a table.  <br /></td></tr>
<tr class="separator:gad861920389b600bb3310ecb22e307316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025670a619591e80fdf972c36e625005"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a025670a619591e80fdf972c36e625005">nullable</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;view)</td></tr>
<tr class="memdesc:a025670a619591e80fdf972c36e625005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns True if any of the columns in the table is nullable. (not entire hierarchy)  <br /></td></tr>
<tr class="separator:a025670a619591e80fdf972c36e625005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b69e95220c2cc259bbf510506b6fff9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a0b69e95220c2cc259bbf510506b6fff9">has_nulls</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;view)</td></tr>
<tr class="memdesc:a0b69e95220c2cc259bbf510506b6fff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns True if the table has nulls in any of its columns.  <br /></td></tr>
<tr class="separator:a0b69e95220c2cc259bbf510506b6fff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e88bcc8b11230b602d828b692636c55"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a6e88bcc8b11230b602d828b692636c55">has_nested_nulls</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input)</td></tr>
<tr class="memdesc:a6e88bcc8b11230b602d828b692636c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns True if the table has nulls in any of its columns hierarchy  <br /></td></tr>
<tr class="separator:a6e88bcc8b11230b602d828b692636c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1263279c1224a4c7634455ca08ae7ae3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcudf_1_1column__view.html">column_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a1263279c1224a4c7634455ca08ae7ae3">get_nullable_columns</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;<a class="el" href="classcudf_1_1table.html">table</a>)</td></tr>
<tr class="memdesc:a1263279c1224a4c7634455ca08ae7ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function to collect all nullable columns at all nested levels in a given table.  <br /></td></tr>
<tr class="separator:a1263279c1224a4c7634455ca08ae7ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f79c6fbeb12b15851bee1aa09f76c92"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a2f79c6fbeb12b15851bee1aa09f76c92">have_same_types</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;lhs, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;rhs)</td></tr>
<tr class="memdesc:a2f79c6fbeb12b15851bee1aa09f76c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code>s have columns of same types  <br /></td></tr>
<tr class="separator:a2f79c6fbeb12b15851bee1aa09f76c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3eece7be385b3be2bda53b24a48dbdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcudf_1_1table__view.html">table_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ab3eece7be385b3be2bda53b24a48dbdc">scatter_columns</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;source, std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; const &amp;map, <a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;target)</td></tr>
<tr class="memdesc:ab3eece7be385b3be2bda53b24a48dbdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy column_views from a <a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a> into another <a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a> according to a column indices map.  <br /></td></tr>
<tr class="separator:ab3eece7be385b3be2bda53b24a48dbdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10b4d0e6674922ddf34b9bc32f3543e9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__transform.html#ga10b4d0e6674922ddf34b9bc32f3543e9">transform</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, std::string const &amp;unary_udf, <a class="el" href="classcudf_1_1data__type.html">data_type</a> output_type, bool is_ptx, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga10b4d0e6674922ddf34b9bc32f3543e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new column by applying a unary function against every element of an input column.  <br /></td></tr>
<tr class="separator:ga10b4d0e6674922ddf34b9bc32f3543e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d49c4245df211abb5b5157cfed58744"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; rmm::device_buffer &gt;, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__transform.html#ga6d49c4245df211abb5b5157cfed58744">nans_to_nulls</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga6d49c4245df211abb5b5157cfed58744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a null_mask from <code>input</code> by converting <code>NaN</code> to null and preserving existing null values and also returns new null_count.  <br /></td></tr>
<tr class="separator:ga6d49c4245df211abb5b5157cfed58744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf935e4f6a30de36cdeb51c2120cf4ece"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__transform.html#gaf935e4f6a30de36cdeb51c2120cf4ece">compute_column</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;<a class="el" href="classcudf_1_1table.html">table</a>, <a class="el" href="structcudf_1_1ast_1_1expression.html">ast::expression</a> const &amp;expr, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gaf935e4f6a30de36cdeb51c2120cf4ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a new column by evaluating an expression tree on a table.  <br /></td></tr>
<tr class="separator:gaf935e4f6a30de36cdeb51c2120cf4ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dd8538088b9897a261ab52583d8d192"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; rmm::device_buffer &gt;, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__transform.html#ga4dd8538088b9897a261ab52583d8d192">bools_to_mask</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga4dd8538088b9897a261ab52583d8d192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a bitmask from a column of boolean elements.  <br /></td></tr>
<tr class="separator:ga4dd8538088b9897a261ab52583d8d192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fb087bbf77bdfd10bdc418aad34792e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">cudf::table</a> &gt;, std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__transform.html#ga2fb087bbf77bdfd10bdc418aad34792e">encode</a> (<a class="el" href="classcudf_1_1table__view.html">cudf::table_view</a> const &amp;input, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga2fb087bbf77bdfd10bdc418aad34792e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode the rows of the given table as integers  <br /></td></tr>
<tr class="separator:ga2fb087bbf77bdfd10bdc418aad34792e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d0d48b61fa97030d90ec7f697fa83e9"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;, <a class="el" href="classcudf_1_1table__view.html">table_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__transform.html#ga6d0d48b61fa97030d90ec7f697fa83e9">one_hot_encode</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;categories, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga6d0d48b61fa97030d90ec7f697fa83e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes <code>input</code> by generating a new column for each value in <code>categories</code> indicating the presence of that value in <code>input</code>.  <br /></td></tr>
<tr class="separator:ga6d0d48b61fa97030d90ec7f697fa83e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57308abbc54d2b0fc6cd221c539b3903"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__transform.html#ga57308abbc54d2b0fc6cd221c539b3903">mask_to_bools</a> (<a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> const *bitmask, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> begin_bit, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> end_bit, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga57308abbc54d2b0fc6cd221c539b3903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a boolean column from given bitmask.  <br /></td></tr>
<tr class="separator:ga57308abbc54d2b0fc6cd221c539b3903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae017bd71f182100b614e7e00f0e0c7ed"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__transform.html#gae017bd71f182100b614e7e00f0e0c7ed">row_bit_count</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;t, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gae017bd71f182100b614e7e00f0e0c7ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an approximate cumulative size in bits of all columns in the <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code> for each row.  <br /></td></tr>
<tr class="separator:gae017bd71f182100b614e7e00f0e0c7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cde57d2207336e62ddc74c8b23db832"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;, <a class="el" href="classcudf_1_1table__view.html">table_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reshape__transpose.html#ga7cde57d2207336e62ddc74c8b23db832">transpose</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga7cde57d2207336e62ddc74c8b23db832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes a table.  <br /></td></tr>
<tr class="separator:ga7cde57d2207336e62ddc74c8b23db832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4211fc2c58997473ebae90b522492e39"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4211fc2c58997473ebae90b522492e39"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga4211fc2c58997473ebae90b522492e39">distance</a> (T f, T l)</td></tr>
<tr class="memdesc:ga4211fc2c58997473ebae90b522492e39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <code>std::distance</code> but returns <code><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9" title="Row index type for columns and tables">cudf::size_type</a></code> and performs <code>static_cast</code>  <br /></td></tr>
<tr class="separator:ga4211fc2c58997473ebae90b522492e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43d59dc0b7badf0776db20b172210045"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga43d59dc0b7badf0776db20b172210045">operator==</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> const &amp;lhs, <a class="el" href="classcudf_1_1data__type.html">data_type</a> const &amp;rhs)</td></tr>
<tr class="memdesc:ga43d59dc0b7badf0776db20b172210045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> objects for equality.  <br /></td></tr>
<tr class="separator:ga43d59dc0b7badf0776db20b172210045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga832a5fbbf8b2adc9aae9f96798813720"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga832a5fbbf8b2adc9aae9f96798813720">operator!=</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> const &amp;lhs, <a class="el" href="classcudf_1_1data__type.html">data_type</a> const &amp;rhs)</td></tr>
<tr class="memdesc:ga832a5fbbf8b2adc9aae9f96798813720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> objects for inequality.  <br /></td></tr>
<tr class="separator:ga832a5fbbf8b2adc9aae9f96798813720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51b0daf2c01663d51cb3b87ad8ce93c0"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga51b0daf2c01663d51cb3b87ad8ce93c0">size_of</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> t)</td></tr>
<tr class="memdesc:ga51b0daf2c01663d51cb3b87ad8ce93c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size in bytes of elements of the specified <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code>  <br /></td></tr>
<tr class="separator:ga51b0daf2c01663d51cb3b87ad8ce93c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9ccb7f148feeb38dc70f3dbd242cf77"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__unaryops.html#gaa9ccb7f148feeb38dc70f3dbd242cf77">unary_operation</a> (<a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> const &amp;input, <a class="el" href="group__transformation__unaryops.html#ga030e62f30b296602f398e70d1ca657c4">cudf::unary_operator</a> op, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gaa9ccb7f148feeb38dc70f3dbd242cf77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs unary op on all values in column  <br /></td></tr>
<tr class="separator:gaa9ccb7f148feeb38dc70f3dbd242cf77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46e28ccfd5e3d08b618ff50c27669d1c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__unaryops.html#ga46e28ccfd5e3d08b618ff50c27669d1c">is_null</a> (<a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> const &amp;input, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga46e28ccfd5e3d08b618ff50c27669d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a column of <code><a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd" title="Boolean using one byte per value, 0 == false, else true">type_id::BOOL8</a></code> elements where for every element in <code>input</code> <code>true</code> indicates the value is null and <code>false</code> indicates the value is valid.  <br /></td></tr>
<tr class="separator:ga46e28ccfd5e3d08b618ff50c27669d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6add319b999ddaa1ccf3477599fdc0bc"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__unaryops.html#ga6add319b999ddaa1ccf3477599fdc0bc">is_valid</a> (<a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> const &amp;input, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga6add319b999ddaa1ccf3477599fdc0bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a column of <code><a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd" title="Boolean using one byte per value, 0 == false, else true">type_id::BOOL8</a></code> elements where for every element in <code>input</code> <code>true</code> indicates the value is valid and <code>false</code> indicates the value is null.  <br /></td></tr>
<tr class="separator:ga6add319b999ddaa1ccf3477599fdc0bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4687e7ed2576032200e400077f82dbf0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__unaryops.html#ga4687e7ed2576032200e400077f82dbf0">cast</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, <a class="el" href="classcudf_1_1data__type.html">data_type</a> out_type, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga4687e7ed2576032200e400077f82dbf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts data from dtype specified in input to dtype specified in output.  <br /></td></tr>
<tr class="separator:ga4687e7ed2576032200e400077f82dbf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59578e8513f1c33d8c03b7b3efeb6cab"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__unaryops.html#ga59578e8513f1c33d8c03b7b3efeb6cab">is_nan</a> (<a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> const &amp;input, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga59578e8513f1c33d8c03b7b3efeb6cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a column of <code><a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd" title="Boolean using one byte per value, 0 == false, else true">type_id::BOOL8</a></code> elements indicating the presence of <code>NaN</code> values in a column of floating point values. The output element at row <code>i</code> is <code>true</code> if the element in <code>input</code> at row i is <code>NAN</code>, else <code>false</code>  <br /></td></tr>
<tr class="separator:ga59578e8513f1c33d8c03b7b3efeb6cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99e856d9abf718ded7668b33f03effa2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformation__unaryops.html#ga99e856d9abf718ded7668b33f03effa2">is_not_nan</a> (<a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> const &amp;input, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga99e856d9abf718ded7668b33f03effa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a column of <code><a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd" title="Boolean using one byte per value, 0 == false, else true">type_id::BOOL8</a></code> elements indicating the absence of <code>NaN</code> values in a column of floating point values. The output element at row <code>i</code> is <code>false</code> if the element in <code>input</code> at row i is <code>NAN</code>, else <code>true</code>  <br /></td></tr>
<tr class="separator:ga99e856d9abf718ded7668b33f03effa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f93fa04ed3df94180c09b0719d4d668"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="types_8hpp.html#adc4a74f3fb4b327ed43b31d0fca65ba3">CUDF_HOST_DEVICE</a> <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__bitmask.html#ga4f93fa04ed3df94180c09b0719d4d668">word_index</a> (<a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> bit_index)</td></tr>
<tr class="memdesc:ga4f93fa04ed3df94180c09b0719d4d668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the word containing the specified bit.  <br /></td></tr>
<tr class="separator:ga4f93fa04ed3df94180c09b0719d4d668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44f4cef44ddd5ef149420e8f8707f23a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="types_8hpp.html#adc4a74f3fb4b327ed43b31d0fca65ba3">CUDF_HOST_DEVICE</a> <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__bitmask.html#ga44f4cef44ddd5ef149420e8f8707f23a">intra_word_index</a> (<a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> bit_index)</td></tr>
<tr class="memdesc:ga44f4cef44ddd5ef149420e8f8707f23a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position within a word of the specified bit.  <br /></td></tr>
<tr class="separator:ga44f4cef44ddd5ef149420e8f8707f23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00673f7c2476e7c429304bac820c2560"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8hpp.html#adc4a74f3fb4b327ed43b31d0fca65ba3">CUDF_HOST_DEVICE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__bitmask.html#ga00673f7c2476e7c429304bac820c2560">set_bit_unsafe</a> (<a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> *bitmask, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> bit_index)</td></tr>
<tr class="memdesc:ga00673f7c2476e7c429304bac820c2560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the specified bit to <code>1</code>  <br /></td></tr>
<tr class="separator:ga00673f7c2476e7c429304bac820c2560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb540f6ba5e87ae4ced0672f3ecf1c59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8hpp.html#adc4a74f3fb4b327ed43b31d0fca65ba3">CUDF_HOST_DEVICE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__bitmask.html#gaeb540f6ba5e87ae4ced0672f3ecf1c59">clear_bit_unsafe</a> (<a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> *bitmask, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> bit_index)</td></tr>
<tr class="memdesc:gaeb540f6ba5e87ae4ced0672f3ecf1c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the specified bit to <code>0</code>  <br /></td></tr>
<tr class="separator:gaeb540f6ba5e87ae4ced0672f3ecf1c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2d905951bd90303422a5f9631c55124"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8hpp.html#adc4a74f3fb4b327ed43b31d0fca65ba3">CUDF_HOST_DEVICE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__bitmask.html#gad2d905951bd90303422a5f9631c55124">bit_is_set</a> (<a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> const *bitmask, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> bit_index)</td></tr>
<tr class="memdesc:gad2d905951bd90303422a5f9631c55124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the specified bit is set to <code>1</code>  <br /></td></tr>
<tr class="separator:gad2d905951bd90303422a5f9631c55124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafd7de16384765ce87da7e00fc8a1c70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8hpp.html#adc4a74f3fb4b327ed43b31d0fca65ba3">CUDF_HOST_DEVICE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__bitmask.html#gaafd7de16384765ce87da7e00fc8a1c70">bit_value_or</a> (<a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a> const *bitmask, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> bit_index, bool default_value)</td></tr>
<tr class="memdesc:gaafd7de16384765ce87da7e00fc8a1c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">optional-like interface to check if a specified bit of a bitmask is set.  <br /></td></tr>
<tr class="separator:gaafd7de16384765ce87da7e00fc8a1c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cb42c2aa948d300b4b2b524c01b93a8"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="types_8hpp.html#adc4a74f3fb4b327ed43b31d0fca65ba3">CUDF_HOST_DEVICE</a> <a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__bitmask.html#ga5cb42c2aa948d300b4b2b524c01b93a8">set_least_significant_bits</a> (<a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> n)</td></tr>
<tr class="memdesc:ga5cb42c2aa948d300b4b2b524c01b93a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a bitmask word with the <code>n</code> least significant bits set.  <br /></td></tr>
<tr class="separator:ga5cb42c2aa948d300b4b2b524c01b93a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1761cf9cca86fe86d379bfdaa422e7b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="types_8hpp.html#adc4a74f3fb4b327ed43b31d0fca65ba3">CUDF_HOST_DEVICE</a> <a class="el" href="group__utility__types.html#ga1d17001baf070a639c3a5e8ed8c46d34">bitmask_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__bitmask.html#gae1761cf9cca86fe86d379bfdaa422e7b">set_most_significant_bits</a> (<a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> n)</td></tr>
<tr class="memdesc:gae1761cf9cca86fe86d379bfdaa422e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a bitmask word with the <code>n</code> most significant bits set.  <br /></td></tr>
<tr class="separator:gae1761cf9cca86fe86d379bfdaa422e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001ed29e71e759518cae31e52312befa"><td class="memItemLeft" align="right" valign="top">rmm::cuda_stream_view const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">get_default_stream</a> ()</td></tr>
<tr class="memdesc:a001ed29e71e759518cae31e52312befa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current default stream  <br /></td></tr>
<tr class="separator:a001ed29e71e759518cae31e52312befa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab174115df603dd615e8aa8407217a8b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#ab174115df603dd615e8aa8407217a8b3">is_ptds_enabled</a> ()</td></tr>
<tr class="memdesc:ab174115df603dd615e8aa8407217a8b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if per-thread default stream is enabled.  <br /></td></tr>
<tr class="separator:ab174115df603dd615e8aa8407217a8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef9b08b206b1340c5ac3893d17943309"><td class="memTemplParams" colspan="2">template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:gaef9b08b206b1340c5ac3893d17943309"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#gaef9b08b206b1340c5ac3893d17943309">is_relationally_comparable</a> ()</td></tr>
<tr class="memdesc:gaef9b08b206b1340c5ac3893d17943309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether objects of types <code>L</code> and <code>R</code> can be relationally compared.  <br /></td></tr>
<tr class="separator:gaef9b08b206b1340c5ac3893d17943309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga645a96d47abea35f5da669ecf10ceae7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga645a96d47abea35f5da669ecf10ceae7">is_relationally_comparable</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:ga645a96d47abea35f5da669ecf10ceae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> <code>type</code> supports relational comparisons.  <br /></td></tr>
<tr class="separator:ga645a96d47abea35f5da669ecf10ceae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82f7470f89e1e2b53077246712787120"><td class="memTemplParams" colspan="2">template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ga82f7470f89e1e2b53077246712787120"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga82f7470f89e1e2b53077246712787120">is_equality_comparable</a> ()</td></tr>
<tr class="memdesc:ga82f7470f89e1e2b53077246712787120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether objects of types <code>L</code> and <code>R</code> can be compared for equality.  <br /></td></tr>
<tr class="separator:ga82f7470f89e1e2b53077246712787120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40162d35408ca1e9cc9b02af29b7149d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga40162d35408ca1e9cc9b02af29b7149d">is_equality_comparable</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:ga40162d35408ca1e9cc9b02af29b7149d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> <code>type</code> supports equality comparisons.  <br /></td></tr>
<tr class="separator:ga40162d35408ca1e9cc9b02af29b7149d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga736c39af324b57534639bd3d8af357e4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga736c39af324b57534639bd3d8af357e4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga736c39af324b57534639bd3d8af357e4">is_numeric</a> ()</td></tr>
<tr class="memdesc:ga736c39af324b57534639bd3d8af357e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the type <code>T</code> is a numeric type.  <br /></td></tr>
<tr class="separator:ga736c39af324b57534639bd3d8af357e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2eaf2d3443dd8aa17724e78190b537ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga2eaf2d3443dd8aa17724e78190b537ba">is_numeric</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:ga2eaf2d3443dd8aa17724e78190b537ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether <code>type</code> is a numeric <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code>.  <br /></td></tr>
<tr class="separator:ga2eaf2d3443dd8aa17724e78190b537ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79a73ff286550b2f4fc764a6dbc2d782"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga79a73ff286550b2f4fc764a6dbc2d782"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga79a73ff286550b2f4fc764a6dbc2d782">is_index_type</a> ()</td></tr>
<tr class="memdesc:ga79a73ff286550b2f4fc764a6dbc2d782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the type <code>T</code> is a index type.  <br /></td></tr>
<tr class="separator:ga79a73ff286550b2f4fc764a6dbc2d782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c4225b65c8d89fc680fc705676ff6f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga4c4225b65c8d89fc680fc705676ff6f1">is_index_type</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:ga4c4225b65c8d89fc680fc705676ff6f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the type <code>type</code> is a index type.  <br /></td></tr>
<tr class="separator:ga4c4225b65c8d89fc680fc705676ff6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf186010866f2f5eb497467963eaf3d54"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf186010866f2f5eb497467963eaf3d54"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#gaf186010866f2f5eb497467963eaf3d54">is_unsigned</a> ()</td></tr>
<tr class="memdesc:gaf186010866f2f5eb497467963eaf3d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the type <code>T</code> is a unsigned numeric type.  <br /></td></tr>
<tr class="separator:gaf186010866f2f5eb497467963eaf3d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95969e57d58b6b7468b1cba9f435d95e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga95969e57d58b6b7468b1cba9f435d95e">is_unsigned</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:ga95969e57d58b6b7468b1cba9f435d95e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether <code>type</code> is a unsigned numeric <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code>.  <br /></td></tr>
<tr class="separator:ga95969e57d58b6b7468b1cba9f435d95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga960cec36c56cd253a84fcd2cec3933f9"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:ga960cec36c56cd253a84fcd2cec3933f9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga960cec36c56cd253a84fcd2cec3933f9">is_signed_iterator</a> ()</td></tr>
<tr class="memdesc:ga960cec36c56cd253a84fcd2cec3933f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the <code>Iterator</code> value type is unsigned.  <br /></td></tr>
<tr class="separator:ga960cec36c56cd253a84fcd2cec3933f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa964d11859bcec770945cf53d964371c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa964d11859bcec770945cf53d964371c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#gaa964d11859bcec770945cf53d964371c">is_integral</a> ()</td></tr>
<tr class="memdesc:gaa964d11859bcec770945cf53d964371c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the type <code>T</code> is an integral type.  <br /></td></tr>
<tr class="separator:gaa964d11859bcec770945cf53d964371c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31c663c44b3af8ae957a1d514052c923"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga31c663c44b3af8ae957a1d514052c923">is_integral</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:ga31c663c44b3af8ae957a1d514052c923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether <code>type</code> is a integral <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code>.  <br /></td></tr>
<tr class="separator:ga31c663c44b3af8ae957a1d514052c923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac36fa8429a279de79c2afec53c02ee8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaac36fa8429a279de79c2afec53c02ee8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#gaac36fa8429a279de79c2afec53c02ee8">is_floating_point</a> ()</td></tr>
<tr class="memdesc:gaac36fa8429a279de79c2afec53c02ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the type <code>T</code> is a floating point type.  <br /></td></tr>
<tr class="separator:gaac36fa8429a279de79c2afec53c02ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga947bd07e5edd70d8d56b38aeb856e9c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga947bd07e5edd70d8d56b38aeb856e9c6">is_floating_point</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:ga947bd07e5edd70d8d56b38aeb856e9c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether <code>type</code> is a floating point <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code>.  <br /></td></tr>
<tr class="separator:ga947bd07e5edd70d8d56b38aeb856e9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27d4363f72ef43feeb12c06d90ff44c8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga27d4363f72ef43feeb12c06d90ff44c8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga27d4363f72ef43feeb12c06d90ff44c8">is_byte</a> ()</td></tr>
<tr class="memdesc:ga27d4363f72ef43feeb12c06d90ff44c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether <code>T</code> is a std::byte type.  <br /></td></tr>
<tr class="separator:ga27d4363f72ef43feeb12c06d90ff44c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1b9dd3a6ee95fa52224a53869cd164e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa1b9dd3a6ee95fa52224a53869cd164e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#gaa1b9dd3a6ee95fa52224a53869cd164e">is_boolean</a> ()</td></tr>
<tr class="memdesc:gaa1b9dd3a6ee95fa52224a53869cd164e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether <code>T</code> is a Boolean type.  <br /></td></tr>
<tr class="separator:gaa1b9dd3a6ee95fa52224a53869cd164e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73bcdf0744b62b98f4aef5fccea5840c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga73bcdf0744b62b98f4aef5fccea5840c">is_boolean</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:ga73bcdf0744b62b98f4aef5fccea5840c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether <code>type</code> is a Boolean <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code>.  <br /></td></tr>
<tr class="separator:ga73bcdf0744b62b98f4aef5fccea5840c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90ebb90931abfed637396889b7829173"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga90ebb90931abfed637396889b7829173"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga90ebb90931abfed637396889b7829173">is_timestamp</a> ()</td></tr>
<tr class="memdesc:ga90ebb90931abfed637396889b7829173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the type <code>T</code> is a timestamp type.  <br /></td></tr>
<tr class="separator:ga90ebb90931abfed637396889b7829173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92ea03fd93fa19ae17c3190cb439e5b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga92ea03fd93fa19ae17c3190cb439e5b3">is_timestamp</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:ga92ea03fd93fa19ae17c3190cb439e5b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether <code>type</code> is a timestamp <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code>.  <br /></td></tr>
<tr class="separator:ga92ea03fd93fa19ae17c3190cb439e5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02880fc9d2470aa36761dfe41c5309ee"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga02880fc9d2470aa36761dfe41c5309ee"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga02880fc9d2470aa36761dfe41c5309ee">is_fixed_point</a> ()</td></tr>
<tr class="memdesc:ga02880fc9d2470aa36761dfe41c5309ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the type <code>T</code> is a fixed-point type.  <br /></td></tr>
<tr class="separator:ga02880fc9d2470aa36761dfe41c5309ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad339e701fa8a26d7630aa28f846399fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#gad339e701fa8a26d7630aa28f846399fb">is_fixed_point</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:gad339e701fa8a26d7630aa28f846399fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether <code>type</code> is a fixed point <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code>.  <br /></td></tr>
<tr class="separator:gad339e701fa8a26d7630aa28f846399fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5196242442d99904c755da4920f1043f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5196242442d99904c755da4920f1043f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga5196242442d99904c755da4920f1043f">is_duration</a> ()</td></tr>
<tr class="memdesc:ga5196242442d99904c755da4920f1043f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the type <code>T</code> is a duration type.  <br /></td></tr>
<tr class="separator:ga5196242442d99904c755da4920f1043f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga285e3a7963fa18d913c1c9ff389d58ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga285e3a7963fa18d913c1c9ff389d58ba">is_duration</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:ga285e3a7963fa18d913c1c9ff389d58ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether <code>type</code> is a duration <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code>.  <br /></td></tr>
<tr class="separator:ga285e3a7963fa18d913c1c9ff389d58ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72f2d42d20b254754fd7bc8f4f32a990"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga72f2d42d20b254754fd7bc8f4f32a990"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga72f2d42d20b254754fd7bc8f4f32a990">is_chrono</a> ()</td></tr>
<tr class="memdesc:ga72f2d42d20b254754fd7bc8f4f32a990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the type <code>T</code> is a chrono type.  <br /></td></tr>
<tr class="separator:ga72f2d42d20b254754fd7bc8f4f32a990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2846c31e90421f0cbe7834334822e6a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#gad2846c31e90421f0cbe7834334822e6a">is_chrono</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:gad2846c31e90421f0cbe7834334822e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether <code>type</code> is a chrono <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code>.  <br /></td></tr>
<tr class="separator:gad2846c31e90421f0cbe7834334822e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c6839d4131493a1277f78a686226e54"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7c6839d4131493a1277f78a686226e54"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga7c6839d4131493a1277f78a686226e54">is_rep_layout_compatible</a> ()</td></tr>
<tr class="memdesc:ga7c6839d4131493a1277f78a686226e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether <code>T</code> is layout compatible with its "representation" type.  <br /></td></tr>
<tr class="separator:ga7c6839d4131493a1277f78a686226e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f0657d191e4b383da031cd506c5196f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1f0657d191e4b383da031cd506c5196f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga1f0657d191e4b383da031cd506c5196f">is_dictionary</a> ()</td></tr>
<tr class="memdesc:ga1f0657d191e4b383da031cd506c5196f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the type <code>T</code> is a dictionary type.  <br /></td></tr>
<tr class="separator:ga1f0657d191e4b383da031cd506c5196f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e213a7906791cb36453a966a16bf326"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga0e213a7906791cb36453a966a16bf326">is_dictionary</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:ga0e213a7906791cb36453a966a16bf326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether <code>type</code> is a dictionary <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code>.  <br /></td></tr>
<tr class="separator:ga0e213a7906791cb36453a966a16bf326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa937abead085ea9420b15c6473f08a7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaaa937abead085ea9420b15c6473f08a7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#gaaa937abead085ea9420b15c6473f08a7">is_fixed_width</a> ()</td></tr>
<tr class="memdesc:gaaa937abead085ea9420b15c6473f08a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether elements of type <code>T</code> are fixed-width.  <br /></td></tr>
<tr class="separator:gaaa937abead085ea9420b15c6473f08a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad588b3f9ca419e5a32f1ce42031994a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#gad588b3f9ca419e5a32f1ce42031994a5">is_fixed_width</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:gad588b3f9ca419e5a32f1ce42031994a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether elements of <code>type</code> are fixed-width.  <br /></td></tr>
<tr class="separator:gad588b3f9ca419e5a32f1ce42031994a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14e1cea4200d1d92d7f38d596333d28a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga14e1cea4200d1d92d7f38d596333d28a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga14e1cea4200d1d92d7f38d596333d28a">is_compound</a> ()</td></tr>
<tr class="memdesc:ga14e1cea4200d1d92d7f38d596333d28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the type <code>T</code> is a compound type.  <br /></td></tr>
<tr class="separator:ga14e1cea4200d1d92d7f38d596333d28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b9445eeead457a3d5e18a2a675eb8dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga7b9445eeead457a3d5e18a2a675eb8dd">is_compound</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:ga7b9445eeead457a3d5e18a2a675eb8dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether elements of <code>type</code> are compound.  <br /></td></tr>
<tr class="separator:ga7b9445eeead457a3d5e18a2a675eb8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaa242e2e068ab62bdaae071ed748357"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gacaa242e2e068ab62bdaae071ed748357"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#gacaa242e2e068ab62bdaae071ed748357">is_nested</a> ()</td></tr>
<tr class="memdesc:gacaa242e2e068ab62bdaae071ed748357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether <code>T</code> is a nested type.  <br /></td></tr>
<tr class="separator:gacaa242e2e068ab62bdaae071ed748357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bfcb79b22de847a085d106dbf813c03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga8bfcb79b22de847a085d106dbf813c03">is_nested</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:ga8bfcb79b22de847a085d106dbf813c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether <code>type</code> is a nested type  <br /></td></tr>
<tr class="separator:ga8bfcb79b22de847a085d106dbf813c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73dd2d74b0eafb1543eb1cd27accd38e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga73dd2d74b0eafb1543eb1cd27accd38e">is_bit_castable</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> from, <a class="el" href="classcudf_1_1data__type.html">data_type</a> to)</td></tr>
<tr class="memdesc:ga73dd2d74b0eafb1543eb1cd27accd38e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether <code>from</code> is bit-castable to <code>to</code>.  <br /></td></tr>
<tr class="separator:ga73dd2d74b0eafb1543eb1cd27accd38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840f61a0eccd339fd42fc7c12e02dbe3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#a840f61a0eccd339fd42fc7c12e02dbe3">column_types_equal</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;lhs, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;rhs)</td></tr>
<tr class="memdesc:a840f61a0eccd339fd42fc7c12e02dbe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the type of two <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code>s  <br /></td></tr>
<tr class="separator:a840f61a0eccd339fd42fc7c12e02dbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ba5eea729f54e486b228ab4d4fbb8bc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9ba5eea729f54e486b228ab4d4fbb8bc"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="group__utility__types.html#gadf077607da617d1dadcc5417e2783539">type_id</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__dispatcher.html#ga9ba5eea729f54e486b228ab4d4fbb8bc">type_to_id</a> ()</td></tr>
<tr class="memdesc:ga9ba5eea729f54e486b228ab4d4fbb8bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a C++ type to it's corresponding <code><a class="el" href="group__utility__types.html#gadf077607da617d1dadcc5417e2783539" title="Identifies a column&#39;s logical element type">cudf::type_id</a></code>  <br /></td></tr>
<tr class="separator:ga9ba5eea729f54e486b228ab4d4fbb8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed4d6fee1f0059e5f26ab79eda8ad758"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaed4d6fee1f0059e5f26ab79eda8ad758"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__dispatcher.html#gaed4d6fee1f0059e5f26ab79eda8ad758">type_id_matches_device_storage_type</a> (<a class="el" href="group__utility__types.html#gadf077607da617d1dadcc5417e2783539">type_id</a> id)</td></tr>
<tr class="memdesc:gaed4d6fee1f0059e5f26ab79eda8ad758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <code>fixed_point</code>-like types have template type <code>T</code> matching the column's stored type id  <br /></td></tr>
<tr class="separator:gaed4d6fee1f0059e5f26ab79eda8ad758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebd6c6fd035b72912e32ba89963af939"><td class="memTemplParams" colspan="2">template&lt;template&lt; <a class="el" href="group__utility__types.html#gadf077607da617d1dadcc5417e2783539">cudf::type_id</a> &gt; typename IdTypeMap = id_to_type_impl, typename Functor , typename... Ts&gt; </td></tr>
<tr class="memitem:gaebd6c6fd035b72912e32ba89963af939"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_8hpp.html#adc4a74f3fb4b327ed43b31d0fca65ba3">CUDF_HOST_DEVICE</a> __forceinline__ constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__dispatcher.html#gaebd6c6fd035b72912e32ba89963af939">type_dispatcher</a> (<a class="el" href="classcudf_1_1data__type.html">cudf::data_type</a> dtype, Functor f, Ts &amp;&amp;... args)</td></tr>
<tr class="memdesc:gaebd6c6fd035b72912e32ba89963af939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes an <code>operator()</code> template with the type instantiation based on the specified <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">cudf::data_type</a></code>'s <code>id()</code>.  <br /></td></tr>
<tr class="separator:gaebd6c6fd035b72912e32ba89963af939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga334c80129f729bd620894373d39bf67c"><td class="memTemplParams" colspan="2">template&lt;template&lt; <a class="el" href="group__utility__types.html#gadf077607da617d1dadcc5417e2783539">cudf::type_id</a> &gt; typename IdTypeMap = id_to_type_impl, typename F , typename... Ts&gt; </td></tr>
<tr class="memitem:ga334c80129f729bd620894373d39bf67c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_8hpp.html#adc4a74f3fb4b327ed43b31d0fca65ba3">CUDF_HOST_DEVICE</a> __forceinline__ constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__dispatcher.html#ga334c80129f729bd620894373d39bf67c">double_type_dispatcher</a> (<a class="el" href="classcudf_1_1data__type.html">cudf::data_type</a> type1, <a class="el" href="classcudf_1_1data__type.html">cudf::data_type</a> type2, F &amp;&amp;f, Ts &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga334c80129f729bd620894373d39bf67c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches two type template parameters to a callable.  <br /></td></tr>
<tr class="separator:ga334c80129f729bd620894373d39bf67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2418799abf6328e235beaa00cc0d0e94"><td class="memTemplParams" colspan="2">template&lt;typename Integer &gt; </td></tr>
<tr class="memitem:ga2418799abf6328e235beaa00cc0d0e94"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_8hpp.html#adc4a74f3fb4b327ed43b31d0fca65ba3">CUDF_HOST_DEVICE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__dictionary__classes.html#ga2418799abf6328e235beaa00cc0d0e94">operator==</a> (<a class="el" href="structcudf_1_1dictionary__wrapper.html">dictionary_wrapper</a>&lt; Integer &gt; const &amp;lhs, <a class="el" href="structcudf_1_1dictionary__wrapper.html">dictionary_wrapper</a>&lt; Integer &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:ga2418799abf6328e235beaa00cc0d0e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wqual to operator for <a class="el" href="structcudf_1_1dictionary__wrapper.html" title="A strongly typed wrapper for indices in a DICTIONARY type column.">dictionary_wrapper</a>  <br /></td></tr>
<tr class="separator:ga2418799abf6328e235beaa00cc0d0e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d6b365ea353739b6a63058a0fd66d15"><td class="memTemplParams" colspan="2">template&lt;typename Integer &gt; </td></tr>
<tr class="memitem:ga5d6b365ea353739b6a63058a0fd66d15"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_8hpp.html#adc4a74f3fb4b327ed43b31d0fca65ba3">CUDF_HOST_DEVICE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__dictionary__classes.html#ga5d6b365ea353739b6a63058a0fd66d15">operator!=</a> (<a class="el" href="structcudf_1_1dictionary__wrapper.html">dictionary_wrapper</a>&lt; Integer &gt; const &amp;lhs, <a class="el" href="structcudf_1_1dictionary__wrapper.html">dictionary_wrapper</a>&lt; Integer &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:ga5d6b365ea353739b6a63058a0fd66d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not equal to operator for <a class="el" href="structcudf_1_1dictionary__wrapper.html" title="A strongly typed wrapper for indices in a DICTIONARY type column.">dictionary_wrapper</a>  <br /></td></tr>
<tr class="separator:ga5d6b365ea353739b6a63058a0fd66d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacf24d904c87ba71cc02721540f2928f"><td class="memTemplParams" colspan="2">template&lt;typename Integer &gt; </td></tr>
<tr class="memitem:gaacf24d904c87ba71cc02721540f2928f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_8hpp.html#adc4a74f3fb4b327ed43b31d0fca65ba3">CUDF_HOST_DEVICE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__dictionary__classes.html#gaacf24d904c87ba71cc02721540f2928f">operator&lt;=</a> (<a class="el" href="structcudf_1_1dictionary__wrapper.html">dictionary_wrapper</a>&lt; Integer &gt; const &amp;lhs, <a class="el" href="structcudf_1_1dictionary__wrapper.html">dictionary_wrapper</a>&lt; Integer &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:gaacf24d904c87ba71cc02721540f2928f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than or equal to operator for <a class="el" href="structcudf_1_1dictionary__wrapper.html" title="A strongly typed wrapper for indices in a DICTIONARY type column.">dictionary_wrapper</a>  <br /></td></tr>
<tr class="separator:gaacf24d904c87ba71cc02721540f2928f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6356d1c824567d649cfd957acbf547c8"><td class="memTemplParams" colspan="2">template&lt;typename Integer &gt; </td></tr>
<tr class="memitem:ga6356d1c824567d649cfd957acbf547c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_8hpp.html#adc4a74f3fb4b327ed43b31d0fca65ba3">CUDF_HOST_DEVICE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__dictionary__classes.html#ga6356d1c824567d649cfd957acbf547c8">operator&gt;=</a> (<a class="el" href="structcudf_1_1dictionary__wrapper.html">dictionary_wrapper</a>&lt; Integer &gt; const &amp;lhs, <a class="el" href="structcudf_1_1dictionary__wrapper.html">dictionary_wrapper</a>&lt; Integer &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:ga6356d1c824567d649cfd957acbf547c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than or equal to operator for <a class="el" href="structcudf_1_1dictionary__wrapper.html" title="A strongly typed wrapper for indices in a DICTIONARY type column.">dictionary_wrapper</a>  <br /></td></tr>
<tr class="separator:ga6356d1c824567d649cfd957acbf547c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b11b0eb8b44d0a1a4d659fe459afeb8"><td class="memTemplParams" colspan="2">template&lt;typename Integer &gt; </td></tr>
<tr class="memitem:ga5b11b0eb8b44d0a1a4d659fe459afeb8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_8hpp.html#adc4a74f3fb4b327ed43b31d0fca65ba3">CUDF_HOST_DEVICE</a> constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__dictionary__classes.html#ga5b11b0eb8b44d0a1a4d659fe459afeb8">operator&lt;</a> (<a class="el" href="structcudf_1_1dictionary__wrapper.html">dictionary_wrapper</a>&lt; Integer &gt; const &amp;lhs, <a class="el" href="structcudf_1_1dictionary__wrapper.html">dictionary_wrapper</a>&lt; Integer &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:ga5b11b0eb8b44d0a1a4d659fe459afeb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than operator for <a class="el" href="structcudf_1_1dictionary__wrapper.html" title="A strongly typed wrapper for indices in a DICTIONARY type column.">dictionary_wrapper</a>  <br /></td></tr>
<tr class="separator:ga5b11b0eb8b44d0a1a4d659fe459afeb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9498addb2103d4eb7ef489f6065b368d"><td class="memTemplParams" colspan="2">template&lt;typename Integer &gt; </td></tr>
<tr class="memitem:ga9498addb2103d4eb7ef489f6065b368d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="types_8hpp.html#adc4a74f3fb4b327ed43b31d0fca65ba3">CUDF_HOST_DEVICE</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__dictionary__classes.html#ga9498addb2103d4eb7ef489f6065b368d">operator&gt;</a> (<a class="el" href="structcudf_1_1dictionary__wrapper.html">dictionary_wrapper</a>&lt; Integer &gt; const &amp;lhs, <a class="el" href="structcudf_1_1dictionary__wrapper.html">dictionary_wrapper</a>&lt; Integer &gt; const &amp;rhs)</td></tr>
<tr class="memdesc:ga9498addb2103d4eb7ef489f6065b368d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than operator for <a class="el" href="structcudf_1_1dictionary__wrapper.html" title="A strongly typed wrapper for indices in a DICTIONARY type column.">dictionary_wrapper</a>  <br /></td></tr>
<tr class="separator:ga9498addb2103d4eb7ef489f6065b368d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
变量</h2></td></tr>
<tr class="memitem:ga68de1d04aa2c0ea2eeacfc73fd99a915"><td class="memItemLeft" align="right" valign="top">static constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__hash.html#ga68de1d04aa2c0ea2eeacfc73fd99a915">DEFAULT_HASH_SEED</a> = 0</td></tr>
<tr class="memdesc:ga68de1d04aa2c0ea2eeacfc73fd99a915"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default seed value for hash functions  <br /></td></tr>
<tr class="separator:ga68de1d04aa2c0ea2eeacfc73fd99a915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eece3f40ff89fe8f1117097d86913b7"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga0eece3f40ff89fe8f1117097d86913b7">UNKNOWN_NULL_COUNT</a> {-1}</td></tr>
<tr class="memdesc:ga0eece3f40ff89fe8f1117097d86913b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates an unknown null count.  <br /></td></tr>
<tr class="separator:ga0eece3f40ff89fe8f1117097d86913b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add874002afe5d4f40cb59453704712bb"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf.html#add874002afe5d4f40cb59453704712bb">dynamic_extent</a> = std::numeric_limits&lt;std::size_t&gt;::max()</td></tr>
<tr class="memdesc:add874002afe5d4f40cb59453704712bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant used to differentiate std::span of static and dynamic extent  <br /></td></tr>
<tr class="separator:add874002afe5d4f40cb59453704712bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96e9ce4d30dc9a948112d814ee4cba79"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ga96e9ce4d30dc9a948112d814ee4cba79"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga96e9ce4d30dc9a948112d814ee4cba79">has_common_type_v</a> = <a class="el" href="structcudf_1_1detail_1_1has__common__type__impl.html">detail::has_common_type_impl</a>&lt;void, Ts...&gt;::value</td></tr>
<tr class="memdesc:ga96e9ce4d30dc9a948112d814ee4cba79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template for has_common_type&lt;&gt;::value  <br /></td></tr>
<tr class="separator:ga96e9ce4d30dc9a948112d814ee4cba79"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><p>cuDF interfaces </p>
</div><h2 class="groupheader">类型定义说明</h2>
<a id="af4f547550d24ad068f9f8ad75886af56" name="af4f547550d24ad068f9f8ad75886af56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f547550d24ad068f9f8ad75886af56">&#9670;&#160;</a></span>char_utf8</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="namespacecudf.html#af4f547550d24ad068f9f8ad75886af56">cudf::char_utf8</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UTF-8 characters are 1-4 bytes </p>

<p class="definition">在文件 <a class="el" href="utf8_8hpp_source.html">utf8.hpp</a> 第 <a class="el" href="utf8_8hpp_source.html#l00027">27</a> 行定义.</p>

</div>
</div>
<a id="a98b5509c0aeedbdb5bce4dc3b6869f26" name="a98b5509c0aeedbdb5bce4dc3b6869f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98b5509c0aeedbdb5bce4dc3b6869f26">&#9670;&#160;</a></span>hash_value_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecudf.html#a98b5509c0aeedbdb5bce4dc3b6869f26">cudf::hash_value_type</a> = typedef uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of hash value </p>

<p class="definition">在文件 <a class="el" href="hashing_8hpp_source.html">hashing.hpp</a> 第 <a class="el" href="hashing_8hpp_source.html#l00025">25</a> 行定义.</p>

</div>
</div>
<a id="aff73bd537f5aa6cb5eaea205ddad27d1" name="aff73bd537f5aa6cb5eaea205ddad27d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff73bd537f5aa6cb5eaea205ddad27d1">&#9670;&#160;</a></span>thread_range</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecudf.html#aff73bd537f5aa6cb5eaea205ddad27d1">cudf::thread_range</a> = typedef <a class="el" href="classnvtx3_1_1domain__thread__range.html">::nvtx3::domain_thread_range</a>&lt;<a class="el" href="structcudf_1_1libcudf__domain.html">libcudf_domain</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for an NVTX range in the libcudf domain. </p>

<p class="definition">在文件 <a class="el" href="ranges_8hpp_source.html">ranges.hpp</a> 第 <a class="el" href="ranges_8hpp_source.html#l00032">32</a> 行定义.</p>

</div>
</div>
<h2 class="groupheader">函数说明</h2>
<a id="a8bd44b61ff4585b5278f2d2203c909b7" name="a8bd44b61ff4585b5278f2d2203c909b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd44b61ff4585b5278f2d2203c909b7">&#9670;&#160;</a></span>bit_cast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcudf_1_1column__view.html">column_view</a> cudf::bit_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Zero-copy cast between types with the same size and compatible underlying representations. </p>
<p>This is similar to <code>reinterpret_cast</code> or <code>bit_cast</code> in that it gives a view of the same raw bits as a different type. Unlike <code>reinterpret_cast</code> however, this cast is only allowed on types that have the same width and compatible representations. For example, the way timestamp types are laid out in memory is equivalent to an integer representing a duration since a fixed epoch; bit-casting to the same integer type (INT32 for days, INT64 for others) results in a raw view of the duration count. A FLOAT32 can also be bit-casted into INT32 and treated as an integer value. However, an INT32 column cannot be bit-casted to INT64 as the sizes differ, nor can a <a class="el" href="classcudf_1_1string__view.html" title="A non-owning, immutable view of device data that is a variable length char array representing a UTF-8...">string_view</a> column be casted into a numeric type column as their data representations are not compatible.</p>
<p>The validity of the conversion can be checked with <code><a class="el" href="group__utility__types.html#ga73dd2d74b0eafb1543eb1cd27accd38e" title="Indicates whether from is bit-castable to to.">cudf::is_bit_castable()</a></code>.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if the specified cast is not possible, i.e., <code>is_bit_castable(input.type(), type)</code> is false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> to cast from </td></tr>
    <tr><td class="paramname">type</td><td>The <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> to cast to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>New <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> wrapping the same data as <code>input</code> but cast to <code>type</code> </dd></dl>

</div>
</div>
<a id="a312e4e0407f66456946bf14c6713f54b" name="a312e4e0407f66456946bf14c6713f54b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a312e4e0407f66456946bf14c6713f54b">&#9670;&#160;</a></span>bit_cast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcudf_1_1mutable__column__view.html">mutable_column_view</a> cudf::bit_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1mutable__column__view.html">mutable_column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Zero-copy cast between types with the same size and compatible underlying representations. </p>
<p>This is similar to <code>reinterpret_cast</code> or <code>bit_cast</code> in that it gives a view of the same raw bits as a different type. Unlike <code>reinterpret_cast</code> however, this cast is only allowed on types that have the same width and compatible representations. For example, the way timestamp types are laid out in memory is equivalent to an integer representing a duration since a fixed epoch; bit-casting to the same integer type (INT32 for days, INT64 for others) results in a raw view of the duration count. A FLOAT32 can also be bit-casted into INT32 and treated as an integer value. However, an INT32 column cannot be bit-casted to INT64 as the sizes differ, nor can a <a class="el" href="classcudf_1_1string__view.html" title="A non-owning, immutable view of device data that is a variable length char array representing a UTF-8...">string_view</a> column be casted into a numeric type column as their data representations are not compatible.</p>
<p>The validity of the conversion can be checked with <code><a class="el" href="group__utility__types.html#ga73dd2d74b0eafb1543eb1cd27accd38e" title="Indicates whether from is bit-castable to to.">cudf::is_bit_castable()</a></code>.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if the specified cast is not possible, i.e., <code>is_bit_castable(input.type(), type)</code> is false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The <code><a class="el" href="classcudf_1_1mutable__column__view.html" title="A non-owning, mutable view of device data as a column of elements, some of which may be null as indic...">mutable_column_view</a></code> to cast from </td></tr>
    <tr><td class="paramname">type</td><td>The <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> to cast to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>New <code><a class="el" href="classcudf_1_1mutable__column__view.html" title="A non-owning, mutable view of device data as a column of elements, some of which may be null as indic...">mutable_column_view</a></code> wrapping the same data as <code>input</code> but cast to <code>type</code> </dd></dl>

</div>
</div>
<a id="a840f61a0eccd339fd42fc7c12e02dbe3" name="a840f61a0eccd339fd42fc7c12e02dbe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a840f61a0eccd339fd42fc7c12e02dbe3">&#9670;&#160;</a></span>column_types_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cudf::column_types_equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the type of two <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code>s </p>
<p>This function returns true if the type of <code>lhs</code> equals that of <code>rhs</code>.</p><ul>
<li>For fixed point types, the scale is compared.</li>
<li>For dictionary types, the type of the keys are compared if both are non-empty columns.</li>
<li>For lists types, the type of child columns are compared recursively.</li>
<li>For struct types, the type of each field are compared in order.</li>
<li>For all other types, the <code>id</code> of <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> is compared.</li>
</ul>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> to compare </td></tr>
    <tr><td class="paramname">rhs</td><td>The second <code><a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">column_view</a></code> to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>true if column types match </dd></dl>

</div>
</div>
<a id="aef675a9c75a848ab796ae9b2b51c4238" name="aef675a9c75a848ab796ae9b2b51c4238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef675a9c75a848ab796ae9b2b51c4238">&#9670;&#160;</a></span>count_descendants()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> cudf::count_descendants </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a>&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of descendants of the specified parent. </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>The parent whose descendants will be counted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>size_type The number of descendants of the parent </dd></dl>

</div>
</div>
<a id="a001ed29e71e759518cae31e52312befa" name="a001ed29e71e759518cae31e52312befa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a001ed29e71e759518cae31e52312befa">&#9670;&#160;</a></span>get_default_stream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rmm::cuda_stream_view const cudf::get_default_stream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current default stream </p>
<dl class="section return"><dt>返回</dt><dd>The current default stream. </dd></dl>

</div>
</div>
<a id="a1263279c1224a4c7634455ca08ae7ae3" name="a1263279c1224a4c7634455ca08ae7ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1263279c1224a4c7634455ca08ae7ae3">&#9670;&#160;</a></span>get_nullable_columns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classcudf_1_1column__view.html">column_view</a> &gt; cudf::get_nullable_columns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function to collect all nullable columns at all nested levels in a given table. </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>The input table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A vector containing all nullable columns in the input table </dd></dl>

</div>
</div>
<a id="a6e88bcc8b11230b602d828b692636c55" name="a6e88bcc8b11230b602d828b692636c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e88bcc8b11230b602d828b692636c55">&#9670;&#160;</a></span>has_nested_nulls()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cudf::has_nested_nulls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns True if the table has nulls in any of its columns hierarchy </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The table to check for nulls </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>True if the table has nulls in any of its columns hierarchy, false otherwise </dd></dl>

<p class="definition">在文件 <a class="el" href="table__view_8hpp_source.html">table_view.hpp</a> 第 <a class="el" href="table__view_8hpp_source.html#l00329">329</a> 行定义.</p>

</div>
</div>
<a id="a0b69e95220c2cc259bbf510506b6fff9" name="a0b69e95220c2cc259bbf510506b6fff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b69e95220c2cc259bbf510506b6fff9">&#9670;&#160;</a></span>has_nulls()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cudf::has_nulls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>view</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns True if the table has nulls in any of its columns. </p>
<p>This checks for nulls in the columns and but not in any of the columns' children.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>The table to check for nulls </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>True if the table has nulls in any of its columns, false otherwise </dd></dl>

<p class="definition">在文件 <a class="el" href="table__view_8hpp_source.html">table_view.hpp</a> 第 <a class="el" href="table__view_8hpp_source.html#l00318">318</a> 行定义.</p>

</div>
</div>
<a id="a2f79c6fbeb12b15851bee1aa09f76c92" name="a2f79c6fbeb12b15851bee1aa09f76c92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f79c6fbeb12b15851bee1aa09f76c92">&#9670;&#160;</a></span>have_same_types()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cudf::have_same_types </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two <code><a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a></code>s have columns of same types </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>left-side <a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a> operand </td></tr>
    <tr><td class="paramname">rhs</td><td>right-side <a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a> operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>boolean comparison result </dd></dl>

<p class="definition">在文件 <a class="el" href="table__view_8hpp_source.html">table_view.hpp</a> 第 <a class="el" href="table__view_8hpp_source.html#l00354">354</a> 行定义.</p>

</div>
</div>
<a id="ab174115df603dd615e8aa8407217a8b3" name="ab174115df603dd615e8aa8407217a8b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab174115df603dd615e8aa8407217a8b3">&#9670;&#160;</a></span>is_ptds_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cudf::is_ptds_enabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if per-thread default stream is enabled. </p>
<dl class="section return"><dt>返回</dt><dd>true if PTDS is enabled, false otherwise. </dd></dl>

</div>
</div>
<a id="a025670a619591e80fdf972c36e625005" name="a025670a619591e80fdf972c36e625005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a025670a619591e80fdf972c36e625005">&#9670;&#160;</a></span>nullable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cudf::nullable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>view</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns True if any of the columns in the table is nullable. (not entire hierarchy) </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>The table to check for nullability </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>True if any of the columns in the table is nullable, false otherwise </dd></dl>

<p class="definition">在文件 <a class="el" href="table__view_8hpp_source.html">table_view.hpp</a> 第 <a class="el" href="table__view_8hpp_source.html#l00305">305</a> 行定义.</p>

</div>
</div>
<a id="ab3eece7be385b3be2bda53b24a48dbdc" name="ab3eece7be385b3be2bda53b24a48dbdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3eece7be385b3be2bda53b24a48dbdc">&#9670;&#160;</a></span>scatter_columns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcudf_1_1table__view.html">table_view</a> cudf::scatter_columns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy column_views from a <a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a> into another <a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a> according to a column indices map. </p>
<p>The output table view, <code>out_table</code> is a copy of the <code>target</code> <a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a> but with elements updated according to <code>out_table[map[i]] = source[i]</code> where <code>i</code> is <code>[0,source.size())</code></p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Table of new columns to scatter into the output table view. </td></tr>
    <tr><td class="paramname">map</td><td>The indices where each new_column should be copied into the output. </td></tr>
    <tr><td class="paramname">target</td><td>Table to receive the updated column views. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>New <a class="el" href="classcudf_1_1table__view.html" title="A set of cudf::column_view&#39;s of the same size.">table_view</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">变量说明</h2>
<a id="add874002afe5d4f40cb59453704712bb" name="add874002afe5d4f40cb59453704712bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add874002afe5d4f40cb59453704712bb">&#9670;&#160;</a></span>dynamic_extent</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t cudf::dynamic_extent = std::numeric_limits&lt;std::size_t&gt;::max()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A constant used to differentiate std::span of static and dynamic extent </p>

<p class="definition">在文件 <a class="el" href="span_8hpp_source.html">span.hpp</a> 第 <a class="el" href="span_8hpp_source.html#l00035">35</a> 行定义.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecudf.html">cudf</a></li>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
