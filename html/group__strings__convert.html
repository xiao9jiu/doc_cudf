<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Strings_convert</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__strings__convert.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#files">文件</a> &#124;
<a href="#func-members">函数</a>  </div>
  <div class="headertitle"><div class="title">Strings_convert</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
文件</h2></td></tr>
<tr class="memitem:convert__booleans_8hpp"><td class="memItemLeft" align="right" valign="top">文件 &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="convert__booleans_8hpp.html">convert_booleans.hpp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:convert__datetime_8hpp"><td class="memItemLeft" align="right" valign="top">文件 &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="convert__datetime_8hpp.html">convert_datetime.hpp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:convert__durations_8hpp"><td class="memItemLeft" align="right" valign="top">文件 &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="convert__durations_8hpp.html">convert_durations.hpp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:convert__fixed__point_8hpp"><td class="memItemLeft" align="right" valign="top">文件 &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="convert__fixed__point_8hpp.html">convert_fixed_point.hpp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:convert__floats_8hpp"><td class="memItemLeft" align="right" valign="top">文件 &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="convert__floats_8hpp.html">convert_floats.hpp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:convert__integers_8hpp"><td class="memItemLeft" align="right" valign="top">文件 &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="convert__integers_8hpp.html">convert_integers.hpp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:convert__ipv4_8hpp"><td class="memItemLeft" align="right" valign="top">文件 &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="convert__ipv4_8hpp.html">convert_ipv4.hpp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:convert__lists_8hpp"><td class="memItemLeft" align="right" valign="top">文件 &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="convert__lists_8hpp.html">convert_lists.hpp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:convert__urls_8hpp"><td class="memItemLeft" align="right" valign="top">文件 &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="convert__urls_8hpp.html">convert_urls.hpp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
函数</h2></td></tr>
<tr class="memitem:ga2c4cebc90897b668acf77db60ffd4b00"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#ga2c4cebc90897b668acf77db60ffd4b00">cudf::strings::to_booleans</a> (<a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;strings, <a class="el" href="classcudf_1_1string__scalar.html">string_scalar</a> const &amp;true_string=<a class="el" href="classcudf_1_1string__scalar.html">string_scalar</a>(&quot;true&quot;), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga2c4cebc90897b668acf77db60ffd4b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new BOOL8 column by parsing boolean values from the strings in the provided strings column.  <br /></td></tr>
<tr class="separator:ga2c4cebc90897b668acf77db60ffd4b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5c05d19cc3c60cbc7106286b10659fd"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#gab5c05d19cc3c60cbc7106286b10659fd">cudf::strings::from_booleans</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;booleans, <a class="el" href="classcudf_1_1string__scalar.html">string_scalar</a> const &amp;true_string=<a class="el" href="classcudf_1_1string__scalar.html">string_scalar</a>(&quot;true&quot;), <a class="el" href="classcudf_1_1string__scalar.html">string_scalar</a> const &amp;false_string=<a class="el" href="classcudf_1_1string__scalar.html">string_scalar</a>(&quot;false&quot;), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gab5c05d19cc3c60cbc7106286b10659fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new strings column converting the boolean values from the provided column into strings.  <br /></td></tr>
<tr class="separator:gab5c05d19cc3c60cbc7106286b10659fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1b3e9b08df54914309f168e7892a9b3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#gac1b3e9b08df54914309f168e7892a9b3">cudf::strings::to_timestamps</a> (<a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;strings, <a class="el" href="classcudf_1_1data__type.html">data_type</a> timestamp_type, std::string_view format, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gac1b3e9b08df54914309f168e7892a9b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new timestamp column converting a strings column into timestamps using the provided format pattern.  <br /></td></tr>
<tr class="separator:gac1b3e9b08df54914309f168e7892a9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4edf69c839f5d4cf7e135bcad00a1409"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#ga4edf69c839f5d4cf7e135bcad00a1409">cudf::strings::is_timestamp</a> (<a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;strings, std::string_view format, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga4edf69c839f5d4cf7e135bcad00a1409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies the given strings column can be parsed to timestamps using the provided format pattern.  <br /></td></tr>
<tr class="separator:ga4edf69c839f5d4cf7e135bcad00a1409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae93a174879bd65baae31e6506049ef2f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#gae93a174879bd65baae31e6506049ef2f">cudf::strings::from_timestamps</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;timestamps, std::string_view format=&quot;%Y-%m-%dT%H:%M:%SZ&quot;, <a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;names=<a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a>(<a class="el" href="classcudf_1_1column__view.html">column_view</a>{ <a class="el" href="classcudf_1_1data__type.html">data_type</a>{<a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a63b588d5559f64f89a416e656880b949">type_id::STRING</a>}, 0, nullptr}), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gae93a174879bd65baae31e6506049ef2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new strings column converting a timestamp column into strings using the provided format pattern.  <br /></td></tr>
<tr class="separator:gae93a174879bd65baae31e6506049ef2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga164923136957d72792b867347c2fa3fb"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#ga164923136957d72792b867347c2fa3fb">cudf::strings::to_durations</a> (<a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;strings, <a class="el" href="classcudf_1_1data__type.html">data_type</a> duration_type, std::string_view format, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga164923136957d72792b867347c2fa3fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new duration column converting a strings column into durations using the provided format pattern.  <br /></td></tr>
<tr class="separator:ga164923136957d72792b867347c2fa3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga550620599415065a06a7f838e4720c91"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#ga550620599415065a06a7f838e4720c91">cudf::strings::from_durations</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;durations, std::string_view format=&quot;%D days %H:%M:%S&quot;, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga550620599415065a06a7f838e4720c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new strings column converting a duration column into strings using the provided format pattern.  <br /></td></tr>
<tr class="separator:ga550620599415065a06a7f838e4720c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1764713b9062627bba68afa04dd33760"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#ga1764713b9062627bba68afa04dd33760">cudf::strings::to_fixed_point</a> (<a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;input, <a class="el" href="classcudf_1_1data__type.html">data_type</a> output_type, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga1764713b9062627bba68afa04dd33760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new fixed-point column parsing decimal values from the provided strings column.  <br /></td></tr>
<tr class="separator:ga1764713b9062627bba68afa04dd33760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab891a9f288852a9f822af87aea6ffc30"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#gab891a9f288852a9f822af87aea6ffc30">cudf::strings::from_fixed_point</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gab891a9f288852a9f822af87aea6ffc30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new strings column converting the fixed-point values into a strings column.  <br /></td></tr>
<tr class="separator:gab891a9f288852a9f822af87aea6ffc30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8b5d28ad36a8cac873c8c24c180ad88"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#gad8b5d28ad36a8cac873c8c24c180ad88">cudf::strings::is_fixed_point</a> (<a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;input, <a class="el" href="classcudf_1_1data__type.html">data_type</a> decimal_type=<a class="el" href="classcudf_1_1data__type.html">data_type</a>{<a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539ad43431506a21dcfd2ada4cd4c28f8f56">type_id::DECIMAL64</a>}, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gad8b5d28ad36a8cac873c8c24c180ad88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a boolean column identifying strings in which all characters are valid for conversion to fixed-point.  <br /></td></tr>
<tr class="separator:gad8b5d28ad36a8cac873c8c24c180ad88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d4b894db661bb540390c3f4e0820e19"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#ga2d4b894db661bb540390c3f4e0820e19">cudf::strings::to_floats</a> (<a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;strings, <a class="el" href="classcudf_1_1data__type.html">data_type</a> output_type, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga2d4b894db661bb540390c3f4e0820e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new numeric column by parsing float values from each string in the provided strings column.  <br /></td></tr>
<tr class="separator:ga2d4b894db661bb540390c3f4e0820e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b0f56def6819005020848e88c551c12"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#ga1b0f56def6819005020848e88c551c12">cudf::strings::from_floats</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;floats, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga1b0f56def6819005020848e88c551c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new strings column converting the float values from the provided column into strings.  <br /></td></tr>
<tr class="separator:ga1b0f56def6819005020848e88c551c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5544ea96e72940e4b3dd19dad63cc857"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#ga5544ea96e72940e4b3dd19dad63cc857">cudf::strings::is_float</a> (<a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;strings, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga5544ea96e72940e4b3dd19dad63cc857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a boolean column identifying strings in which all characters are valid for conversion to floats.  <br /></td></tr>
<tr class="separator:ga5544ea96e72940e4b3dd19dad63cc857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c8700a96f92c9505b68458392c116a3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#ga7c8700a96f92c9505b68458392c116a3">cudf::strings::to_integers</a> (<a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;strings, <a class="el" href="classcudf_1_1data__type.html">data_type</a> output_type, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga7c8700a96f92c9505b68458392c116a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new integer numeric column parsing integer values from the provided strings column.  <br /></td></tr>
<tr class="separator:ga7c8700a96f92c9505b68458392c116a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec26298399579eb85eff150baa189683"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#gaec26298399579eb85eff150baa189683">cudf::strings::from_integers</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;integers, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gaec26298399579eb85eff150baa189683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new strings column converting the integer values from the provided column into strings.  <br /></td></tr>
<tr class="separator:gaec26298399579eb85eff150baa189683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga524bebc3d94f11ed53fdd3977f038252"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#ga524bebc3d94f11ed53fdd3977f038252">cudf::strings::is_integer</a> (<a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;strings, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga524bebc3d94f11ed53fdd3977f038252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a boolean column identifying strings in which all characters are valid for conversion to integers.  <br /></td></tr>
<tr class="separator:ga524bebc3d94f11ed53fdd3977f038252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7dca4066a61ece7179a788a3103ebfb"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#gac7dca4066a61ece7179a788a3103ebfb">cudf::strings::is_integer</a> (<a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;strings, <a class="el" href="classcudf_1_1data__type.html">data_type</a> int_type, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gac7dca4066a61ece7179a788a3103ebfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a boolean column identifying strings in which all characters are valid for conversion to integers.  <br /></td></tr>
<tr class="separator:gac7dca4066a61ece7179a788a3103ebfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8ef01f6071190a7f2196ff418147c98"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#gab8ef01f6071190a7f2196ff418147c98">cudf::strings::hex_to_integers</a> (<a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;strings, <a class="el" href="classcudf_1_1data__type.html">data_type</a> output_type, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gab8ef01f6071190a7f2196ff418147c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new integer numeric column parsing hexadecimal values from the provided strings column.  <br /></td></tr>
<tr class="separator:gab8ef01f6071190a7f2196ff418147c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga387b620deea582d71ae2c696d4d46ffc"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#ga387b620deea582d71ae2c696d4d46ffc">cudf::strings::is_hex</a> (<a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;strings, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga387b620deea582d71ae2c696d4d46ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a boolean column identifying strings in which all characters are valid for conversion to integers from hex.  <br /></td></tr>
<tr class="separator:ga387b620deea582d71ae2c696d4d46ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad13c290ea59b3b282cfb067b8c8c38c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#gaad13c290ea59b3b282cfb067b8c8c38c">cudf::strings::integers_to_hex</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;input, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gaad13c290ea59b3b282cfb067b8c8c38c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new strings column converting integer columns to hexadecimal characters.  <br /></td></tr>
<tr class="separator:gaad13c290ea59b3b282cfb067b8c8c38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fb015fd7d0a6d51df4ea2fa2b5128c7"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#ga8fb015fd7d0a6d51df4ea2fa2b5128c7">cudf::strings::ipv4_to_integers</a> (<a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;strings, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga8fb015fd7d0a6d51df4ea2fa2b5128c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts IPv4 addresses into integers.  <br /></td></tr>
<tr class="separator:ga8fb015fd7d0a6d51df4ea2fa2b5128c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbbabbaf5bb7fc802a308c5a439f0575"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#gafbbabbaf5bb7fc802a308c5a439f0575">cudf::strings::integers_to_ipv4</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;integers, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gafbbabbaf5bb7fc802a308c5a439f0575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts integers into IPv4 addresses as strings.  <br /></td></tr>
<tr class="separator:gafbbabbaf5bb7fc802a308c5a439f0575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga054480e448c0507f91c30d7c3ea298e4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#ga054480e448c0507f91c30d7c3ea298e4">cudf::strings::is_ipv4</a> (<a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;strings, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga054480e448c0507f91c30d7c3ea298e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a boolean column identifying strings in which all characters are valid for conversion to integers from IPv4 format.  <br /></td></tr>
<tr class="separator:ga054480e448c0507f91c30d7c3ea298e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ae1bf5dea1de2f7d85c142e66c3ddd2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#ga7ae1bf5dea1de2f7d85c142e66c3ddd2">cudf::strings::format_list_column</a> (<a class="el" href="classcudf_1_1lists__column__view.html">lists_column_view</a> const &amp;input, <a class="el" href="classcudf_1_1string__scalar.html">string_scalar</a> const &amp;na_rep=<a class="el" href="classcudf_1_1string__scalar.html">string_scalar</a>(&quot;NULL&quot;), <a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;separators=<a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a>(<a class="el" href="classcudf_1_1column__view.html">column_view</a>{ <a class="el" href="classcudf_1_1data__type.html">data_type</a>{<a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a63b588d5559f64f89a416e656880b949">type_id::STRING</a>}, 0, nullptr}), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga7ae1bf5dea1de2f7d85c142e66c3ddd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a list column of strings into a formatted strings column.  <br /></td></tr>
<tr class="separator:ga7ae1bf5dea1de2f7d85c142e66c3ddd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17f40e3c3fc15a21c524371c799968b4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#ga17f40e3c3fc15a21c524371c799968b4">cudf::strings::url_encode</a> (<a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;strings, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga17f40e3c3fc15a21c524371c799968b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes each string using URL encoding.  <br /></td></tr>
<tr class="separator:ga17f40e3c3fc15a21c524371c799968b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c2883dab61684ed341b2df0391f61d5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__strings__convert.html#ga0c2883dab61684ed341b2df0391f61d5">cudf::strings::url_decode</a> (<a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;strings, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga0c2883dab61684ed341b2df0391f61d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes each string using URL encoding.  <br /></td></tr>
<tr class="separator:ga0c2883dab61684ed341b2df0391f61d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<h2 class="groupheader">函数说明</h2>
<a id="ga7ae1bf5dea1de2f7d85c142e66c3ddd2" name="ga7ae1bf5dea1de2f7d85c142e66c3ddd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ae1bf5dea1de2f7d85c142e66c3ddd2">&#9670;&#160;</a></span>format_list_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::strings::format_list_column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1lists__column__view.html">lists_column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1string__scalar.html">string_scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>na_rep</em> = <code><a class="el" href="classcudf_1_1string__scalar.html">string_scalar</a>(&quot;NULL&quot;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>separators</em> = <code><a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a>(<a class="el" href="classcudf_1_1column__view.html">column_view</a>{&#160;<a class="el" href="classcudf_1_1data__type.html">data_type</a>{<a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a63b588d5559f64f89a416e656880b949">type_id::STRING</a>},&#160;0,&#160;nullptr})</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a list column of strings into a formatted strings column. </p>
<p>The <code>separators</code> column should contain 3 strings elements in the following order:</p><ul>
<li>element separator (default is comma <code>,</code>)</li>
<li>left-hand enclosure (default is <code>[</code>)</li>
<li>right-hand enclosure (default is <code>]</code>)</li>
</ul>
<div class="fragment"><div class="line">l1 = { [[a,b,c], [d,e]], [[f,g], [h]] }</div>
<div class="line">s1 = format_list_column(l1)</div>
<div class="line">s1 is now [&quot;[[a,b,c],[d,e]]&quot;, &quot;[[f,g],[h]]&quot;]</div>
<div class="line"> </div>
<div class="line">l2 = { [[a,b,c], [d,e]], [NULL], [[f,g], NULL, [h]] }</div>
<div class="line">s2 = format_list_column(l1, &#39;-&#39;, [&#39;:&#39;, &#39;{&#39;, &#39;}&#39;])</div>
<div class="line">s2 is now [&quot;{{a:b:c}:{d:e}}&quot;, &quot;{-}&quot;, &quot;{{f:g}:-:{h}}&quot;]</div>
</div><!-- fragment --><dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if the input column is not a LIST type with a STRING child.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Lists column to format. </td></tr>
    <tr><td class="paramname">na_rep</td><td>Replacement string for null elements. </td></tr>
    <tr><td class="paramname">separators</td><td>Strings to use for enclosing list components and separating elements. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>New strings column. </dd></dl>

</div>
</div>
<a id="gab5c05d19cc3c60cbc7106286b10659fd" name="gab5c05d19cc3c60cbc7106286b10659fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5c05d19cc3c60cbc7106286b10659fd">&#9670;&#160;</a></span>from_booleans()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::strings::from_booleans </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>booleans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1string__scalar.html">string_scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>true_string</em> = <code><a class="el" href="classcudf_1_1string__scalar.html">string_scalar</a>(&quot;true&quot;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1string__scalar.html">string_scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>false_string</em> = <code><a class="el" href="classcudf_1_1string__scalar.html">string_scalar</a>(&quot;false&quot;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new strings column converting the boolean values from the provided column into strings. </p>
<p>Any null entries will result in corresponding null entries in the output column.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if the input column is not BOOL8 type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">booleans</td><td>Boolean column to convert. </td></tr>
    <tr><td class="paramname">true_string</td><td>String to use for true in the output column. </td></tr>
    <tr><td class="paramname">false_string</td><td>String to use for false in the output column. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>New strings column. </dd></dl>

</div>
</div>
<a id="ga550620599415065a06a7f838e4720c91" name="ga550620599415065a06a7f838e4720c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga550620599415065a06a7f838e4720c91">&#9670;&#160;</a></span>from_durations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::strings::from_durations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>durations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>format</em> = <code>&quot;%D&#160;days&#160;%H:%M:%S&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new strings column converting a duration column into strings using the provided format pattern. </p>
<p>The format pattern can include the following specifiers: "%%,%n,%t,%D,%H,%I,%M,%S,%p,%R,%T,%r,%OH,%OI,%OM,%OS"</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Specifier   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Range    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%%   </td><td class="markdownTableBodyNone">A literal % character   </td><td class="markdownTableBodyNone">%    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%n   </td><td class="markdownTableBodyNone">A newline character   </td><td class="markdownTableBodyNone">\n    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%t   </td><td class="markdownTableBodyNone">A horizontal tab character   </td><td class="markdownTableBodyNone">\t    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%D   </td><td class="markdownTableBodyNone">Days   </td><td class="markdownTableBodyNone">-2,147,483,648 to 2,147,483,647    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%H   </td><td class="markdownTableBodyNone">24-hour of the day   </td><td class="markdownTableBodyNone">00 to 23    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%I   </td><td class="markdownTableBodyNone">12-hour of the day   </td><td class="markdownTableBodyNone">00 to 11    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%M   </td><td class="markdownTableBodyNone">Minute of the hour   </td><td class="markdownTableBodyNone">00 to 59    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%S   </td><td class="markdownTableBodyNone">Second of the minute   </td><td class="markdownTableBodyNone">00 to 59.999999999    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%OH   </td><td class="markdownTableBodyNone">same as H but without sign   </td><td class="markdownTableBodyNone">00 to 23    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%OI   </td><td class="markdownTableBodyNone">same as I but without sign   </td><td class="markdownTableBodyNone">00 to 11    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%OM   </td><td class="markdownTableBodyNone">same as M but without sign   </td><td class="markdownTableBodyNone">00 to 59    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%OS   </td><td class="markdownTableBodyNone">same as S but without sign   </td><td class="markdownTableBodyNone">00 to 59    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%p   </td><td class="markdownTableBodyNone">AM/PM designations associated with a 12-hour clock   </td><td class="markdownTableBodyNone">'AM' or 'PM'    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%R   </td><td class="markdownTableBodyNone">Equivalent to "%H:%M"   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%T   </td><td class="markdownTableBodyNone">Equivalent to "%H:%M:%S"   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%r   </td><td class="markdownTableBodyNone">Equivalent to "%OI:%OM:%OS %p"   </td><td class="markdownTableBodyNone"></td></tr>
</table>
<p>No checking is done for invalid formats or invalid duration values. Formatting sticks to specifications of <code>std::formatter&lt;std::chrono::duration&gt;</code> as much as possible.</p>
<p>Any null input entry will result in a corresponding null entry in the output column.</p>
<p>The time units of the input column influence the number of digits in decimal of seconds. It uses 3 digits for milliseconds, 6 digits for microseconds and 9 digits for nanoseconds. If duration value is negative, only one negative sign is written to output string. The specifiers with signs are "%H,%I,%M,%S,%R,%T".</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>durations</code> column parameter is not a duration type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">durations</td><td>Duration values to convert. </td></tr>
    <tr><td class="paramname">format</td><td>The string specifying output format. Default format is ""d days H:M:S". </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>New strings column with formatted durations. </dd></dl>

</div>
</div>
<a id="gab891a9f288852a9f822af87aea6ffc30" name="gab891a9f288852a9f822af87aea6ffc30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab891a9f288852a9f822af87aea6ffc30">&#9670;&#160;</a></span>from_fixed_point()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::strings::from_fixed_point </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new strings column converting the fixed-point values into a strings column. </p>
<p>Any null entries result in corresponding null entries in the output column.</p>
<p>For each value, a string is created in base-10 decimal. Negative numbers include a '-' prefix in the output string. The column's scale value is used to place the decimal point. A negative scale value may add padded zeros after the decimal point.</p>
<div class="fragment"><div class="line">Example:</div>
<div class="line">fp is [110, 222, 3330, -440, -1] with scale = -2</div>
<div class="line">s = from_fixed_point(fp)</div>
<div class="line">s is now [&#39;1.10&#39;, &#39;2.22&#39;, &#39;33.30&#39;, &#39;-4.40&#39;, &#39;-0.01&#39;]</div>
</div><!-- fragment --><dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if the <code>input</code> column is not a fixed-point decimal type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Fixed-point column to convert. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>New strings column. </dd></dl>

</div>
</div>
<a id="ga1b0f56def6819005020848e88c551c12" name="ga1b0f56def6819005020848e88c551c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b0f56def6819005020848e88c551c12">&#9670;&#160;</a></span>from_floats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::strings::from_floats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>floats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new strings column converting the float values from the provided column into strings. </p>
<p>Any null entries will result in corresponding null entries in the output column.</p>
<p>For each float, a string is created in base-10 decimal. Negative numbers will include a '-' prefix. Numbers producing more than 10 significant digits will produce a string that includes scientific notation (e.g. "-1.78e+15").</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if floats column is not float type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">floats</td><td>Numeric column to convert. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>New strings column with floats as strings. </dd></dl>

</div>
</div>
<a id="gaec26298399579eb85eff150baa189683" name="gaec26298399579eb85eff150baa189683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec26298399579eb85eff150baa189683">&#9670;&#160;</a></span>from_integers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::strings::from_integers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>integers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new strings column converting the integer values from the provided column into strings. </p>
<p>Any null entries will result in corresponding null entries in the output column.</p>
<p>For each integer, a string is created in base-10 decimal. Negative numbers will include a '-' prefix.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if integers column is not integral type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">integers</td><td>Numeric column to convert. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>New strings column with integers as strings. </dd></dl>

</div>
</div>
<a id="gae93a174879bd65baae31e6506049ef2f" name="gae93a174879bd65baae31e6506049ef2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae93a174879bd65baae31e6506049ef2f">&#9670;&#160;</a></span>from_timestamps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::strings::from_timestamps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>timestamps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>format</em> = <code>&quot;%Y-%m-%dT%H:%M:%SZ&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>names</em> = <code><a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a>(<a class="el" href="classcudf_1_1column__view.html">column_view</a>{&#160;<a class="el" href="classcudf_1_1data__type.html">data_type</a>{<a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539a63b588d5559f64f89a416e656880b949">type_id::STRING</a>},&#160;0,&#160;nullptr})</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new strings column converting a timestamp column into strings using the provided format pattern. </p>
<p>The format pattern can include the following specifiers: "%Y,%y,%m,%d,%H,%I,%p,%M,%S,%f,%z,%Z"</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Specifier   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%d   </td><td class="markdownTableBodyNone">Day of the month: 01-31    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%m   </td><td class="markdownTableBodyNone">Month of the year: 01-12    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%y   </td><td class="markdownTableBodyNone">Year without century: 00-99    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%Y   </td><td class="markdownTableBodyNone">Year with century: 0001-9999    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%H   </td><td class="markdownTableBodyNone">24-hour of the day: 00-23    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%I   </td><td class="markdownTableBodyNone">12-hour of the day: 01-12    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%M   </td><td class="markdownTableBodyNone">Minute of the hour: 00-59    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%S   </td><td class="markdownTableBodyNone">Second of the minute: 00-59    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%f   </td><td class="markdownTableBodyNone">6-digit microsecond: 000000-999999    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%z   </td><td class="markdownTableBodyNone">Always outputs "+0000"    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%Z   </td><td class="markdownTableBodyNone">Always outputs "UTC"    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%j   </td><td class="markdownTableBodyNone">Day of the year: 001-366    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%u   </td><td class="markdownTableBodyNone">ISO weekday where Monday is 1 and Sunday is 7    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%w   </td><td class="markdownTableBodyNone">Weekday where Sunday is 0 and Saturday is 6    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%U   </td><td class="markdownTableBodyNone">Week of the year with Sunday as the first day: 00-53    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%W   </td><td class="markdownTableBodyNone">Week of the year with Monday as the first day: 00-53    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%V   </td><td class="markdownTableBodyNone">Week of the year per ISO-8601 format: 01-53    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%G   </td><td class="markdownTableBodyNone">Year based on the ISO-8601 weeks: 0000-9999    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%p   </td><td class="markdownTableBodyNone">AM/PM from <code>timestamp_names::am_str/pm_str</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%a   </td><td class="markdownTableBodyNone">Weekday abbreviation from the <code>names</code> parameter    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%A   </td><td class="markdownTableBodyNone">Weekday from the <code>names</code> parameter    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%b   </td><td class="markdownTableBodyNone">Month name abbreviation from the <code>names</code> parameter    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%B   </td><td class="markdownTableBodyNone">Month name from the <code>names</code> parameter   </td></tr>
</table>
<p>Additional descriptions can be found here: <a href="https://en.cppreference.com/w/cpp/chrono/system_clock/formatter">https://en.cppreference.com/w/cpp/chrono/system_clock/formatter</a></p>
<p>No checking is done for invalid formats or invalid timestamp values. All timestamps values are formatted to UTC.</p>
<p>Any null input entry will result in a corresponding null entry in the output column.</p>
<p>The time units of the input column do not influence the number of digits written by the "%f" specifier. The "%f" supports a precision value to write out numeric digits for the subsecond value. Specify the precision with a single integer value (1-9) between the "%" and the "f" as follows: use "%3f" for milliseconds, use "%6f" for microseconds and use "%9f" for nanoseconds. If the precision is higher than the units, then zeroes are padded to the right of the subsecond value. If the precision is lower than the units, the subsecond value may be truncated.</p>
<p>If the "%a", "%A", "%b", "%B" specifiers are included in the format, the caller should provide the format names in the <code>names</code> strings column using the following as a guide:</p>
<div class="fragment"><div class="line">[&quot;AM&quot;, &quot;PM&quot;,                             // specify the AM/PM strings</div>
<div class="line"> &quot;Sunday&quot;, &quot;Monday&quot;, ..., &quot;Saturday&quot;,    // Weekday full names</div>
<div class="line"> &quot;Sun&quot;, &quot;Mon&quot;, ..., &quot;Sat&quot;,               // Weekday abbreviated names</div>
<div class="line"> &quot;January&quot;, &quot;February&quot;, ..., &quot;December&quot;, // Month full names</div>
<div class="line"> &quot;Jan&quot;, &quot;Feb&quot;, ..., &quot;Dec&quot;]               // Month abbreviated names</div>
</div><!-- fragment --><p>The result is undefined if the format names are not provided for these specifiers.</p>
<p>These format names can be retrieved for specific locales using the <code>nl_langinfo</code> functions from C++ <code>clocale</code> (std) library or the Python <code>locale</code> library.</p>
<p>The following code is an example of retrieving these strings from the locale using c++ std functions:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;clocale&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;langinfo.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// note: install language pack on Ubuntu using &#39;apt-get install language-pack-de&#39;</span></div>
<div class="line">{</div>
<div class="line">  <span class="comment">// set to a German language locale for date settings</span></div>
<div class="line">  std::setlocale(LC_TIME, <span class="stringliteral">&quot;de_DE.UTF-8&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;std::string&gt; names({nl_langinfo(AM_STR), nl_langinfo(PM_STR),</div>
<div class="line">    nl_langinfo(DAY_1), nl_langinfo(DAY_2), nl_langinfo(DAY_3), nl_langinfo(DAY_4),</div>
<div class="line">     nl_langinfo(DAY_5), nl_langinfo(DAY_6), nl_langinfo(DAY_7),</div>
<div class="line">    nl_langinfo(ABDAY_1), nl_langinfo(ABDAY_2), nl_langinfo(ABDAY_3), nl_langinfo(ABDAY_4),</div>
<div class="line">     nl_langinfo(ABDAY_5), nl_langinfo(ABDAY_6), nl_langinfo(ABDAY_7),</div>
<div class="line">    nl_langinfo(MON_1), nl_langinfo(MON_2), nl_langinfo(MON_3), nl_langinfo(MON_4),</div>
<div class="line">     nl_langinfo(MON_5), nl_langinfo(MON_6), nl_langinfo(MON_7), nl_langinfo(MON_8),</div>
<div class="line">     nl_langinfo(MON_9), nl_langinfo(MON_10), nl_langinfo(MON_11), nl_langinfo(MON_12),</div>
<div class="line">    nl_langinfo(ABMON_1), nl_langinfo(ABMON_2), nl_langinfo(ABMON_3), nl_langinfo(ABMON_4),</div>
<div class="line">     nl_langinfo(ABMON_5), nl_langinfo(ABMON_6), nl_langinfo(ABMON_7), nl_langinfo(ABMON_8),</div>
<div class="line">     nl_langinfo(ABMON_9), nl_langinfo(ABMON_10), nl_langinfo(ABMON_11), nl_langinfo(ABMON_12)});</div>
<div class="line"> </div>
<div class="line">  std::setlocale(LC_TIME,<span class="stringliteral">&quot;&quot;</span>); <span class="comment">// reset to default locale</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>timestamps</code> column parameter is not a timestamp type. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if the <code>format</code> string is empty </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>names.size()</code> is an invalid size. Must be 0 or 40 strings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">timestamps</td><td>Timestamp values to convert. </td></tr>
    <tr><td class="paramname">format</td><td>The string specifying output format. Default format is "%Y-%m-%dT%H:%M:%SZ". </td></tr>
    <tr><td class="paramname">names</td><td>The string names to use for weekdays ("%a", "%A") and months ("%b", "%B") Default is an empty <code><a class="el" href="classcudf_1_1strings__column__view.html" title="Given a column-view of strings type, an instance of this class provides a wrapper on this compound co...">strings_column_view</a></code>. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>New strings column with formatted timestamps. </dd></dl>

</div>
</div>
<a id="gab8ef01f6071190a7f2196ff418147c98" name="gab8ef01f6071190a7f2196ff418147c98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8ef01f6071190a7f2196ff418147c98">&#9670;&#160;</a></span>hex_to_integers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::strings::hex_to_integers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>output_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new integer numeric column parsing hexadecimal values from the provided strings column. </p>
<p>Any null entries will result in corresponding null entries in the output column.</p>
<p>Only characters [0-9] and [A-F] are recognized. When any other character is encountered, the parsing ends for that string. No interpretation is made on the sign of the integer.</p>
<p>Overflow of the resulting integer type is not checked. Each string is converted using an int64 type and then cast to the target integer type before storing it into the output column. If the resulting integer type is too small to hold the value, the stored value will be undefined.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if output_type is not integral type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">strings</td><td>Strings instance for this operation. </td></tr>
    <tr><td class="paramname">output_type</td><td>Type of integer numeric column to return. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>New column with integers converted from strings. </dd></dl>

</div>
</div>
<a id="gaad13c290ea59b3b282cfb067b8c8c38c" name="gaad13c290ea59b3b282cfb067b8c8c38c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad13c290ea59b3b282cfb067b8c8c38c">&#9670;&#160;</a></span>integers_to_hex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::strings::integers_to_hex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new strings column converting integer columns to hexadecimal characters. </p>
<p>Any null entries will result in corresponding null entries in the output column.</p>
<p>The output character set is '0'-'9' and 'A'-'F'. The output string width will be a multiple of 2 depending on the size of the integer type. A single leading zero is applied to the first non-zero output byte if it less than 0x10.</p>
<div class="fragment"><div class="line">Example:</div>
<div class="line">input = [123, -1, 0, 27, 342718233] // int32 type input column</div>
<div class="line">s = integers_to_hex(input)</div>
<div class="line">s is [ &#39;04D2&#39;, &#39;FFFFFFFF&#39;, &#39;00&#39;, &#39;1B&#39;, &#39;146D7719&#39;]</div>
</div><!-- fragment --><p>The example above shows an <code>INT32</code> type column where each integer is 4 bytes. Leading zeros are suppressed unless filling out a complete byte as in &lsquo;123 -&gt; '04D2&rsquo;<code>instead of</code>000004D2<code>or</code>4D2`.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if the input column is not integral type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Integer column to convert to hex. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>New strings column with hexadecimal characters. </dd></dl>

</div>
</div>
<a id="gafbbabbaf5bb7fc802a308c5a439f0575" name="gafbbabbaf5bb7fc802a308c5a439f0575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbbabbaf5bb7fc802a308c5a439f0575">&#9670;&#160;</a></span>integers_to_ipv4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::strings::integers_to_ipv4 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>integers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts integers into IPv4 addresses as strings. </p>
<p>The IPv4 format is 1-3 character digits [0-9] between 3 dots (e.g. 123.45.67.890). Each section can have a value between [0-255].</p>
<p>Each input integer is dissected into four integers by dividing the input into 8-bit sections. These sub-integers are then converted into [0-9] characters and placed between '.' characters.</p>
<p>No checking is done on the input integer value. Only the lower 32-bits are used.</p>
<p>Any null entries will result in corresponding null entries in the output column.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if the input column is not INT64 type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">integers</td><td>Integer (INT64) column to convert. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>New strings column. </dd></dl>

</div>
</div>
<a id="ga8fb015fd7d0a6d51df4ea2fa2b5128c7" name="ga8fb015fd7d0a6d51df4ea2fa2b5128c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fb015fd7d0a6d51df4ea2fa2b5128c7">&#9670;&#160;</a></span>ipv4_to_integers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::strings::ipv4_to_integers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts IPv4 addresses into integers. </p>
<p>The IPv4 format is 1-3 character digits [0-9] between 3 dots (e.g. 123.45.67.890). Each section can have a value between [0-255].</p>
<p>The four sets of digits are converted to integers and placed in 8-bit fields inside the resulting integer. </p><div class="fragment"><div class="line">i0.i1.i2.i3 -&gt; (i0 &lt;&lt; 24) | (i1 &lt;&lt; 16) | (i2 &lt;&lt; 8) | (i3)</div>
</div><!-- fragment --><p>No checking is done on the format. If a string is not in IPv4 format, the resulting integer is undefined.</p>
<p>The resulting 32-bit integer is placed in an int64_t to avoid setting the sign-bit in an int32_t type. This could be changed if cudf supported a UINT32 type in the future.</p>
<p>Any null entries will result in corresponding null entries in the output column.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">strings</td><td>Strings instance for this operation. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>New INT64 column converted from strings. </dd></dl>

</div>
</div>
<a id="gad8b5d28ad36a8cac873c8c24c180ad88" name="gad8b5d28ad36a8cac873c8c24c180ad88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8b5d28ad36a8cac873c8c24c180ad88">&#9670;&#160;</a></span>is_fixed_point()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::strings::is_fixed_point </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>decimal_type</em> = <code><a class="el" href="classcudf_1_1data__type.html">data_type</a>{<a class="el" href="group__utility__types.html#ggadf077607da617d1dadcc5417e2783539ad43431506a21dcfd2ada4cd4c28f8f56">type_id::DECIMAL64</a>}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a boolean column identifying strings in which all characters are valid for conversion to fixed-point. </p>
<p>The sign and the exponent is optional. The decimal point may only appear once. Also, the integer component must fit within the size limits of the underlying fixed-point storage type. The value of the integer component is based on the scale of the <code>decimal_type</code> provided.</p>
<div class="fragment"><div class="line">Example:</div>
<div class="line">s = [&#39;123&#39;, &#39;-456&#39;, &#39;&#39;, &#39;1.2.3&#39;, &#39;+17E30&#39;, &#39;12.34&#39;, &#39;.789&#39;, &#39;-0.005]</div>
<div class="line">b = is_fixed_point(s)</div>
<div class="line">b is [true, true, false, false, true, true, true, true]</div>
</div><!-- fragment --><p>Any null entries result in corresponding null entries in the output column.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if the <code>decimal_type</code> is not a fixed-point decimal type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Strings instance for this operation. </td></tr>
    <tr><td class="paramname">decimal_type</td><td>Fixed-point type (with scale) used only for checking overflow. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>New column of boolean results for each string. </dd></dl>

</div>
</div>
<a id="ga5544ea96e72940e4b3dd19dad63cc857" name="ga5544ea96e72940e4b3dd19dad63cc857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5544ea96e72940e4b3dd19dad63cc857">&#9670;&#160;</a></span>is_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::strings::is_float </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a boolean column identifying strings in which all characters are valid for conversion to floats. </p>
<p>The output row entry will be set to <code>true</code> if the corresponding string element has at least one character in [-+0-9eE.].</p>
<div class="fragment"><div class="line">Example:</div>
<div class="line">s = [&#39;123&#39;, &#39;-456&#39;, &#39;&#39;, &#39;A&#39;, &#39;+7&#39;, &#39;8.9&#39; &#39;3.7e+5&#39;]</div>
<div class="line">b = s.is_float(s)</div>
<div class="line">b is [true, true, false, false, true, true, true]</div>
</div><!-- fragment --><p>Any null row results in a null entry for that row in the output column.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">strings</td><td>Strings instance for this operation. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>New column of boolean results for each string. </dd></dl>

</div>
</div>
<a id="ga387b620deea582d71ae2c696d4d46ffc" name="ga387b620deea582d71ae2c696d4d46ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga387b620deea582d71ae2c696d4d46ffc">&#9670;&#160;</a></span>is_hex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::strings::is_hex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a boolean column identifying strings in which all characters are valid for conversion to integers from hex. </p>
<p>The output row entry will be set to <code>true</code> if the corresponding string element has at least one character in [0-9A-Za-z]. Also, the string may start with '0x'.</p>
<div class="fragment"><div class="line">Example:</div>
<div class="line">s = [&#39;123&#39;, &#39;-456&#39;, &#39;&#39;, &#39;AGE&#39;, &#39;+17EA&#39;, &#39;0x9EF&#39; &#39;123ABC&#39;]</div>
<div class="line">b = is_hex(s)</div>
<div class="line">b is [true, false, false, false, false, true, true]</div>
</div><!-- fragment --><p>Any null row results in a null entry for that row in the output column.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">strings</td><td>Strings instance for this operation. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>New column of boolean results for each string. </dd></dl>

</div>
</div>
<a id="gac7dca4066a61ece7179a788a3103ebfb" name="gac7dca4066a61ece7179a788a3103ebfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7dca4066a61ece7179a788a3103ebfb">&#9670;&#160;</a></span>is_integer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::strings::is_integer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>int_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a boolean column identifying strings in which all characters are valid for conversion to integers. </p>
<p>The output row entry will be set to <code>true</code> if the corresponding string element has all characters in [-+0-9]. The optional sign character must only be in the first position. Also, the integer component must fit within the size limits of the underlying storage type, which is provided by the int_type parameter.</p>
<div class="fragment"><div class="line">Example:</div>
<div class="line">s = [&#39;123456&#39;, &#39;-456&#39;, &#39;&#39;, &#39;A&#39;, &#39;+7&#39;]</div>
<div class="line"> </div>
<div class="line">output1 = s.is_integer(s, data_type{type_id::INT32})</div>
<div class="line">output1 is [true, true, false, false, true]</div>
<div class="line"> </div>
<div class="line">output2 = s.is_integer(s, data_type{type_id::INT8})</div>
<div class="line">output2 is [false, false, false, false, true]</div>
</div><!-- fragment --><p>Any null row results in a null entry for that row in the output column.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">strings</td><td>Strings instance for this operation. </td></tr>
    <tr><td class="paramname">int_type</td><td>Integer type used for checking underflow and overflow. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>New column of boolean results for each string. </dd></dl>

</div>
</div>
<a id="ga524bebc3d94f11ed53fdd3977f038252" name="ga524bebc3d94f11ed53fdd3977f038252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga524bebc3d94f11ed53fdd3977f038252">&#9670;&#160;</a></span>is_integer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::strings::is_integer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a boolean column identifying strings in which all characters are valid for conversion to integers. </p>
<p>The output row entry will be set to <code>true</code> if the corresponding string element have all characters in [-+0-9]. The optional sign character must only be in the first position. Notice that the the integer value is not checked to be within its storage limits. For strict integer type check, use the other <code><a class="el" href="group__strings__convert.html#ga524bebc3d94f11ed53fdd3977f038252" title="Returns a boolean column identifying strings in which all characters are valid for conversion to inte...">is_integer()</a></code> API which accepts <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> argument.</p>
<div class="fragment"><div class="line">Example:</div>
<div class="line">s = [&#39;123&#39;, &#39;-456&#39;, &#39;&#39;, &#39;A&#39;, &#39;+7&#39;]</div>
<div class="line">b = s.is_integer(s)</div>
<div class="line">b is [true, true, false, false, true]</div>
</div><!-- fragment --><p>Any null row results in a null entry for that row in the output column.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">strings</td><td>Strings instance for this operation. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>New column of boolean results for each string. </dd></dl>

</div>
</div>
<a id="ga054480e448c0507f91c30d7c3ea298e4" name="ga054480e448c0507f91c30d7c3ea298e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga054480e448c0507f91c30d7c3ea298e4">&#9670;&#160;</a></span>is_ipv4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::strings::is_ipv4 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a boolean column identifying strings in which all characters are valid for conversion to integers from IPv4 format. </p>
<p>The output row entry will be set to <code>true</code> if the corresponding string element has the following format <code>xxx.xxx.xxx.xxx</code> where <code>xxx</code> is integer digits between 0-255.</p>
<div class="fragment"><div class="line">Example:</div>
<div class="line">s = [&#39;123.255.0.7&#39;, &#39;127.0.0.1&#39;, &#39;&#39;, &#39;1.2.34&#39; &#39;123.456.789.10&#39;]</div>
<div class="line">b = s.is_ipv4(s)</div>
<div class="line">b is [true, true, false, false, true]</div>
</div><!-- fragment --><p>Any null row results in a null entry for that row in the output column.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">strings</td><td>Strings instance for this operation. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>New column of boolean results for each string. </dd></dl>

</div>
</div>
<a id="ga4edf69c839f5d4cf7e135bcad00a1409" name="ga4edf69c839f5d4cf7e135bcad00a1409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4edf69c839f5d4cf7e135bcad00a1409">&#9670;&#160;</a></span>is_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::strings::is_timestamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies the given strings column can be parsed to timestamps using the provided format pattern. </p>
<p>The format pattern can include the following specifiers: "%Y,%y,%m,%d,%H,%I,%p,%M,%S,%f,%z"</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Specifier   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%d   </td><td class="markdownTableBodyNone">Day of the month: 01-31    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%m   </td><td class="markdownTableBodyNone">Month of the year: 01-12    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%y   </td><td class="markdownTableBodyNone">Year without century: 00-99. [0,68] maps to [2000,2068] and [69,99] maps to [1969,1999]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%Y   </td><td class="markdownTableBodyNone">Year with century: 0001-9999    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%H   </td><td class="markdownTableBodyNone">24-hour of the day: 00-23    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%I   </td><td class="markdownTableBodyNone">12-hour of the day: 01-12    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%M   </td><td class="markdownTableBodyNone">Minute of the hour: 00-59    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%S   </td><td class="markdownTableBodyNone">Second of the minute: 00-59. Leap second is not supported.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%f   </td><td class="markdownTableBodyNone">6-digit microsecond: 000000-999999    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%z   </td><td class="markdownTableBodyNone">UTC offset with format ±HHMM Example +0500    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%j   </td><td class="markdownTableBodyNone">Day of the year: 001-366    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%p   </td><td class="markdownTableBodyNone">Only 'AM', 'PM' or 'am', 'pm' are recognized   </td></tr>
</table>
<p>Other specifiers are not currently supported. The "%f" supports a precision value to read the numeric digits. Specify the precision with a single integer value (1-9) as follows: use "%3f" for milliseconds, "%6f" for microseconds and "%9f" for nanoseconds.</p>
<p>Any null string entry will result in a corresponding null row in the output column.</p>
<p>This will return a column of type BOOL8 where a <code>true</code> row indicates the corresponding input string can be parsed correctly with the given format.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">strings</td><td>Strings instance for this operation. </td></tr>
    <tr><td class="paramname">format</td><td>String specifying the timestamp format in strings. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>New BOOL8 column. </dd></dl>

</div>
</div>
<a id="ga2c4cebc90897b668acf77db60ffd4b00" name="ga2c4cebc90897b668acf77db60ffd4b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c4cebc90897b668acf77db60ffd4b00">&#9670;&#160;</a></span>to_booleans()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::strings::to_booleans </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1string__scalar.html">string_scalar</a> const &amp;&#160;</td>
          <td class="paramname"><em>true_string</em> = <code><a class="el" href="classcudf_1_1string__scalar.html">string_scalar</a>(&quot;true&quot;)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new BOOL8 column by parsing boolean values from the strings in the provided strings column. </p>
<p>Any null entries will result in corresponding null entries in the output column.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">strings</td><td>Strings instance for this operation. </td></tr>
    <tr><td class="paramname">true_string</td><td>String to expect for true. Non-matching strings are false. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>New BOOL8 column converted from strings. </dd></dl>

</div>
</div>
<a id="ga164923136957d72792b867347c2fa3fb" name="ga164923136957d72792b867347c2fa3fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga164923136957d72792b867347c2fa3fb">&#9670;&#160;</a></span>to_durations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::strings::to_durations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>duration_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new duration column converting a strings column into durations using the provided format pattern. </p>
<p>The format pattern can include the following specifiers: "%%,%n,%t,%D,%H,%I,%M,%S,%p,%R,%T,%r,%OH,%OI,%OM,%OS"</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Specifier   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Range    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%%   </td><td class="markdownTableBodyNone">A literal % character   </td><td class="markdownTableBodyNone">%    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%n   </td><td class="markdownTableBodyNone">A newline character   </td><td class="markdownTableBodyNone">\n    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%t   </td><td class="markdownTableBodyNone">A horizontal tab character   </td><td class="markdownTableBodyNone">\t    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%D   </td><td class="markdownTableBodyNone">Days   </td><td class="markdownTableBodyNone">-2,147,483,648 to 2,147,483,647    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%H   </td><td class="markdownTableBodyNone">24-hour of the day   </td><td class="markdownTableBodyNone">00 to 23    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%I   </td><td class="markdownTableBodyNone">12-hour of the day   </td><td class="markdownTableBodyNone">00 to 11    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%M   </td><td class="markdownTableBodyNone">Minute of the hour   </td><td class="markdownTableBodyNone">00 to 59    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%S   </td><td class="markdownTableBodyNone">Second of the minute   </td><td class="markdownTableBodyNone">00 to 59.999999999    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%OH   </td><td class="markdownTableBodyNone">same as H but without sign   </td><td class="markdownTableBodyNone">00 to 23    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%OI   </td><td class="markdownTableBodyNone">same as I but without sign   </td><td class="markdownTableBodyNone">00 to 11    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%OM   </td><td class="markdownTableBodyNone">same as M but without sign   </td><td class="markdownTableBodyNone">00 to 59    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%OS   </td><td class="markdownTableBodyNone">same as S but without sign   </td><td class="markdownTableBodyNone">00 to 59    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%p   </td><td class="markdownTableBodyNone">AM/PM designations associated with a 12-hour clock   </td><td class="markdownTableBodyNone">'AM' or 'PM'    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%R   </td><td class="markdownTableBodyNone">Equivalent to "%H:%M"   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%T   </td><td class="markdownTableBodyNone">Equivalent to "%H:%M:%S"   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%r   </td><td class="markdownTableBodyNone">Equivalent to "%OI:%OM:%OS %p"   </td><td class="markdownTableBodyNone"></td></tr>
</table>
<p>Other specifiers are not currently supported.</p>
<p>Invalid formats are not checked. If the string contains unexpected or insufficient characters, that output row entry's duration value is undefined.</p>
<p>Any null string entry will result in a corresponding null row in the output column.</p>
<p>The resulting time units are specified by the <code>duration_type</code> parameter.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if duration_type is not a duration type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">strings</td><td>Strings instance for this operation. </td></tr>
    <tr><td class="paramname">duration_type</td><td>The duration type used for creating the output column. </td></tr>
    <tr><td class="paramname">format</td><td>String specifying the duration format in strings. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>New duration column. </dd></dl>

</div>
</div>
<a id="ga1764713b9062627bba68afa04dd33760" name="ga1764713b9062627bba68afa04dd33760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1764713b9062627bba68afa04dd33760">&#9670;&#160;</a></span>to_fixed_point()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::strings::to_fixed_point </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>output_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new fixed-point column parsing decimal values from the provided strings column. </p>
<p>Any null entries result in corresponding null entries in the output column.</p>
<p>The expected format is <code>[sign][integer][.][fraction]</code>, where the sign is either not present, <code>-</code> or <code>+</code>, The decimal point <code>[.]</code> may or may not be present, and <code>integer</code> and <code>fraction</code> are comprised of zero or more digits in [0-9]. An invalid data format results in undefined behavior in the corresponding output row result.</p>
<div class="fragment"><div class="line">Example:</div>
<div class="line">s = [&#39;123&#39;, &#39;-876&#39;, &#39;543.2&#39;, &#39;-0.12&#39;]</div>
<div class="line">datatype = {DECIMAL32, scale=-2}</div>
<div class="line">fp = to_fixed_point(s, datatype)</div>
<div class="line">fp is [123400, -87600, 54320, -12]</div>
</div><!-- fragment --><p>Overflow of the resulting value type is not checked. The scale in the <code>output_type</code> is used for setting the integer component.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>output_type</code> is not a fixed-point decimal type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Strings instance for this operation. </td></tr>
    <tr><td class="paramname">output_type</td><td>Type of fixed-point column to return including the scale value. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>New column of <code>output_type</code>. </dd></dl>

</div>
</div>
<a id="ga2d4b894db661bb540390c3f4e0820e19" name="ga2d4b894db661bb540390c3f4e0820e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d4b894db661bb540390c3f4e0820e19">&#9670;&#160;</a></span>to_floats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::strings::to_floats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>output_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new numeric column by parsing float values from each string in the provided strings column. </p>
<p>Any null entries will result in corresponding null entries in the output column.</p>
<p>Only characters [0-9] plus a prefix '-' and '+' and decimal '.' are recognized. Additionally, scientific notation is also supported (e.g. "-1.78e+5").</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if output_type is not float type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">strings</td><td>Strings instance for this operation. </td></tr>
    <tr><td class="paramname">output_type</td><td>Type of float numeric column to return. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>New column with floats converted from strings. </dd></dl>

</div>
</div>
<a id="ga7c8700a96f92c9505b68458392c116a3" name="ga7c8700a96f92c9505b68458392c116a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c8700a96f92c9505b68458392c116a3">&#9670;&#160;</a></span>to_integers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::strings::to_integers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>output_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new integer numeric column parsing integer values from the provided strings column. </p>
<p>Any null entries will result in corresponding null entries in the output column.</p>
<p>Only characters [0-9] plus a prefix '-' and '+' are recognized. When any other character is encountered, the parsing ends for that string and the current digits are converted into an integer.</p>
<p>Overflow of the resulting integer type is not checked. Each string is converted using an int64 type and then cast to the target integer type before storing it into the output column. If the resulting integer type is too small to hold the value, the stored value will be undefined.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if output_type is not integral type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">strings</td><td>Strings instance for this operation. </td></tr>
    <tr><td class="paramname">output_type</td><td>Type of integer numeric column to return. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>New column with integers converted from strings. </dd></dl>

</div>
</div>
<a id="gac1b3e9b08df54914309f168e7892a9b3" name="gac1b3e9b08df54914309f168e7892a9b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1b3e9b08df54914309f168e7892a9b3">&#9670;&#160;</a></span>to_timestamps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::strings::to_timestamps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a>&#160;</td>
          <td class="paramname"><em>timestamp_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new timestamp column converting a strings column into timestamps using the provided format pattern. </p>
<p>The format pattern can include the following specifiers: "%Y,%y,%m,%d,%H,%I,%p,%M,%S,%f,%z"</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Specifier   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%d   </td><td class="markdownTableBodyNone">Day of the month: 01-31    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%m   </td><td class="markdownTableBodyNone">Month of the year: 01-12    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%y   </td><td class="markdownTableBodyNone">Year without century: 00-99. [0,68] maps to [2000,2068] and [69,99] maps to [1969,1999]    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%Y   </td><td class="markdownTableBodyNone">Year with century: 0001-9999    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%H   </td><td class="markdownTableBodyNone">24-hour of the day: 00-23    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%I   </td><td class="markdownTableBodyNone">12-hour of the day: 01-12    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%M   </td><td class="markdownTableBodyNone">Minute of the hour: 00-59    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%S   </td><td class="markdownTableBodyNone">Second of the minute: 00-59. Leap second is not supported.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%f   </td><td class="markdownTableBodyNone">6-digit microsecond: 000000-999999    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%z   </td><td class="markdownTableBodyNone">UTC offset with format ±HHMM Example +0500    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">%j   </td><td class="markdownTableBodyNone">Day of the year: 001-366    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">%p   </td><td class="markdownTableBodyNone">Only 'AM', 'PM' or 'am', 'pm' are recognized   </td></tr>
</table>
<p>Other specifiers are not currently supported.</p>
<p>Invalid formats are not checked. If the string contains unexpected or insufficient characters, that output row entry's timestamp value is undefined.</p>
<p>Any null string entry will result in a corresponding null row in the output column.</p>
<p>The resulting time units are specified by the <code>timestamp_type</code> parameter. The time units are independent of the number of digits parsed by the "%f" specifier. The "%f" supports a precision value to read the numeric digits. Specify the precision with a single integer value (1-9) as follows: use "%3f" for milliseconds, "%6f" for microseconds and "%9f" for nanoseconds.</p>
<p>Although leap second is not supported for "%S", no checking is performed on the value. The <a class="el" href="group__strings__convert.html#ga4edf69c839f5d4cf7e135bcad00a1409" title="Verifies the given strings column can be parsed to timestamps using the provided format pattern.">cudf::strings::is_timestamp</a> can be used to verify the valid range of values.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if timestamp_type is not a timestamp type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">strings</td><td>Strings instance for this operation. </td></tr>
    <tr><td class="paramname">timestamp_type</td><td>The timestamp type used for creating the output column. </td></tr>
    <tr><td class="paramname">format</td><td>String specifying the timestamp format in strings. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>New datetime column. </dd></dl>

</div>
</div>
<a id="ga0c2883dab61684ed341b2df0391f61d5" name="ga0c2883dab61684ed341b2df0391f61d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c2883dab61684ed341b2df0391f61d5">&#9670;&#160;</a></span>url_decode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::strings::url_decode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes each string using URL encoding. </p>
<p>Converts all character sequences starting with '' into character code-points interpreting the 2 following characters as hex values to create the code-point. For example, the sequence '%20' is converted into byte (0x20) which is a single space character. Another example converts 'C3A9' into 2 sequential bytes (0xc3 and 0xa9 respectively) which is the é character. Overall, 3 characters are converted into one char byte whenever a '%' (single percent) character is encountered in the string.</p>
<p>Any null entries will result in corresponding null entries in the output column.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">strings</td><td>Strings instance for this operation. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>New strings column. </dd></dl>

</div>
</div>
<a id="ga17f40e3c3fc15a21c524371c799968b4" name="ga17f40e3c3fc15a21c524371c799968b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17f40e3c3fc15a21c524371c799968b4">&#9670;&#160;</a></span>url_encode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; cudf::strings::url_encode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">strings_column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes each string using URL encoding. </p>
<p>Converts mostly non-ascii characters and control characters into UTF-8 hex code-points prefixed with ''. For example, the space character must be converted to characters '%20' where the '20' indicates the hex value for space in UTF-8. Likewise, multi-byte characters are converted to multiple hex characters. For example, the é character is converted to characters 'C3A9' where 'C3A9' is the UTF-8 bytes 0xC3A9 for this character.</p>
<p>Any null entries will result in corresponding null entries in the output column.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">strings</td><td>Strings instance for this operation. </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>New strings column. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
