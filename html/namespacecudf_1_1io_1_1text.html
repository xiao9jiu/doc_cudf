<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: cudf::io::text 命名空间参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacecudf_1_1io_1_1text.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">命名空间</a> &#124;
<a href="#nested-classes">类</a> &#124;
<a href="#func-members">函数</a>  </div>
  <div class="headertitle"><div class="title">cudf::io::text 命名空间参考</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
命名空间</h2></td></tr>
<tr class="memitem:namespacecudf_1_1io_1_1text_1_1detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1io_1_1text_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
类</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1io_1_1text_1_1byte__range__info.html">byte_range_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores offset and size used to indicate a byte range  <a href="classcudf_1_1io_1_1text_1_1byte__range__info.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1io_1_1text_1_1data__chunk__reader.html">data_chunk_reader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a reader capable of producing views over device memory.  <a href="classcudf_1_1io_1_1text_1_1data__chunk__reader.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1io_1_1text_1_1data__chunk__source.html">data_chunk_source</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a data source capable of creating a reader which can produce views of the data source in device memory.  <a href="classcudf_1_1io_1_1text_1_1data__chunk__source.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1io_1_1text_1_1device__data__chunk.html">device_data_chunk</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A contract guaranteeing stream-ordered memory access to the underlying device data.  <a href="classcudf_1_1io_1_1text_1_1device__data__chunk.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1io_1_1text_1_1parse__options.html">parse_options</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parsing options for multibyte_split.  <a href="structcudf_1_1io_1_1text_1_1parse__options.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
函数</h2></td></tr>
<tr class="memitem:a61eadbadb306fc95d06dd5a6523795f3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcudf_1_1io_1_1text_1_1byte__range__info.html">byte_range_info</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1io_1_1text.html#a61eadbadb306fc95d06dd5a6523795f3">create_byte_range_infos_consecutive</a> (int64_t total_bytes, int64_t range_count)</td></tr>
<tr class="memdesc:a61eadbadb306fc95d06dd5a6523795f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a collection of consecutive ranges between [0, total_bytes).  <br /></td></tr>
<tr class="separator:a61eadbadb306fc95d06dd5a6523795f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534362ac41ba4f410486d91262d114d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcudf_1_1io_1_1text_1_1byte__range__info.html">byte_range_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1io_1_1text.html#a534362ac41ba4f410486d91262d114d5">create_byte_range_info_max</a> ()</td></tr>
<tr class="memdesc:a534362ac41ba4f410486d91262d114d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classcudf_1_1io_1_1text_1_1byte__range__info.html" title="stores offset and size used to indicate a byte range">byte_range_info</a> which represents as much of a file as possible. Specifically, <code>[0, numeric_limit&lt;int64_t&gt;::max())</code>.  <br /></td></tr>
<tr class="separator:a534362ac41ba4f410486d91262d114d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba50e0c2d4e39e174b8162809296770"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1io_1_1text_1_1data__chunk__source.html">data_chunk_source</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1io_1_1text.html#abba50e0c2d4e39e174b8162809296770">make_source</a> (<a class="el" href="classcudf_1_1io_1_1datasource.html">datasource</a> &amp;data)</td></tr>
<tr class="memdesc:abba50e0c2d4e39e174b8162809296770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a data source capable of producing device-buffered views of a datasource.  <br /></td></tr>
<tr class="separator:abba50e0c2d4e39e174b8162809296770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0867986f8e44a8a7985fb8b84ffe60a0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1io_1_1text_1_1data__chunk__source.html">data_chunk_source</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1io_1_1text.html#a0867986f8e44a8a7985fb8b84ffe60a0">make_source</a> (<a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; const char &gt; data)</td></tr>
<tr class="memdesc:a0867986f8e44a8a7985fb8b84ffe60a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a data source capable of producing device-buffered views of the given string.  <br /></td></tr>
<tr class="separator:a0867986f8e44a8a7985fb8b84ffe60a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a18f59fc05517b2a2388e7c87a81472"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1io_1_1text_1_1data__chunk__source.html">data_chunk_source</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1io_1_1text.html#a3a18f59fc05517b2a2388e7c87a81472">make_source_from_file</a> (std::string_view filename)</td></tr>
<tr class="memdesc:a3a18f59fc05517b2a2388e7c87a81472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a data source capable of producing device-buffered views of the file  <br /></td></tr>
<tr class="separator:a3a18f59fc05517b2a2388e7c87a81472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc32043b226cfe3559336297b32e8198"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1io_1_1text_1_1data__chunk__source.html">data_chunk_source</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1io_1_1text.html#afc32043b226cfe3559336297b32e8198">make_source_from_bgzip_file</a> (std::string_view filename)</td></tr>
<tr class="memdesc:afc32043b226cfe3559336297b32e8198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a data source capable of producing device-buffered views of a BGZIP compressed file.  <br /></td></tr>
<tr class="separator:afc32043b226cfe3559336297b32e8198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a25f9a49bdbff493d03f996673ff52"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1io_1_1text_1_1data__chunk__source.html">data_chunk_source</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1io_1_1text.html#a96a25f9a49bdbff493d03f996673ff52">make_source_from_bgzip_file</a> (std::string_view filename, uint64_t virtual_begin, uint64_t virtual_end)</td></tr>
<tr class="memdesc:a96a25f9a49bdbff493d03f996673ff52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a data source capable of producing device-buffered views of a BGZIP compressed file with virtual record offsets.  <br /></td></tr>
<tr class="separator:a96a25f9a49bdbff493d03f996673ff52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56971648285aae182cccf90634b899d4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1io_1_1text_1_1data__chunk__source.html">data_chunk_source</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1io_1_1text.html#a56971648285aae182cccf90634b899d4">make_source</a> (<a class="el" href="classcudf_1_1string__scalar.html">cudf::string_scalar</a> &amp;data)</td></tr>
<tr class="memdesc:a56971648285aae182cccf90634b899d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a data source capable of producing views of the given device string scalar  <br /></td></tr>
<tr class="separator:a56971648285aae182cccf90634b899d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08835f7c12bd074240a5f5f7c3ce94a5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1io_1_1text.html#a08835f7c12bd074240a5f5f7c3ce94a5">multibyte_split</a> (<a class="el" href="classcudf_1_1io_1_1text_1_1data__chunk__source.html">data_chunk_source</a> const &amp;source, std::string const &amp;delimiter, <a class="el" href="structcudf_1_1io_1_1text_1_1parse__options.html">parse_options</a> options={}, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:a08835f7c12bd074240a5f5f7c3ce94a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the source text into a strings column using a multiple byte delimiter.  <br /></td></tr>
<tr class="separator:a08835f7c12bd074240a5f5f7c3ce94a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee8f4dac4fc9e328f5db541ee5e9040"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1io_1_1text.html#a5ee8f4dac4fc9e328f5db541ee5e9040">multibyte_split</a> (<a class="el" href="classcudf_1_1io_1_1text_1_1data__chunk__source.html">data_chunk_source</a> const &amp;source, std::string const &amp;delimiter, std::optional&lt; <a class="el" href="classcudf_1_1io_1_1text_1_1byte__range__info.html">byte_range_info</a> &gt; byte_range, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="separator:a5ee8f4dac4fc9e328f5db541ee5e9040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6425d0e90f334fc549582ac7707c6d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1io_1_1text.html#abd6425d0e90f334fc549582ac7707c6d">multibyte_split</a> (<a class="el" href="classcudf_1_1io_1_1text_1_1data__chunk__source.html">data_chunk_source</a> const &amp;source, std::string const &amp;delimiter, rmm::mr::device_memory_resource *mr)</td></tr>
<tr class="separator:abd6425d0e90f334fc549582ac7707c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">函数说明</h2>
<a id="a534362ac41ba4f410486d91262d114d5" name="a534362ac41ba4f410486d91262d114d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a534362ac41ba4f410486d91262d114d5">&#9670;&#160;</a></span>create_byte_range_info_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcudf_1_1io_1_1text_1_1byte__range__info.html">byte_range_info</a> cudf::io::text::create_byte_range_info_max </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classcudf_1_1io_1_1text_1_1byte__range__info.html" title="stores offset and size used to indicate a byte range">byte_range_info</a> which represents as much of a file as possible. Specifically, <code>[0, numeric_limit&lt;int64_t&gt;::max())</code>. </p>
<dl class="section return"><dt>返回</dt><dd><code>[0, numeric_limit&lt;int64_t&gt;::max())</code> </dd></dl>

</div>
</div>
<a id="a61eadbadb306fc95d06dd5a6523795f3" name="a61eadbadb306fc95d06dd5a6523795f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61eadbadb306fc95d06dd5a6523795f3">&#9670;&#160;</a></span>create_byte_range_infos_consecutive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classcudf_1_1io_1_1text_1_1byte__range__info.html">byte_range_info</a> &gt; cudf::io::text::create_byte_range_infos_consecutive </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>total_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>range_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a collection of consecutive ranges between [0, total_bytes). </p>
<p>Each range wil be the same size except if <code>total_bytes</code> is not evenly divisible by <code>range_count</code>, in which case the last range size will be the remainder.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">total_bytes</td><td>total number of bytes in all ranges </td></tr>
    <tr><td class="paramname">range_count</td><td>total number of ranges in which to divide bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Vector of range objects </dd></dl>

</div>
</div>
<a id="a56971648285aae182cccf90634b899d4" name="a56971648285aae182cccf90634b899d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56971648285aae182cccf90634b899d4">&#9670;&#160;</a></span>make_source() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1io_1_1text_1_1data__chunk__source.html">data_chunk_source</a> &gt; cudf::io::text::make_source </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1string__scalar.html">cudf::string_scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a data source capable of producing views of the given device string scalar </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the device data to be exposed as a data chunk source. Its lifetime must be at least as long as the lifetime of the returned <a class="el" href="classcudf_1_1io_1_1text_1_1data__chunk__source.html" title="a data source capable of creating a reader which can produce views of the data source in device memor...">data_chunk_source</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>the data chunk source for the provided host data. It does not create any copies. </dd></dl>

</div>
</div>
<a id="abba50e0c2d4e39e174b8162809296770" name="abba50e0c2d4e39e174b8162809296770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abba50e0c2d4e39e174b8162809296770">&#9670;&#160;</a></span>make_source() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1io_1_1text_1_1data__chunk__source.html">data_chunk_source</a> &gt; cudf::io::text::make_source </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1io_1_1datasource.html">datasource</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a data source capable of producing device-buffered views of a datasource. </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the datasource to be exposed as a data chunk source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>the data chunk source for the provided datasource. It must not outlive the datasource used to construct it. </dd></dl>

</div>
</div>
<a id="a0867986f8e44a8a7985fb8b84ffe60a0" name="a0867986f8e44a8a7985fb8b84ffe60a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0867986f8e44a8a7985fb8b84ffe60a0">&#9670;&#160;</a></span>make_source() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1io_1_1text_1_1data__chunk__source.html">data_chunk_source</a> &gt; cudf::io::text::make_source </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcudf_1_1host__span.html">host_span</a>&lt; const char &gt;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a data source capable of producing device-buffered views of the given string. </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the host data to be exposed as a data chunk source. Its lifetime must be at least as long as the lifetime of the returned <a class="el" href="classcudf_1_1io_1_1text_1_1data__chunk__source.html" title="a data source capable of creating a reader which can produce views of the data source in device memor...">data_chunk_source</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>the data chunk source for the provided host data. It copies data from the host to the device. </dd></dl>

</div>
</div>
<a id="afc32043b226cfe3559336297b32e8198" name="afc32043b226cfe3559336297b32e8198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc32043b226cfe3559336297b32e8198">&#9670;&#160;</a></span>make_source_from_bgzip_file() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1io_1_1text_1_1data__chunk__source.html">data_chunk_source</a> &gt; cudf::io::text::make_source_from_bgzip_file </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a data source capable of producing device-buffered views of a BGZIP compressed file. </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the filename of the BGZIP-compressed file to be exposed as a data chunk source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>the data chunk source for the provided filename. It reads data from the file and copies it to the device, where it will be decompressed. </dd></dl>

</div>
</div>
<a id="a96a25f9a49bdbff493d03f996673ff52" name="a96a25f9a49bdbff493d03f996673ff52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a25f9a49bdbff493d03f996673ff52">&#9670;&#160;</a></span>make_source_from_bgzip_file() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1io_1_1text_1_1data__chunk__source.html">data_chunk_source</a> &gt; cudf::io::text::make_source_from_bgzip_file </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>virtual_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>virtual_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a data source capable of producing device-buffered views of a BGZIP compressed file with virtual record offsets. </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the filename of the BGZIP-compressed file to be exposed as a data chunk source. </td></tr>
    <tr><td class="paramname">virtual_begin</td><td>the virtual (Tabix) offset of the first byte to be read. Its upper 48 bits describe the offset into the compressed file, its lower 16 bits describe the block-local offset. </td></tr>
    <tr><td class="paramname">virtual_end</td><td>the virtual (Tabix) offset one past the last byte to be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>the data chunk source for the provided filename. It reads data from the file and copies it to the device, where it will be decompressed. The chunk source only returns data between the virtual offsets <code>virtual_begin</code> and <code>virtual_end</code>. </dd></dl>

</div>
</div>
<a id="a3a18f59fc05517b2a2388e7c87a81472" name="a3a18f59fc05517b2a2388e7c87a81472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a18f59fc05517b2a2388e7c87a81472">&#9670;&#160;</a></span>make_source_from_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1io_1_1text_1_1data__chunk__source.html">data_chunk_source</a> &gt; cudf::io::text::make_source_from_file </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a data source capable of producing device-buffered views of the file </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the filename of the file to be exposed as a data chunk source. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>the data chunk source for the provided filename. It reads data from the file and copies it to the device. </dd></dl>

</div>
</div>
<a id="a08835f7c12bd074240a5f5f7c3ce94a5" name="a08835f7c12bd074240a5f5f7c3ce94a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08835f7c12bd074240a5f5f7c3ce94a5">&#9670;&#160;</a></span>multibyte_split() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt; cudf::io::text::multibyte_split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1io_1_1text_1_1data__chunk__source.html">data_chunk_source</a> const &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcudf_1_1io_1_1text_1_1parse__options.html">parse_options</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits the source text into a strings column using a multiple byte delimiter. </p>
<p>Providing a byte range allows multibyte_split to read a file partially, only returning the offsets of delimiters which begin within the range. If thinking in terms of "records", where each delimiter dictates the end of a record, all records which begin within the byte range provided will be returned, including any record which may begin in the range but end outside of the range. Records which begin outside of the range will ignored, even if those records end inside the range.</p>
<div class="fragment"><div class="line">Examples:</div>
<div class="line"> source:     &quot;abc..def..ghi..jkl..&quot;</div>
<div class="line"> delimiter:  &quot;..&quot;</div>
<div class="line"> </div>
<div class="line"> byte_range: nullopt</div>
<div class="line"> return:     [&quot;abc..&quot;, &quot;def..&quot;, &quot;ghi..&quot;, jkl..&quot;, &quot;&quot;]</div>
<div class="line"> </div>
<div class="line"> byte_range: [0, 2)</div>
<div class="line"> return:     [&quot;abc..&quot;]</div>
<div class="line"> </div>
<div class="line"> byte_range: [2, 9)</div>
<div class="line"> return:     [&quot;def..&quot;, &quot;ghi..&quot;]</div>
<div class="line"> </div>
<div class="line"> byte_range: [11, 2)</div>
<div class="line"> return:     []</div>
<div class="line"> </div>
<div class="line"> byte_range: [13, 7)</div>
<div class="line"> return:     [&quot;jkl..&quot;, &quot;&quot;]</div>
</div><!-- fragment --><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source string </td></tr>
    <tr><td class="paramname">delimiter</td><td>UTF-8 encoded string for which to find offsets in the source </td></tr>
    <tr><td class="paramname">options</td><td>the parsing options to use (including byte range) </td></tr>
    <tr><td class="paramname">mr</td><td>Memory resource to use for the device memory allocation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>The strings found by splitting the source by the delimiter within the relevant byte range. </dd></dl>

</div>
</div>
<a id="abd6425d0e90f334fc549582ac7707c6d" name="abd6425d0e90f334fc549582ac7707c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd6425d0e90f334fc549582ac7707c6d">&#9670;&#160;</a></span>multibyte_split() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt; cudf::io::text::multibyte_split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1io_1_1text_1_1data__chunk__source.html">data_chunk_source</a> const &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ee8f4dac4fc9e328f5db541ee5e9040" name="a5ee8f4dac4fc9e328f5db541ee5e9040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee8f4dac4fc9e328f5db541ee5e9040">&#9670;&#160;</a></span>multibyte_split() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt; cudf::io::text::multibyte_split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1io_1_1text_1_1data__chunk__source.html">data_chunk_source</a> const &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classcudf_1_1io_1_1text_1_1byte__range__info.html">byte_range_info</a> &gt;&#160;</td>
          <td class="paramname"><em>byte_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecudf.html">cudf</a></li><li class="navelem"><a class="el" href="namespacecudf_1_1io.html">io</a></li><li class="navelem"><a class="el" href="namespacecudf_1_1io_1_1text.html">text</a></li>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
