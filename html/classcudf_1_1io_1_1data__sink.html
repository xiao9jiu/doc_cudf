<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: cudf::io::data_sink类 参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classcudf_1_1io_1_1data__sink.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public 成员函数</a> &#124;
<a href="#pub-static-methods">静态 Public 成员函数</a> &#124;
<a href="classcudf_1_1io_1_1data__sink-members.html">所有成员列表</a>  </div>
  <div class="headertitle"><div class="title">cudf::io::data_sink类 参考<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Interface class for storing the output data from the writers  
 <a href="classcudf_1_1io_1_1data__sink.html#details">更多...</a></p>

<p><code>#include &lt;<a class="el" href="data__sink_8hpp_source.html">data_sink.hpp</a>&gt;</code></p>
<div class="dynheader">
cudf::io::data_sink 的协作图:</div>
<div class="dyncontent">
<div class="center"><img src="classcudf_1_1io_1_1data__sink__coll__graph.png" border="0" usemap="#acudf_1_1io_1_1data__sink_coll__map" alt="Collaboration graph"/></div>
<map name="acudf_1_1io_1_1data__sink_coll__map" id="acudf_1_1io_1_1data__sink_coll__map">
<area shape="rect" title="Interface class for storing the output data from the writers" alt="" coords="5,5,181,331"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public 成员函数</h2></td></tr>
<tr class="memitem:a778f6bad53ffc49dc6285dd8a9879f73"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1io_1_1data__sink.html#a778f6bad53ffc49dc6285dd8a9879f73">~data_sink</a> ()</td></tr>
<tr class="memdesc:a778f6bad53ffc49dc6285dd8a9879f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class destructor  <br /></td></tr>
<tr class="separator:a778f6bad53ffc49dc6285dd8a9879f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68621d609bd643680481195dc07422c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1io_1_1data__sink.html#ab68621d609bd643680481195dc07422c">host_write</a> (void const *data, size_t size)=0</td></tr>
<tr class="memdesc:ab68621d609bd643680481195dc07422c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the buffer content to the sink  <br /></td></tr>
<tr class="separator:ab68621d609bd643680481195dc07422c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2904b3b6e1167676f0d88e3324a3b3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1io_1_1data__sink.html#a3a2904b3b6e1167676f0d88e3324a3b3">supports_device_write</a> () const</td></tr>
<tr class="memdesc:a3a2904b3b6e1167676f0d88e3324a3b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not this sink supports writing from gpu memory addresses.  <br /></td></tr>
<tr class="separator:a3a2904b3b6e1167676f0d88e3324a3b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61919a2f46a62914b64cb1756058f7a3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1io_1_1data__sink.html#a61919a2f46a62914b64cb1756058f7a3">is_device_write_preferred</a> (size_t size) const</td></tr>
<tr class="memdesc:a61919a2f46a62914b64cb1756058f7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimates whether a direct device write would be more optimal for the given size.  <br /></td></tr>
<tr class="separator:a61919a2f46a62914b64cb1756058f7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1de8c173d8320ba6e65e3ca72bb54c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1io_1_1data__sink.html#a2a1de8c173d8320ba6e65e3ca72bb54c">device_write</a> (void const *gpu_data, size_t size, rmm::cuda_stream_view stream)</td></tr>
<tr class="memdesc:a2a1de8c173d8320ba6e65e3ca72bb54c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the buffer content to the sink from a gpu address  <br /></td></tr>
<tr class="separator:a2a1de8c173d8320ba6e65e3ca72bb54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e8b3322ddc23f1d5be7ee2407a3b96"><td class="memItemLeft" align="right" valign="top">virtual std::future&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1io_1_1data__sink.html#a33e8b3322ddc23f1d5be7ee2407a3b96">device_write_async</a> (void const *gpu_data, size_t size, rmm::cuda_stream_view stream)</td></tr>
<tr class="memdesc:a33e8b3322ddc23f1d5be7ee2407a3b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously append the buffer content to the sink from a gpu address  <br /></td></tr>
<tr class="separator:a33e8b3322ddc23f1d5be7ee2407a3b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059e16ef19d5901feed0098bc97babfa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1io_1_1data__sink.html#a059e16ef19d5901feed0098bc97babfa">flush</a> ()=0</td></tr>
<tr class="memdesc:a059e16ef19d5901feed0098bc97babfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the data written into the sink  <br /></td></tr>
<tr class="separator:a059e16ef19d5901feed0098bc97babfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b43b4b466aa55d96366e4fd934dd971"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1io_1_1data__sink.html#a8b43b4b466aa55d96366e4fd934dd971">bytes_written</a> ()=0</td></tr>
<tr class="memdesc:a8b43b4b466aa55d96366e4fd934dd971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of bytes written into this sink  <br /></td></tr>
<tr class="separator:a8b43b4b466aa55d96366e4fd934dd971"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
静态 Public 成员函数</h2></td></tr>
<tr class="memitem:a548c5228c6f57f77346a4095c6718a02"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classcudf_1_1io_1_1data__sink.html">data_sink</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1io_1_1data__sink.html#a548c5228c6f57f77346a4095c6718a02">create</a> (const std::string &amp;filepath)</td></tr>
<tr class="memdesc:a548c5228c6f57f77346a4095c6718a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a sink from a file path  <br /></td></tr>
<tr class="separator:a548c5228c6f57f77346a4095c6718a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a0c509947e843ce99f444d722e4fef"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classcudf_1_1io_1_1data__sink.html">data_sink</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1io_1_1data__sink.html#a17a0c509947e843ce99f444d722e4fef">create</a> (std::vector&lt; char &gt; *buffer)</td></tr>
<tr class="memdesc:a17a0c509947e843ce99f444d722e4fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a sink from a std::vector  <br /></td></tr>
<tr class="separator:a17a0c509947e843ce99f444d722e4fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8d5a963e97b707296df3d4e3b2552c"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classcudf_1_1io_1_1data__sink.html">data_sink</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1io_1_1data__sink.html#aaa8d5a963e97b707296df3d4e3b2552c">create</a> ()</td></tr>
<tr class="memdesc:aaa8d5a963e97b707296df3d4e3b2552c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a void sink (one that does no actual io)  <br /></td></tr>
<tr class="separator:aaa8d5a963e97b707296df3d4e3b2552c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c322a48d51176301f3a157291c09fbd"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classcudf_1_1io_1_1data__sink.html">data_sink</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1io_1_1data__sink.html#a9c322a48d51176301f3a157291c09fbd">create</a> (<a class="el" href="classcudf_1_1io_1_1data__sink.html">cudf::io::data_sink</a> *const user_sink)</td></tr>
<tr class="memdesc:a9c322a48d51176301f3a157291c09fbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a wrapped custom user data sink  <br /></td></tr>
<tr class="separator:a9c322a48d51176301f3a157291c09fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d85364483b33d6eddd24f031954fb7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a09d85364483b33d6eddd24f031954fb7"><td class="memTemplItemLeft" align="right" valign="top">static std::vector&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1io_1_1data__sink.html">data_sink</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcudf_1_1io_1_1data__sink.html#a09d85364483b33d6eddd24f031954fb7">create</a> (std::vector&lt; T &gt; const &amp;args)</td></tr>
<tr class="memdesc:a09d85364483b33d6eddd24f031954fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vector of data sinks, one per element in the input vector.  <br /></td></tr>
<tr class="separator:a09d85364483b33d6eddd24f031954fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><p>Interface class for storing the output data from the writers </p>

<p class="definition">在文件 <a class="el" href="data__sink_8hpp_source.html">data_sink.hpp</a> 第 <a class="el" href="data__sink_8hpp_source.html#l00035">35</a> 行定义.</p>
</div><h2 class="groupheader">构造及析构函数说明</h2>
<a id="a778f6bad53ffc49dc6285dd8a9879f73" name="a778f6bad53ffc49dc6285dd8a9879f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a778f6bad53ffc49dc6285dd8a9879f73">&#9670;&#160;</a></span>~data_sink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual cudf::io::data_sink::~data_sink </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Base class destructor </p>

<p class="definition">在文件 <a class="el" href="data__sink_8hpp_source.html">data_sink.hpp</a> 第 <a class="el" href="data__sink_8hpp_source.html#l00096">96</a> 行定义.</p>

</div>
</div>
<h2 class="groupheader">成员函数说明</h2>
<a id="a8b43b4b466aa55d96366e4fd934dd971" name="a8b43b4b466aa55d96366e4fd934dd971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b43b4b466aa55d96366e4fd934dd971">&#9670;&#160;</a></span>bytes_written()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t cudf::io::data_sink::bytes_written </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of bytes written into this sink </p>
<dl class="section return"><dt>返回</dt><dd>size_t Total number of bytes written into this sink </dd></dl>

</div>
</div>
<a id="aaa8d5a963e97b707296df3d4e3b2552c" name="aaa8d5a963e97b707296df3d4e3b2552c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa8d5a963e97b707296df3d4e3b2552c">&#9670;&#160;</a></span>create() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::unique_ptr&lt; <a class="el" href="classcudf_1_1io_1_1data__sink.html">data_sink</a> &gt; cudf::io::data_sink::create </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a void sink (one that does no actual io) </p>
<p>A useful code path for benchmarking, to eliminate physical hardware randomness from profiling.</p>
<dl class="section return"><dt>返回</dt><dd>Constructed <a class="el" href="classcudf_1_1io_1_1data__sink.html" title="Interface class for storing the output data from the writers">data_sink</a> object </dd></dl>

</div>
</div>
<a id="a548c5228c6f57f77346a4095c6718a02" name="a548c5228c6f57f77346a4095c6718a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a548c5228c6f57f77346a4095c6718a02">&#9670;&#160;</a></span>create() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::unique_ptr&lt; <a class="el" href="classcudf_1_1io_1_1data__sink.html">data_sink</a> &gt; cudf::io::data_sink::create </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filepath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a sink from a file path </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filepath</td><td>Path to the file to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Constructed <a class="el" href="classcudf_1_1io_1_1data__sink.html" title="Interface class for storing the output data from the writers">data_sink</a> object </dd></dl>

</div>
</div>
<a id="a9c322a48d51176301f3a157291c09fbd" name="a9c322a48d51176301f3a157291c09fbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c322a48d51176301f3a157291c09fbd">&#9670;&#160;</a></span>create() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::unique_ptr&lt; <a class="el" href="classcudf_1_1io_1_1data__sink.html">data_sink</a> &gt; cudf::io::data_sink::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1io_1_1data__sink.html">cudf::io::data_sink</a> *const&#160;</td>
          <td class="paramname"><em>user_sink</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a wrapped custom user data sink </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">user_sink</td><td>User-provided data sink (typically custom class)</td></tr>
  </table>
  </dd>
</dl>
<p>The data sink returned here is not the one passed by the user. It is an internal class that wraps the user pointer. The principle is to allow the user to declare a custom sink instance and use it across multiple write() calls.</p>
<dl class="section return"><dt>返回</dt><dd>Constructed <a class="el" href="classcudf_1_1io_1_1data__sink.html" title="Interface class for storing the output data from the writers">data_sink</a> object </dd></dl>

</div>
</div>
<a id="a17a0c509947e843ce99f444d722e4fef" name="a17a0c509947e843ce99f444d722e4fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17a0c509947e843ce99f444d722e4fef">&#9670;&#160;</a></span>create() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::unique_ptr&lt; <a class="el" href="classcudf_1_1io_1_1data__sink.html">data_sink</a> &gt; cudf::io::data_sink::create </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; char &gt; *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a sink from a std::vector </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>Pointer to the output vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Constructed <a class="el" href="classcudf_1_1io_1_1data__sink.html" title="Interface class for storing the output data from the writers">data_sink</a> object </dd></dl>

</div>
</div>
<a id="a09d85364483b33d6eddd24f031954fb7" name="a09d85364483b33d6eddd24f031954fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d85364483b33d6eddd24f031954fb7">&#9670;&#160;</a></span>create() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1io_1_1data__sink.html">data_sink</a> &gt; &gt; cudf::io::data_sink::create </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a vector of data sinks, one per element in the input vector. </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>vector of parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Constructed vector of data sinks </dd></dl>

<p class="definition">在文件 <a class="el" href="data__sink_8hpp_source.html">data_sink.hpp</a> 第 <a class="el" href="data__sink_8hpp_source.html#l00083">83</a> 行定义.</p>

</div>
</div>
<a id="a2a1de8c173d8320ba6e65e3ca72bb54c" name="a2a1de8c173d8320ba6e65e3ca72bb54c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a1de8c173d8320ba6e65e3ca72bb54c">&#9670;&#160;</a></span>device_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cudf::io::data_sink::device_write </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>gpu_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append the buffer content to the sink from a gpu address </p>
<p>For optimal performance, should only be called when <code>is_device_write_preferred</code> returns <code>true</code>. Data sink implementations that don't support direct device writes don't need to override this function.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>the object does not support direct device writes, i.e. <code>supports_device_write</code> returns <code>false</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_data</td><td>Pointer to the buffer to be written into the sink object </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to write </td></tr>
    <tr><td class="paramname">stream</td><td>CUDA stream to use </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="data__sink_8hpp_source.html">data_sink.hpp</a> 第 <a class="el" href="data__sink_8hpp_source.html#l00155">155</a> 行定义.</p>

</div>
</div>
<a id="a33e8b3322ddc23f1d5be7ee2407a3b96" name="a33e8b3322ddc23f1d5be7ee2407a3b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e8b3322ddc23f1d5be7ee2407a3b96">&#9670;&#160;</a></span>device_write_async()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::future&lt; void &gt; cudf::io::data_sink::device_write_async </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>gpu_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously append the buffer content to the sink from a gpu address </p>
<p>For optimal performance, should only be called when <code>is_device_write_preferred</code> returns <code>true</code>. Data sink implementations that don't support direct device writes don't need to override this function.</p>
<p><code>gpu_data</code> must not be freed until this call is synchronized. </p><div class="fragment"><div class="line">auto result = device_write_async(gpu_data, size, stream);</div>
<div class="line">result.wait(); // OR result.get()</div>
</div><!-- fragment --><dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>the object does not support direct device writes, i.e. <code>supports_device_write</code> returns <code>false</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpu_data</td><td>Pointer to the buffer to be written into the sink object </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to write </td></tr>
    <tr><td class="paramname">stream</td><td>CUDA stream to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>a future that can be used to synchronize the call </dd></dl>

<p class="definition">在文件 <a class="el" href="data__sink_8hpp_source.html">data_sink.hpp</a> 第 <a class="el" href="data__sink_8hpp_source.html#l00182">182</a> 行定义.</p>

</div>
</div>
<a id="a059e16ef19d5901feed0098bc97babfa" name="a059e16ef19d5901feed0098bc97babfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a059e16ef19d5901feed0098bc97babfa">&#9670;&#160;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cudf::io::data_sink::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flush the data written into the sink </p>

</div>
</div>
<a id="ab68621d609bd643680481195dc07422c" name="ab68621d609bd643680481195dc07422c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab68621d609bd643680481195dc07422c">&#9670;&#160;</a></span>host_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cudf::io::data_sink::host_write </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append the buffer content to the sink </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the buffer to be written into the sink object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61919a2f46a62914b64cb1756058f7a3" name="a61919a2f46a62914b64cb1756058f7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61919a2f46a62914b64cb1756058f7a3">&#9670;&#160;</a></span>is_device_write_preferred()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cudf::io::data_sink::is_device_write_preferred </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Estimates whether a direct device write would be more optimal for the given size. </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Number of bytes to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>whether the device write is expected to be more performant for the given size </dd></dl>

<p class="definition">在文件 <a class="el" href="data__sink_8hpp_source.html">data_sink.hpp</a> 第 <a class="el" href="data__sink_8hpp_source.html#l00136">136</a> 行定义.</p>

</div>
</div>
<a id="a3a2904b3b6e1167676f0d88e3324a3b3" name="a3a2904b3b6e1167676f0d88e3324a3b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a2904b3b6e1167676f0d88e3324a3b3">&#9670;&#160;</a></span>supports_device_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cudf::io::data_sink::supports_device_write </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether or not this sink supports writing from gpu memory addresses. </p>
<p>Internal to some of the file format writers, we have code that does things like</p>
<p>tmp_buffer = alloc_temp_buffer(); cudaMemcpy(tmp_buffer, device_buffer, size); sink-&gt;write(tmp_buffer, size);</p>
<p>In the case where the sink type is itself a memory buffered write, this ends up being effectively a second memcpy. So a useful optimization for a "smart" custom <a class="el" href="classcudf_1_1io_1_1data__sink.html" title="Interface class for storing the output data from the writers">data_sink</a> is to do it's own internal management of the movement of data between cpu and gpu; turning the internals of the writer into simply</p>
<p>sink-&gt;device_write(device_buffer, size)</p>
<p>If this function returns true, the <a class="el" href="classcudf_1_1io_1_1data__sink.html" title="Interface class for storing the output data from the writers">data_sink</a> will receive calls to <a class="el" href="classcudf_1_1io_1_1data__sink.html#a2a1de8c173d8320ba6e65e3ca72bb54c" title="Append the buffer content to the sink from a gpu address">device_write()</a> instead of write() when possible. However, it is still possible to receive write() calls as well.</p>
<dl class="section return"><dt>返回</dt><dd>bool If this writer supports <a class="el" href="classcudf_1_1io_1_1data__sink.html#a2a1de8c173d8320ba6e65e3ca72bb54c" title="Append the buffer content to the sink from a gpu address">device_write()</a> calls </dd></dl>

<p class="definition">在文件 <a class="el" href="data__sink_8hpp_source.html">data_sink.hpp</a> 第 <a class="el" href="data__sink_8hpp_source.html#l00128">128</a> 行定义.</p>

</div>
</div>
<hr/>该类的文档由以下文件生成:<ul>
<li>D:/gitLibrary/cudf/cpp/include/cudf/io/<a class="el" href="data__sink_8hpp_source.html">data_sink.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecudf.html">cudf</a></li><li class="navelem"><a class="el" href="namespacecudf_1_1io.html">io</a></li><li class="navelem"><a class="el" href="classcudf_1_1io_1_1data__sink.html">data_sink</a></li>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
