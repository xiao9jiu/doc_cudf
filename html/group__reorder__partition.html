<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Reorder_partition</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__reorder__partition.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#files">文件</a> &#124;
<a href="#func-members">函数</a>  </div>
  <div class="headertitle"><div class="title">Reorder_partition</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
文件</h2></td></tr>
<tr class="memitem:partitioning_8hpp"><td class="memItemLeft" align="right" valign="top">文件 &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="partitioning_8hpp.html">partitioning.hpp</a></td></tr>
<tr class="memdesc:partitioning_8hpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column partitioning APIs <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
函数</h2></td></tr>
<tr class="memitem:gac862ac3926d44c41e92e6d3a47c6d388"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;, std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reorder__partition.html#gac862ac3926d44c41e92e6d3a47c6d388">cudf::partition</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;t, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;partition_map, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> num_partitions, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gac862ac3926d44c41e92e6d3a47c6d388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partitions rows of <code>t</code> according to the mapping specified by <code>partition_map</code>.  <br /></td></tr>
<tr class="separator:gac862ac3926d44c41e92e6d3a47c6d388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5e2aad87e6f5f09fa4370f4cec3be17"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;, std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reorder__partition.html#gac5e2aad87e6f5f09fa4370f4cec3be17">cudf::hash_partition</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; const &amp;columns_to_hash, int num_partitions, <a class="el" href="group__column__hash.html#gaced8b9d129825edd13d76e912e4413c3">hash_id</a> hash_function=<a class="el" href="group__column__hash.html#ggaced8b9d129825edd13d76e912e4413c3ae9ec854e962136b1afcf108e5301c354">hash_id::HASH_MURMUR3</a>, uint32_t seed=<a class="el" href="group__column__hash.html#ga68de1d04aa2c0ea2eeacfc73fd99a915">DEFAULT_HASH_SEED</a>, rmm::cuda_stream_view stream=<a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>(), rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:gac5e2aad87e6f5f09fa4370f4cec3be17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partitions rows from the input table into multiple output tables.  <br /></td></tr>
<tr class="separator:gac5e2aad87e6f5f09fa4370f4cec3be17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5db3c207f2be3f7659416122ba3a1fdb"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">cudf::table</a> &gt;, std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reorder__partition.html#ga5db3c207f2be3f7659416122ba3a1fdb">cudf::round_robin_partition</a> (<a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;input, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a> num_partitions, <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a> start_partition=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_current_device_resource())</td></tr>
<tr class="memdesc:ga5db3c207f2be3f7659416122ba3a1fdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round-robin partition.  <br /></td></tr>
<tr class="separator:ga5db3c207f2be3f7659416122ba3a1fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<h2 class="groupheader">函数说明</h2>
<a id="gac5e2aad87e6f5f09fa4370f4cec3be17" name="gac5e2aad87e6f5f09fa4370f4cec3be17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5e2aad87e6f5f09fa4370f4cec3be17">&#9670;&#160;</a></span>hash_partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;, std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; &gt; cudf::hash_partition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>columns_to_hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__column__hash.html#gaced8b9d129825edd13d76e912e4413c3">hash_id</a>&#160;</td>
          <td class="paramname"><em>hash_function</em> = <code><a class="el" href="group__column__hash.html#ggaced8b9d129825edd13d76e912e4413c3ae9ec854e962136b1afcf108e5301c354">hash_id::HASH_MURMUR3</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code><a class="el" href="group__column__hash.html#ga68de1d04aa2c0ea2eeacfc73fd99a915">DEFAULT_HASH_SEED</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::cuda_stream_view&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="namespacecudf.html#a001ed29e71e759518cae31e52312befa">cudf::get_default_stream</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partitions rows from the input table into multiple output tables. </p>
<p>Partitions rows of <code>input</code> into <code>num_partitions</code> bins based on the hash value of the columns specified by <code>columns_to_hash</code>. Rows partitioned into the same bin are grouped consecutively in the output table. Returns a vector of row offsets to the start of each partition in the output table.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if index is <code>columns_to_hash</code> is invalid</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The table to partition </td></tr>
    <tr><td class="paramname">columns_to_hash</td><td>Indices of input columns to hash </td></tr>
    <tr><td class="paramname">num_partitions</td><td>The number of partitions to use </td></tr>
    <tr><td class="paramname">hash_function</td><td>Optional hash id that chooses the hash function to use </td></tr>
    <tr><td class="paramname">seed</td><td>Optional seed value to the hash function </td></tr>
    <tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned table's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>An output table and a vector of row offsets to each partition </dd></dl>

</div>
</div>
<a id="gac862ac3926d44c41e92e6d3a47c6d388" name="gac862ac3926d44c41e92e6d3a47c6d388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac862ac3926d44c41e92e6d3a47c6d388">&#9670;&#160;</a></span>partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">table</a> &gt;, std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a> &gt; &gt; cudf::partition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>partition_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">size_type</a>&#160;</td>
          <td class="paramname"><em>num_partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partitions rows of <code>t</code> according to the mapping specified by <code>partition_map</code>. </p>
<p>For each row at <code>i</code> in <code>t</code>, <code>partition_map[i]</code> indicates which partition row <code>i</code> belongs to. <code>partition</code> creates a new table by rearranging the rows of <code>t</code> such that rows in the same partition are contiguous. The returned table is in ascending partition order from <code>[0, num_partitions)</code>. The order within each partition is undefined.</p>
<p>Returns a <code>vector&lt;size_type&gt;</code> of <code>num_partitions + 1</code> values that indicate the starting position of each partition within the returned table, i.e., partition <code>i</code> starts at <code>offsets[i]</code> (inclusive) and ends at <code>offset[i+1]</code> (exclusive). As a result, if value <code>j</code> in <code>[0, num_partitions)</code> does not appear in <code>partition_map</code>, partition <code>j</code> will be empty, i.e., <code>offsets[j+1] - offsets[j] == 0</code>.</p>
<p>Values in <code>partition_map</code> must be in the range <code>[0, num_partitions)</code>, otherwise behavior is undefined.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>when <code>partition_map</code> is a non-integer type </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>when <code>partition_map.has_nulls() == true</code> </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>when <code>partition_map.size() != t.num_rows()</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to partition </td></tr>
    <tr><td class="paramname">partition_map</td><td>Non-nullable column of integer values that map each row in <code>t</code> to it's partition. </td></tr>
    <tr><td class="paramname">num_partitions</td><td>The total number of partitions </td></tr>
    <tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned table's device memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Pair containing the reordered table and vector of <code>num_partitions + 1</code> offsets to each partition such that the size of partition <code>i</code> is determined by <code>offset[i+1] - offset[i]</code>. </dd></dl>

</div>
</div>
<a id="ga5db3c207f2be3f7659416122ba3a1fdb" name="ga5db3c207f2be3f7659416122ba3a1fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5db3c207f2be3f7659416122ba3a1fdb">&#9670;&#160;</a></span>round_robin_partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1table.html">cudf::table</a> &gt;, std::vector&lt; <a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a> &gt; &gt; cudf::round_robin_partition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcudf_1_1table__view.html">table_view</a> const &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a>&#160;</td>
          <td class="paramname"><em>num_partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__utility__types.html#ga0aff16b2db009d92300befaca11827e9">cudf::size_type</a>&#160;</td>
          <td class="paramname"><em>start_partition</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rmm::mr::device_memory_resource *&#160;</td>
          <td class="paramname"><em>mr</em> = <code>rmm::mr::get_current_device_resource()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Round-robin partition. </p>
<p>Returns a new table with rows re-arranged into partition groups and a vector of row offsets to the start of each partition in the output table. Rows are assigned partitions based on their row index in the table, in a round robin fashion.</p>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>num_partitions &lt;= 1</code> </td></tr>
    <tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>start_partition &gt;= num_partitions</code></td></tr>
  </table>
  </dd>
</dl>
<p>A good analogy for the algorithm is dealing out cards:</p>
<ol type="1">
<li>The deck of cards is represented as the rows in the table.</li>
<li>The number of partitions is the number of players being dealt cards.</li>
<li>the start_partition indicates which player starts getting cards first.</li>
</ol>
<p>The algorithm has two outcomes:</p>
<ol type="1">
<li>Another deck of cards formed by stacking each player's cards back into a deck again, preserving the order of cards dealt to each player, starting with player 0.</li>
<li>A vector into the output deck indicating where a player's cards start.</li>
</ol>
<p>A player's deck (partition) is the range of cards starting at the corresponding offset and ending at the next player's starting offset or the last card in the deck if it's the last player.</p>
<p>When num_partitions &gt; nrows, we have more players than cards. We start dealing to the first indicated player and continuing around the players until we run out of cards before we run out of players. Players that did not get any cards are represented by <code>offset[i] == offset[i+1] or offset[i] == <a class="el" href="classcudf_1_1table.html#a6f413ef7e62bf5b2863c26e98f664c54" title="Returns the number of rows">table.num_rows()</a> if i == num_partitions-1</code> meaning there are no cards (rows) in their deck (partition).</p>
<div class="fragment"><div class="line">Example 1:</div>
<div class="line">input:</div>
<div class="line"><a class="code hl_class" href="classcudf_1_1table.html">table</a> =&gt; col 1 {0, ..., 12}</div>
<div class="line">num_partitions = 3</div>
<div class="line">start_partition = 0</div>
<div class="line"> </div>
<div class="line">output: pair&lt;table, partition_offsets&gt;</div>
<div class="line">table =&gt; col 1 {0,3,6,9,12,1,4,7,10,2,5,8,11}</div>
<div class="line">partition_offsets =&gt; {0,5,9}</div>
<div class="line"> </div>
<div class="line">Example 2:</div>
<div class="line">input:</div>
<div class="line">table =&gt; col 1 {0, ..., 12}</div>
<div class="line">num_partitions = 3</div>
<div class="line">start_partition = 1</div>
<div class="line"> </div>
<div class="line">output: pair&lt;table, partition_offsets&gt;</div>
<div class="line">table =&gt; col 1 {2,5,8,11,0,3,6,9,12,1,4,7,10}</div>
<div class="line">partition_offsets =&gt; {0,4,9}</div>
<div class="line"> </div>
<div class="line">Example 3:</div>
<div class="line">input:</div>
<div class="line">table =&gt; col 1 {0, ..., 10}</div>
<div class="line">num_partitions = 3</div>
<div class="line">start_partition = 0</div>
<div class="line"> </div>
<div class="line">output: pair&lt;table, partition_offsets&gt;</div>
<div class="line">table =&gt; col 1 {0,3,6,9,1,4,7,10,2,5,8}</div>
<div class="line">partition_offsets =&gt; {0,4,8}</div>
<div class="line"> </div>
<div class="line">Example 4:</div>
<div class="line">input:</div>
<div class="line">table =&gt; col 1 {0, ..., 10}</div>
<div class="line">num_partitions = 3</div>
<div class="line">start_partition = 1</div>
<div class="line"> </div>
<div class="line">output: pair&lt;table, partition_offsets&gt;</div>
<div class="line">table =&gt; col 1 {2,5,8,0,3,6,9,1,4,7,10}</div>
<div class="line">partition_offsets =&gt; {0,3,7}</div>
<div class="line"> </div>
<div class="line">Example 5:</div>
<div class="line">input:</div>
<div class="line">table =&gt; col 1 {0, ..., 10}</div>
<div class="line">num_partitions = 3</div>
<div class="line">start_partition = 2</div>
<div class="line"> </div>
<div class="line">output: pair&lt;table, partition_offsets&gt;</div>
<div class="line">table =&gt; col 1 {1,4,7,10,2,5,8,0,3,6,9}</div>
<div class="line">partition_offsets =&gt; {0,4,7}</div>
<div class="line"> </div>
<div class="line">Example 6:</div>
<div class="line">input:</div>
<div class="line">table =&gt; col 1 {0, ..., 10}</div>
<div class="line">num_partitions = 15 &gt; num_rows = 11</div>
<div class="line">start_partition = 2</div>
<div class="line"> </div>
<div class="line">output: pair&lt;table, partition_offsets&gt;</div>
<div class="line">table =&gt; col 1 {0,1,2,3,4,5,6,7,8,9,10}</div>
<div class="line">partition_offsets =&gt; {0,0,0,1,2,3,4,5,6,7,8,9,10,11,11}</div>
<div class="line"> </div>
<div class="line">Example 7:</div>
<div class="line">input:</div>
<div class="line">table =&gt; col 1 {0, ..., 10}</div>
<div class="line">num_partitions = 15 &gt; num_rows = 11</div>
<div class="line">start_partition = 10</div>
<div class="line"> </div>
<div class="line">output: pair&lt;table, partition_offsets&gt;</div>
<div class="line">table =&gt; col 1 {5,6,7,8,9,10,0,1,2,3,4}</div>
<div class="line">partition_offsets =&gt; {0,1,2,3,4,5,6,6,6,6,6,7,8,9,10}</div>
<div class="line"> </div>
<div class="line">Example 8:</div>
<div class="line">input:</div>
<div class="line">table =&gt; col 1 {0, ..., 10}</div>
<div class="line">num_partitions = 15 &gt; num_rows = 11</div>
<div class="line">start_partition = 14</div>
<div class="line"> </div>
<div class="line">output: pair&lt;table, partition_offsets&gt;</div>
<div class="line">table =&gt; col 1 {1,2,3,4,5,6,7,8,9,10,0}</div>
<div class="line">partition_offsets =&gt; {0,1,2,3,4,5,6,7,8,9,10,10,10,10,10}</div>
<div class="line"> </div>
<div class="line">Example 9:</div>
<div class="line">input:</div>
<div class="line">table =&gt; col 1 {0, ..., 10}</div>
<div class="line">num_partitions = 11 == num_rows = 11</div>
<div class="line">start_partition = 2</div>
<div class="line"> </div>
<div class="line">output: pair&lt;table, partition_offsets&gt;</div>
<div class="line">table =&gt; col 1 {9,10,0,1,2,3,4,5,6,7,8}</div>
<div class="line">partition_offsets =&gt; {0,1,2,3,4,5,6,7,8,9,10}</div>
<div class="ttc" id="aclasscudf_1_1table_html"><div class="ttname"><a href="classcudf_1_1table.html">cudf::table</a></div><div class="ttdoc">A set of cudf::column's of the same size.</div><div class="ttdef"><b>Definition</b> <a href="table_8hpp_source.html#l00040">table.hpp:40</a></div></div>
</div><!-- fragment --><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The input table to be round-robin partitioned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_partitions</td><td>Number of partitions for the table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_partition</td><td>Index of the 1st partition </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned table's device memory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A std::pair consisting of a unique_ptr to the partitioned table and the partition offsets for each partition within the table. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
