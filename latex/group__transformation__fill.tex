\doxysection{Transformation\+\_\+fill}
\hypertarget{group__transformation__fill}{}\label{group__transformation__fill}\index{Transformation\_fill@{Transformation\_fill}}
\doxysubsubsection*{文件}
\begin{DoxyCompactItemize}
\item 
文件 \mbox{\hyperlink{filling_8hpp}{filling.\+hpp}}
\begin{DoxyCompactList}\small\item\em Column APIs for fill, repeat, and sequence \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{函数}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{group__transformation__fill_ga53223e7585a8a507802815201a4eb5ba}{cudf\+::fill\+\_\+in\+\_\+place}} (\mbox{\hyperlink{classcudf_1_1mutable__column__view}{mutable\+\_\+column\+\_\+view}} \&destination, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} begin, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} end, \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&value)
\begin{DoxyCompactList}\small\item\em Fills a range of elements in-\/place in a column with a scalar value. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__transformation__fill_ga06c5a274e53d68a38151ab402492ebe8}{cudf\+::fill}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&input, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} begin, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} end, \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&value, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Fills a range of elements in a column out-\/of-\/place with a scalar value. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{group__transformation__fill_ga0ae5112e1a07cb1cadfcdb3d3a03f096}{cudf\+::repeat}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&input\+\_\+table, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&count, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Repeat rows of a Table. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{group__transformation__fill_ga3a7108024c5faef011b8a4cbf411e196}{cudf\+::repeat}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&input\+\_\+table, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} count, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Repeat rows of a Table. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__transformation__fill_gac846399ac2ee0729e1bdfaedbf3b7735}{cudf\+::sequence}} (\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} size, \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&init, \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&step, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Fills a column with a sequence of value specified by an initial value and a step. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__transformation__fill_ga08b5167ef67be7ad7fe9a07adc3de31b}{cudf\+::sequence}} (\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} size, \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&init, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Fills a column with a sequence of value specified by an initial value and a step of 1. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{cudf\+::column}} $>$ \mbox{\hyperlink{group__transformation__fill_ga0691c762ba0a3efb1b432b423e6fe60a}{cudf\+::calendrical\+\_\+month\+\_\+sequence}} (\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} size, \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&init, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} months, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Generate a sequence of timestamps beginning at {\ttfamily init} and incrementing by {\ttfamily months} for each successive element, i.\+e., {\ttfamily output\mbox{[}i\mbox{]} = init + i \texorpdfstring{$\ast$}{*} months} for {\ttfamily i} in {\ttfamily \mbox{[}0, size)}. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{详细描述}


\doxysubsection{函数说明}
\Hypertarget{group__transformation__fill_ga0691c762ba0a3efb1b432b423e6fe60a}\label{group__transformation__fill_ga0691c762ba0a3efb1b432b423e6fe60a} 
\index{Transformation\_fill@{Transformation\_fill}!calendrical\_month\_sequence@{calendrical\_month\_sequence}}
\index{calendrical\_month\_sequence@{calendrical\_month\_sequence}!Transformation\_fill@{Transformation\_fill}}
\doxysubsubsection{\texorpdfstring{calendrical\_month\_sequence()}{calendrical\_month\_sequence()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{cudf\+::column}} $>$ cudf\+::calendrical\+\_\+month\+\_\+sequence (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{size,  }\item[{\mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&}]{init,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{months,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Generate a sequence of timestamps beginning at {\ttfamily init} and incrementing by {\ttfamily months} for each successive element, i.\+e., {\ttfamily output\mbox{[}i\mbox{]} = init + i \texorpdfstring{$\ast$}{*} months} for {\ttfamily i} in {\ttfamily \mbox{[}0, size)}. 

If a given date is invalid, the date is scaled back to the last available day of that month.

Example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{size\ =\ 3}
\DoxyCodeLine{init\ =\ 2020-\/01-\/31\ 08:00:00}
\DoxyCodeLine{months\ =\ 1}
\DoxyCodeLine{\textcolor{keywordflow}{return}\ =\ [2020-\/01-\/31\ 08:00:00,\ 2020-\/02-\/29\ 08:00:00,\ 2020-\/03-\/31\ 08:00:00]}

\end{DoxyCode}



\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if input datatype is not a TIMESTAMP\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em size} & Number of timestamps to generate \\
\hline
{\em init} & The initial timestamp \\
\hline
{\em months} & Months to increment \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Timestamps column with sequences of months 
\end{DoxyReturn}
\Hypertarget{group__transformation__fill_ga06c5a274e53d68a38151ab402492ebe8}\label{group__transformation__fill_ga06c5a274e53d68a38151ab402492ebe8} 
\index{Transformation\_fill@{Transformation\_fill}!fill@{fill}}
\index{fill@{fill}!Transformation\_fill@{Transformation\_fill}}
\doxysubsubsection{\texorpdfstring{fill()}{fill()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::fill (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{input,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{begin,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{end,  }\item[{\mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&}]{value,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Fills a range of elements in a column out-\/of-\/place with a scalar value. 

Creates a new column as-\/if an in-\/place fill was performed into {\ttfamily input}; i.\+e. it is as if a copy of {\ttfamily input} was created first and then the elements indicated by the indices \mbox{[}{\ttfamily begin}, {\ttfamily end}) were overwritten by {\ttfamily value}.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & for invalid range (if {\ttfamily begin} \texorpdfstring{$<$}{<} 0, {\ttfamily begin} \texorpdfstring{$>$}{>} {\ttfamily end}, or {\ttfamily end} \texorpdfstring{$>$}{>} {\ttfamily destination.\+size()}). \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily destination} and {\ttfamily value} have different types.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em input} & The input column used to create a new column. The new column is created by replacing the values of {\ttfamily input} in the specified range with {\ttfamily value}. \\
\hline
{\em begin} & The starting index of the fill range (inclusive) \\
\hline
{\em end} & The index of the last element in the fill range (exclusive) \\
\hline
{\em value} & The scalar value to fill \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
The result output column 
\end{DoxyReturn}
\Hypertarget{group__transformation__fill_ga53223e7585a8a507802815201a4eb5ba}\label{group__transformation__fill_ga53223e7585a8a507802815201a4eb5ba} 
\index{Transformation\_fill@{Transformation\_fill}!fill\_in\_place@{fill\_in\_place}}
\index{fill\_in\_place@{fill\_in\_place}!Transformation\_fill@{Transformation\_fill}}
\doxysubsubsection{\texorpdfstring{fill\_in\_place()}{fill\_in\_place()}}
{\footnotesize\ttfamily void cudf\+::fill\+\_\+in\+\_\+place (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1mutable__column__view}{mutable\+\_\+column\+\_\+view}} \&}]{destination,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{begin,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{end,  }\item[{\mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&}]{value }\end{DoxyParamCaption})}



Fills a range of elements in-\/place in a column with a scalar value. 

Fills N elements of {\ttfamily destination} starting at {\ttfamily begin} with {\ttfamily value}, where N = ({\ttfamily end} -\/ {\ttfamily begin}).

Overwrites the range of elements in {\ttfamily destination} indicated by the indices \mbox{[}{\ttfamily begin}, {\ttfamily end}) with {\ttfamily value}. Use the out-\/of-\/place fill function returning std\+::unique\+\_\+ptr$<$column$>$ for use cases requiring memory reallocation.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if memory reallocation is required (e.\+g. for variable width types). \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & for invalid range (if {\ttfamily begin} \texorpdfstring{$<$}{<} 0, {\ttfamily begin} \texorpdfstring{$>$}{>} {\ttfamily end}, or {\ttfamily end} \texorpdfstring{$>$}{>} {\ttfamily destination.\+size()}). \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily destination} and {\ttfamily value} have different types. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily value} is invalid but {\ttfamily destination} is not nullable.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em destination} & The preallocated column to fill into \\
\hline
{\em begin} & The starting index of the fill range (inclusive) \\
\hline
{\em end} & The index of the last element in the fill range (exclusive) \\
\hline
{\em value} & The scalar value to fill \\
\hline
\end{DoxyParams}
\Hypertarget{group__transformation__fill_ga0ae5112e1a07cb1cadfcdb3d3a03f096}\label{group__transformation__fill_ga0ae5112e1a07cb1cadfcdb3d3a03f096} 
\index{Transformation\_fill@{Transformation\_fill}!repeat@{repeat}}
\index{repeat@{repeat}!Transformation\_fill@{Transformation\_fill}}
\doxysubsubsection{\texorpdfstring{repeat()}{repeat()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::repeat (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{input\+\_\+table,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{count,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Repeat rows of a Table. 

Creates a new table by repeating the rows of {\ttfamily input\+\_\+table}. The number of repetitions of each element is defined by the value at the corresponding index of {\ttfamily count} Example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{in\ =\ [4,5,6]}
\DoxyCodeLine{count\ =\ [1,2,3]}
\DoxyCodeLine{\textcolor{keywordflow}{return}\ =\ [4,5,5,6,6,6]}

\end{DoxyCode}
 {\ttfamily count} should not have null values; should not contain negative values; and the sum of count elements should not overflow the size\+\_\+type\textquotesingle{}s limit. The behavior of this function is undefined if {\ttfamily count} has negative values or the sum overflows.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if the data type of {\ttfamily count} is not size\+\_\+type. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily input\+\_\+table} and {\ttfamily count} have different number of rows. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily count} has null values.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em input\+\_\+table} & Input table \\
\hline
{\em count} & Non-\/nullable column of an integral type \\
\hline
{\em mr} & Device memory resource used to allocate the returned table\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
The result table containing the repetitions 
\end{DoxyReturn}
\Hypertarget{group__transformation__fill_ga3a7108024c5faef011b8a4cbf411e196}\label{group__transformation__fill_ga3a7108024c5faef011b8a4cbf411e196} 
\index{Transformation\_fill@{Transformation\_fill}!repeat@{repeat}}
\index{repeat@{repeat}!Transformation\_fill@{Transformation\_fill}}
\doxysubsubsection{\texorpdfstring{repeat()}{repeat()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::repeat (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{input\+\_\+table,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{count,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Repeat rows of a Table. 

Creates a new table by repeating {\ttfamily count} times the rows of {\ttfamily input\+\_\+table}. Example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{in\ =\ [4,5,6]}
\DoxyCodeLine{count\ =\ 2}
\DoxyCodeLine{\textcolor{keywordflow}{return}\ =\ [4,4,5,5,6,6]}

\end{DoxyCode}
 
\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if the data type of {\ttfamily count} is not size\+\_\+type. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily count} is invalid or {\ttfamily count} is negative. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily input\+\_\+table.\+num\+\_\+rows()} \texorpdfstring{$\ast$}{*} {\ttfamily count} overflows size\+\_\+type.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em input\+\_\+table} & Input table \\
\hline
{\em count} & Number of repetitions \\
\hline
{\em mr} & Device memory resource used to allocate the returned table\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
The result table containing the repetitions 
\end{DoxyReturn}
\Hypertarget{group__transformation__fill_ga08b5167ef67be7ad7fe9a07adc3de31b}\label{group__transformation__fill_ga08b5167ef67be7ad7fe9a07adc3de31b} 
\index{Transformation\_fill@{Transformation\_fill}!sequence@{sequence}}
\index{sequence@{sequence}!Transformation\_fill@{Transformation\_fill}}
\doxysubsubsection{\texorpdfstring{sequence()}{sequence()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::sequence (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{size,  }\item[{\mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&}]{init,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Fills a column with a sequence of value specified by an initial value and a step of 1. 

Creates a new column and fills with {\ttfamily size} values starting at {\ttfamily init} and incrementing by 1, generating the sequence \mbox{[} init, init+1, init+2, ... init + (size -\/ 1)\mbox{]}


\begin{DoxyCode}{0}
\DoxyCodeLine{size\ =\ 3}
\DoxyCodeLine{init\ =\ 0}
\DoxyCodeLine{\textcolor{keywordflow}{return}\ =\ [0,\ 1,\ 2]}

\end{DoxyCode}
 
\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily init} is not numeric. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily size} is \texorpdfstring{$<$}{<} 0.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em size} & Size of the output column \\
\hline
{\em init} & First value in the sequence \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
The result column containing the generated sequence 
\end{DoxyReturn}
\Hypertarget{group__transformation__fill_gac846399ac2ee0729e1bdfaedbf3b7735}\label{group__transformation__fill_gac846399ac2ee0729e1bdfaedbf3b7735} 
\index{Transformation\_fill@{Transformation\_fill}!sequence@{sequence}}
\index{sequence@{sequence}!Transformation\_fill@{Transformation\_fill}}
\doxysubsubsection{\texorpdfstring{sequence()}{sequence()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::sequence (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{size,  }\item[{\mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&}]{init,  }\item[{\mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&}]{step,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Fills a column with a sequence of value specified by an initial value and a step. 

Creates a new column and fills with {\ttfamily size} values starting at {\ttfamily init} and incrementing by {\ttfamily step}, generating the sequence \mbox{[} init, init+step, init+2\texorpdfstring{$\ast$}{*}step, ... init + (size -\/ 1)\texorpdfstring{$\ast$}{*}step\mbox{]}


\begin{DoxyCode}{0}
\DoxyCodeLine{size\ =\ 3}
\DoxyCodeLine{init\ =\ 0}
\DoxyCodeLine{step\ =\ 2}
\DoxyCodeLine{\textcolor{keywordflow}{return}\ =\ [0,\ 2,\ 4]}

\end{DoxyCode}
 
\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily init} and {\ttfamily step} are not the same type. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if scalar types are not numeric. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily size} is \texorpdfstring{$<$}{<} 0.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em size} & Size of the output column \\
\hline
{\em init} & First value in the sequence \\
\hline
{\em step} & Increment value \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
The result column containing the generated sequence 
\end{DoxyReturn}
