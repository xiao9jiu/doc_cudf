\doxysection{Dictionary\+\_\+update}
\hypertarget{group__dictionary__update}{}\label{group__dictionary__update}\index{Dictionary\_update@{Dictionary\_update}}
\doxysubsubsection*{文件}
\begin{DoxyCompactItemize}
\item 
文件 \mbox{\hyperlink{update__keys_8hpp}{update\+\_\+keys.\+hpp}}
\end{DoxyCompactItemize}
\doxysubsubsection*{函数}
\begin{DoxyCompactItemize}
\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__dictionary__update_ga26aab2d4065554ab7b800f98f3c5c0fd}{cudf\+::dictionary\+::add\+\_\+keys}} (\mbox{\hyperlink{classcudf_1_1dictionary__column__view}{dictionary\+\_\+column\+\_\+view}} const \&dictionary\+\_\+column, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&new\+\_\+keys, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Create a new dictionary column by adding the new keys elements to the existing dictionary\+\_\+column. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__dictionary__update_ga9e9d03e8d8183e43b6665911ca740b33}{cudf\+::dictionary\+::remove\+\_\+keys}} (\mbox{\hyperlink{classcudf_1_1dictionary__column__view}{dictionary\+\_\+column\+\_\+view}} const \&dictionary\+\_\+column, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&keys\+\_\+to\+\_\+remove, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Create a new dictionary column by removing the specified keys from the existing dictionary\+\_\+column. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__dictionary__update_ga001e8ae4abb0cc16cf2cc7b82626d286}{cudf\+::dictionary\+::remove\+\_\+unused\+\_\+keys}} (\mbox{\hyperlink{classcudf_1_1dictionary__column__view}{dictionary\+\_\+column\+\_\+view}} const \&dictionary\+\_\+column, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Create a new dictionary column by removing any keys that are not referenced by any of the indices. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__dictionary__update_ga6b51b2c3778e68a55b0ccc641c0b2b33}{cudf\+::dictionary\+::set\+\_\+keys}} (\mbox{\hyperlink{classcudf_1_1dictionary__column__view}{dictionary\+\_\+column\+\_\+view}} const \&dictionary\+\_\+column, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&keys, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Create a new dictionary column by applying only the specified keys to the existing dictionary\+\_\+column. \end{DoxyCompactList}\item 
std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ $>$ \mbox{\hyperlink{group__dictionary__update_ga71b186f48400ed3231237ea25e520257}{cudf\+::dictionary\+::match\+\_\+dictionaries}} (\mbox{\hyperlink{structcudf_1_1host__span}{cudf\+::host\+\_\+span}}$<$ \mbox{\hyperlink{classcudf_1_1dictionary__column__view}{dictionary\+\_\+column\+\_\+view}} const $>$ input, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Create new dictionaries that have keys merged from the input dictionaries. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{详细描述}


\doxysubsection{函数说明}
\Hypertarget{group__dictionary__update_ga26aab2d4065554ab7b800f98f3c5c0fd}\label{group__dictionary__update_ga26aab2d4065554ab7b800f98f3c5c0fd} 
\index{Dictionary\_update@{Dictionary\_update}!add\_keys@{add\_keys}}
\index{add\_keys@{add\_keys}!Dictionary\_update@{Dictionary\_update}}
\doxysubsubsection{\texorpdfstring{add\_keys()}{add\_keys()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::dictionary\+::add\+\_\+keys (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1dictionary__column__view}{dictionary\+\_\+column\+\_\+view}} const \&}]{dictionary\+\_\+column,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{new\+\_\+keys,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Create a new dictionary column by adding the new keys elements to the existing dictionary\+\_\+column. 

The indices are updated if any of the new keys are sorted before any of the existing dictionary elements.


\begin{DoxyCode}{0}
\DoxyCodeLine{d1\ =\ \{\ keys=["{}a"{},\ "{}c"{},\ "{}d"{}],\ indices=[2,\ 0,\ 1,\ 0,\ 1]\}}
\DoxyCodeLine{d2\ =\ add\_keys(\ d1,\ ["{}b"{},\ "{}c"{}]\ )}
\DoxyCodeLine{d2\ is\ now\ \{keys=["{}a"{},\ "{}b"{},\ "{}c"{},\ "{}d"{}],\ indices=[3,\ 0,\ 2,\ 0,\ 2]\}}

\end{DoxyCode}


The output column will have the same number of rows as the input column. Null entries from the input column are copied to the output column. No new null entries are created by this operation.


\begin{DoxyExceptions}{异常}
{\em cudf\+\_\+logic\+\_\+error} & if the new\+\_\+keys type does not match the keys type in the dictionary\+\_\+column. \\
\hline
{\em cudf\+\_\+logic\+\_\+error} & if the new\+\_\+keys contain nulls.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em dictionary\+\_\+column} & Existing dictionary column. \\
\hline
{\em new\+\_\+keys} & New keys to incorporate into the dictionary\+\_\+column \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
New dictionary column. 
\end{DoxyReturn}
\Hypertarget{group__dictionary__update_ga71b186f48400ed3231237ea25e520257}\label{group__dictionary__update_ga71b186f48400ed3231237ea25e520257} 
\index{Dictionary\_update@{Dictionary\_update}!match\_dictionaries@{match\_dictionaries}}
\index{match\_dictionaries@{match\_dictionaries}!Dictionary\_update@{Dictionary\_update}}
\doxysubsubsection{\texorpdfstring{match\_dictionaries()}{match\_dictionaries()}}
{\footnotesize\ttfamily std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ $>$ cudf\+::dictionary\+::match\+\_\+dictionaries (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structcudf_1_1host__span}{cudf\+::host\+\_\+span}}$<$ \mbox{\hyperlink{classcudf_1_1dictionary__column__view}{dictionary\+\_\+column\+\_\+view}} const $>$}]{input,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Create new dictionaries that have keys merged from the input dictionaries. 

This will concatenate the keys for each dictionary and then call {\ttfamily set\+\_\+keys} on each. The result is a vector of new dictionaries with a common set of keys.


\begin{DoxyParams}{参数}
{\em input} & Dictionary columns to match keys. \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
New dictionary columns. 
\end{DoxyReturn}
\Hypertarget{group__dictionary__update_ga9e9d03e8d8183e43b6665911ca740b33}\label{group__dictionary__update_ga9e9d03e8d8183e43b6665911ca740b33} 
\index{Dictionary\_update@{Dictionary\_update}!remove\_keys@{remove\_keys}}
\index{remove\_keys@{remove\_keys}!Dictionary\_update@{Dictionary\_update}}
\doxysubsubsection{\texorpdfstring{remove\_keys()}{remove\_keys()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::dictionary\+::remove\+\_\+keys (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1dictionary__column__view}{dictionary\+\_\+column\+\_\+view}} const \&}]{dictionary\+\_\+column,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{keys\+\_\+to\+\_\+remove,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Create a new dictionary column by removing the specified keys from the existing dictionary\+\_\+column. 

The output column will have the same number of rows as the input column. Null entries from the input column and copied to the output column. The indices are updated to the new positions of the remaining keys. Any indices pointing to removed keys sets that row to null.


\begin{DoxyCode}{0}
\DoxyCodeLine{d1\ =\ \{keys=["{}a"{},\ "{}c"{},\ "{}d"{}],\ indices=[2,\ 0,\ 1,\ 0,\ 2]\}}
\DoxyCodeLine{d2\ =\ remove\_keys(\ d1,\ ["{}b"{},\ "{}c"{}]\ )}
\DoxyCodeLine{d2\ is\ now\ \{keys=["{}a"{},\ "{}d"{}],\ indices=[1,\ 0,\ x,\ 0,\ 1],\ valids=[1,\ 1,\ 0,\ 1,\ 1]\}}

\end{DoxyCode}
 Note that \"{}a\"{} has been removed so output row\mbox{[}2\mbox{]} becomes null.


\begin{DoxyExceptions}{异常}
{\em cudf\+\_\+logic\+\_\+error} & if the keys\+\_\+to\+\_\+remove type does not match the keys type in the dictionary\+\_\+column. \\
\hline
{\em cudf\+\_\+logic\+\_\+error} & if the keys\+\_\+to\+\_\+remove contain nulls.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em dictionary\+\_\+column} & Existing dictionary column. \\
\hline
{\em keys\+\_\+to\+\_\+remove} & The keys to remove from the dictionary\+\_\+column \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
New dictionary column. 
\end{DoxyReturn}
\Hypertarget{group__dictionary__update_ga001e8ae4abb0cc16cf2cc7b82626d286}\label{group__dictionary__update_ga001e8ae4abb0cc16cf2cc7b82626d286} 
\index{Dictionary\_update@{Dictionary\_update}!remove\_unused\_keys@{remove\_unused\_keys}}
\index{remove\_unused\_keys@{remove\_unused\_keys}!Dictionary\_update@{Dictionary\_update}}
\doxysubsubsection{\texorpdfstring{remove\_unused\_keys()}{remove\_unused\_keys()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::dictionary\+::remove\+\_\+unused\+\_\+keys (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1dictionary__column__view}{dictionary\+\_\+column\+\_\+view}} const \&}]{dictionary\+\_\+column,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Create a new dictionary column by removing any keys that are not referenced by any of the indices. 

The indices are updated to the new position values of the remaining keys.


\begin{DoxyCode}{0}
\DoxyCodeLine{d1\ =\ \{["{}a"{},"{}c"{},"{}d"{}],[2,0,2,0]\}}
\DoxyCodeLine{d2\ =\ remove\_unused\_keys(d1)}
\DoxyCodeLine{d2\ is\ now\ \{["{}a"{},"{}d"{}],[1,0,1,0]\}}

\end{DoxyCode}



\begin{DoxyParams}{参数}
{\em dictionary\+\_\+column} & Existing dictionary column. \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
New dictionary column. 
\end{DoxyReturn}
\Hypertarget{group__dictionary__update_ga6b51b2c3778e68a55b0ccc641c0b2b33}\label{group__dictionary__update_ga6b51b2c3778e68a55b0ccc641c0b2b33} 
\index{Dictionary\_update@{Dictionary\_update}!set\_keys@{set\_keys}}
\index{set\_keys@{set\_keys}!Dictionary\_update@{Dictionary\_update}}
\doxysubsubsection{\texorpdfstring{set\_keys()}{set\_keys()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::dictionary\+::set\+\_\+keys (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1dictionary__column__view}{dictionary\+\_\+column\+\_\+view}} const \&}]{dictionary\+\_\+column,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{keys,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Create a new dictionary column by applying only the specified keys to the existing dictionary\+\_\+column. 

Any new elements found in the keys parameter are added to the output dictionary. Any existing keys not in the keys parameter are removed.

The number of rows in the output column will be the same as the number of rows in the input column. Existing null entries are copied to the output column. The indices are updated to reflect the position values of the new keys. Any indices pointing to removed keys sets those rows to null.


\begin{DoxyCode}{0}
\DoxyCodeLine{d1\ =\ \{keys=["{}a"{},\ "{}b"{},\ "{}c"{}],\ indices=[2,\ 0,\ 1,\ 2,\ 1]\}}
\DoxyCodeLine{d2\ =\ set\_keys(existing\_dict,\ ["{}b"{},"{}c"{},"{}d"{}])}
\DoxyCodeLine{d2\ is\ now\ \{keys=["{}b"{},\ "{}c"{},\ "{}d"{}],\ indices=[1,\ x,\ 0,\ 1,\ 0],\ valids=[1,\ 0,\ 1,\ 1,\ 1]\}}

\end{DoxyCode}



\begin{DoxyExceptions}{异常}
{\em cudf\+\_\+logic\+\_\+error} & if the keys type does not match the keys type in the dictionary\+\_\+column. \\
\hline
{\em cudf\+\_\+logic\+\_\+error} & if the keys contain nulls.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em dictionary\+\_\+column} & Existing dictionary column. \\
\hline
{\em keys} & New keys to use for the output column. Must not contain nulls. \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
New dictionary column. 
\end{DoxyReturn}
