\doxysection{cudf\+::reduction 命名空间参考}
\hypertarget{namespacecudf_1_1reduction}{}\label{namespacecudf_1_1reduction}\index{cudf::reduction@{cudf::reduction}}
\doxysubsubsection*{函数}
\begin{DoxyCompactItemize}
\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} $>$ \mbox{\hyperlink{namespacecudf_1_1reduction_a9a503d34c025917580be5ea1a6568ebf}{sum}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&col, \mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} const output\+\_\+dtype, std\+::optional$<$ std\+::reference\+\_\+wrapper$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const $>$ $>$ init, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Computes sum of elements in input column \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} $>$ \mbox{\hyperlink{namespacecudf_1_1reduction_a0c5e479724e5503b71adf996a0b68c04}{min}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&col, \mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} const output\+\_\+dtype, std\+::optional$<$ std\+::reference\+\_\+wrapper$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const $>$ $>$ init, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Computes minimum of elements in input column \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} $>$ \mbox{\hyperlink{namespacecudf_1_1reduction_a29dd4f5e84ae4b9bc228206db25368d4}{max}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&col, \mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} const output\+\_\+dtype, std\+::optional$<$ std\+::reference\+\_\+wrapper$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const $>$ $>$ init, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Computes maximum of elements in input column \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} $>$ \mbox{\hyperlink{namespacecudf_1_1reduction_a64e329fd7a5066a411ae8f3628b9051c}{any}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&col, \mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} const output\+\_\+dtype, std\+::optional$<$ std\+::reference\+\_\+wrapper$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const $>$ $>$ init, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Computes any of elements in input column is true when typecasted to bool \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} $>$ \mbox{\hyperlink{namespacecudf_1_1reduction_ae94ffdbae58138ae7361cf89c88abd5f}{all}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&col, \mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} const output\+\_\+dtype, std\+::optional$<$ std\+::reference\+\_\+wrapper$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const $>$ $>$ init, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Computes all of elements in input column is true when typecasted to bool \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} $>$ \mbox{\hyperlink{namespacecudf_1_1reduction_adc241ef3a5aa4b0cba78ff7810574c96}{product}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&col, \mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} const output\+\_\+dtype, std\+::optional$<$ std\+::reference\+\_\+wrapper$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const $>$ $>$ init, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Computes product of elements in input column \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} $>$ \mbox{\hyperlink{namespacecudf_1_1reduction_a4dcc7883ec004ce6f6e5c758a60efd18}{sum\+\_\+of\+\_\+squares}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&col, \mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} const output\+\_\+dtype, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Computes sum of squares of elements in input column \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} $>$ \mbox{\hyperlink{namespacecudf_1_1reduction_af83cfb3bb693eb3496293af7ffa45fdb}{mean}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&col, \mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} const output\+\_\+dtype, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Computes mean of elements in input column \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} $>$ \mbox{\hyperlink{namespacecudf_1_1reduction_aeede968555f08573779b5505c320aaa8}{variance}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&col, \mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} const output\+\_\+dtype, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{cudf\+::size\+\_\+type}} ddof, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Computes variance of elements in input column \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} $>$ \mbox{\hyperlink{namespacecudf_1_1reduction_a247bd864b5acc46b0e7f0b55b2ef4f60}{standard\+\_\+deviation}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&col, \mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} const output\+\_\+dtype, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{cudf\+::size\+\_\+type}} ddof, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Computes standard deviation of elements in input column \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} $>$ \mbox{\hyperlink{namespacecudf_1_1reduction_ae5d1648bba2207642bdaeede15159517}{nth\+\_\+element}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&col, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} n, \mbox{\hyperlink{group__utility__types_ga1b8cda4afb95a7c42c4679b4fae61009}{null\+\_\+policy}} null\+\_\+handling, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Returns nth element in input column \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} $>$ \mbox{\hyperlink{namespacecudf_1_1reduction_a7104f29005c8ccb64ffcf5058de27057}{collect\+\_\+list}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&col, \mbox{\hyperlink{group__utility__types_ga1b8cda4afb95a7c42c4679b4fae61009}{null\+\_\+policy}} null\+\_\+handling, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Collect input column into a (list) scalar \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} $>$ \mbox{\hyperlink{namespacecudf_1_1reduction_a8209e36dbd687aeb171bf311b2e0608e}{merge\+\_\+lists}} (\mbox{\hyperlink{classcudf_1_1lists__column__view}{lists\+\_\+column\+\_\+view}} const \&col, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Merge a bunch of list scalars into single list scalar \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} $>$ \mbox{\hyperlink{namespacecudf_1_1reduction_a9094ea070874b5604fad9d590c528f68}{collect\+\_\+set}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&col, \mbox{\hyperlink{group__utility__types_ga1b8cda4afb95a7c42c4679b4fae61009}{null\+\_\+policy}} null\+\_\+handling, \mbox{\hyperlink{group__utility__types_ga08a672308cd0f61562410d106b377771}{null\+\_\+equality}} nulls\+\_\+equal, \mbox{\hyperlink{group__utility__types_gae9d1055c69c3089452794783c7c82f83}{nan\+\_\+equality}} nans\+\_\+equal, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Collect input column into a (list) scalar without duplicated elements \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} $>$ \mbox{\hyperlink{namespacecudf_1_1reduction_a46f2323908757ae7f11dcbd1ffc3c8c8}{merge\+\_\+sets}} (\mbox{\hyperlink{classcudf_1_1lists__column__view}{lists\+\_\+column\+\_\+view}} const \&col, \mbox{\hyperlink{group__utility__types_ga08a672308cd0f61562410d106b377771}{null\+\_\+equality}} nulls\+\_\+equal, \mbox{\hyperlink{group__utility__types_gae9d1055c69c3089452794783c7c82f83}{nan\+\_\+equality}} nans\+\_\+equal, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Merge a bunch of list scalars into single list scalar then drop duplicated elements \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1reduction_ae4dbf5143ee605cc85b3b035c08ef77f}{segmented\+\_\+sum}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&col, \mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$ offsets, \mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} const output\+\_\+dtype, \mbox{\hyperlink{group__utility__types_ga1b8cda4afb95a7c42c4679b4fae61009}{null\+\_\+policy}} null\+\_\+handling, std\+::optional$<$ std\+::reference\+\_\+wrapper$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const $>$ $>$ init, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Compute sum of each segment in input column. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1reduction_a289b02e26d06685c96a688cfa839624d}{segmented\+\_\+product}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&col, \mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$ offsets, \mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} const output\+\_\+dtype, \mbox{\hyperlink{group__utility__types_ga1b8cda4afb95a7c42c4679b4fae61009}{null\+\_\+policy}} null\+\_\+handling, std\+::optional$<$ std\+::reference\+\_\+wrapper$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const $>$ $>$ init, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Computes product of each segment in input column. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1reduction_abe78326ad4cf3104d24f1703f6e747c9}{segmented\+\_\+min}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&col, \mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$ offsets, \mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} const output\+\_\+dtype, \mbox{\hyperlink{group__utility__types_ga1b8cda4afb95a7c42c4679b4fae61009}{null\+\_\+policy}} null\+\_\+handling, std\+::optional$<$ std\+::reference\+\_\+wrapper$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const $>$ $>$ init, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Compute minimum of each segment in input column. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1reduction_ae1f92c0c0419d57cb10a36b7187965cf}{segmented\+\_\+max}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&col, \mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$ offsets, \mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} const output\+\_\+dtype, \mbox{\hyperlink{group__utility__types_ga1b8cda4afb95a7c42c4679b4fae61009}{null\+\_\+policy}} null\+\_\+handling, std\+::optional$<$ std\+::reference\+\_\+wrapper$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const $>$ $>$ init, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Compute maximum of each segment in input column. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1reduction_a8f1f323e8eadc88a832efccac948165b}{segmented\+\_\+any}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&col, \mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$ offsets, \mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} const output\+\_\+dtype, \mbox{\hyperlink{group__utility__types_ga1b8cda4afb95a7c42c4679b4fae61009}{null\+\_\+policy}} null\+\_\+handling, std\+::optional$<$ std\+::reference\+\_\+wrapper$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const $>$ $>$ init, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Compute if any of the values in the segment are true when typecasted to bool. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1reduction_a3b5f91f97f6d4b17b435e4f509a57ddd}{segmented\+\_\+all}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&col, \mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$ offsets, \mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} const output\+\_\+dtype, \mbox{\hyperlink{group__utility__types_ga1b8cda4afb95a7c42c4679b4fae61009}{null\+\_\+policy}} null\+\_\+handling, std\+::optional$<$ std\+::reference\+\_\+wrapper$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const $>$ $>$ init, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Compute if all of the values in the segment are true when typecasted to bool. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{函数说明}
\Hypertarget{namespacecudf_1_1reduction_ae94ffdbae58138ae7361cf89c88abd5f}\label{namespacecudf_1_1reduction_ae94ffdbae58138ae7361cf89c88abd5f} 
\index{cudf::reduction@{cudf::reduction}!all@{all}}
\index{all@{all}!cudf::reduction@{cudf::reduction}}
\doxysubsubsection{\texorpdfstring{all()}{all()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} $>$ cudf\+::reduction\+::all (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{col,  }\item[{\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} const}]{output\+\_\+dtype,  }\item[{std\+::optional$<$ std\+::reference\+\_\+wrapper$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const $>$ $>$}]{init,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Computes all of elements in input column is true when typecasted to bool 

If all elements in input column are null, output scalar is null.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if input column type is not convertible to bool \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily output\+\_\+dtype} is not bool\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em col} & input column to compute all \\
\hline
{\em output\+\_\+dtype} & data type of return type and typecast elements of input column \\
\hline
{\em init} & initial value of the all \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches \\
\hline
{\em mr} & Device memory resource used to allocate the returned scalar\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
bool scalar if all of elements is true when typecasted to bool 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1reduction_a64e329fd7a5066a411ae8f3628b9051c}\label{namespacecudf_1_1reduction_a64e329fd7a5066a411ae8f3628b9051c} 
\index{cudf::reduction@{cudf::reduction}!any@{any}}
\index{any@{any}!cudf::reduction@{cudf::reduction}}
\doxysubsubsection{\texorpdfstring{any()}{any()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} $>$ cudf\+::reduction\+::any (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{col,  }\item[{\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} const}]{output\+\_\+dtype,  }\item[{std\+::optional$<$ std\+::reference\+\_\+wrapper$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const $>$ $>$}]{init,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Computes any of elements in input column is true when typecasted to bool 

If all elements in input column are null, output scalar is null.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if input column type is not convertible to bool \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily output\+\_\+dtype} is not bool\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em col} & input column to compute any \\
\hline
{\em output\+\_\+dtype} & data type of return type and typecast elements of input column \\
\hline
{\em init} & initial value of the any \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches \\
\hline
{\em mr} & Device memory resource used to allocate the returned scalar\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
bool scalar if any of elements is true when typecasted to bool 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1reduction_a7104f29005c8ccb64ffcf5058de27057}\label{namespacecudf_1_1reduction_a7104f29005c8ccb64ffcf5058de27057} 
\index{cudf::reduction@{cudf::reduction}!collect\_list@{collect\_list}}
\index{collect\_list@{collect\_list}!cudf::reduction@{cudf::reduction}}
\doxysubsubsection{\texorpdfstring{collect\_list()}{collect\_list()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} $>$ cudf\+::reduction\+::collect\+\_\+list (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{col,  }\item[{\mbox{\hyperlink{group__utility__types_ga1b8cda4afb95a7c42c4679b4fae61009}{null\+\_\+policy}}}]{null\+\_\+handling,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Collect input column into a (list) scalar 


\begin{DoxyParams}{参数}
{\em col} & input column to collect from \\
\hline
{\em null\+\_\+handling} & Indicates if null values will be counted while collecting \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches \\
\hline
{\em mr} & Device memory resource used to allocate the returned scalar\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
collected list as scalar 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1reduction_a9094ea070874b5604fad9d590c528f68}\label{namespacecudf_1_1reduction_a9094ea070874b5604fad9d590c528f68} 
\index{cudf::reduction@{cudf::reduction}!collect\_set@{collect\_set}}
\index{collect\_set@{collect\_set}!cudf::reduction@{cudf::reduction}}
\doxysubsubsection{\texorpdfstring{collect\_set()}{collect\_set()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} $>$ cudf\+::reduction\+::collect\+\_\+set (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{col,  }\item[{\mbox{\hyperlink{group__utility__types_ga1b8cda4afb95a7c42c4679b4fae61009}{null\+\_\+policy}}}]{null\+\_\+handling,  }\item[{\mbox{\hyperlink{group__utility__types_ga08a672308cd0f61562410d106b377771}{null\+\_\+equality}}}]{nulls\+\_\+equal,  }\item[{\mbox{\hyperlink{group__utility__types_gae9d1055c69c3089452794783c7c82f83}{nan\+\_\+equality}}}]{nans\+\_\+equal,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Collect input column into a (list) scalar without duplicated elements 


\begin{DoxyParams}{参数}
{\em col} & input column to collect from \\
\hline
{\em null\+\_\+handling} & Indicates if null values will be counted while collecting \\
\hline
{\em nulls\+\_\+equal} & Indicates if null values will be considered as equal values \\
\hline
{\em nans\+\_\+equal} & Indicates if nan values will be considered as equal values \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches \\
\hline
{\em mr} & Device memory resource used to allocate the returned scalar\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
collected list with unique elements as scalar 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1reduction_a29dd4f5e84ae4b9bc228206db25368d4}\label{namespacecudf_1_1reduction_a29dd4f5e84ae4b9bc228206db25368d4} 
\index{cudf::reduction@{cudf::reduction}!max@{max}}
\index{max@{max}!cudf::reduction@{cudf::reduction}}
\doxysubsubsection{\texorpdfstring{max()}{max()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} $>$ cudf\+::reduction\+::max (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{col,  }\item[{\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} const}]{output\+\_\+dtype,  }\item[{std\+::optional$<$ std\+::reference\+\_\+wrapper$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const $>$ $>$}]{init,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Computes maximum of elements in input column 

If all elements in input column are null, output scalar is null.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if input column type is convertible to {\ttfamily output\+\_\+dtype}\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em col} & input column to compute maximum \\
\hline
{\em output\+\_\+dtype} & data type of return type and typecast elements of input column \\
\hline
{\em init} & initial value of the maximum \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches \\
\hline
{\em mr} & Device memory resource used to allocate the returned scalar\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Maximum element as scalar of type {\ttfamily output\+\_\+dtype} 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1reduction_af83cfb3bb693eb3496293af7ffa45fdb}\label{namespacecudf_1_1reduction_af83cfb3bb693eb3496293af7ffa45fdb} 
\index{cudf::reduction@{cudf::reduction}!mean@{mean}}
\index{mean@{mean}!cudf::reduction@{cudf::reduction}}
\doxysubsubsection{\texorpdfstring{mean()}{mean()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} $>$ cudf\+::reduction\+::mean (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{col,  }\item[{\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} const}]{output\+\_\+dtype,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Computes mean of elements in input column 

If all elements in input column are null, output scalar is null.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if input column type is not arithmetic type \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily output\+\_\+dtype} is not floating point type\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em col} & input column to compute mean \\
\hline
{\em output\+\_\+dtype} & data type of return type and typecast elements of input column \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches \\
\hline
{\em mr} & Device memory resource used to allocate the returned scalar\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Mean as scalar of type {\ttfamily output\+\_\+dtype} 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1reduction_a8209e36dbd687aeb171bf311b2e0608e}\label{namespacecudf_1_1reduction_a8209e36dbd687aeb171bf311b2e0608e} 
\index{cudf::reduction@{cudf::reduction}!merge\_lists@{merge\_lists}}
\index{merge\_lists@{merge\_lists}!cudf::reduction@{cudf::reduction}}
\doxysubsubsection{\texorpdfstring{merge\_lists()}{merge\_lists()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} $>$ cudf\+::reduction\+::merge\+\_\+lists (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1lists__column__view}{lists\+\_\+column\+\_\+view}} const \&}]{col,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Merge a bunch of list scalars into single list scalar 


\begin{DoxyParams}{参数}
{\em col} & input list column representing numbers of list scalars to be merged \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches \\
\hline
{\em mr} & Device memory resource used to allocate the returned scalar\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
merged list as scalar 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1reduction_a46f2323908757ae7f11dcbd1ffc3c8c8}\label{namespacecudf_1_1reduction_a46f2323908757ae7f11dcbd1ffc3c8c8} 
\index{cudf::reduction@{cudf::reduction}!merge\_sets@{merge\_sets}}
\index{merge\_sets@{merge\_sets}!cudf::reduction@{cudf::reduction}}
\doxysubsubsection{\texorpdfstring{merge\_sets()}{merge\_sets()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} $>$ cudf\+::reduction\+::merge\+\_\+sets (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1lists__column__view}{lists\+\_\+column\+\_\+view}} const \&}]{col,  }\item[{\mbox{\hyperlink{group__utility__types_ga08a672308cd0f61562410d106b377771}{null\+\_\+equality}}}]{nulls\+\_\+equal,  }\item[{\mbox{\hyperlink{group__utility__types_gae9d1055c69c3089452794783c7c82f83}{nan\+\_\+equality}}}]{nans\+\_\+equal,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Merge a bunch of list scalars into single list scalar then drop duplicated elements 


\begin{DoxyParams}{参数}
{\em col} & input list column representing numbers of list scalars to be merged \\
\hline
{\em nulls\+\_\+equal} & Indicates if null values will be considered as equal values \\
\hline
{\em nans\+\_\+equal} & Indicates if nan values will be considered as equal values \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches \\
\hline
{\em mr} & Device memory resource used to allocate the returned scalar\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
collected list with unique elements as scalar 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1reduction_a0c5e479724e5503b71adf996a0b68c04}\label{namespacecudf_1_1reduction_a0c5e479724e5503b71adf996a0b68c04} 
\index{cudf::reduction@{cudf::reduction}!min@{min}}
\index{min@{min}!cudf::reduction@{cudf::reduction}}
\doxysubsubsection{\texorpdfstring{min()}{min()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} $>$ cudf\+::reduction\+::min (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{col,  }\item[{\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} const}]{output\+\_\+dtype,  }\item[{std\+::optional$<$ std\+::reference\+\_\+wrapper$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const $>$ $>$}]{init,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Computes minimum of elements in input column 

If all elements in input column are null, output scalar is null.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if input column type is convertible to {\ttfamily output\+\_\+dtype}\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em col} & input column to compute minimum \\
\hline
{\em output\+\_\+dtype} & data type of return type and typecast elements of input column \\
\hline
{\em init} & initial value of the minimum \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches \\
\hline
{\em mr} & Device memory resource used to allocate the returned scalar\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Minimum element as scalar of type {\ttfamily output\+\_\+dtype} 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1reduction_ae5d1648bba2207642bdaeede15159517}\label{namespacecudf_1_1reduction_ae5d1648bba2207642bdaeede15159517} 
\index{cudf::reduction@{cudf::reduction}!nth\_element@{nth\_element}}
\index{nth\_element@{nth\_element}!cudf::reduction@{cudf::reduction}}
\doxysubsubsection{\texorpdfstring{nth\_element()}{nth\_element()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} $>$ cudf\+::reduction\+::nth\+\_\+element (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{col,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{n,  }\item[{\mbox{\hyperlink{group__utility__types_ga1b8cda4afb95a7c42c4679b4fae61009}{null\+\_\+policy}}}]{null\+\_\+handling,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Returns nth element in input column 

A negative value {\ttfamily n} is interpreted as {\ttfamily n+count}, where {\ttfamily count} is the number of valid elements in the input column if {\ttfamily null\+\_\+handling} is {\ttfamily \doxylink{group__utility__types_gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8}{null\+\_\+policy\+::\+EXCLUDE}}, else {\ttfamily col.\+size()}.

If all elements in input column are null, output scalar is null.

\begin{DoxyWarning}{警告}
This function is expensive (invokes a kernel launch). So, it is not recommended to be used in performance sensitive code or inside a loop. It takes O({\ttfamily col.\+size()}) time and space complexity for nullable column with {\ttfamily \doxylink{group__utility__types_gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8}{null\+\_\+policy\+::\+EXCLUDE}} as input.
\end{DoxyWarning}

\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if n falls outside the range {\ttfamily \mbox{[}-\/count, count)} where {\ttfamily count} is the number of valid \texorpdfstring{$\ast$}{*} elements in the input column if {\ttfamily null\+\_\+handling} is {\ttfamily \doxylink{group__utility__types_gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8}{null\+\_\+policy\+::\+EXCLUDE}}, else {\ttfamily col.\+size()}.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em col} & input column to get nth element from \\
\hline
{\em n} & index of element to get \\
\hline
{\em null\+\_\+handling} & Indicates if null values will be counted while indexing \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches \\
\hline
{\em mr} & Device memory resource used to allocate the returned scalar\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
nth element as scalar 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1reduction_adc241ef3a5aa4b0cba78ff7810574c96}\label{namespacecudf_1_1reduction_adc241ef3a5aa4b0cba78ff7810574c96} 
\index{cudf::reduction@{cudf::reduction}!product@{product}}
\index{product@{product}!cudf::reduction@{cudf::reduction}}
\doxysubsubsection{\texorpdfstring{product()}{product()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} $>$ cudf\+::reduction\+::product (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{col,  }\item[{\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} const}]{output\+\_\+dtype,  }\item[{std\+::optional$<$ std\+::reference\+\_\+wrapper$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const $>$ $>$}]{init,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Computes product of elements in input column 

If all elements in input column are null, output scalar is null.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if input column type is not convertible to {\ttfamily output\+\_\+dtype} \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily output\+\_\+dtype} is not an arithmetic type\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em col} & input column to compute product \\
\hline
{\em output\+\_\+dtype} & data type of return type and typecast elements of input column \\
\hline
{\em init} & initial value of the product \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches \\
\hline
{\em mr} & Device memory resource used to allocate the returned scalar\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Product as scalar of type {\ttfamily output\+\_\+dtype} 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1reduction_a3b5f91f97f6d4b17b435e4f509a57ddd}\label{namespacecudf_1_1reduction_a3b5f91f97f6d4b17b435e4f509a57ddd} 
\index{cudf::reduction@{cudf::reduction}!segmented\_all@{segmented\_all}}
\index{segmented\_all@{segmented\_all}!cudf::reduction@{cudf::reduction}}
\doxysubsubsection{\texorpdfstring{segmented\_all()}{segmented\_all()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::reduction\+::segmented\+\_\+all (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{col,  }\item[{\mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$}]{offsets,  }\item[{\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} const}]{output\+\_\+dtype,  }\item[{\mbox{\hyperlink{group__utility__types_ga1b8cda4afb95a7c42c4679b4fae61009}{null\+\_\+policy}}}]{null\+\_\+handling,  }\item[{std\+::optional$<$ std\+::reference\+\_\+wrapper$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const $>$ $>$}]{init,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Compute if all of the values in the segment are true when typecasted to bool. 

If an input segment is empty, the segment result is null.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if input column type is not convertible to bool. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily output\+\_\+dtype} is not bool8.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em col} & Input column to compute all \\
\hline
{\em offsets} & Indices to identify segment boundaries \\
\hline
{\em output\+\_\+dtype} & Data type of return type and typecast elements of input column \\
\hline
{\em null\+\_\+handling} & If {\ttfamily \doxylink{group__utility__types_gga1b8cda4afb95a7c42c4679b4fae61009a04ff6a9583ba9957ebe1128d0f988ad8}{null\+\_\+policy\+::\+INCLUDE}}, all elements in a segment must be valid for the reduced value to be valid. If {\ttfamily \doxylink{group__utility__types_gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8}{null\+\_\+policy\+::\+EXCLUDE}}, the reduced value is valid if any element in the segment is valid. \\
\hline
{\em init} & Initial value of each all \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches \\
\hline
{\em mr} & Device memory resource used to allocate the returned scalar\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Column of bool8 for the results of the segments 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1reduction_a8f1f323e8eadc88a832efccac948165b}\label{namespacecudf_1_1reduction_a8f1f323e8eadc88a832efccac948165b} 
\index{cudf::reduction@{cudf::reduction}!segmented\_any@{segmented\_any}}
\index{segmented\_any@{segmented\_any}!cudf::reduction@{cudf::reduction}}
\doxysubsubsection{\texorpdfstring{segmented\_any()}{segmented\_any()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::reduction\+::segmented\+\_\+any (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{col,  }\item[{\mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$}]{offsets,  }\item[{\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} const}]{output\+\_\+dtype,  }\item[{\mbox{\hyperlink{group__utility__types_ga1b8cda4afb95a7c42c4679b4fae61009}{null\+\_\+policy}}}]{null\+\_\+handling,  }\item[{std\+::optional$<$ std\+::reference\+\_\+wrapper$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const $>$ $>$}]{init,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Compute if any of the values in the segment are true when typecasted to bool. 

If an input segment is empty, the segment result is null.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if input column type is not convertible to bool. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily output\+\_\+dtype} is not bool8.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em col} & Input column to compute any \\
\hline
{\em offsets} & Indices to identify segment boundaries \\
\hline
{\em output\+\_\+dtype} & Data type of return type and typecast elements of input column \\
\hline
{\em null\+\_\+handling} & If {\ttfamily \doxylink{group__utility__types_gga1b8cda4afb95a7c42c4679b4fae61009a04ff6a9583ba9957ebe1128d0f988ad8}{null\+\_\+policy\+::\+INCLUDE}}, all elements in a segment must be valid for the reduced value to be valid. If {\ttfamily \doxylink{group__utility__types_gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8}{null\+\_\+policy\+::\+EXCLUDE}}, the reduced value is valid if any element in the segment is valid. \\
\hline
{\em init} & Initial value of each any \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches \\
\hline
{\em mr} & Device memory resource used to allocate the returned scalar\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Column of bool8 for the results of the segments 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1reduction_ae1f92c0c0419d57cb10a36b7187965cf}\label{namespacecudf_1_1reduction_ae1f92c0c0419d57cb10a36b7187965cf} 
\index{cudf::reduction@{cudf::reduction}!segmented\_max@{segmented\_max}}
\index{segmented\_max@{segmented\_max}!cudf::reduction@{cudf::reduction}}
\doxysubsubsection{\texorpdfstring{segmented\_max()}{segmented\_max()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::reduction\+::segmented\+\_\+max (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{col,  }\item[{\mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$}]{offsets,  }\item[{\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} const}]{output\+\_\+dtype,  }\item[{\mbox{\hyperlink{group__utility__types_ga1b8cda4afb95a7c42c4679b4fae61009}{null\+\_\+policy}}}]{null\+\_\+handling,  }\item[{std\+::optional$<$ std\+::reference\+\_\+wrapper$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const $>$ $>$}]{init,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Compute maximum of each segment in input column. 

If an input segment is empty, the segment result is null.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if input column type is convertible to {\ttfamily output\+\_\+dtype}.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em col} & Input column to compute maximum \\
\hline
{\em offsets} & Indices to identify segment boundaries \\
\hline
{\em output\+\_\+dtype} & Data type of return type and typecast elements of input column \\
\hline
{\em null\+\_\+handling} & If {\ttfamily \doxylink{group__utility__types_gga1b8cda4afb95a7c42c4679b4fae61009a04ff6a9583ba9957ebe1128d0f988ad8}{null\+\_\+policy\+::\+INCLUDE}}, all elements in a segment must be valid for the reduced value to be valid. If {\ttfamily \doxylink{group__utility__types_gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8}{null\+\_\+policy\+::\+EXCLUDE}}, the reduced value is valid if any element in the segment is valid. \\
\hline
{\em init} & Initial value of each maximum \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches \\
\hline
{\em mr} & Device memory resource used to allocate the returned scalar\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Maximums of segments in type {\ttfamily output\+\_\+dtype} 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1reduction_abe78326ad4cf3104d24f1703f6e747c9}\label{namespacecudf_1_1reduction_abe78326ad4cf3104d24f1703f6e747c9} 
\index{cudf::reduction@{cudf::reduction}!segmented\_min@{segmented\_min}}
\index{segmented\_min@{segmented\_min}!cudf::reduction@{cudf::reduction}}
\doxysubsubsection{\texorpdfstring{segmented\_min()}{segmented\_min()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::reduction\+::segmented\+\_\+min (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{col,  }\item[{\mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$}]{offsets,  }\item[{\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} const}]{output\+\_\+dtype,  }\item[{\mbox{\hyperlink{group__utility__types_ga1b8cda4afb95a7c42c4679b4fae61009}{null\+\_\+policy}}}]{null\+\_\+handling,  }\item[{std\+::optional$<$ std\+::reference\+\_\+wrapper$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const $>$ $>$}]{init,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Compute minimum of each segment in input column. 

If an input segment is empty, the segment result is null.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if input column type is convertible to {\ttfamily output\+\_\+dtype}.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em col} & Input column to compute minimum \\
\hline
{\em offsets} & Indices to identify segment boundaries \\
\hline
{\em output\+\_\+dtype} & Data type of return type and typecast elements of input column \\
\hline
{\em null\+\_\+handling} & If {\ttfamily \doxylink{group__utility__types_gga1b8cda4afb95a7c42c4679b4fae61009a04ff6a9583ba9957ebe1128d0f988ad8}{null\+\_\+policy\+::\+INCLUDE}}, all elements in a segment must be valid for the reduced value to be valid. If {\ttfamily \doxylink{group__utility__types_gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8}{null\+\_\+policy\+::\+EXCLUDE}}, the reduced value is valid if any element in the segment is valid. \\
\hline
{\em init} & Initial value of each minimum \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches \\
\hline
{\em mr} & Device memory resource used to allocate the returned scalar\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Minimums of segments in type {\ttfamily output\+\_\+dtype} 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1reduction_a289b02e26d06685c96a688cfa839624d}\label{namespacecudf_1_1reduction_a289b02e26d06685c96a688cfa839624d} 
\index{cudf::reduction@{cudf::reduction}!segmented\_product@{segmented\_product}}
\index{segmented\_product@{segmented\_product}!cudf::reduction@{cudf::reduction}}
\doxysubsubsection{\texorpdfstring{segmented\_product()}{segmented\_product()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::reduction\+::segmented\+\_\+product (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{col,  }\item[{\mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$}]{offsets,  }\item[{\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} const}]{output\+\_\+dtype,  }\item[{\mbox{\hyperlink{group__utility__types_ga1b8cda4afb95a7c42c4679b4fae61009}{null\+\_\+policy}}}]{null\+\_\+handling,  }\item[{std\+::optional$<$ std\+::reference\+\_\+wrapper$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const $>$ $>$}]{init,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Computes product of each segment in input column. 

If an input segment is empty, the segment result is null.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if input column type is not convertible to {\ttfamily output\+\_\+dtype}. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily output\+\_\+dtype} is not an arithmetic type.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em col} & Input column to compute product \\
\hline
{\em offsets} & Indices to identify segment boundaries \\
\hline
{\em output\+\_\+dtype} & data type of return type and typecast elements of input column \\
\hline
{\em null\+\_\+handling} & If {\ttfamily \doxylink{group__utility__types_gga1b8cda4afb95a7c42c4679b4fae61009a04ff6a9583ba9957ebe1128d0f988ad8}{null\+\_\+policy\+::\+INCLUDE}}, all elements in a segment must be valid for the reduced value to be valid. If {\ttfamily \doxylink{group__utility__types_gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8}{null\+\_\+policy\+::\+EXCLUDE}}, the reduced value is valid if any element in the segment is valid. \\
\hline
{\em init} & Initial value of each product \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches \\
\hline
{\em mr} & Device memory resource used to allocate the returned scalar\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Product as scalar of type {\ttfamily output\+\_\+dtype} 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1reduction_ae4dbf5143ee605cc85b3b035c08ef77f}\label{namespacecudf_1_1reduction_ae4dbf5143ee605cc85b3b035c08ef77f} 
\index{cudf::reduction@{cudf::reduction}!segmented\_sum@{segmented\_sum}}
\index{segmented\_sum@{segmented\_sum}!cudf::reduction@{cudf::reduction}}
\doxysubsubsection{\texorpdfstring{segmented\_sum()}{segmented\_sum()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::reduction\+::segmented\+\_\+sum (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{col,  }\item[{\mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$}]{offsets,  }\item[{\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} const}]{output\+\_\+dtype,  }\item[{\mbox{\hyperlink{group__utility__types_ga1b8cda4afb95a7c42c4679b4fae61009}{null\+\_\+policy}}}]{null\+\_\+handling,  }\item[{std\+::optional$<$ std\+::reference\+\_\+wrapper$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const $>$ $>$}]{init,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Compute sum of each segment in input column. 

If an input segment is empty, the segment result is null.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if input column type is not convertible to {\ttfamily output\+\_\+dtype}. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily output\+\_\+dtype} is not an arithmetic type.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em col} & Input column to compute sum \\
\hline
{\em offsets} & Indices to identify segment boundaries \\
\hline
{\em output\+\_\+dtype} & Data type of return type and typecast elements of input column \\
\hline
{\em null\+\_\+handling} & If {\ttfamily \doxylink{group__utility__types_gga1b8cda4afb95a7c42c4679b4fae61009a04ff6a9583ba9957ebe1128d0f988ad8}{null\+\_\+policy\+::\+INCLUDE}}, all elements in a segment must be valid for the reduced value to be valid. If {\ttfamily \doxylink{group__utility__types_gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8}{null\+\_\+policy\+::\+EXCLUDE}}, the reduced value is valid if any element in the segment is valid. \\
\hline
{\em init} & Initial value of each sum \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Sums of segments in type {\ttfamily output\+\_\+dtype} 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1reduction_a247bd864b5acc46b0e7f0b55b2ef4f60}\label{namespacecudf_1_1reduction_a247bd864b5acc46b0e7f0b55b2ef4f60} 
\index{cudf::reduction@{cudf::reduction}!standard\_deviation@{standard\_deviation}}
\index{standard\_deviation@{standard\_deviation}!cudf::reduction@{cudf::reduction}}
\doxysubsubsection{\texorpdfstring{standard\_deviation()}{standard\_deviation()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} $>$ cudf\+::reduction\+::standard\+\_\+deviation (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{col,  }\item[{\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} const}]{output\+\_\+dtype,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{cudf\+::size\+\_\+type}}}]{ddof,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Computes standard deviation of elements in input column 

If all elements in input column are null, output scalar is null.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if input column type is not arithmetic type \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily output\+\_\+dtype} is not floating point type\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em col} & input column to compute standard deviation \\
\hline
{\em output\+\_\+dtype} & data type of return type and typecast elements of input column \\
\hline
{\em ddof} & Delta degrees of freedom. The divisor used is N -\/ ddof, where N represents the number of elements. \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches \\
\hline
{\em mr} & Device memory resource used to allocate the returned scalar\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Standard deviation as scalar of type {\ttfamily output\+\_\+dtype} 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1reduction_a9a503d34c025917580be5ea1a6568ebf}\label{namespacecudf_1_1reduction_a9a503d34c025917580be5ea1a6568ebf} 
\index{cudf::reduction@{cudf::reduction}!sum@{sum}}
\index{sum@{sum}!cudf::reduction@{cudf::reduction}}
\doxysubsubsection{\texorpdfstring{sum()}{sum()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} $>$ cudf\+::reduction\+::sum (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{col,  }\item[{\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} const}]{output\+\_\+dtype,  }\item[{std\+::optional$<$ std\+::reference\+\_\+wrapper$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const $>$ $>$}]{init,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Computes sum of elements in input column 

If all elements in input column are null, output scalar is null.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if input column type is not convertible to {\ttfamily output\+\_\+dtype} \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily output\+\_\+dtype} is not an arithmetic type\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em col} & input column to compute sum \\
\hline
{\em output\+\_\+dtype} & data type of return type and typecast elements of input column \\
\hline
{\em init} & initial value of the sum \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches \\
\hline
{\em mr} & Device memory resource used to allocate the returned scalar\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Sum as scalar of type {\ttfamily output\+\_\+dtype} 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1reduction_a4dcc7883ec004ce6f6e5c758a60efd18}\label{namespacecudf_1_1reduction_a4dcc7883ec004ce6f6e5c758a60efd18} 
\index{cudf::reduction@{cudf::reduction}!sum\_of\_squares@{sum\_of\_squares}}
\index{sum\_of\_squares@{sum\_of\_squares}!cudf::reduction@{cudf::reduction}}
\doxysubsubsection{\texorpdfstring{sum\_of\_squares()}{sum\_of\_squares()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} $>$ cudf\+::reduction\+::sum\+\_\+of\+\_\+squares (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{col,  }\item[{\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} const}]{output\+\_\+dtype,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Computes sum of squares of elements in input column 

If all elements in input column are null, output scalar is null.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if input column type is not convertible to {\ttfamily output\+\_\+dtype} \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily output\+\_\+dtype} is not an arithmetic type\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em col} & input column to compute sum of squares \\
\hline
{\em output\+\_\+dtype} & data type of return type and typecast elements of input column \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches \\
\hline
{\em mr} & Device memory resource used to allocate the returned scalar\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Sum of squares as scalar of type {\ttfamily output\+\_\+dtype} 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1reduction_aeede968555f08573779b5505c320aaa8}\label{namespacecudf_1_1reduction_aeede968555f08573779b5505c320aaa8} 
\index{cudf::reduction@{cudf::reduction}!variance@{variance}}
\index{variance@{variance}!cudf::reduction@{cudf::reduction}}
\doxysubsubsection{\texorpdfstring{variance()}{variance()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} $>$ cudf\+::reduction\+::variance (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{col,  }\item[{\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} const}]{output\+\_\+dtype,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{cudf\+::size\+\_\+type}}}]{ddof,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Computes variance of elements in input column 

If all elements in input column are null, output scalar is null.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if input column type is not arithmetic type \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily output\+\_\+dtype} is not floating point type\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em col} & input column to compute variance \\
\hline
{\em output\+\_\+dtype} & data type of return type and typecast elements of input column \\
\hline
{\em ddof} & Delta degrees of freedom. The divisor used is N -\/ ddof, where N represents the number of elements. \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches \\
\hline
{\em mr} & Device memory resource used to allocate the returned scalar\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Variance as scalar of type {\ttfamily output\+\_\+dtype} 
\end{DoxyReturn}
