\doxysection{Factories}
\hypertarget{group__column__factories}{}\label{group__column__factories}\index{Factories@{Factories}}
\doxysubsubsection*{文件}
\begin{DoxyCompactItemize}
\item 
文件 \mbox{\hyperlink{column__factories_8hpp}{column\+\_\+factories.\+hpp}}
\begin{DoxyCompactList}\small\item\em Column factory APIs \end{DoxyCompactList}\item 
文件 \mbox{\hyperlink{dictionary__factories_8hpp}{dictionary\+\_\+factories.\+hpp}}
\end{DoxyCompactItemize}
\doxysubsubsection*{函数}
\begin{DoxyCompactItemize}
\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__column__factories_gaa80de7d88a408ab660541a4a3b214ead}{cudf\+::make\+\_\+empty\+\_\+column}} (\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} type)
\begin{DoxyCompactList}\small\item\em Creates an empty column of the specified {\ttfamily type} \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__column__factories_ga890d1519f4d245dca1f33d09b90f7ca5}{cudf\+::make\+\_\+empty\+\_\+column}} (\mbox{\hyperlink{group__utility__types_gadf077607da617d1dadcc5417e2783539}{type\+\_\+id}} id)
\begin{DoxyCompactList}\small\item\em Creates an empty column of the specified type. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__column__factories_ga84a9f9deecdbac612cb79cec10a1cff6}{cudf\+::make\+\_\+numeric\+\_\+column}} (\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} type, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} size, \mbox{\hyperlink{group__utility__types_ga4daf20c000ab374d76f4d56f0ddb7b26}{mask\+\_\+state}} state=\mbox{\hyperlink{group__utility__types_gga4daf20c000ab374d76f4d56f0ddb7b26a628732521c22dcf8a24bf1a0326bde80}{mask\+\_\+state\+::\+UNALLOCATED}}, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Construct column with sufficient uninitialized storage to hold {\ttfamily size} elements of the specified numeric {\ttfamily \doxylink{classcudf_1_1data__type}{data\+\_\+type}} with an optional null mask. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename B $>$ }\\std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__column__factories_gad908ea3b27809643a5459d191e52ac91}{cudf\+::make\+\_\+numeric\+\_\+column}} (\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} type, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} size, B \&\&null\+\_\+mask, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} null\+\_\+count=\mbox{\hyperlink{group__utility__types_ga0eece3f40ff89fe8f1117097d86913b7}{cudf\+::\+UNKNOWN\+\_\+\+NULL\+\_\+\+COUNT}}, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Construct column with sufficient uninitialized storage to hold {\ttfamily size} elements of the specified numeric {\ttfamily \doxylink{classcudf_1_1data__type}{data\+\_\+type}} with a null mask. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__column__factories_ga9329fc1ef9d96f36d71eab418926c206}{cudf\+::make\+\_\+fixed\+\_\+point\+\_\+column}} (\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} type, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} size, \mbox{\hyperlink{group__utility__types_ga4daf20c000ab374d76f4d56f0ddb7b26}{mask\+\_\+state}} state=\mbox{\hyperlink{group__utility__types_gga4daf20c000ab374d76f4d56f0ddb7b26a628732521c22dcf8a24bf1a0326bde80}{mask\+\_\+state\+::\+UNALLOCATED}}, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Construct column with sufficient uninitialized storage to hold {\ttfamily size} elements of the specified {\ttfamily fixed\+\_\+point} {\ttfamily \doxylink{classcudf_1_1data__type}{data\+\_\+type}} with an optional null mask. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename B $>$ }\\std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__column__factories_gae70cbf7bed0d8e08087cbef612d0affb}{cudf\+::make\+\_\+fixed\+\_\+point\+\_\+column}} (\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} type, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} size, B \&\&null\+\_\+mask, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} null\+\_\+count=\mbox{\hyperlink{group__utility__types_ga0eece3f40ff89fe8f1117097d86913b7}{cudf\+::\+UNKNOWN\+\_\+\+NULL\+\_\+\+COUNT}}, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Construct column with sufficient uninitialized storage to hold {\ttfamily size} elements of the specified {\ttfamily fixed\+\_\+point} {\ttfamily \doxylink{classcudf_1_1data__type}{data\+\_\+type}} with a null mask. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__column__factories_gad3dd1ff4b11ca9c70322004ea72fdf0d}{cudf\+::make\+\_\+timestamp\+\_\+column}} (\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} type, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} size, \mbox{\hyperlink{group__utility__types_ga4daf20c000ab374d76f4d56f0ddb7b26}{mask\+\_\+state}} state=\mbox{\hyperlink{group__utility__types_gga4daf20c000ab374d76f4d56f0ddb7b26a628732521c22dcf8a24bf1a0326bde80}{mask\+\_\+state\+::\+UNALLOCATED}}, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Construct column with sufficient uninitialized storage to hold {\ttfamily size} elements of the specified timestamp {\ttfamily \doxylink{classcudf_1_1data__type}{data\+\_\+type}} with an optional null mask. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename B $>$ }\\std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__column__factories_ga82d67ff8acbde7370b6dfa4eeaf63893}{cudf\+::make\+\_\+timestamp\+\_\+column}} (\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} type, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} size, B \&\&null\+\_\+mask, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} null\+\_\+count=\mbox{\hyperlink{group__utility__types_ga0eece3f40ff89fe8f1117097d86913b7}{cudf\+::\+UNKNOWN\+\_\+\+NULL\+\_\+\+COUNT}}, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Construct column with sufficient uninitialized storage to hold {\ttfamily size} elements of the specified timestamp {\ttfamily \doxylink{classcudf_1_1data__type}{data\+\_\+type}} with a null mask. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__column__factories_ga7b83c4013e49cc28c0a2a74569853228}{cudf\+::make\+\_\+duration\+\_\+column}} (\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} type, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} size, \mbox{\hyperlink{group__utility__types_ga4daf20c000ab374d76f4d56f0ddb7b26}{mask\+\_\+state}} state=\mbox{\hyperlink{group__utility__types_gga4daf20c000ab374d76f4d56f0ddb7b26a628732521c22dcf8a24bf1a0326bde80}{mask\+\_\+state\+::\+UNALLOCATED}}, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Construct column with sufficient uninitialized storage to hold {\ttfamily size} elements of the specified duration {\ttfamily \doxylink{classcudf_1_1data__type}{data\+\_\+type}} with an optional null mask. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename B $>$ }\\std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__column__factories_ga0720e031f009c728943536a1cc9d361d}{cudf\+::make\+\_\+duration\+\_\+column}} (\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} type, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} size, B \&\&null\+\_\+mask, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} null\+\_\+count=\mbox{\hyperlink{group__utility__types_ga0eece3f40ff89fe8f1117097d86913b7}{cudf\+::\+UNKNOWN\+\_\+\+NULL\+\_\+\+COUNT}}, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Construct column with sufficient uninitialized storage to hold {\ttfamily size} elements of the specified duration {\ttfamily \doxylink{classcudf_1_1data__type}{data\+\_\+type}} with a null mask. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__column__factories_gac251edf105c64ee963df5e53eeffd091}{cudf\+::make\+\_\+fixed\+\_\+width\+\_\+column}} (\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} type, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} size, \mbox{\hyperlink{group__utility__types_ga4daf20c000ab374d76f4d56f0ddb7b26}{mask\+\_\+state}} state=\mbox{\hyperlink{group__utility__types_gga4daf20c000ab374d76f4d56f0ddb7b26a628732521c22dcf8a24bf1a0326bde80}{mask\+\_\+state\+::\+UNALLOCATED}}, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Construct column with sufficient uninitialized storage to hold {\ttfamily size} elements of the specified fixed width {\ttfamily \doxylink{classcudf_1_1data__type}{data\+\_\+type}} with an optional null mask. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename B $>$ }\\std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__column__factories_gabe7756d1ac2c1027c2d1403054f482cb}{cudf\+::make\+\_\+fixed\+\_\+width\+\_\+column}} (\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} type, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} size, B \&\&null\+\_\+mask, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} null\+\_\+count=\mbox{\hyperlink{group__utility__types_ga0eece3f40ff89fe8f1117097d86913b7}{cudf\+::\+UNKNOWN\+\_\+\+NULL\+\_\+\+COUNT}}, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Construct column with sufficient uninitialized storage to hold {\ttfamily size} elements of the specified fixed width {\ttfamily \doxylink{classcudf_1_1data__type}{data\+\_\+type}} with a null mask. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__column__factories_ga1b4c7323b0728830bccaf9fd8785ce18}{cudf\+::make\+\_\+strings\+\_\+column}} (\mbox{\hyperlink{structcudf_1_1device__span}{cudf\+::device\+\_\+span}}$<$ thrust\+::pair$<$ const char \texorpdfstring{$\ast$}{*}, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ const $>$ strings, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Construct a STRING type column given a device span of pointer/size pairs. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__column__factories_gac63c5f712a69911f57e1a25ea19aa4b9}{cudf\+::make\+\_\+strings\+\_\+column}} (\mbox{\hyperlink{structcudf_1_1device__span}{cudf\+::device\+\_\+span}}$<$ \mbox{\hyperlink{classcudf_1_1string__view}{string\+\_\+view}} const $>$ string\+\_\+views, const \mbox{\hyperlink{classcudf_1_1string__view}{string\+\_\+view}} null\+\_\+placeholder, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Construct a STRING type column given a device span of \doxylink{classcudf_1_1string__view}{string\+\_\+view}. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__column__factories_ga344b235a4e1cbecd985858e64d8b2075}{cudf\+::make\+\_\+strings\+\_\+column}} (\mbox{\hyperlink{structcudf_1_1device__span}{cudf\+::device\+\_\+span}}$<$ char const $>$ strings, \mbox{\hyperlink{structcudf_1_1device__span}{cudf\+::device\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$ offsets, \mbox{\hyperlink{structcudf_1_1device__span}{cudf\+::device\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga1d17001baf070a639c3a5e8ed8c46d34}{bitmask\+\_\+type}} const $>$ null\+\_\+mask=\{\}, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} null\+\_\+count=\mbox{\hyperlink{group__utility__types_ga0eece3f40ff89fe8f1117097d86913b7}{cudf\+::\+UNKNOWN\+\_\+\+NULL\+\_\+\+COUNT}}, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Construct a STRING type column given a device span of chars encoded as UTF-\/8, a device span of byte offsets identifying individual strings within the char vector, and an optional null bitmask. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__column__factories_gace1c51569535b5ea5d23805470cfe8b7}{cudf\+::make\+\_\+strings\+\_\+column}} (\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} num\+\_\+strings, std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ offsets\+\_\+column, std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ chars\+\_\+column, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} null\+\_\+count, rmm\+::device\+\_\+buffer \&\&null\+\_\+mask)
\begin{DoxyCompactList}\small\item\em Construct a STRING type column given offsets column, chars columns, and null mask and null count. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__column__factories_ga12fdea6621b2945532151737c740a368}{cudf\+::make\+\_\+strings\+\_\+column}} (\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} num\+\_\+strings, rmm\+::device\+\_\+uvector$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ \&\&offsets, rmm\+::device\+\_\+uvector$<$ char $>$ \&\&chars, rmm\+::device\+\_\+buffer \&\&null\+\_\+mask=\{\}, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} null\+\_\+count=\mbox{\hyperlink{group__utility__types_ga0eece3f40ff89fe8f1117097d86913b7}{cudf\+::\+UNKNOWN\+\_\+\+NULL\+\_\+\+COUNT}})
\begin{DoxyCompactList}\small\item\em Construct a STRING type column given offsets, columns, and optional null count and null mask. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{cudf\+::column}} $>$ \mbox{\hyperlink{group__column__factories_gaedfbe8e49523fcea96952534c6fa44b2}{cudf\+::make\+\_\+lists\+\_\+column}} (\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} num\+\_\+rows, std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ offsets\+\_\+column, std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ child\+\_\+column, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} null\+\_\+count, rmm\+::device\+\_\+buffer \&\&null\+\_\+mask, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Construct a LIST type column given offsets column, child column, null mask and null count. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{cudf\+::column}} $>$ \mbox{\hyperlink{group__column__factories_gaca4580640fa3c0304fe22377b5ef1d3b}{cudf\+::make\+\_\+structs\+\_\+column}} (\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} num\+\_\+rows, std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ $>$ \&\&child\+\_\+columns, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} null\+\_\+count, rmm\+::device\+\_\+buffer \&\&null\+\_\+mask, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Construct a STRUCT column using specified child columns as members. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__column__factories_gaf402ec1007ea53418b2d5800daae8041}{cudf\+::make\+\_\+column\+\_\+from\+\_\+scalar}} (\mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&s, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} size, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Construct a column with size elements that are all equal to the given scalar. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__column__factories_gae4cb6e1340b0b96386142f25a0126fb6}{cudf\+::make\+\_\+dictionary\+\_\+from\+\_\+scalar}} (\mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&s, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} size, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Construct a dictionary column with size elements that are all equal to the given scalar. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__column__factories_ga96e5dd80377177bcd78b9db9f28c86af}{cudf\+::make\+\_\+dictionary\+\_\+column}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&keys\+\_\+column, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&indices\+\_\+column, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Construct a dictionary column by copying the provided {\ttfamily keys} and {\ttfamily indices}. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__column__factories_ga7e8ca4d0362868416149924d42a0bd4f}{cudf\+::make\+\_\+dictionary\+\_\+column}} (std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ keys\+\_\+column, std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ indices\+\_\+column, rmm\+::device\+\_\+buffer \&\&null\+\_\+mask, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} null\+\_\+count)
\begin{DoxyCompactList}\small\item\em Construct a dictionary column by taking ownership of the provided keys and indices columns. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__column__factories_gad227b50d9a2903d17ee4cf2ee2dd5887}{cudf\+::make\+\_\+dictionary\+\_\+column}} (std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ keys\+\_\+column, std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ indices\+\_\+column, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Construct a dictionary column by taking ownership of the provided keys and indices columns. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{详细描述}


\doxysubsection{函数说明}
\Hypertarget{group__column__factories_gaf402ec1007ea53418b2d5800daae8041}\label{group__column__factories_gaf402ec1007ea53418b2d5800daae8041} 
\index{Factories@{Factories}!make\_column\_from\_scalar@{make\_column\_from\_scalar}}
\index{make\_column\_from\_scalar@{make\_column\_from\_scalar}!Factories@{Factories}}
\doxysubsubsection{\texorpdfstring{make\_column\_from\_scalar()}{make\_column\_from\_scalar()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::make\+\_\+column\+\_\+from\+\_\+scalar (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&}]{s,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{size,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Construct a column with size elements that are all equal to the given scalar. 

The output column will have the same type as {\ttfamily s.\+type()} The output column will contain all null rows if {\ttfamily s.\+invalid()==false} The output column will be empty if {\ttfamily size==0}. For LIST scalars, the column hierarchy from {\ttfamily s} is preserved.


\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em s} & The scalar to use for values in the column. \\
\hline
\mbox{\texttt{ in}}  & {\em size} & The number of rows for the output column. \\
\hline
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Constructed column whose rows all contain the scalar value 
\end{DoxyReturn}
\Hypertarget{group__column__factories_ga96e5dd80377177bcd78b9db9f28c86af}\label{group__column__factories_ga96e5dd80377177bcd78b9db9f28c86af} 
\index{Factories@{Factories}!make\_dictionary\_column@{make\_dictionary\_column}}
\index{make\_dictionary\_column@{make\_dictionary\_column}!Factories@{Factories}}
\doxysubsubsection{\texorpdfstring{make\_dictionary\_column()}{make\_dictionary\_column()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::make\+\_\+dictionary\+\_\+column (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{keys\+\_\+column,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{indices\+\_\+column,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Construct a dictionary column by copying the provided {\ttfamily keys} and {\ttfamily indices}. 

It is expected that {\ttfamily keys\+\_\+column.\+has\+\_\+nulls() == false}. It is assumed the elements in {\ttfamily keys\+\_\+column} are unique and are in a strict, total order. Meaning, {\ttfamily keys\+\_\+column\mbox{[}i\mbox{]}} is ordered before {\ttfamily keys\+\_\+column\mbox{[}i+1\mbox{]}} for all {\ttfamily i in \mbox{[}0,n-\/1)} where {\ttfamily n} is the number of keys.

The indices values must be in the range \mbox{[}0,keys\+\_\+column.\+size()).

The null\+\_\+mask and null count for the output column are copied from the indices column. If element {\ttfamily i} in {\ttfamily indices\+\_\+column} is null, then element {\ttfamily i} in the returned dictionary column will also be null.


\begin{DoxyCode}{0}
\DoxyCodeLine{k\ =\ [\textcolor{stringliteral}{"{}a"{}},\textcolor{stringliteral}{"{}c"{}},\textcolor{stringliteral}{"{}d"{}}]}
\DoxyCodeLine{i\ =\ [1,0,null,2,2]}
\DoxyCodeLine{d\ =\ \mbox{\hyperlink{group__column__factories_ga96e5dd80377177bcd78b9db9f28c86af}{make\_dictionary\_column}}(k,i)}
\DoxyCodeLine{d\ is\ now\ \{[\textcolor{stringliteral}{"{}a"{}},\textcolor{stringliteral}{"{}c"{}},\textcolor{stringliteral}{"{}d"{}}],[1,0,undefined,2,2]\}\ bitmask=\{1,1,0,1,1\}}

\end{DoxyCode}


The null\+\_\+mask and null count for the output column are copied from the indices column.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if keys\+\_\+column contains nulls \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if indices\+\_\+column type is not INT32\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em keys\+\_\+column} & Column of unique, ordered values to use as the new dictionary column\textquotesingle{}s keys. \\
\hline
{\em indices\+\_\+column} & Indices to use for the new dictionary column. \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
New dictionary column. 
\end{DoxyReturn}
\Hypertarget{group__column__factories_gad227b50d9a2903d17ee4cf2ee2dd5887}\label{group__column__factories_gad227b50d9a2903d17ee4cf2ee2dd5887} 
\index{Factories@{Factories}!make\_dictionary\_column@{make\_dictionary\_column}}
\index{make\_dictionary\_column@{make\_dictionary\_column}!Factories@{Factories}}
\doxysubsubsection{\texorpdfstring{make\_dictionary\_column()}{make\_dictionary\_column()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::make\+\_\+dictionary\+\_\+column (\begin{DoxyParamCaption}\item[{std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$}]{keys\+\_\+column,  }\item[{std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$}]{indices\+\_\+column,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Construct a dictionary column by taking ownership of the provided keys and indices columns. 

The {\ttfamily keys\+\_\+column} must contain no nulls and is assumed to have elements that are unique and are in a strict, total order. Meaning, {\ttfamily keys\+\_\+column\mbox{[}i\mbox{]}} is ordered before {\ttfamily keys\+\_\+column\mbox{[}i+1\mbox{]}} for all {\ttfamily i in \mbox{[}0,n-\/1)} where {\ttfamily n} is the number of keys.

The {\ttfamily indices\+\_\+column} can be any integer type and should contain the null-\/mask to be used for the output column. The indices values must be in the range \mbox{[}0,keys\+\_\+column.\+size()).


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if keys\+\_\+column contains nulls\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em keys\+\_\+column} & Column of unique, ordered values to use as the new dictionary column\textquotesingle{}s keys. \\
\hline
{\em indices\+\_\+column} & Indices values and null-\/mask to use for the new dictionary column. \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
New dictionary column. 
\end{DoxyReturn}
\Hypertarget{group__column__factories_ga7e8ca4d0362868416149924d42a0bd4f}\label{group__column__factories_ga7e8ca4d0362868416149924d42a0bd4f} 
\index{Factories@{Factories}!make\_dictionary\_column@{make\_dictionary\_column}}
\index{make\_dictionary\_column@{make\_dictionary\_column}!Factories@{Factories}}
\doxysubsubsection{\texorpdfstring{make\_dictionary\_column()}{make\_dictionary\_column()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::make\+\_\+dictionary\+\_\+column (\begin{DoxyParamCaption}\item[{std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$}]{keys\+\_\+column,  }\item[{std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$}]{indices\+\_\+column,  }\item[{rmm\+::device\+\_\+buffer \&\&}]{null\+\_\+mask,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{null\+\_\+count }\end{DoxyParamCaption})}



Construct a dictionary column by taking ownership of the provided keys and indices columns. 

The keys\+\_\+column and indices columns must contain no nulls. It is assumed the elements in {\ttfamily keys\+\_\+column} are unique and are in a strict, total order. Meaning, {\ttfamily keys\+\_\+column\mbox{[}i\mbox{]}} is ordered before {\ttfamily keys\+\_\+column\mbox{[}i+1\mbox{]}} for all {\ttfamily i in \mbox{[}0,n-\/1)} where {\ttfamily n} is the number of keys.

The indices values must be in the range \mbox{[}0,keys\+\_\+column.\+size()).


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if keys\+\_\+column or indices\+\_\+column contains nulls \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if indices\+\_\+column type is not an unsigned integer type\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em keys\+\_\+column} & Column of unique, ordered values to use as the new dictionary column\textquotesingle{}s keys. \\
\hline
{\em indices\+\_\+column} & Indices to use for the new dictionary column. \\
\hline
{\em null\+\_\+mask} & Null mask for the output column. \\
\hline
{\em null\+\_\+count} & Number of nulls for the output column. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
New dictionary column. 
\end{DoxyReturn}
\Hypertarget{group__column__factories_gae4cb6e1340b0b96386142f25a0126fb6}\label{group__column__factories_gae4cb6e1340b0b96386142f25a0126fb6} 
\index{Factories@{Factories}!make\_dictionary\_from\_scalar@{make\_dictionary\_from\_scalar}}
\index{make\_dictionary\_from\_scalar@{make\_dictionary\_from\_scalar}!Factories@{Factories}}
\doxysubsubsection{\texorpdfstring{make\_dictionary\_from\_scalar()}{make\_dictionary\_from\_scalar()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::make\+\_\+dictionary\+\_\+from\+\_\+scalar (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&}]{s,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{size,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Construct a dictionary column with size elements that are all equal to the given scalar. 

The output column will have keys of type {\ttfamily s.\+type()} The output column will be empty if {\ttfamily size==0}.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily s.\+is\+\_\+valid()==false}\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em s} & The scalar to use for values in the column. \\
\hline
\mbox{\texttt{ in}}  & {\em size} & The number of rows for the output column. \\
\hline
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Constructed dictionary column 
\end{DoxyReturn}
\Hypertarget{group__column__factories_ga0720e031f009c728943536a1cc9d361d}\label{group__column__factories_ga0720e031f009c728943536a1cc9d361d} 
\index{Factories@{Factories}!make\_duration\_column@{make\_duration\_column}}
\index{make\_duration\_column@{make\_duration\_column}!Factories@{Factories}}
\doxysubsubsection{\texorpdfstring{make\_duration\_column()}{make\_duration\_column()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename B $>$ \\
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::make\+\_\+duration\+\_\+column (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}}}]{type,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{size,  }\item[{B \&\&}]{null\+\_\+mask,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{null\+\_\+count = {\ttfamily \mbox{\hyperlink{group__utility__types_ga0eece3f40ff89fe8f1117097d86913b7}{cudf\+::\+UNKNOWN\+\_\+\+NULL\+\_\+\+COUNT}}},  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Construct column with sufficient uninitialized storage to hold {\ttfamily size} elements of the specified duration {\ttfamily \doxylink{classcudf_1_1data__type}{data\+\_\+type}} with a null mask. 

\begin{DoxyNote}{注解}
null\+\_\+count is optional and will be computed if not provided.
\end{DoxyNote}

\begin{DoxyExceptions}{异常}
{\em std\+::bad\+\_\+alloc} & if device memory allocation fails \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily type} is not a duration type\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em type} & The desired duration element type \\
\hline
\mbox{\texttt{ in}}  & {\em size} & The number of elements in the column \\
\hline
\mbox{\texttt{ in}}  & {\em null\+\_\+mask} & Null mask to use for this column. \\
\hline
\mbox{\texttt{ in}}  & {\em null\+\_\+count} & Optional number of nulls in the null\+\_\+mask. \\
\hline
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Constructed duration type column 
\end{DoxyReturn}


在文件 \mbox{\hyperlink{column__factories_8hpp_source}{column\+\_\+factories.\+hpp}} 第 \mbox{\hyperlink{column__factories_8hpp_source_l00275}{275}} 行定义.

\Hypertarget{group__column__factories_ga7b83c4013e49cc28c0a2a74569853228}\label{group__column__factories_ga7b83c4013e49cc28c0a2a74569853228} 
\index{Factories@{Factories}!make\_duration\_column@{make\_duration\_column}}
\index{make\_duration\_column@{make\_duration\_column}!Factories@{Factories}}
\doxysubsubsection{\texorpdfstring{make\_duration\_column()}{make\_duration\_column()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::make\+\_\+duration\+\_\+column (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}}}]{type,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{size,  }\item[{\mbox{\hyperlink{group__utility__types_ga4daf20c000ab374d76f4d56f0ddb7b26}{mask\+\_\+state}}}]{state = {\ttfamily \mbox{\hyperlink{group__utility__types_gga4daf20c000ab374d76f4d56f0ddb7b26a628732521c22dcf8a24bf1a0326bde80}{mask\+\_\+state\+::\+UNALLOCATED}}},  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Construct column with sufficient uninitialized storage to hold {\ttfamily size} elements of the specified duration {\ttfamily \doxylink{classcudf_1_1data__type}{data\+\_\+type}} with an optional null mask. 

\begin{DoxyNote}{注解}
{\ttfamily null\+\_\+count()} is determined by the requested null mask {\ttfamily state}
\end{DoxyNote}

\begin{DoxyExceptions}{异常}
{\em std\+::bad\+\_\+alloc} & if device memory allocation fails \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily type} is not a duration type \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily size \texorpdfstring{$<$}{<} 0}\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em type} & The desired duration element type \\
\hline
\mbox{\texttt{ in}}  & {\em size} & The number of elements in the column \\
\hline
\mbox{\texttt{ in}}  & {\em state} & Optional, controls allocation/initialization of the column\textquotesingle{}s null mask. By default, no null mask is allocated. \\
\hline
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Constructed duration type column 
\end{DoxyReturn}
\Hypertarget{group__column__factories_gaa80de7d88a408ab660541a4a3b214ead}\label{group__column__factories_gaa80de7d88a408ab660541a4a3b214ead} 
\index{Factories@{Factories}!make\_empty\_column@{make\_empty\_column}}
\index{make\_empty\_column@{make\_empty\_column}!Factories@{Factories}}
\doxysubsubsection{\texorpdfstring{make\_empty\_column()}{make\_empty\_column()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::make\+\_\+empty\+\_\+column (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}}}]{type }\end{DoxyParamCaption})}



Creates an empty column of the specified {\ttfamily type} 

An empty column contains zero elements and no validity mask.


\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em type} & The column data type \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Empty column with desired type 
\end{DoxyReturn}
\Hypertarget{group__column__factories_ga890d1519f4d245dca1f33d09b90f7ca5}\label{group__column__factories_ga890d1519f4d245dca1f33d09b90f7ca5} 
\index{Factories@{Factories}!make\_empty\_column@{make\_empty\_column}}
\index{make\_empty\_column@{make\_empty\_column}!Factories@{Factories}}
\doxysubsubsection{\texorpdfstring{make\_empty\_column()}{make\_empty\_column()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::make\+\_\+empty\+\_\+column (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__utility__types_gadf077607da617d1dadcc5417e2783539}{type\+\_\+id}}}]{id }\end{DoxyParamCaption})}



Creates an empty column of the specified type. 

An empty column contains zero elements and no validity mask.


\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em id} & The column type id \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Empty column with specified type 
\end{DoxyReturn}
\Hypertarget{group__column__factories_gae70cbf7bed0d8e08087cbef612d0affb}\label{group__column__factories_gae70cbf7bed0d8e08087cbef612d0affb} 
\index{Factories@{Factories}!make\_fixed\_point\_column@{make\_fixed\_point\_column}}
\index{make\_fixed\_point\_column@{make\_fixed\_point\_column}!Factories@{Factories}}
\doxysubsubsection{\texorpdfstring{make\_fixed\_point\_column()}{make\_fixed\_point\_column()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename B $>$ \\
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::make\+\_\+fixed\+\_\+point\+\_\+column (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}}}]{type,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{size,  }\item[{B \&\&}]{null\+\_\+mask,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{null\+\_\+count = {\ttfamily \mbox{\hyperlink{group__utility__types_ga0eece3f40ff89fe8f1117097d86913b7}{cudf\+::\+UNKNOWN\+\_\+\+NULL\+\_\+\+COUNT}}},  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Construct column with sufficient uninitialized storage to hold {\ttfamily size} elements of the specified {\ttfamily fixed\+\_\+point} {\ttfamily \doxylink{classcudf_1_1data__type}{data\+\_\+type}} with a null mask. 

\begin{DoxyNote}{注解}
null\+\_\+count is optional and will be computed if not provided.
\end{DoxyNote}

\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily type} is not a {\ttfamily fixed\+\_\+point} type.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em type} & The desired {\ttfamily fixed\+\_\+point} element type. \\
\hline
\mbox{\texttt{ in}}  & {\em size} & The number of elements in the column. \\
\hline
\mbox{\texttt{ in}}  & {\em null\+\_\+mask} & Null mask to use for this column. \\
\hline
\mbox{\texttt{ in}}  & {\em null\+\_\+count} & Optional number of nulls in the null\+\_\+mask. \\
\hline
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Constructed fixed-\/point type column 
\end{DoxyReturn}


在文件 \mbox{\hyperlink{column__factories_8hpp_source}{column\+\_\+factories.\+hpp}} 第 \mbox{\hyperlink{column__factories_8hpp_source_l00157}{157}} 行定义.

\Hypertarget{group__column__factories_ga9329fc1ef9d96f36d71eab418926c206}\label{group__column__factories_ga9329fc1ef9d96f36d71eab418926c206} 
\index{Factories@{Factories}!make\_fixed\_point\_column@{make\_fixed\_point\_column}}
\index{make\_fixed\_point\_column@{make\_fixed\_point\_column}!Factories@{Factories}}
\doxysubsubsection{\texorpdfstring{make\_fixed\_point\_column()}{make\_fixed\_point\_column()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::make\+\_\+fixed\+\_\+point\+\_\+column (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}}}]{type,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{size,  }\item[{\mbox{\hyperlink{group__utility__types_ga4daf20c000ab374d76f4d56f0ddb7b26}{mask\+\_\+state}}}]{state = {\ttfamily \mbox{\hyperlink{group__utility__types_gga4daf20c000ab374d76f4d56f0ddb7b26a628732521c22dcf8a24bf1a0326bde80}{mask\+\_\+state\+::\+UNALLOCATED}}},  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Construct column with sufficient uninitialized storage to hold {\ttfamily size} elements of the specified {\ttfamily fixed\+\_\+point} {\ttfamily \doxylink{classcudf_1_1data__type}{data\+\_\+type}} with an optional null mask. 

\begin{DoxyNote}{注解}
The column\textquotesingle{}s null count is determined by the requested null mask {\ttfamily state}.
\end{DoxyNote}

\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily type} is not a {\ttfamily fixed\+\_\+point} type. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily size \texorpdfstring{$<$}{<} 0}\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em type} & The desired {\ttfamily fixed\+\_\+point} element type. \\
\hline
\mbox{\texttt{ in}}  & {\em size} & The number of elements in the column. \\
\hline
\mbox{\texttt{ in}}  & {\em state} & Optional, controls allocation/initialization of the. column\textquotesingle{}s null mask. By default, no null mask is allocated. \\
\hline
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Constructed fixed-\/point type column 
\end{DoxyReturn}
\Hypertarget{group__column__factories_gabe7756d1ac2c1027c2d1403054f482cb}\label{group__column__factories_gabe7756d1ac2c1027c2d1403054f482cb} 
\index{Factories@{Factories}!make\_fixed\_width\_column@{make\_fixed\_width\_column}}
\index{make\_fixed\_width\_column@{make\_fixed\_width\_column}!Factories@{Factories}}
\doxysubsubsection{\texorpdfstring{make\_fixed\_width\_column()}{make\_fixed\_width\_column()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename B $>$ \\
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::make\+\_\+fixed\+\_\+width\+\_\+column (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}}}]{type,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{size,  }\item[{B \&\&}]{null\+\_\+mask,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{null\+\_\+count = {\ttfamily \mbox{\hyperlink{group__utility__types_ga0eece3f40ff89fe8f1117097d86913b7}{cudf\+::\+UNKNOWN\+\_\+\+NULL\+\_\+\+COUNT}}},  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Construct column with sufficient uninitialized storage to hold {\ttfamily size} elements of the specified fixed width {\ttfamily \doxylink{classcudf_1_1data__type}{data\+\_\+type}} with a null mask. 

\begin{DoxyNote}{注解}
null\+\_\+count is optional and will be computed if not provided.
\end{DoxyNote}

\begin{DoxyExceptions}{异常}
{\em std\+::bad\+\_\+alloc} & if device memory allocation fails \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily type} is not a fixed width type\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em type} & The desired fixed width element type \\
\hline
\mbox{\texttt{ in}}  & {\em size} & The number of elements in the column \\
\hline
\mbox{\texttt{ in}}  & {\em null\+\_\+mask} & Null mask to use for this column. \\
\hline
\mbox{\texttt{ in}}  & {\em null\+\_\+count} & Optional number of nulls in the null\+\_\+mask. \\
\hline
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Constructed fixed-\/width type column 
\end{DoxyReturn}


在文件 \mbox{\hyperlink{column__factories_8hpp_source}{column\+\_\+factories.\+hpp}} 第 \mbox{\hyperlink{column__factories_8hpp_source_l00334}{334}} 行定义.

\Hypertarget{group__column__factories_gac251edf105c64ee963df5e53eeffd091}\label{group__column__factories_gac251edf105c64ee963df5e53eeffd091} 
\index{Factories@{Factories}!make\_fixed\_width\_column@{make\_fixed\_width\_column}}
\index{make\_fixed\_width\_column@{make\_fixed\_width\_column}!Factories@{Factories}}
\doxysubsubsection{\texorpdfstring{make\_fixed\_width\_column()}{make\_fixed\_width\_column()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::make\+\_\+fixed\+\_\+width\+\_\+column (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}}}]{type,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{size,  }\item[{\mbox{\hyperlink{group__utility__types_ga4daf20c000ab374d76f4d56f0ddb7b26}{mask\+\_\+state}}}]{state = {\ttfamily \mbox{\hyperlink{group__utility__types_gga4daf20c000ab374d76f4d56f0ddb7b26a628732521c22dcf8a24bf1a0326bde80}{mask\+\_\+state\+::\+UNALLOCATED}}},  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Construct column with sufficient uninitialized storage to hold {\ttfamily size} elements of the specified fixed width {\ttfamily \doxylink{classcudf_1_1data__type}{data\+\_\+type}} with an optional null mask. 

\begin{DoxyNote}{注解}
{\ttfamily null\+\_\+count()} is determined by the requested null mask {\ttfamily state}
\end{DoxyNote}

\begin{DoxyExceptions}{异常}
{\em std\+::bad\+\_\+alloc} & if device memory allocation fails \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily type} is not a fixed width type \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily size \texorpdfstring{$<$}{<} 0}\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em type} & The desired fixed width type \\
\hline
\mbox{\texttt{ in}}  & {\em size} & The number of elements in the column \\
\hline
\mbox{\texttt{ in}}  & {\em state} & Optional, controls allocation/initialization of the column\textquotesingle{}s null mask. By default, no null mask is allocated. \\
\hline
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Constructed fixed-\/width type column 
\end{DoxyReturn}
\Hypertarget{group__column__factories_gaedfbe8e49523fcea96952534c6fa44b2}\label{group__column__factories_gaedfbe8e49523fcea96952534c6fa44b2} 
\index{Factories@{Factories}!make\_lists\_column@{make\_lists\_column}}
\index{make\_lists\_column@{make\_lists\_column}!Factories@{Factories}}
\doxysubsubsection{\texorpdfstring{make\_lists\_column()}{make\_lists\_column()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{cudf\+::column}} $>$ cudf\+::make\+\_\+lists\+\_\+column (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{num\+\_\+rows,  }\item[{std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$}]{offsets\+\_\+column,  }\item[{std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$}]{child\+\_\+column,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{null\+\_\+count,  }\item[{rmm\+::device\+\_\+buffer \&\&}]{null\+\_\+mask,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Construct a LIST type column given offsets column, child column, null mask and null count. 

The columns and mask are moved into the resulting lists column.

List columns are structured similarly to strings columns. They contain a set of offsets which represents the lengths of the lists in each row, and a \"{}child\"{} column of data that is referenced by the offsets. Since lists are a nested type, the child column may itself be further nested.

When child column at depth N+1 is itself a list, the offsets column at depth N references the offsets column for depth N+1. When the child column at depth N+1 is a leaf type (int, float, etc), the offsets column at depth N references the data for depth N+1.


\begin{DoxyCode}{0}
\DoxyCodeLine{Example:}
\DoxyCodeLine{List<int>}
\DoxyCodeLine{input:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\{1,\ 2\},\ \{3,\ 4,\ 5\}\}}
\DoxyCodeLine{offsets\ (depth\ 0)\ \ \ \{0,\ 2,\ 5\}}
\DoxyCodeLine{data\ \ \ \ (depth\ 0)}
\DoxyCodeLine{offsets\ (depth\ 1)}
\DoxyCodeLine{data\ \ \ \ (depth\ 1)\ \ \ \{1,\ 2,\ 3,\ 4,\ 5\}}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{Example:}
\DoxyCodeLine{List<List<int>>}
\DoxyCodeLine{input:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\ \{\{1,\ 2\}\},\ \{\{3,\ 4,\ 5\},\ \{6,\ 7\}\}\ \}}
\DoxyCodeLine{offsets\ (depth\ 0)\ \ \ \{0,\ 1,\ 3\}}
\DoxyCodeLine{data\ \ \ \ (depth\ 0)}
\DoxyCodeLine{offsets\ (depth\ 1)\ \ \ \{0,\ 2,\ 5,\ 7\}}
\DoxyCodeLine{data\ \ \ \ (depth\ 1)}
\DoxyCodeLine{offsets\ (depth\ 2)}
\DoxyCodeLine{data\ \ \ \ (depth\ 1)\ \ \ \{1,\ 2,\ 3,\ 4,\ 5,\ 6,\ 7\}}

\end{DoxyCode}



\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em num\+\_\+rows} & The number of lists the column represents. \\
\hline
\mbox{\texttt{ in}}  & {\em offsets\+\_\+column} & The column of offset values for this column. Each value should represent the starting offset into the child elements that corresponds to the beginning of the row, with the first row starting at 0. The length of row N can be determined by subtracting offsets\mbox{[}N+1\mbox{]} -\/ offsets\mbox{[}N\mbox{]}. The total number of offsets should be 1 longer than the \# of rows in the column. \\
\hline
\mbox{\texttt{ in}}  & {\em child\+\_\+column} & The column of nested data referenced by the lists represented by the offsets\+\_\+column. Note\+: the child column may itself be further nested. \\
\hline
\mbox{\texttt{ in}}  & {\em null\+\_\+count} & The number of null list entries. \\
\hline
\mbox{\texttt{ in}}  & {\em null\+\_\+mask} & The bits specifying the null lists in device memory. Arrow format for nulls is used for interpreting this bitmask. \\
\hline
\mbox{\texttt{ in}}  & {\em stream} & Optional stream for use with all memory allocation and device kernels \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Optional resource to use for device memory allocation of the column\textquotesingle{}s {\ttfamily null\+\_\+mask} and children. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Constructed lists column 
\end{DoxyReturn}
\Hypertarget{group__column__factories_gad908ea3b27809643a5459d191e52ac91}\label{group__column__factories_gad908ea3b27809643a5459d191e52ac91} 
\index{Factories@{Factories}!make\_numeric\_column@{make\_numeric\_column}}
\index{make\_numeric\_column@{make\_numeric\_column}!Factories@{Factories}}
\doxysubsubsection{\texorpdfstring{make\_numeric\_column()}{make\_numeric\_column()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename B $>$ \\
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::make\+\_\+numeric\+\_\+column (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}}}]{type,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{size,  }\item[{B \&\&}]{null\+\_\+mask,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{null\+\_\+count = {\ttfamily \mbox{\hyperlink{group__utility__types_ga0eece3f40ff89fe8f1117097d86913b7}{cudf\+::\+UNKNOWN\+\_\+\+NULL\+\_\+\+COUNT}}},  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Construct column with sufficient uninitialized storage to hold {\ttfamily size} elements of the specified numeric {\ttfamily \doxylink{classcudf_1_1data__type}{data\+\_\+type}} with a null mask. 

\begin{DoxyNote}{注解}
null\+\_\+count is optional and will be computed if not provided.
\end{DoxyNote}

\begin{DoxyExceptions}{异常}
{\em std\+::bad\+\_\+alloc} & if device memory allocation fails \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily type} is not a numeric type\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em type} & The desired numeric element type \\
\hline
\mbox{\texttt{ in}}  & {\em size} & The number of elements in the column \\
\hline
\mbox{\texttt{ in}}  & {\em null\+\_\+mask} & Null mask to use for this column. \\
\hline
\mbox{\texttt{ in}}  & {\em null\+\_\+count} & Optional number of nulls in the null\+\_\+mask. \\
\hline
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Constructed numeric column 
\end{DoxyReturn}


在文件 \mbox{\hyperlink{column__factories_8hpp_source}{column\+\_\+factories.\+hpp}} 第 \mbox{\hyperlink{column__factories_8hpp_source_l00100}{100}} 行定义.

\Hypertarget{group__column__factories_ga84a9f9deecdbac612cb79cec10a1cff6}\label{group__column__factories_ga84a9f9deecdbac612cb79cec10a1cff6} 
\index{Factories@{Factories}!make\_numeric\_column@{make\_numeric\_column}}
\index{make\_numeric\_column@{make\_numeric\_column}!Factories@{Factories}}
\doxysubsubsection{\texorpdfstring{make\_numeric\_column()}{make\_numeric\_column()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::make\+\_\+numeric\+\_\+column (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}}}]{type,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{size,  }\item[{\mbox{\hyperlink{group__utility__types_ga4daf20c000ab374d76f4d56f0ddb7b26}{mask\+\_\+state}}}]{state = {\ttfamily \mbox{\hyperlink{group__utility__types_gga4daf20c000ab374d76f4d56f0ddb7b26a628732521c22dcf8a24bf1a0326bde80}{mask\+\_\+state\+::\+UNALLOCATED}}},  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Construct column with sufficient uninitialized storage to hold {\ttfamily size} elements of the specified numeric {\ttfamily \doxylink{classcudf_1_1data__type}{data\+\_\+type}} with an optional null mask. 

\begin{DoxyNote}{注解}
{\ttfamily null\+\_\+count()} is determined by the requested null mask {\ttfamily state}
\end{DoxyNote}

\begin{DoxyExceptions}{异常}
{\em std\+::bad\+\_\+alloc} & if device memory allocation fails \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily type} is not a numeric type \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily size \texorpdfstring{$<$}{<} 0}\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em type} & The desired numeric element type \\
\hline
\mbox{\texttt{ in}}  & {\em size} & The number of elements in the column \\
\hline
\mbox{\texttt{ in}}  & {\em state} & Optional, controls allocation/initialization of the column\textquotesingle{}s null mask. By default, no null mask is allocated. \\
\hline
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Constructed numeric column 
\end{DoxyReturn}
\Hypertarget{group__column__factories_ga344b235a4e1cbecd985858e64d8b2075}\label{group__column__factories_ga344b235a4e1cbecd985858e64d8b2075} 
\index{Factories@{Factories}!make\_strings\_column@{make\_strings\_column}}
\index{make\_strings\_column@{make\_strings\_column}!Factories@{Factories}}
\doxysubsubsection{\texorpdfstring{make\_strings\_column()}{make\_strings\_column()}\hspace{0.1cm}{\footnotesize\ttfamily [1/5]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::make\+\_\+strings\+\_\+column (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structcudf_1_1device__span}{cudf\+::device\+\_\+span}}$<$ char const $>$}]{strings,  }\item[{\mbox{\hyperlink{structcudf_1_1device__span}{cudf\+::device\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$}]{offsets,  }\item[{\mbox{\hyperlink{structcudf_1_1device__span}{cudf\+::device\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga1d17001baf070a639c3a5e8ed8c46d34}{bitmask\+\_\+type}} const $>$}]{null\+\_\+mask = {\ttfamily \{\}},  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{null\+\_\+count = {\ttfamily \mbox{\hyperlink{group__utility__types_ga0eece3f40ff89fe8f1117097d86913b7}{cudf\+::\+UNKNOWN\+\_\+\+NULL\+\_\+\+COUNT}}},  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Construct a STRING type column given a device span of chars encoded as UTF-\/8, a device span of byte offsets identifying individual strings within the char vector, and an optional null bitmask. 

{\ttfamily offsets.\+front()} must always be zero.

The total number of char bytes must not exceed the maximum size of size\+\_\+type. Use the \doxylink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view} class to perform strings operations on this type of column.

This function makes a deep copy of the strings, offsets, null\+\_\+mask to create a new column.


\begin{DoxyExceptions}{异常}
{\em std\+::bad\+\_\+alloc} & if device memory allocation fails\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em strings} & The device span of chars in device memory. This char vector is expected to be UTF-\/8 encoded characters. \\
\hline
\mbox{\texttt{ in}}  & {\em offsets} & The device span of byte offsets in device memory. The number of elements is one more than the total number of strings so the {\ttfamily offsets.\+back()} is the total number of bytes in the strings array. {\ttfamily offsets.\+front()} must always be 0 to point to the beginning of {\ttfamily strings}. \\
\hline
\mbox{\texttt{ in}}  & {\em null\+\_\+mask} & Device span containing the null element indicator bitmask. Arrow format for nulls is used for interpreting this bitmask. \\
\hline
\mbox{\texttt{ in}}  & {\em null\+\_\+count} & The number of null string entries. If equal to {\ttfamily UNKNOWN\+\_\+\+NULL\+\_\+\+COUNT}, the null count will be computed dynamically on the first invocation of {\ttfamily \doxylink{classcudf_1_1column_a2d92092a5214eb9ea8205eea0adbd9bc}{column\+::null\+\_\+count()}} \\
\hline
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Device memory resource used for allocation of the column\textquotesingle{}s {\ttfamily null\+\_\+mask} and children columns\textquotesingle{} device memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Constructed strings column 
\end{DoxyReturn}
\Hypertarget{group__column__factories_gac63c5f712a69911f57e1a25ea19aa4b9}\label{group__column__factories_gac63c5f712a69911f57e1a25ea19aa4b9} 
\index{Factories@{Factories}!make\_strings\_column@{make\_strings\_column}}
\index{make\_strings\_column@{make\_strings\_column}!Factories@{Factories}}
\doxysubsubsection{\texorpdfstring{make\_strings\_column()}{make\_strings\_column()}\hspace{0.1cm}{\footnotesize\ttfamily [2/5]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::make\+\_\+strings\+\_\+column (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structcudf_1_1device__span}{cudf\+::device\+\_\+span}}$<$ \mbox{\hyperlink{classcudf_1_1string__view}{string\+\_\+view}} const $>$}]{string\+\_\+views,  }\item[{const \mbox{\hyperlink{classcudf_1_1string__view}{string\+\_\+view}}}]{null\+\_\+placeholder,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Construct a STRING type column given a device span of \doxylink{classcudf_1_1string__view}{string\+\_\+view}. 

The total number of char bytes must not exceed the maximum size of size\+\_\+type. The string characters are expected to be UTF-\/8 encoded sequence of char bytes. Use the \doxylink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view} class to perform strings operations on this type of column.

\begin{DoxyNote}{注解}
For each \doxylink{classcudf_1_1string__view}{string\+\_\+view}, if {\ttfamily .data()} is {\ttfamily null\+\_\+placeholder.\+data()}, that string is considered null. Likewise, a string is considered empty (not null) if {\ttfamily .data()} is not {\ttfamily null\+\_\+placeholder.\+data()} and {\ttfamily .size\+\_\+bytes()} is 0. Otherwise the {\ttfamily .data()} must be a valid device address pointing to {\ttfamily .size\+\_\+bytes()} consecutive bytes. The {\ttfamily null\+\_\+count()} for the output column will be equal to the number of input {\ttfamily \doxylink{classcudf_1_1string__view}{string\+\_\+view}}s that are null.
\end{DoxyNote}

\begin{DoxyExceptions}{异常}
{\em std\+::bad\+\_\+alloc} & if device memory allocation fails\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em string\+\_\+views} & The span of \doxylink{classcudf_1_1string__view}{string\+\_\+view}. Each \doxylink{classcudf_1_1string__view}{string\+\_\+view} must point to a device memory address or {\ttfamily null\+\_\+placeholder} (indicating a null string). The size must be the number of bytes. \\
\hline
\mbox{\texttt{ in}}  & {\em null\+\_\+placeholder} & \doxylink{classcudf_1_1string__view}{string\+\_\+view} indicating null string in given list of string\+\_\+views. \\
\hline
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Device memory resource used for allocation of the column\textquotesingle{}s {\ttfamily null\+\_\+mask} and children columns\textquotesingle{} device memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Constructed strings column 
\end{DoxyReturn}
\Hypertarget{group__column__factories_ga1b4c7323b0728830bccaf9fd8785ce18}\label{group__column__factories_ga1b4c7323b0728830bccaf9fd8785ce18} 
\index{Factories@{Factories}!make\_strings\_column@{make\_strings\_column}}
\index{make\_strings\_column@{make\_strings\_column}!Factories@{Factories}}
\doxysubsubsection{\texorpdfstring{make\_strings\_column()}{make\_strings\_column()}\hspace{0.1cm}{\footnotesize\ttfamily [3/5]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::make\+\_\+strings\+\_\+column (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structcudf_1_1device__span}{cudf\+::device\+\_\+span}}$<$ thrust\+::pair$<$ const char \texorpdfstring{$\ast$}{*}, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ const $>$}]{strings,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Construct a STRING type column given a device span of pointer/size pairs. 

The total number of char bytes must not exceed the maximum size of size\+\_\+type. The string characters are expected to be UTF-\/8 encoded sequence of char bytes. Use the \doxylink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view} class to perform strings operations on this type of column.

\begin{DoxyNote}{注解}
{\ttfamily null\+\_\+count()} and {\ttfamily null\+\_\+bitmask} are determined if a pair contains a null string. That is, for each pair, if {\ttfamily .first} is null, that string is considered null. Likewise, a string is considered empty (not null) if {\ttfamily .first} is not null and {\ttfamily .second} is 0. Otherwise the {\ttfamily .first} member must be a valid device address pointing to {\ttfamily .second} consecutive bytes.
\end{DoxyNote}

\begin{DoxyExceptions}{异常}
{\em std\+::bad\+\_\+alloc} & if device memory allocation fails\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em strings} & The device span of pointer/size pairs. Each pointer must be a device memory address or {\ttfamily nullptr} (indicating a null string). The size must be the number of bytes. \\
\hline
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Device memory resource used for allocation of the column\textquotesingle{}s {\ttfamily null\+\_\+mask} and children columns\textquotesingle{} device memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Constructed strings column 
\end{DoxyReturn}
\Hypertarget{group__column__factories_ga12fdea6621b2945532151737c740a368}\label{group__column__factories_ga12fdea6621b2945532151737c740a368} 
\index{Factories@{Factories}!make\_strings\_column@{make\_strings\_column}}
\index{make\_strings\_column@{make\_strings\_column}!Factories@{Factories}}
\doxysubsubsection{\texorpdfstring{make\_strings\_column()}{make\_strings\_column()}\hspace{0.1cm}{\footnotesize\ttfamily [4/5]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::make\+\_\+strings\+\_\+column (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{num\+\_\+strings,  }\item[{rmm\+::device\+\_\+uvector$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ \&\&}]{offsets,  }\item[{rmm\+::device\+\_\+uvector$<$ char $>$ \&\&}]{chars,  }\item[{rmm\+::device\+\_\+buffer \&\&}]{null\+\_\+mask = {\ttfamily \{\}},  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{null\+\_\+count = {\ttfamily \mbox{\hyperlink{group__utility__types_ga0eece3f40ff89fe8f1117097d86913b7}{cudf\+::\+UNKNOWN\+\_\+\+NULL\+\_\+\+COUNT}}} }\end{DoxyParamCaption})}



Construct a STRING type column given offsets, columns, and optional null count and null mask. 


\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em num\+\_\+strings} & The number of strings the column represents. \\
\hline
\mbox{\texttt{ in}}  & {\em offsets} & The offset values for this column. The number of elements is one more than the total number of strings so the {\ttfamily offset\mbox{[}last\mbox{]} -\/ offset\mbox{[}0\mbox{]}} is the total number of bytes in the strings vector. \\
\hline
\mbox{\texttt{ in}}  & {\em chars} & The char bytes for all the strings for this column. Individual strings are identified by the offsets and the nullmask. \\
\hline
\mbox{\texttt{ in}}  & {\em null\+\_\+mask} & The bits specifying the null strings in device memory. Arrow format for nulls is used for interpreting this bitmask. \\
\hline
\mbox{\texttt{ in}}  & {\em null\+\_\+count} & The number of null string entries. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Constructed strings column 
\end{DoxyReturn}
\Hypertarget{group__column__factories_gace1c51569535b5ea5d23805470cfe8b7}\label{group__column__factories_gace1c51569535b5ea5d23805470cfe8b7} 
\index{Factories@{Factories}!make\_strings\_column@{make\_strings\_column}}
\index{make\_strings\_column@{make\_strings\_column}!Factories@{Factories}}
\doxysubsubsection{\texorpdfstring{make\_strings\_column()}{make\_strings\_column()}\hspace{0.1cm}{\footnotesize\ttfamily [5/5]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::make\+\_\+strings\+\_\+column (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{num\+\_\+strings,  }\item[{std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$}]{offsets\+\_\+column,  }\item[{std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$}]{chars\+\_\+column,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{null\+\_\+count,  }\item[{rmm\+::device\+\_\+buffer \&\&}]{null\+\_\+mask }\end{DoxyParamCaption})}



Construct a STRING type column given offsets column, chars columns, and null mask and null count. 

The columns and mask are moved into the resulting strings column.


\begin{DoxyParams}{参数}
{\em num\+\_\+strings} & The number of strings the column represents. \\
\hline
{\em offsets\+\_\+column} & The column of offset values for this column. The number of elements is one more than the total number of strings so the {\ttfamily offset\mbox{[}last\mbox{]} -\/ offset\mbox{[}0\mbox{]}} is the total number of bytes in the strings vector. \\
\hline
{\em chars\+\_\+column} & The column of char bytes for all the strings for this column. Individual strings are identified by the offsets and the nullmask. \\
\hline
{\em null\+\_\+count} & The number of null string entries. \\
\hline
{\em null\+\_\+mask} & The bits specifying the null strings in device memory. Arrow format for nulls is used for interpreting this bitmask. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Constructed strings column 
\end{DoxyReturn}
\Hypertarget{group__column__factories_gaca4580640fa3c0304fe22377b5ef1d3b}\label{group__column__factories_gaca4580640fa3c0304fe22377b5ef1d3b} 
\index{Factories@{Factories}!make\_structs\_column@{make\_structs\_column}}
\index{make\_structs\_column@{make\_structs\_column}!Factories@{Factories}}
\doxysubsubsection{\texorpdfstring{make\_structs\_column()}{make\_structs\_column()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{cudf\+::column}} $>$ cudf\+::make\+\_\+structs\+\_\+column (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{num\+\_\+rows,  }\item[{std\+::vector$<$ std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ $>$ \&\&}]{child\+\_\+columns,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{null\+\_\+count,  }\item[{rmm\+::device\+\_\+buffer \&\&}]{null\+\_\+mask,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Construct a STRUCT column using specified child columns as members. 

Specified child/member columns and null\+\_\+mask are adopted by resultant struct column.

A struct column requires that all specified child columns have the same number of rows. A struct column\textquotesingle{}s row count equals that of any/all of its child columns. A single struct row at any index is comprised of all the individual child column values at the same index, in the order specified in the list of child columns.

The specified null mask governs which struct row has a null value. This is orthogonal to the null values of individual child columns.


\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em num\+\_\+rows} & The number of struct values in the struct column. \\
\hline
\mbox{\texttt{ in}}  & {\em child\+\_\+columns} & The list of child/members that the struct is comprised of. \\
\hline
\mbox{\texttt{ in}}  & {\em null\+\_\+count} & The number of null values in the struct column. \\
\hline
\mbox{\texttt{ in}}  & {\em null\+\_\+mask} & The bits specifying the null struct values in the column. \\
\hline
\mbox{\texttt{ in}}  & {\em stream} & Optional stream for use with all memory allocation and device kernels. \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Optional resource to use for device memory allocation. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Constructed structs column 
\end{DoxyReturn}
\Hypertarget{group__column__factories_ga82d67ff8acbde7370b6dfa4eeaf63893}\label{group__column__factories_ga82d67ff8acbde7370b6dfa4eeaf63893} 
\index{Factories@{Factories}!make\_timestamp\_column@{make\_timestamp\_column}}
\index{make\_timestamp\_column@{make\_timestamp\_column}!Factories@{Factories}}
\doxysubsubsection{\texorpdfstring{make\_timestamp\_column()}{make\_timestamp\_column()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename B $>$ \\
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::make\+\_\+timestamp\+\_\+column (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}}}]{type,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{size,  }\item[{B \&\&}]{null\+\_\+mask,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{null\+\_\+count = {\ttfamily \mbox{\hyperlink{group__utility__types_ga0eece3f40ff89fe8f1117097d86913b7}{cudf\+::\+UNKNOWN\+\_\+\+NULL\+\_\+\+COUNT}}},  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Construct column with sufficient uninitialized storage to hold {\ttfamily size} elements of the specified timestamp {\ttfamily \doxylink{classcudf_1_1data__type}{data\+\_\+type}} with a null mask. 

\begin{DoxyNote}{注解}
null\+\_\+count is optional and will be computed if not provided.
\end{DoxyNote}

\begin{DoxyExceptions}{异常}
{\em std\+::bad\+\_\+alloc} & if device memory allocation fails \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily type} is not a timestamp type\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em type} & The desired timestamp element type \\
\hline
\mbox{\texttt{ in}}  & {\em size} & The number of elements in the column \\
\hline
\mbox{\texttt{ in}}  & {\em null\+\_\+mask} & Null mask to use for this column. \\
\hline
\mbox{\texttt{ in}}  & {\em null\+\_\+count} & Optional number of nulls in the null\+\_\+mask. \\
\hline
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Constructed timestamp type column 
\end{DoxyReturn}


在文件 \mbox{\hyperlink{column__factories_8hpp_source}{column\+\_\+factories.\+hpp}} 第 \mbox{\hyperlink{column__factories_8hpp_source_l00216}{216}} 行定义.

\Hypertarget{group__column__factories_gad3dd1ff4b11ca9c70322004ea72fdf0d}\label{group__column__factories_gad3dd1ff4b11ca9c70322004ea72fdf0d} 
\index{Factories@{Factories}!make\_timestamp\_column@{make\_timestamp\_column}}
\index{make\_timestamp\_column@{make\_timestamp\_column}!Factories@{Factories}}
\doxysubsubsection{\texorpdfstring{make\_timestamp\_column()}{make\_timestamp\_column()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::make\+\_\+timestamp\+\_\+column (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}}}]{type,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{size,  }\item[{\mbox{\hyperlink{group__utility__types_ga4daf20c000ab374d76f4d56f0ddb7b26}{mask\+\_\+state}}}]{state = {\ttfamily \mbox{\hyperlink{group__utility__types_gga4daf20c000ab374d76f4d56f0ddb7b26a628732521c22dcf8a24bf1a0326bde80}{mask\+\_\+state\+::\+UNALLOCATED}}},  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Construct column with sufficient uninitialized storage to hold {\ttfamily size} elements of the specified timestamp {\ttfamily \doxylink{classcudf_1_1data__type}{data\+\_\+type}} with an optional null mask. 

\begin{DoxyNote}{注解}
{\ttfamily null\+\_\+count()} is determined by the requested null mask {\ttfamily state}
\end{DoxyNote}

\begin{DoxyExceptions}{异常}
{\em std\+::bad\+\_\+alloc} & if device memory allocation fails \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily type} is not a timestamp type \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily size \texorpdfstring{$<$}{<} 0}\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em type} & The desired timestamp element type \\
\hline
\mbox{\texttt{ in}}  & {\em size} & The number of elements in the column \\
\hline
\mbox{\texttt{ in}}  & {\em state} & Optional, controls allocation/initialization of the column\textquotesingle{}s null mask. By default, no null mask is allocated. \\
\hline
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Constructed timestamp type column 
\end{DoxyReturn}
