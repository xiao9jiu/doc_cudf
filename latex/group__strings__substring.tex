\doxysection{Strings\+\_\+substring}
\hypertarget{group__strings__substring}{}\label{group__strings__substring}\index{Strings\_substring@{Strings\_substring}}
\doxysubsubsection*{文件}
\begin{DoxyCompactItemize}
\item 
文件 \mbox{\hyperlink{strings_2extract_8hpp}{extract.\+hpp}}
\item 
文件 \mbox{\hyperlink{substring_8hpp}{substring.\+hpp}}
\end{DoxyCompactItemize}
\doxysubsubsection*{函数}
\begin{DoxyCompactItemize}
\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{group__strings__substring_ga3da970ea4891b84e0974b2eab7ae379d}{cudf\+::strings\+::extract}} (\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&strings, std\+::string\+\_\+view pattern, \mbox{\hyperlink{group__strings__regex_ga341eb616bce8b15119196ad8208ec16d}{regex\+\_\+flags}} const flags=\mbox{\hyperlink{group__strings__regex_gga341eb616bce8b15119196ad8208ec16da432e1bed0776491ae9d73f3915142912}{regex\+\_\+flags\+::\+DEFAULT}}, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Returns a table of strings columns where each column corresponds to the matching group specified in the given regular expression pattern. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{group__strings__substring_ga127ca4f0c908743df473a6bdbf44ad13}{cudf\+::strings\+::extract}} (\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&strings, \mbox{\hyperlink{structcudf_1_1strings_1_1regex__program}{regex\+\_\+program}} const \&prog, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Returns a table of strings columns where each column corresponds to the matching group specified in the given \doxylink{structcudf_1_1strings_1_1regex__program}{regex\+\_\+program} object \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__strings__substring_ga0af0629f84622385c6c6483d13ddc742}{cudf\+::strings\+::extract\+\_\+all\+\_\+record}} (\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&strings, std\+::string\+\_\+view pattern, \mbox{\hyperlink{group__strings__regex_ga341eb616bce8b15119196ad8208ec16d}{regex\+\_\+flags}} const flags=\mbox{\hyperlink{group__strings__regex_gga341eb616bce8b15119196ad8208ec16da432e1bed0776491ae9d73f3915142912}{regex\+\_\+flags\+::\+DEFAULT}}, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Returns a lists column of strings where each string column row corresponds to the matching group specified in the given regular expression pattern. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__strings__substring_ga0865099d0243249af4e6c75d091b2729}{cudf\+::strings\+::extract\+\_\+all\+\_\+record}} (\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&strings, \mbox{\hyperlink{structcudf_1_1strings_1_1regex__program}{regex\+\_\+program}} const \&prog, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Returns a lists column of strings where each string column row corresponds to the matching group specified in the given \doxylink{structcudf_1_1strings_1_1regex__program}{regex\+\_\+program} object \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__strings__substring_gaaef2683f47258c615885d57502c042af}{cudf\+::strings\+::slice\+\_\+strings}} (\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&strings, \mbox{\hyperlink{classcudf_1_1numeric__scalar}{numeric\+\_\+scalar}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ const \&start=\mbox{\hyperlink{classcudf_1_1numeric__scalar}{numeric\+\_\+scalar}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$(0, false), \mbox{\hyperlink{classcudf_1_1numeric__scalar}{numeric\+\_\+scalar}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ const \&stop=\mbox{\hyperlink{classcudf_1_1numeric__scalar}{numeric\+\_\+scalar}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$(0, false), \mbox{\hyperlink{classcudf_1_1numeric__scalar}{numeric\+\_\+scalar}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ const \&step=\mbox{\hyperlink{classcudf_1_1numeric__scalar}{numeric\+\_\+scalar}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$(1), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Returns a new strings column that contains substrings of the strings in the provided column. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__strings__substring_ga24a2feb9a5a477a37ea213750746cb23}{cudf\+::strings\+::slice\+\_\+strings}} (\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&strings, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&starts, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&stops, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Returns a new strings column that contains substrings of the strings in the provided column using unique ranges for each string. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__strings__substring_ga663b4812c350c7070c90aa9aff653fab}{cudf\+::strings\+::slice\+\_\+strings}} (\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&strings, \mbox{\hyperlink{classcudf_1_1string__scalar}{string\+\_\+scalar}} const \&delimiter, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} count, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Slices a column of strings by using a delimiter as a slice point. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__strings__substring_ga867eac9aa0fef7d1971cfc09f6b9aaf2}{cudf\+::strings\+::slice\+\_\+strings}} (\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&strings, \mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&delimiter\+\_\+strings, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} count, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Slices a column of strings by using a delimiter column as slice points. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{详细描述}


\doxysubsection{函数说明}
\Hypertarget{group__strings__substring_ga127ca4f0c908743df473a6bdbf44ad13}\label{group__strings__substring_ga127ca4f0c908743df473a6bdbf44ad13} 
\index{Strings\_substring@{Strings\_substring}!extract@{extract}}
\index{extract@{extract}!Strings\_substring@{Strings\_substring}}
\doxysubsubsection{\texorpdfstring{extract()}{extract()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::strings\+::extract (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&}]{strings,  }\item[{\mbox{\hyperlink{structcudf_1_1strings_1_1regex__program}{regex\+\_\+program}} const \&}]{prog,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Returns a table of strings columns where each column corresponds to the matching group specified in the given \doxylink{structcudf_1_1strings_1_1regex__program}{regex\+\_\+program} object 

All the strings for the first group will go in the first output column; the second group go in the second column and so on. Null entries are added to the columns in row {\ttfamily i} if the string at row {\ttfamily i} does not match.

Any null string entries return corresponding null output column entries.


\begin{DoxyCode}{0}
\DoxyCodeLine{Example:}
\DoxyCodeLine{s\ =\ ["{}a1"{},\ "{}b2"{},\ "{}c3"{}]}
\DoxyCodeLine{p\ =\ regex\_program::create("{}([ab])(\(\backslash\)\(\backslash\)d)"{})}
\DoxyCodeLine{r\ =\ extract(s,\ p)}
\DoxyCodeLine{r\ is\ now\ [\ ["{}a"{},\ "{}b"{},\ null],}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ ["{}1"{},\ "{}2"{},\ null]\ ]}

\end{DoxyCode}


See the Regex Features page for details on patterns supported by this API.


\begin{DoxyParams}{参数}
{\em strings} & Strings instance for this operation \\
\hline
{\em prog} & Regex program instance \\
\hline
{\em mr} & Device memory resource used to allocate the returned table\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Columns of strings extracted from the input column 
\end{DoxyReturn}
\Hypertarget{group__strings__substring_ga3da970ea4891b84e0974b2eab7ae379d}\label{group__strings__substring_ga3da970ea4891b84e0974b2eab7ae379d} 
\index{Strings\_substring@{Strings\_substring}!extract@{extract}}
\index{extract@{extract}!Strings\_substring@{Strings\_substring}}
\doxysubsubsection{\texorpdfstring{extract()}{extract()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::strings\+::extract (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&}]{strings,  }\item[{std\+::string\+\_\+view}]{pattern,  }\item[{\mbox{\hyperlink{group__strings__regex_ga341eb616bce8b15119196ad8208ec16d}{regex\+\_\+flags}} const}]{flags = {\ttfamily \mbox{\hyperlink{group__strings__regex_gga341eb616bce8b15119196ad8208ec16da432e1bed0776491ae9d73f3915142912}{regex\+\_\+flags\+::\+DEFAULT}}},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Returns a table of strings columns where each column corresponds to the matching group specified in the given regular expression pattern. 

All the strings for the first group will go in the first output column; the second group go in the second column and so on. Null entries are added to the columns in row {\ttfamily i} if the string at row {\ttfamily i} does not match.

Any null string entries return corresponding null output column entries.


\begin{DoxyCode}{0}
\DoxyCodeLine{Example:}
\DoxyCodeLine{s\ =\ ["{}a1"{},\ "{}b2"{},\ "{}c3"{}]}
\DoxyCodeLine{r\ =\ extract(s,\ "{}([ab])(\(\backslash\)\(\backslash\)d)"{})}
\DoxyCodeLine{r\ is\ now\ [\ ["{}a"{},\ "{}b"{},\ null],}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ ["{}1"{},\ "{}2"{},\ null]\ ]}

\end{DoxyCode}


See the Regex Features page for details on patterns supported by this API.


\begin{DoxyParams}{参数}
{\em strings} & Strings instance for this operation. \\
\hline
{\em pattern} & The regular expression pattern with group indicators. \\
\hline
{\em flags} & Regex flags for interpreting special characters in the pattern. \\
\hline
{\em mr} & Device memory resource used to allocate the returned table\textquotesingle{}s device memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Columns of strings extracted from the input column. 
\end{DoxyReturn}
\Hypertarget{group__strings__substring_ga0865099d0243249af4e6c75d091b2729}\label{group__strings__substring_ga0865099d0243249af4e6c75d091b2729} 
\index{Strings\_substring@{Strings\_substring}!extract\_all\_record@{extract\_all\_record}}
\index{extract\_all\_record@{extract\_all\_record}!Strings\_substring@{Strings\_substring}}
\doxysubsubsection{\texorpdfstring{extract\_all\_record()}{extract\_all\_record()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::strings\+::extract\+\_\+all\+\_\+record (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&}]{strings,  }\item[{\mbox{\hyperlink{structcudf_1_1strings_1_1regex__program}{regex\+\_\+program}} const \&}]{prog,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Returns a lists column of strings where each string column row corresponds to the matching group specified in the given \doxylink{structcudf_1_1strings_1_1regex__program}{regex\+\_\+program} object 

All the matching groups for the first row will go in the first row output column; the second row results will go into the second row output column and so on.

A null output row will result if the corresponding input string row does not match or that input row is null.


\begin{DoxyCode}{0}
\DoxyCodeLine{Example:}
\DoxyCodeLine{s\ =\ ["{}a1\ b4"{},\ "{}b2"{},\ "{}c3\ a5"{},\ "{}b"{},\ null]}
\DoxyCodeLine{p\ =\ regex\_program::create("{}([ab])(\(\backslash\)\(\backslash\)d)"{})}
\DoxyCodeLine{r\ =\ extract\_all\_record(s,\ p)}
\DoxyCodeLine{r\ is\ now\ [\ ["{}a"{},\ "{}1"{},\ "{}b"{},\ "{}4"{}],}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ ["{}b"{},\ "{}2"{}],}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ ["{}a"{},\ "{}5"{}],}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ null,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ null\ ]}

\end{DoxyCode}


See the Regex Features page for details on patterns supported by this API.


\begin{DoxyParams}{参数}
{\em strings} & Strings instance for this operation \\
\hline
{\em prog} & Regex program instance \\
\hline
{\em mr} & Device memory resource used to allocate any returned device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Lists column containing strings extracted from the input column 
\end{DoxyReturn}
\Hypertarget{group__strings__substring_ga0af0629f84622385c6c6483d13ddc742}\label{group__strings__substring_ga0af0629f84622385c6c6483d13ddc742} 
\index{Strings\_substring@{Strings\_substring}!extract\_all\_record@{extract\_all\_record}}
\index{extract\_all\_record@{extract\_all\_record}!Strings\_substring@{Strings\_substring}}
\doxysubsubsection{\texorpdfstring{extract\_all\_record()}{extract\_all\_record()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::strings\+::extract\+\_\+all\+\_\+record (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&}]{strings,  }\item[{std\+::string\+\_\+view}]{pattern,  }\item[{\mbox{\hyperlink{group__strings__regex_ga341eb616bce8b15119196ad8208ec16d}{regex\+\_\+flags}} const}]{flags = {\ttfamily \mbox{\hyperlink{group__strings__regex_gga341eb616bce8b15119196ad8208ec16da432e1bed0776491ae9d73f3915142912}{regex\+\_\+flags\+::\+DEFAULT}}},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Returns a lists column of strings where each string column row corresponds to the matching group specified in the given regular expression pattern. 

All the matching groups for the first row will go in the first row output column; the second row results will go into the second row output column and so on.

A null output row will result if the corresponding input string row does not match or that input row is null.


\begin{DoxyCode}{0}
\DoxyCodeLine{Example:}
\DoxyCodeLine{s\ =\ ["{}a1\ b4"{},\ "{}b2"{},\ "{}c3\ a5"{},\ "{}b"{},\ null]}
\DoxyCodeLine{r\ =\ extract\_all\_record(s,"{}([ab])(\(\backslash\)\(\backslash\)d)"{})}
\DoxyCodeLine{r\ is\ now\ [\ ["{}a"{},\ "{}1"{},\ "{}b"{},\ "{}4"{}],}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ ["{}b"{},\ "{}2"{}],}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ ["{}a"{},\ "{}5"{}],}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ null,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ null\ ]}

\end{DoxyCode}


See the Regex Features page for details on patterns supported by this API.


\begin{DoxyParams}{参数}
{\em strings} & Strings instance for this operation. \\
\hline
{\em pattern} & The regular expression pattern with group indicators. \\
\hline
{\em flags} & Regex flags for interpreting special characters in the pattern. \\
\hline
{\em mr} & Device memory resource used to allocate any returned device memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Lists column containing strings extracted from the input column. 
\end{DoxyReturn}
\Hypertarget{group__strings__substring_ga24a2feb9a5a477a37ea213750746cb23}\label{group__strings__substring_ga24a2feb9a5a477a37ea213750746cb23} 
\index{Strings\_substring@{Strings\_substring}!slice\_strings@{slice\_strings}}
\index{slice\_strings@{slice\_strings}!Strings\_substring@{Strings\_substring}}
\doxysubsubsection{\texorpdfstring{slice\_strings()}{slice\_strings()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::strings\+::slice\+\_\+strings (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&}]{strings,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{starts,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{stops,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Returns a new strings column that contains substrings of the strings in the provided column using unique ranges for each string. 

The character positions to retrieve in each string are specified in the {\ttfamily starts} and {\ttfamily stops} integer columns. If a start position is outside a string\textquotesingle{}s length, an empty string is returned for that entry. If a stop position is past the end of a string\textquotesingle{}s length, the end of the string is used for stop position for that string. Any stop position value set to -\/1 will indicate to use the end of the string as the stop position for that string.

Null string entries will return null output string entries.

The starts and stops column must both be the same integer type and must be the same size as the strings column.


\begin{DoxyCode}{0}
\DoxyCodeLine{Example:}
\DoxyCodeLine{s\ =\ ["{}hello"{},\ "{}goodbye"{}]}
\DoxyCodeLine{starts\ =\ [\ 1,\ 2\ ]}
\DoxyCodeLine{stops\ =\ [\ 5,\ 4\ ]}
\DoxyCodeLine{r\ =\ substring\_from(s,starts,stops)}
\DoxyCodeLine{r\ is\ now\ ["{}ello"{},"{}od"{}]}

\end{DoxyCode}



\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if starts or stops is a different size than the strings column. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if starts and stops are not same integer type. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if starts or stops contains nulls.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em strings} & Strings column for this operation. \\
\hline
{\em starts} & First character positions to begin the substring. \\
\hline
{\em stops} & Last character (exclusive) positions to end the substring. \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
New strings column with sorted elements of this instance. 
\end{DoxyReturn}
\Hypertarget{group__strings__substring_gaaef2683f47258c615885d57502c042af}\label{group__strings__substring_gaaef2683f47258c615885d57502c042af} 
\index{Strings\_substring@{Strings\_substring}!slice\_strings@{slice\_strings}}
\index{slice\_strings@{slice\_strings}!Strings\_substring@{Strings\_substring}}
\doxysubsubsection{\texorpdfstring{slice\_strings()}{slice\_strings()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::strings\+::slice\+\_\+strings (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&}]{strings,  }\item[{\mbox{\hyperlink{classcudf_1_1numeric__scalar}{numeric\+\_\+scalar}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ const \&}]{start = {\ttfamily \mbox{\hyperlink{classcudf_1_1numeric__scalar}{numeric\+\_\+scalar}}$<$~\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}~$>$(0,~false)},  }\item[{\mbox{\hyperlink{classcudf_1_1numeric__scalar}{numeric\+\_\+scalar}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ const \&}]{stop = {\ttfamily \mbox{\hyperlink{classcudf_1_1numeric__scalar}{numeric\+\_\+scalar}}$<$~\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}~$>$(0,~false)},  }\item[{\mbox{\hyperlink{classcudf_1_1numeric__scalar}{numeric\+\_\+scalar}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ const \&}]{step = {\ttfamily \mbox{\hyperlink{classcudf_1_1numeric__scalar}{numeric\+\_\+scalar}}$<$~\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}~$>$(1)},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Returns a new strings column that contains substrings of the strings in the provided column. 

The character positions to retrieve in each string are {\ttfamily \mbox{[}start,stop)}. If the start position is outside a string\textquotesingle{}s length, an empty string is returned for that entry. If the stop position is past the end of a string\textquotesingle{}s length, the end of the string is used for stop position for that string.

Null string entries will return null output string entries.


\begin{DoxyCode}{0}
\DoxyCodeLine{Example:}
\DoxyCodeLine{s\ =\ ["{}hello"{},\ "{}goodbye"{}]}
\DoxyCodeLine{r\ =\ substring(s,2,6)}
\DoxyCodeLine{r\ is\ now\ ["{}llo"{},"{}odby"{}]}
\DoxyCodeLine{r2\ =\ substring(s,2,5,2)}
\DoxyCodeLine{r2\ is\ now\ ["{}lo"{},"{}ob"{}]}

\end{DoxyCode}



\begin{DoxyParams}{参数}
{\em strings} & Strings column for this operation. \\
\hline
{\em start} & First character position to begin the substring. \\
\hline
{\em stop} & Last character position (exclusive) to end the substring. \\
\hline
{\em step} & Distance between input characters retrieved. \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
New strings column with sorted elements of this instance. 
\end{DoxyReturn}
\Hypertarget{group__strings__substring_ga663b4812c350c7070c90aa9aff653fab}\label{group__strings__substring_ga663b4812c350c7070c90aa9aff653fab} 
\index{Strings\_substring@{Strings\_substring}!slice\_strings@{slice\_strings}}
\index{slice\_strings@{slice\_strings}!Strings\_substring@{Strings\_substring}}
\doxysubsubsection{\texorpdfstring{slice\_strings()}{slice\_strings()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::strings\+::slice\+\_\+strings (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&}]{strings,  }\item[{\mbox{\hyperlink{classcudf_1_1string__scalar}{string\+\_\+scalar}} const \&}]{delimiter,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{count,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Slices a column of strings by using a delimiter as a slice point. 

Returns a column of strings after searching for {\ttfamily delimiter} {\ttfamily count} number of times in the source {\ttfamily strings} from left to right if {\ttfamily count} is positive or from right to left if {\ttfamily count} is negative. If {\ttfamily count} is positive, it returns a substring from the start of the source {\ttfamily strings} up until {\ttfamily count} occurrence of the {\ttfamily delimiter} not including the {\ttfamily delimiter}. If {\ttfamily count} is negative, it returns a substring from the start of the {\ttfamily count} occurrence of the {\ttfamily delimiter} in the source {\ttfamily strings} past the delimiter until the end of the string.

The search for {\ttfamily delimiter} in {\ttfamily strings} is case sensitive. If the row value of {\ttfamily strings} is null, the row value in the output column will be null. If the {\ttfamily count} is 0 or if {\ttfamily delimiter} is invalid or empty, every row in the output column will be an empty string. If the column value for a row is empty, the row value in the output column will be empty. If {\ttfamily count} occurrences of {\ttfamily delimiter} isn\textquotesingle{}t found, the row value in the output column will be the row value from the input {\ttfamily strings} column.


\begin{DoxyCode}{0}
\DoxyCodeLine{Example:}
\DoxyCodeLine{in\_s\ =\ ['www.nvidia.com',\ null,\ 'www.google.com',\ '',\ 'foo']}
\DoxyCodeLine{r\ =\ slice\_strings(in\_s,\ '.',\ 1)}
\DoxyCodeLine{r\ =\ \ \ \ ['www',\ \ \ \ \ \ \ \ \ \ \ \ null,\ 'www',\ \ \ \ \ \ \ \ \ \ \ \ '',\ 'foo']}
\DoxyCodeLine{}
\DoxyCodeLine{in\_s\ =\ ['www.nvidia.com',\ null,\ 'www.google.com',\ '',\ 'foo']}
\DoxyCodeLine{r\ =\ slice\_strings(in\_s,\ '.',\ -\/2)}
\DoxyCodeLine{r\ =\ \ \ \ ['nvidia.com',\ \ \ \ \ null,\ 'google.com',\ \ \ \ \ '',\ 'foo']}

\end{DoxyCode}



\begin{DoxyParams}{参数}
{\em strings} & Strings instance for this operation. \\
\hline
{\em delimiter} & UTF-\/8 encoded string to search for in each string. \\
\hline
{\em count} & Number of times to search for delimiter in each string. If the value is positive, delimiter is searched from left to right; else, it is searched from right to left. \\
\hline
{\em mr} & Resource for allocating device memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
New strings column containing the substrings. 
\end{DoxyReturn}
\Hypertarget{group__strings__substring_ga867eac9aa0fef7d1971cfc09f6b9aaf2}\label{group__strings__substring_ga867eac9aa0fef7d1971cfc09f6b9aaf2} 
\index{Strings\_substring@{Strings\_substring}!slice\_strings@{slice\_strings}}
\index{slice\_strings@{slice\_strings}!Strings\_substring@{Strings\_substring}}
\doxysubsubsection{\texorpdfstring{slice\_strings()}{slice\_strings()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::strings\+::slice\+\_\+strings (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&}]{strings,  }\item[{\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&}]{delimiter\+\_\+strings,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{count,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Slices a column of strings by using a delimiter column as slice points. 

Returns a column of strings after searching the delimiter defined per row from {\ttfamily delimiter\+\_\+strings} {\ttfamily count} number of times in the source {\ttfamily strings} from left to right if {\ttfamily count} is positive or from right to left if {\ttfamily count} is negative. If {\ttfamily count} is positive, it returns a substring from the start of the source {\ttfamily strings} up until {\ttfamily count} occurrence of the delimiter for that row not including that delimiter. If {\ttfamily count} is negative, it returns a substring from the start of the {\ttfamily count} occurrence of the delimiter for that row in the source {\ttfamily strings} past the delimiter until the end of the string.

The search for {\ttfamily delimiter\+\_\+strings} in {\ttfamily strings} is case sensitive. If the {\ttfamily count} is 0, every row in the output column will be an empty string. If the row value of {\ttfamily strings} is null, the row value in the output column will be null. If the row value from {\ttfamily delimiter\+\_\+strings} is invalid or null, the row value in the output column will be an empty string. If the row value from {\ttfamily delimiter\+\_\+strings} or the column value for a row is empty, the row value in the output column will be empty. If {\ttfamily count} occurrences of delimiter isn\textquotesingle{}t found, the row value in the output column will be the row value from the input {\ttfamily strings} column.


\begin{DoxyCode}{0}
\DoxyCodeLine{Example:}
\DoxyCodeLine{in\_s\ =\ \ \ \ \ \ \ ['www.nvidia.com',\ null,\ 'www.google.com',\ 'bar',\ 'foo..bar....goo']}
\DoxyCodeLine{delimiters\ =\ ['.',\ \ \ \ \ \ \ \ \ \ \ \ \ \ '..',\ '',\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ null,\ \ '..']}
\DoxyCodeLine{r\ =\ slice\_strings(in\_s,\ delimiters,\ 2)}
\DoxyCodeLine{r\ =\ \ \ \ \ \ \ \ \ \ ['www.nvidia',\ \ \ \ \ null,\ '',\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ '',\ \ \ 'foo..bar']}
\DoxyCodeLine{}
\DoxyCodeLine{in\_s\ =\ \ \ \ \ \ \ ['www.nvidia.com',\ null,\ 'www.google.com',\ '',\ \ 'foo..bar....goo',\ 'apache.org']}
\DoxyCodeLine{delimiters\ =\ ['.',\ \ \ \ \ \ \ \ \ \ \ \ \ \ '..',\ '',\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ null,'..',\ \ \ \ \ \ \ \ \ \ \ \ \ \ '.']}
\DoxyCodeLine{r\ =\ slice\_strings(in\_s,\ delimiters,\ -\/2)}
\DoxyCodeLine{r\ =\ \ \ \ \ \ \ \ \ \ ['nvidia.com',\ \ \ \ \ null,\ '',\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ '',\ \ '..goo',\ \ \ \ \ \ \ \ \ \ \ 'apache.org']}

\end{DoxyCode}



\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if the number of rows in {\ttfamily strings} and {\ttfamily delimiter\+\_\+strings} do not match.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em strings} & Strings instance for this operation. \\
\hline
{\em delimiter\+\_\+strings} & UTF-\/8 encoded string for each row. \\
\hline
{\em count} & Number of times to search for delimiter in each string. If the value is positive, delimiter is searched from left to right; else, it is searched from right to left. \\
\hline
{\em mr} & Resource for allocating device memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
New strings column containing the substrings. 
\end{DoxyReturn}
