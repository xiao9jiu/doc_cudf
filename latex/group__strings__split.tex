\doxysection{Strings\+\_\+split}
\hypertarget{group__strings__split}{}\label{group__strings__split}\index{Strings\_split@{Strings\_split}}
\doxysubsubsection*{文件}
\begin{DoxyCompactItemize}
\item 
文件 \mbox{\hyperlink{partition_8hpp}{partition.\+hpp}}
\begin{DoxyCompactList}\small\item\em Strings partition APIs \end{DoxyCompactList}\item 
文件 \mbox{\hyperlink{split_8hpp}{split.\+hpp}}
\item 
文件 \mbox{\hyperlink{split__re_8hpp}{split\+\_\+re.\+hpp}}
\end{DoxyCompactItemize}
\doxysubsubsection*{函数}
\begin{DoxyCompactItemize}
\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{group__strings__split_ga88e6a75cd8258c08eb5521e8e2ccc1f2}{cudf\+::strings\+::partition}} (\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&strings, \mbox{\hyperlink{classcudf_1_1string__scalar}{string\+\_\+scalar}} const \&delimiter=\mbox{\hyperlink{classcudf_1_1string__scalar}{string\+\_\+scalar}}(\"{}\"{}), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Returns a set of 3 columns by splitting each string using the specified delimiter. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{group__strings__split_gab2c37c1b02612bc457490527711bae3c}{cudf\+::strings\+::rpartition}} (\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&strings, \mbox{\hyperlink{classcudf_1_1string__scalar}{string\+\_\+scalar}} const \&delimiter=\mbox{\hyperlink{classcudf_1_1string__scalar}{string\+\_\+scalar}}(\"{}\"{}), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Returns a set of 3 columns by splitting each string using the specified delimiter starting from the end of each string. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{group__strings__split_ga1ab09be49da60ba93ea72ec5df0549ed}{cudf\+::strings\+::split}} (\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&strings\+\_\+column, \mbox{\hyperlink{classcudf_1_1string__scalar}{string\+\_\+scalar}} const \&delimiter=\mbox{\hyperlink{classcudf_1_1string__scalar}{string\+\_\+scalar}}(\"{}\"{}), \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} maxsplit=-\/1, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Returns a list of columns by splitting each string using the specified delimiter. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{group__strings__split_gaf9348662853f31e26cd9a9441c6bd5ab}{cudf\+::strings\+::rsplit}} (\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&strings\+\_\+column, \mbox{\hyperlink{classcudf_1_1string__scalar}{string\+\_\+scalar}} const \&delimiter=\mbox{\hyperlink{classcudf_1_1string__scalar}{string\+\_\+scalar}}(\"{}\"{}), \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} maxsplit=-\/1, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Returns a list of columns by splitting each string using the specified delimiter starting from the end of each string. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__strings__split_ga0eb7bd2d112b6828dbec54abf77b932c}{cudf\+::strings\+::split\+\_\+record}} (\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&strings, \mbox{\hyperlink{classcudf_1_1string__scalar}{string\+\_\+scalar}} const \&delimiter=\mbox{\hyperlink{classcudf_1_1string__scalar}{string\+\_\+scalar}}(\"{}\"{}), \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} maxsplit=-\/1, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Splits individual strings elements into a list of strings. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__strings__split_ga5ae1cc7ff76c823e997b2b670fd781c7}{cudf\+::strings\+::rsplit\+\_\+record}} (\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&strings, \mbox{\hyperlink{classcudf_1_1string__scalar}{string\+\_\+scalar}} const \&delimiter=\mbox{\hyperlink{classcudf_1_1string__scalar}{string\+\_\+scalar}}(\"{}\"{}), \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} maxsplit=-\/1, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Splits individual strings elements into a list of strings starting from the end of each string. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{group__strings__split_gab8bb4e1b4228bb7441fdb8c37ebffd1e}{cudf\+::strings\+::split\+\_\+re}} (\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&input, std\+::string\+\_\+view pattern, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} maxsplit=-\/1, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Splits strings elements into a table of strings columns using a regex pattern to delimit each string. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{group__strings__split_ga17a13df72c815545cf1557c451f87d6b}{cudf\+::strings\+::split\+\_\+re}} (\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&input, \mbox{\hyperlink{structcudf_1_1strings_1_1regex__program}{regex\+\_\+program}} const \&prog, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} maxsplit=-\/1, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Splits strings elements into a table of strings columns using a \doxylink{structcudf_1_1strings_1_1regex__program}{regex\+\_\+program}\textquotesingle{}s pattern to delimit each string \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{group__strings__split_ga356a219d0120584420992326904da312}{cudf\+::strings\+::rsplit\+\_\+re}} (\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&input, std\+::string\+\_\+view pattern, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} maxsplit=-\/1, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Splits strings elements into a table of strings columns using a regex pattern to delimit each string starting from the end of the string. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{group__strings__split_ga11b6651b83590d54fcbf28fefb19e80e}{cudf\+::strings\+::rsplit\+\_\+re}} (\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&input, \mbox{\hyperlink{structcudf_1_1strings_1_1regex__program}{regex\+\_\+program}} const \&prog, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} maxsplit=-\/1, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Splits strings elements into a table of strings columns using a \doxylink{structcudf_1_1strings_1_1regex__program}{regex\+\_\+program}\textquotesingle{}s pattern to delimit each string starting from the end of the string \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__strings__split_ga71f49fbda9a72211b1f1bd6498c6fd0f}{cudf\+::strings\+::split\+\_\+record\+\_\+re}} (\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&input, std\+::string\+\_\+view pattern, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} maxsplit=-\/1, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Splits strings elements into a list column of strings using the given regex pattern to delimit each string. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__strings__split_gafddde2063efdfe838d69785801ba3d58}{cudf\+::strings\+::split\+\_\+record\+\_\+re}} (\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&input, \mbox{\hyperlink{structcudf_1_1strings_1_1regex__program}{regex\+\_\+program}} const \&prog, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} maxsplit=-\/1, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Splits strings elements into a list column of strings using the given \doxylink{structcudf_1_1strings_1_1regex__program}{regex\+\_\+program} to delimit each string \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__strings__split_ga4bf12a6d71f1d3cdb84661472d5ead80}{cudf\+::strings\+::rsplit\+\_\+record\+\_\+re}} (\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&input, std\+::string\+\_\+view pattern, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} maxsplit=-\/1, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Splits strings elements into a list column of strings using the given regex pattern to delimit each string starting from the end of the string. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__strings__split_gadd373da6619b75c526bebbf1d0cebc05}{cudf\+::strings\+::rsplit\+\_\+record\+\_\+re}} (\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&input, \mbox{\hyperlink{structcudf_1_1strings_1_1regex__program}{regex\+\_\+program}} const \&prog, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} maxsplit=-\/1, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Splits strings elements into a list column of strings using the given \doxylink{structcudf_1_1strings_1_1regex__program}{regex\+\_\+program} to delimit each string starting from the end of the string \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{详细描述}


\doxysubsection{函数说明}
\Hypertarget{group__strings__split_ga88e6a75cd8258c08eb5521e8e2ccc1f2}\label{group__strings__split_ga88e6a75cd8258c08eb5521e8e2ccc1f2} 
\index{Strings\_split@{Strings\_split}!partition@{partition}}
\index{partition@{partition}!Strings\_split@{Strings\_split}}
\doxysubsubsection{\texorpdfstring{partition()}{partition()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::strings\+::partition (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&}]{strings,  }\item[{\mbox{\hyperlink{classcudf_1_1string__scalar}{string\+\_\+scalar}} const \&}]{delimiter = {\ttfamily \mbox{\hyperlink{classcudf_1_1string__scalar}{string\+\_\+scalar}}(\"{}\"{})},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Returns a set of 3 columns by splitting each string using the specified delimiter. 

The number of rows in the output columns will be the same as the input column. The first column will contain the first tokens of each string as a result of the split. The second column will contain the delimiter. The third column will contain the remaining characters of each string after the delimiter.

Any null string entries return corresponding null output columns.


\begin{DoxyCode}{0}
\DoxyCodeLine{Example:}
\DoxyCodeLine{s\ =\ ["{}ab\_cd"{},"{}def\_g\_h"{}]}
\DoxyCodeLine{r\ =\ partition(s,"{}\_"{})}
\DoxyCodeLine{r[0]\ is\ ["{}ab"{},"{}def"{}]}
\DoxyCodeLine{r[1]\ is\ ["{}\_"{},"{}\_"{}]}
\DoxyCodeLine{r[2]\ is\ ["{}cd"{},"{}g\_h"{}]}

\end{DoxyCode}



\begin{DoxyParams}{参数}
{\em strings} & Strings instance for this operation. \\
\hline
{\em delimiter} & UTF-\/8 encoded string indicating where to split each string. Default of empty string indicates split on whitespace. \\
\hline
{\em mr} & Device memory resource used to allocate the returned table\textquotesingle{}s device memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
New table of strings columns. 
\end{DoxyReturn}
\Hypertarget{group__strings__split_gab2c37c1b02612bc457490527711bae3c}\label{group__strings__split_gab2c37c1b02612bc457490527711bae3c} 
\index{Strings\_split@{Strings\_split}!rpartition@{rpartition}}
\index{rpartition@{rpartition}!Strings\_split@{Strings\_split}}
\doxysubsubsection{\texorpdfstring{rpartition()}{rpartition()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::strings\+::rpartition (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&}]{strings,  }\item[{\mbox{\hyperlink{classcudf_1_1string__scalar}{string\+\_\+scalar}} const \&}]{delimiter = {\ttfamily \mbox{\hyperlink{classcudf_1_1string__scalar}{string\+\_\+scalar}}(\"{}\"{})},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Returns a set of 3 columns by splitting each string using the specified delimiter starting from the end of each string. 

The number of rows in the output columns will be the same as the input column. The first column will contain the characters of each string before the last delimiter found. The second column will contain the delimiter. The third column will contain the remaining characters of each string after the delimiter.

Any null string entries return corresponding null output columns.


\begin{DoxyCode}{0}
\DoxyCodeLine{Example:}
\DoxyCodeLine{s\ =\ ["{}ab\_cd"{},"{}def\_g\_h"{}]}
\DoxyCodeLine{r\ =\ rpartition(s,"{}\_"{})}
\DoxyCodeLine{r[0]\ is\ ["{}ab"{},"{}def\_g"{}]}
\DoxyCodeLine{r[1]\ is\ ["{}\_"{},"{}\_"{}]}
\DoxyCodeLine{r[2]\ is\ ["{}cd"{},"{}h"{}]}

\end{DoxyCode}



\begin{DoxyParams}{参数}
{\em strings} & Strings instance for this operation. \\
\hline
{\em delimiter} & UTF-\/8 encoded string indicating where to split each string. Default of empty string indicates split on whitespace. \\
\hline
{\em mr} & Device memory resource used to allocate the returned table\textquotesingle{}s device memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
New strings columns. 
\end{DoxyReturn}
\Hypertarget{group__strings__split_gaf9348662853f31e26cd9a9441c6bd5ab}\label{group__strings__split_gaf9348662853f31e26cd9a9441c6bd5ab} 
\index{Strings\_split@{Strings\_split}!rsplit@{rsplit}}
\index{rsplit@{rsplit}!Strings\_split@{Strings\_split}}
\doxysubsubsection{\texorpdfstring{rsplit()}{rsplit()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::strings\+::rsplit (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&}]{strings\+\_\+column,  }\item[{\mbox{\hyperlink{classcudf_1_1string__scalar}{string\+\_\+scalar}} const \&}]{delimiter = {\ttfamily \mbox{\hyperlink{classcudf_1_1string__scalar}{string\+\_\+scalar}}(\"{}\"{})},  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{maxsplit = {\ttfamily -\/1},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Returns a list of columns by splitting each string using the specified delimiter starting from the end of each string. 

The number of rows in the output columns will be the same as the input column. The first column will contain the first tokens encountered in each string as a result of the split. Subsequent columns contain the next token strings. Null entries are added for a row where split results have been exhausted. The total number of columns will equal the maximum number of splits encountered on any string in the input column.

Any null string entries return corresponding null output columns.


\begin{DoxyParams}{参数}
{\em strings\+\_\+column} & Strings instance for this operation. \\
\hline
{\em delimiter} & UTF-\/8 encoded string indicating the split points in each string. Default of empty string indicates split on whitespace. \\
\hline
{\em maxsplit} & Maximum number of splits to perform. Default of -\/1 indicates all possible splits on each string. \\
\hline
{\em mr} & Device memory resource used to allocate the returned table\textquotesingle{}s device memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
New strings columns. 
\end{DoxyReturn}
\Hypertarget{group__strings__split_ga11b6651b83590d54fcbf28fefb19e80e}\label{group__strings__split_ga11b6651b83590d54fcbf28fefb19e80e} 
\index{Strings\_split@{Strings\_split}!rsplit\_re@{rsplit\_re}}
\index{rsplit\_re@{rsplit\_re}!Strings\_split@{Strings\_split}}
\doxysubsubsection{\texorpdfstring{rsplit\_re()}{rsplit\_re()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::strings\+::rsplit\+\_\+re (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&}]{input,  }\item[{\mbox{\hyperlink{structcudf_1_1strings_1_1regex__program}{regex\+\_\+program}} const \&}]{prog,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{maxsplit = {\ttfamily -\/1},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Splits strings elements into a table of strings columns using a \doxylink{structcudf_1_1strings_1_1regex__program}{regex\+\_\+program}\textquotesingle{}s pattern to delimit each string starting from the end of the string 

Each element generates a vector of strings that are stored in corresponding rows in the output table -- {\ttfamily table\mbox{[}col,row\mbox{]} = token\mbox{[}col\mbox{]} of string\mbox{[}row\mbox{]}} where {\ttfamily token} is the substring between each delimiter.

The number of rows in the output table will be the same as the number of elements in the input column. The resulting number of columns will be the maximum number of tokens found in any input row.

Splitting occurs by traversing starting from the end of the input string. The {\ttfamily pattern} is used to identify the delimiters within a string and splitting stops when either {\ttfamily maxsplit} or the beginning of the string is reached.

An empty input string will produce a corresponding empty string in the corresponding row of the first column. A null row will produce corresponding null rows in the output table.

The \doxylink{structcudf_1_1strings_1_1regex__program}{regex\+\_\+program}\textquotesingle{}s regex\+\_\+flags are ignored.


\begin{DoxyCode}{0}
\DoxyCodeLine{s\ =\ ["{}a\_bc\ def\_g"{},\ "{}a\_\_bc"{},\ "{}\_ab\ cd"{},\ "{}ab\_cd\ "{}]}
\DoxyCodeLine{p1\ =\ regex\_program::create("{}[\_\ ]"{})}
\DoxyCodeLine{s1\ =\ rsplit\_re(s,\ p1)}
\DoxyCodeLine{s1\ is\ a\ table\ of\ strings\ columns:}
\DoxyCodeLine{\ \ \ \ [\ ["{}a"{},\ "{}a"{},\ "{}"{},\ "{}ab"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}bc"{},\ "{}"{},\ "{}ab"{},\ "{}cd"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}def"{},\ "{}bc"{},\ "{}cd"{},\ "{}"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}g"{},\ null,\ null,\ null]\ ]}
\DoxyCodeLine{p2\ =\ regex\_program::create("{}[\ \_]"{})}
\DoxyCodeLine{s2\ =\ rsplit\_re(s,\ p2,\ 1)}
\DoxyCodeLine{s2\ is\ a\ table\ of\ strings\ columns:}
\DoxyCodeLine{\ \ \ \ [\ ["{}a\_bc\ def"{},\ "{}a\_"{},\ "{}\_ab"{},\ "{}ab"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}g"{},\ "{}bc"{},\ "{}cd"{},\ "{}cd\ "{}]\ ]}

\end{DoxyCode}



\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily pattern} is empty.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em input} & A column of string elements to be split. \\
\hline
{\em prog} & Regex program instance \\
\hline
{\em maxsplit} & Maximum number of splits to perform. Default of -\/1 indicates all possible splits on each string. \\
\hline
{\em mr} & Device memory resource used to allocate the returned result\textquotesingle{}s device memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A table of columns of strings. 
\end{DoxyReturn}
\Hypertarget{group__strings__split_ga356a219d0120584420992326904da312}\label{group__strings__split_ga356a219d0120584420992326904da312} 
\index{Strings\_split@{Strings\_split}!rsplit\_re@{rsplit\_re}}
\index{rsplit\_re@{rsplit\_re}!Strings\_split@{Strings\_split}}
\doxysubsubsection{\texorpdfstring{rsplit\_re()}{rsplit\_re()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::strings\+::rsplit\+\_\+re (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&}]{input,  }\item[{std\+::string\+\_\+view}]{pattern,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{maxsplit = {\ttfamily -\/1},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Splits strings elements into a table of strings columns using a regex pattern to delimit each string starting from the end of the string. 

Each element generates a vector of strings that are stored in corresponding rows in the output table -- {\ttfamily table\mbox{[}col,row\mbox{]} = token\mbox{[}col\mbox{]} of string\mbox{[}row\mbox{]}} where {\ttfamily token} is the substring between each delimiter.

The number of rows in the output table will be the same as the number of elements in the input column. The resulting number of columns will be the maximum number of tokens found in any input row.

Splitting occurs by traversing starting from the end of the input string. The {\ttfamily pattern} is used to identify the delimiters within a string and splitting stops when either {\ttfamily maxsplit} or the beginning of the string is reached.

An empty input string will produce a corresponding empty string in the corresponding row of the first column. A null row will produce corresponding null rows in the output table.


\begin{DoxyCode}{0}
\DoxyCodeLine{s\ =\ ["{}a\_bc\ def\_g"{},\ "{}a\_\_bc"{},\ "{}\_ab\ cd"{},\ "{}ab\_cd\ "{}]}
\DoxyCodeLine{s1\ =\ rsplit\_re(s,\ "{}[\_\ ]"{})}
\DoxyCodeLine{s1\ is\ a\ table\ of\ strings\ columns:}
\DoxyCodeLine{\ \ \ \ [\ ["{}a"{},\ "{}a"{},\ "{}"{},\ "{}ab"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}bc"{},\ "{}"{},\ "{}ab"{},\ "{}cd"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}def"{},\ "{}bc"{},\ "{}cd"{},\ "{}"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}g"{},\ null,\ null,\ null]\ ]}
\DoxyCodeLine{s2\ =\ rsplit\_re(s,\ "{}[\ \_]"{},\ 1)}
\DoxyCodeLine{s2\ is\ a\ table\ of\ strings\ columns:}
\DoxyCodeLine{\ \ \ \ [\ ["{}a\_bc\ def"{},\ "{}a\_"{},\ "{}\_ab"{},\ "{}ab"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}g"{},\ "{}bc"{},\ "{}cd"{},\ "{}cd\ "{}]\ ]}

\end{DoxyCode}



\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily pattern} is empty.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em input} & A column of string elements to be split. \\
\hline
{\em pattern} & The regex pattern for delimiting characters within each string. \\
\hline
{\em maxsplit} & Maximum number of splits to perform. Default of -\/1 indicates all possible splits on each string. \\
\hline
{\em mr} & Device memory resource used to allocate the returned result\textquotesingle{}s device memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A table of columns of strings. 
\end{DoxyReturn}
\Hypertarget{group__strings__split_ga5ae1cc7ff76c823e997b2b670fd781c7}\label{group__strings__split_ga5ae1cc7ff76c823e997b2b670fd781c7} 
\index{Strings\_split@{Strings\_split}!rsplit\_record@{rsplit\_record}}
\index{rsplit\_record@{rsplit\_record}!Strings\_split@{Strings\_split}}
\doxysubsubsection{\texorpdfstring{rsplit\_record()}{rsplit\_record()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::strings\+::rsplit\+\_\+record (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&}]{strings,  }\item[{\mbox{\hyperlink{classcudf_1_1string__scalar}{string\+\_\+scalar}} const \&}]{delimiter = {\ttfamily \mbox{\hyperlink{classcudf_1_1string__scalar}{string\+\_\+scalar}}(\"{}\"{})},  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{maxsplit = {\ttfamily -\/1},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Splits individual strings elements into a list of strings starting from the end of each string. 

Each element generates an array of strings that are stored in an output lists column.

The number of elements in the output column will be the same as the number of elements in the input column. Each individual list item will contain the new strings for that row. The resulting number of strings in each row can vary from 0 to {\ttfamily maxsplit + 1}.

The {\ttfamily delimiter} is searched from end to beginning within each string and splitting stops when either {\ttfamily maxsplit} or the beginning of the string is reached.

If a delimiter is not whitespace and occurs adjacent to another delimiter, an empty string is produced for that split occurrence. Likewise, a non-\/whitespace delimiter produces an empty string if it appears at the beginning or the end of a string.

Note that {\ttfamily rsplit\+\_\+record} and {\ttfamily split\+\_\+record} produce equivalent results for the default {\ttfamily maxsplit} value.


\begin{DoxyCode}{0}
\DoxyCodeLine{s\ =\ ["{}a\_bc\_def\_g"{},\ "{}a\_\_bc"{},\ "{}\_ab\_cd"{},\ "{}ab\_cd\_"{}]}
\DoxyCodeLine{s1\ =\ rsplit\_record(s,\ "{}\_"{})}
\DoxyCodeLine{s1\ is\ a\ lists\ column\ of\ strings:}
\DoxyCodeLine{\ \ \ \ [\ ["{}a"{},\ "{}bc"{},\ "{}def"{},\ "{}g"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}a"{},\ "{}"{},\ "{}bc"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}"{},\ "{}ab"{},\ "{}cd"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}ab"{},\ "{}cd"{},\ "{}"{}]\ ]}
\DoxyCodeLine{s2\ =\ rsplit\_record(s,\ "{}\_"{},\ 1)}
\DoxyCodeLine{s2\ is\ a\ lists\ column\ of\ strings:}
\DoxyCodeLine{\ \ \ \ [\ ["{}a\_bc\_def"{},\ "{}g"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}a\_"{},\ "{}bc"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}\_ab"{},\ "{}cd"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}ab\_cd"{},\ "{}"{}]\ ]}

\end{DoxyCode}


A whitespace delimiter produces no empty strings. 
\begin{DoxyCode}{0}
\DoxyCodeLine{s\ =\ ["{}a\ bc\ def"{},\ "{}a\ \ bc"{},\ "{}\ ab\ cd"{},\ "{}ab\ cd\ "{}]}
\DoxyCodeLine{s1\ =\ rsplit\_record(s,\ "{}"{})}
\DoxyCodeLine{s1\ is\ a\ lists\ column\ of\ strings:}
\DoxyCodeLine{\ \ \ \ [\ ["{}a"{},\ "{}bc"{},\ "{}def"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}a"{},\ "{}bc"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}ab"{},\ "{}cd"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}ab"{},\ "{}cd"{}]\ ]}
\DoxyCodeLine{s2\ =\ rsplit\_record(s,\ "{}"{},\ 1)}
\DoxyCodeLine{s2\ is\ a\ lists\ column\ of\ strings:}
\DoxyCodeLine{\ \ \ \ [\ ["{}a\ bc"{},\ "{}def"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}a"{},\ "{}bc"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}\ ab"{},\ "{}cd"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}ab"{},\ "{}cd"{}]\ ]}

\end{DoxyCode}


A null string element will result in a null list item for that row.


\begin{DoxyExceptions}{异常}
{\em cudf\+:logic\+\_\+error} & if {\ttfamily delimiter} is invalid.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em strings} & A column of string elements to be split. \\
\hline
{\em delimiter} & The string to identify split points in each string. Default of empty string indicates split on whitespace. \\
\hline
{\em maxsplit} & Maximum number of splits to perform. Default of -\/1 indicates all possible splits on each string. \\
\hline
{\em mr} & Device memory resource used to allocate the returned result\textquotesingle{}s device memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Lists column of strings Each vector of the lists column holds splits from a single row element of the input column. 
\end{DoxyReturn}
\Hypertarget{group__strings__split_gadd373da6619b75c526bebbf1d0cebc05}\label{group__strings__split_gadd373da6619b75c526bebbf1d0cebc05} 
\index{Strings\_split@{Strings\_split}!rsplit\_record\_re@{rsplit\_record\_re}}
\index{rsplit\_record\_re@{rsplit\_record\_re}!Strings\_split@{Strings\_split}}
\doxysubsubsection{\texorpdfstring{rsplit\_record\_re()}{rsplit\_record\_re()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::strings\+::rsplit\+\_\+record\+\_\+re (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&}]{input,  }\item[{\mbox{\hyperlink{structcudf_1_1strings_1_1regex__program}{regex\+\_\+program}} const \&}]{prog,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{maxsplit = {\ttfamily -\/1},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Splits strings elements into a list column of strings using the given \doxylink{structcudf_1_1strings_1_1regex__program}{regex\+\_\+program} to delimit each string starting from the end of the string 

Each element generates a vector of strings that are stored in an output lists column -- {\ttfamily list\mbox{[}row\mbox{]} = \mbox{[}token1, token2, ...\mbox{]} found in input\mbox{[}row\mbox{]}} where {\ttfamily token} is a substring between delimiters.

The number of elements in the output column will be the same as the number of elements in the input column. Each individual list item will contain the new strings for that row. The resulting number of strings in each row can vary from 0 to {\ttfamily maxsplit + 1}.

Splitting occurs by traversing starting from the end of the input string. The {\ttfamily pattern} is used to identify the separation points within a string and splitting stops when either {\ttfamily maxsplit} or the beginning of the string is reached.

An empty input string will produce a corresponding empty list item output row. A null row will produce a corresponding null output row.

The \doxylink{structcudf_1_1strings_1_1regex__program}{regex\+\_\+program}\textquotesingle{}s regex\+\_\+flags are ignored.


\begin{DoxyCode}{0}
\DoxyCodeLine{s\ =\ ["{}a\_bc\ def\_g"{},\ "{}a\_\_bc"{},\ "{}\_ab\ cd"{},\ "{}ab\_cd\ "{}]}
\DoxyCodeLine{p1\ =\ regex\_program::create("{}[\_\ ]"{})}
\DoxyCodeLine{s1\ =\ rsplit\_record\_re(s,\ p1)}
\DoxyCodeLine{s1\ is\ a\ lists\ column\ of\ strings:}
\DoxyCodeLine{\ \ \ \ [\ ["{}a"{},\ "{}bc"{},\ "{}def"{},\ "{}g"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}a"{},\ "{}"{},\ "{}bc"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}"{},\ "{}ab"{},\ "{}cd"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}ab"{},\ "{}cd"{},\ "{}"{}]\ ]}
\DoxyCodeLine{p2\ =\ regex\_program::create("{}[\ \_]"{})}
\DoxyCodeLine{s2\ =\ rsplit\_record\_re(s,\ p2,\ 1)}
\DoxyCodeLine{s2\ is\ a\ lists\ column\ of\ strings:}
\DoxyCodeLine{\ \ \ \ [\ ["{}a\_bc\ def"{},\ "{}g"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}a\_"{},\ "{}bc"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}\_ab"{},\ "{}cd"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}ab\_cd"{},\ "{}"{}]\ ]}

\end{DoxyCode}


See the Regex Features page for details on patterns supported by this API.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily pattern} is empty.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em input} & A column of string elements to be split \\
\hline
{\em prog} & Regex program instance \\
\hline
{\em maxsplit} & Maximum number of splits to perform. Default of -\/1 indicates all possible splits on each string. \\
\hline
{\em mr} & Device memory resource used to allocate the returned result\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Lists column of strings 
\end{DoxyReturn}
\Hypertarget{group__strings__split_ga4bf12a6d71f1d3cdb84661472d5ead80}\label{group__strings__split_ga4bf12a6d71f1d3cdb84661472d5ead80} 
\index{Strings\_split@{Strings\_split}!rsplit\_record\_re@{rsplit\_record\_re}}
\index{rsplit\_record\_re@{rsplit\_record\_re}!Strings\_split@{Strings\_split}}
\doxysubsubsection{\texorpdfstring{rsplit\_record\_re()}{rsplit\_record\_re()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::strings\+::rsplit\+\_\+record\+\_\+re (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&}]{input,  }\item[{std\+::string\+\_\+view}]{pattern,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{maxsplit = {\ttfamily -\/1},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Splits strings elements into a list column of strings using the given regex pattern to delimit each string starting from the end of the string. 

Each element generates a vector of strings that are stored in an output lists column -- {\ttfamily list\mbox{[}row\mbox{]} = \mbox{[}token1, token2, ...\mbox{]} found in input\mbox{[}row\mbox{]}} where {\ttfamily token} is a substring between delimiters.

The number of elements in the output column will be the same as the number of elements in the input column. Each individual list item will contain the new strings for that row. The resulting number of strings in each row can vary from 0 to {\ttfamily maxsplit + 1}.

Splitting occurs by traversing starting from the end of the input string. The {\ttfamily pattern} is used to identify the separation points within a string and splitting stops when either {\ttfamily maxsplit} or the beginning of the string is reached.

An empty input string will produce a corresponding empty list item output row. A null row will produce a corresponding null output row.


\begin{DoxyCode}{0}
\DoxyCodeLine{s\ =\ ["{}a\_bc\ def\_g"{},\ "{}a\_\_bc"{},\ "{}\_ab\ cd"{},\ "{}ab\_cd\ "{}]}
\DoxyCodeLine{s1\ =\ rsplit\_record\_re(s,\ "{}[\_\ ]"{})}
\DoxyCodeLine{s1\ is\ a\ lists\ column\ of\ strings:}
\DoxyCodeLine{\ \ \ \ [\ ["{}a"{},\ "{}bc"{},\ "{}def"{},\ "{}g"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}a"{},\ "{}"{},\ "{}bc"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}"{},\ "{}ab"{},\ "{}cd"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}ab"{},\ "{}cd"{},\ "{}"{}]\ ]}
\DoxyCodeLine{s2\ =\ rsplit\_record\_re(s,\ "{}[\ \_]"{},\ 1)}
\DoxyCodeLine{s2\ is\ a\ lists\ column\ of\ strings:}
\DoxyCodeLine{\ \ \ \ [\ ["{}a\_bc\ def"{},\ "{}g"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}a\_"{},\ "{}bc"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}\_ab"{},\ "{}cd"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}ab\_cd"{},\ "{}"{}]\ ]}

\end{DoxyCode}


See the Regex Features page for details on patterns supported by this API.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily pattern} is empty.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em input} & A column of string elements to be split. \\
\hline
{\em pattern} & The regex pattern for delimiting characters within each string. \\
\hline
{\em maxsplit} & Maximum number of splits to perform. Default of -\/1 indicates all possible splits on each string. \\
\hline
{\em mr} & Device memory resource used to allocate the returned result\textquotesingle{}s device memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Lists column of strings. 
\end{DoxyReturn}
\Hypertarget{group__strings__split_ga1ab09be49da60ba93ea72ec5df0549ed}\label{group__strings__split_ga1ab09be49da60ba93ea72ec5df0549ed} 
\index{Strings\_split@{Strings\_split}!split@{split}}
\index{split@{split}!Strings\_split@{Strings\_split}}
\doxysubsubsection{\texorpdfstring{split()}{split()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::strings\+::split (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&}]{strings\+\_\+column,  }\item[{\mbox{\hyperlink{classcudf_1_1string__scalar}{string\+\_\+scalar}} const \&}]{delimiter = {\ttfamily \mbox{\hyperlink{classcudf_1_1string__scalar}{string\+\_\+scalar}}(\"{}\"{})},  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{maxsplit = {\ttfamily -\/1},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Returns a list of columns by splitting each string using the specified delimiter. 

The number of rows in the output columns will be the same as the input column. The first column will contain the first tokens of each string as a result of the split. Subsequent columns contain the next token strings. Null entries are added for a row where split results have been exhausted. The total number of columns will equal the maximum number of splits encountered on any string in the input column.

Any null string entries return corresponding null output columns.


\begin{DoxyParams}{参数}
{\em strings\+\_\+column} & Strings instance for this operation. \\
\hline
{\em delimiter} & UTF-\/8 encoded string indicating the split points in each string. Default of empty string indicates split on whitespace. \\
\hline
{\em maxsplit} & Maximum number of splits to perform. Default of -\/1 indicates all possible splits on each string. \\
\hline
{\em mr} & Device memory resource used to allocate the returned table\textquotesingle{}s device memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
New table of strings columns. 
\end{DoxyReturn}
\Hypertarget{group__strings__split_ga17a13df72c815545cf1557c451f87d6b}\label{group__strings__split_ga17a13df72c815545cf1557c451f87d6b} 
\index{Strings\_split@{Strings\_split}!split\_re@{split\_re}}
\index{split\_re@{split\_re}!Strings\_split@{Strings\_split}}
\doxysubsubsection{\texorpdfstring{split\_re()}{split\_re()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::strings\+::split\+\_\+re (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&}]{input,  }\item[{\mbox{\hyperlink{structcudf_1_1strings_1_1regex__program}{regex\+\_\+program}} const \&}]{prog,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{maxsplit = {\ttfamily -\/1},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Splits strings elements into a table of strings columns using a \doxylink{structcudf_1_1strings_1_1regex__program}{regex\+\_\+program}\textquotesingle{}s pattern to delimit each string 

Each element generates a vector of strings that are stored in corresponding rows in the output table -- {\ttfamily table\mbox{[}col,row\mbox{]} = token\mbox{[}col\mbox{]} of strings\mbox{[}row\mbox{]}} where {\ttfamily token} is a substring between delimiters.

The number of rows in the output table will be the same as the number of elements in the input column. The resulting number of columns will be the maximum number of tokens found in any input row.

The {\ttfamily pattern} is used to identify the delimiters within a string and splitting stops when either {\ttfamily maxsplit} or the end of the string is reached.

An empty input string will produce a corresponding empty string in the corresponding row of the first column. A null row will produce corresponding null rows in the output table.

The \doxylink{structcudf_1_1strings_1_1regex__program}{regex\+\_\+program}\textquotesingle{}s regex\+\_\+flags are ignored.


\begin{DoxyCode}{0}
\DoxyCodeLine{s\ =\ ["{}a\_bc\ def\_g"{},\ "{}a\_\_bc"{},\ "{}\_ab\ cd"{},\ "{}ab\_cd\ "{}]}
\DoxyCodeLine{p1\ =\ regex\_program::create("{}[\_\ ]"{})}
\DoxyCodeLine{s1\ =\ split\_re(s,\ p1)}
\DoxyCodeLine{s1\ is\ a\ table\ of\ strings\ columns:}
\DoxyCodeLine{\ \ \ \ [\ ["{}a"{},\ "{}a"{},\ "{}"{},\ "{}ab"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}bc"{},\ "{}"{},\ "{}ab"{},\ "{}cd"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}def"{},\ "{}bc"{},\ "{}cd"{},\ "{}"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}g"{},\ null,\ null,\ null]\ ]}
\DoxyCodeLine{p2\ =\ regex\_program::create("{}[\ \_]"{})}
\DoxyCodeLine{s2\ =\ split\_re(s,\ p2,\ 1)}
\DoxyCodeLine{s2\ is\ a\ table\ of\ strings\ columns:}
\DoxyCodeLine{\ \ \ \ [\ ["{}a"{},\ "{}a"{},\ "{}"{},\ "{}ab"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}bc\ def\_g"{},\ "{}\_bc"{},\ "{}ab\ cd"{},\ "{}cd\ "{}]\ ]}

\end{DoxyCode}



\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily pattern} is empty.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em input} & A column of string elements to be split \\
\hline
{\em prog} & Regex program instance \\
\hline
{\em maxsplit} & Maximum number of splits to perform. Default of -\/1 indicates all possible splits on each string. \\
\hline
{\em mr} & Device memory resource used to allocate the returned result\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A table of columns of strings 
\end{DoxyReturn}
\Hypertarget{group__strings__split_gab8bb4e1b4228bb7441fdb8c37ebffd1e}\label{group__strings__split_gab8bb4e1b4228bb7441fdb8c37ebffd1e} 
\index{Strings\_split@{Strings\_split}!split\_re@{split\_re}}
\index{split\_re@{split\_re}!Strings\_split@{Strings\_split}}
\doxysubsubsection{\texorpdfstring{split\_re()}{split\_re()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::strings\+::split\+\_\+re (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&}]{input,  }\item[{std\+::string\+\_\+view}]{pattern,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{maxsplit = {\ttfamily -\/1},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Splits strings elements into a table of strings columns using a regex pattern to delimit each string. 

Each element generates a vector of strings that are stored in corresponding rows in the output table -- {\ttfamily table\mbox{[}col,row\mbox{]} = token\mbox{[}col\mbox{]} of strings\mbox{[}row\mbox{]}} where {\ttfamily token} is a substring between delimiters.

The number of rows in the output table will be the same as the number of elements in the input column. The resulting number of columns will be the maximum number of tokens found in any input row.

The {\ttfamily pattern} is used to identify the delimiters within a string and splitting stops when either {\ttfamily maxsplit} or the end of the string is reached.

An empty input string will produce a corresponding empty string in the corresponding row of the first column. A null row will produce corresponding null rows in the output table.


\begin{DoxyCode}{0}
\DoxyCodeLine{s\ =\ ["{}a\_bc\ def\_g"{},\ "{}a\_\_bc"{},\ "{}\_ab\ cd"{},\ "{}ab\_cd\ "{}]}
\DoxyCodeLine{s1\ =\ split\_re(s,\ "{}[\_\ ]"{})}
\DoxyCodeLine{s1\ is\ a\ table\ of\ strings\ columns:}
\DoxyCodeLine{\ \ \ \ [\ ["{}a"{},\ "{}a"{},\ "{}"{},\ "{}ab"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}bc"{},\ "{}"{},\ "{}ab"{},\ "{}cd"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}def"{},\ "{}bc"{},\ "{}cd"{},\ "{}"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}g"{},\ null,\ null,\ null]\ ]}
\DoxyCodeLine{s2\ =\ split\_re(s,\ "{}[\ \_]"{},\ 1)}
\DoxyCodeLine{s2\ is\ a\ table\ of\ strings\ columns:}
\DoxyCodeLine{\ \ \ \ [\ ["{}a"{},\ "{}a"{},\ "{}"{},\ "{}ab"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}bc\ def\_g"{},\ "{}\_bc"{},\ "{}ab\ cd"{},\ "{}cd\ "{}]\ ]}

\end{DoxyCode}



\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily pattern} is empty.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em input} & A column of string elements to be split. \\
\hline
{\em pattern} & The regex pattern for delimiting characters within each string. \\
\hline
{\em maxsplit} & Maximum number of splits to perform. Default of -\/1 indicates all possible splits on each string. \\
\hline
{\em mr} & Device memory resource used to allocate the returned result\textquotesingle{}s device memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A table of columns of strings. 
\end{DoxyReturn}
\Hypertarget{group__strings__split_ga0eb7bd2d112b6828dbec54abf77b932c}\label{group__strings__split_ga0eb7bd2d112b6828dbec54abf77b932c} 
\index{Strings\_split@{Strings\_split}!split\_record@{split\_record}}
\index{split\_record@{split\_record}!Strings\_split@{Strings\_split}}
\doxysubsubsection{\texorpdfstring{split\_record()}{split\_record()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::strings\+::split\+\_\+record (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&}]{strings,  }\item[{\mbox{\hyperlink{classcudf_1_1string__scalar}{string\+\_\+scalar}} const \&}]{delimiter = {\ttfamily \mbox{\hyperlink{classcudf_1_1string__scalar}{string\+\_\+scalar}}(\"{}\"{})},  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{maxsplit = {\ttfamily -\/1},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Splits individual strings elements into a list of strings. 

Each element generates an array of strings that are stored in an output lists column.

The number of elements in the output column will be the same as the number of elements in the input column. Each individual list item will contain the new strings for that row. The resulting number of strings in each row can vary from 0 to {\ttfamily maxsplit + 1}.

The {\ttfamily delimiter} is searched within each string from beginning to end and splitting stops when either {\ttfamily maxsplit} or the end of the string is reached.

If a delimiter is not whitespace and occurs adjacent to another delimiter, an empty string is produced for that split occurrence. Likewise, a non-\/whitespace delimiter produces an empty string if it appears at the beginning or the end of a string.


\begin{DoxyCode}{0}
\DoxyCodeLine{s\ =\ ["{}a\_bc\_def\_g"{},\ "{}a\_\_bc"{},\ "{}\_ab\_cd"{},\ "{}ab\_cd\_"{}]}
\DoxyCodeLine{s1\ =\ split\_record(s,\ "{}\_"{})}
\DoxyCodeLine{s1\ is\ a\ lists\ column\ of\ strings:}
\DoxyCodeLine{\ \ \ \ [\ ["{}a"{},\ "{}bc"{},\ "{}def"{},\ "{}g"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}a"{},\ "{}"{},\ "{}bc"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}"{},\ "{}ab"{},\ "{}cd"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}ab"{},\ "{}cd"{},\ "{}"{}]\ ]}
\DoxyCodeLine{s2\ =\ split\_record(s,\ "{}\_"{},\ 1)}
\DoxyCodeLine{s2\ is\ a\ lists\ column\ of\ strings:}
\DoxyCodeLine{\ \ \ \ [\ ["{}a"{},\ "{}bc\_def\_g"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}a"{},\ "{}\_bc"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}"{},\ "{}ab\_cd"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}ab"{},\ "{}cd\_"{}]\ ]}

\end{DoxyCode}


A whitespace delimiter produces no empty strings. 
\begin{DoxyCode}{0}
\DoxyCodeLine{s\ =\ ["{}a\ bc\ def"{},\ "{}a\ \ bc"{},\ "{}\ ab\ cd"{},\ "{}ab\ cd\ "{}]}
\DoxyCodeLine{s1\ =\ split\_record(s,\ "{}"{})}
\DoxyCodeLine{s1\ is\ a\ lists\ column\ of\ strings:}
\DoxyCodeLine{\ \ \ \ [\ ["{}a"{},\ "{}bc"{},\ "{}def"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}a"{},\ "{}bc"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}ab"{},\ "{}cd"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}ab"{},\ "{}cd"{}]\ ]}
\DoxyCodeLine{s2\ =\ split\_record(s,\ "{}"{},\ 1)}
\DoxyCodeLine{s2\ is\ a\ lists\ column\ of\ strings:}
\DoxyCodeLine{\ \ \ \ [\ ["{}a"{},\ "{}bc\ def"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}a"{},\ "{}bc"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}ab"{},\ "{}cd"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}ab"{},\ "{}cd\ "{}]\ ]}

\end{DoxyCode}


A null string element will result in a null list item for that row.


\begin{DoxyExceptions}{异常}
{\em cudf\+:logic\+\_\+error} & if {\ttfamily delimiter} is invalid.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em strings} & A column of string elements to be split. \\
\hline
{\em delimiter} & The string to identify split points in each string. Default of empty string indicates split on whitespace. \\
\hline
{\em maxsplit} & Maximum number of splits to perform. Default of -\/1 indicates all possible splits on each string. \\
\hline
{\em mr} & Device memory resource used to allocate the returned result\textquotesingle{}s device memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Lists column of strings Each vector of the lists column holds splits from a single row element of the input column. 
\end{DoxyReturn}
\Hypertarget{group__strings__split_gafddde2063efdfe838d69785801ba3d58}\label{group__strings__split_gafddde2063efdfe838d69785801ba3d58} 
\index{Strings\_split@{Strings\_split}!split\_record\_re@{split\_record\_re}}
\index{split\_record\_re@{split\_record\_re}!Strings\_split@{Strings\_split}}
\doxysubsubsection{\texorpdfstring{split\_record\_re()}{split\_record\_re()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::strings\+::split\+\_\+record\+\_\+re (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&}]{input,  }\item[{\mbox{\hyperlink{structcudf_1_1strings_1_1regex__program}{regex\+\_\+program}} const \&}]{prog,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{maxsplit = {\ttfamily -\/1},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Splits strings elements into a list column of strings using the given \doxylink{structcudf_1_1strings_1_1regex__program}{regex\+\_\+program} to delimit each string 

Each element generates an array of strings that are stored in an output lists column -- {\ttfamily list\mbox{[}row\mbox{]} = \mbox{[}token1, token2, ...\mbox{]} found in input\mbox{[}row\mbox{]}} where {\ttfamily token} is a substring between delimiters.

The number of elements in the output column will be the same as the number of elements in the input column. Each individual list item will contain the new strings for that row. The resulting number of strings in each row can vary from 0 to {\ttfamily maxsplit + 1}.

The {\ttfamily pattern} is used to identify the delimiters within a string and splitting stops when either {\ttfamily maxsplit} or the end of the string is reached.

An empty input string will produce a corresponding empty list item output row. A null row will produce a corresponding null output row.

The \doxylink{structcudf_1_1strings_1_1regex__program}{regex\+\_\+program}\textquotesingle{}s regex\+\_\+flags are ignored.


\begin{DoxyCode}{0}
\DoxyCodeLine{s\ =\ ["{}a\_bc\ def\_g"{},\ "{}a\_\_bc"{},\ "{}\_ab\ cd"{},\ "{}ab\_cd\ "{}]}
\DoxyCodeLine{p1\ =\ regex\_program::create("{}[\_\ ]"{})}
\DoxyCodeLine{s1\ =\ split\_record\_re(s,\ p1)}
\DoxyCodeLine{s1\ is\ a\ lists\ column\ of\ strings:}
\DoxyCodeLine{\ \ \ \ [\ ["{}a"{},\ "{}bc"{},\ "{}def"{},\ "{}g"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}a"{},\ "{}"{},\ "{}bc"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}"{},\ "{}ab"{},\ "{}cd"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}ab"{},\ "{}cd"{},\ "{}"{}]\ ]}
\DoxyCodeLine{p2\ =\ regex\_program::create("{}[\ \_]"{})}
\DoxyCodeLine{s2\ =\ split\_record\_re(s,\ p2,\ 1)}
\DoxyCodeLine{s2\ is\ a\ lists\ column\ of\ strings:}
\DoxyCodeLine{\ \ \ \ [\ ["{}a"{},\ "{}bc\ def\_g"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}a"{},\ "{}\_bc"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}"{},\ "{}ab\ cd"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}ab"{},\ "{}cd\ "{}]\ ]}

\end{DoxyCode}



\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily pattern} is empty.\\
\hline
\end{DoxyExceptions}
See the Regex Features page for details on patterns supported by this API.


\begin{DoxyParams}{参数}
{\em input} & A column of string elements to be split \\
\hline
{\em prog} & Regex program instance \\
\hline
{\em maxsplit} & Maximum number of splits to perform. Default of -\/1 indicates all possible splits on each string. \\
\hline
{\em mr} & Device memory resource used to allocate the returned result\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Lists column of strings. 
\end{DoxyReturn}
\Hypertarget{group__strings__split_ga71f49fbda9a72211b1f1bd6498c6fd0f}\label{group__strings__split_ga71f49fbda9a72211b1f1bd6498c6fd0f} 
\index{Strings\_split@{Strings\_split}!split\_record\_re@{split\_record\_re}}
\index{split\_record\_re@{split\_record\_re}!Strings\_split@{Strings\_split}}
\doxysubsubsection{\texorpdfstring{split\_record\_re()}{split\_record\_re()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::strings\+::split\+\_\+record\+\_\+re (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1strings__column__view}{strings\+\_\+column\+\_\+view}} const \&}]{input,  }\item[{std\+::string\+\_\+view}]{pattern,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{maxsplit = {\ttfamily -\/1},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Splits strings elements into a list column of strings using the given regex pattern to delimit each string. 

Each element generates an array of strings that are stored in an output lists column -- {\ttfamily list\mbox{[}row\mbox{]} = \mbox{[}token1, token2, ...\mbox{]} found in input\mbox{[}row\mbox{]}} where {\ttfamily token} is a substring between delimiters.

The number of elements in the output column will be the same as the number of elements in the input column. Each individual list item will contain the new strings for that row. The resulting number of strings in each row can vary from 0 to {\ttfamily maxsplit + 1}.

The {\ttfamily pattern} is used to identify the delimiters within a string and splitting stops when either {\ttfamily maxsplit} or the end of the string is reached.

An empty input string will produce a corresponding empty list item output row. A null row will produce a corresponding null output row.


\begin{DoxyCode}{0}
\DoxyCodeLine{s\ =\ ["{}a\_bc\ def\_g"{},\ "{}a\_\_bc"{},\ "{}\_ab\ cd"{},\ "{}ab\_cd\ "{}]}
\DoxyCodeLine{s1\ =\ split\_record\_re(s,\ "{}[\_\ ]"{})}
\DoxyCodeLine{s1\ is\ a\ lists\ column\ of\ strings:}
\DoxyCodeLine{\ \ \ \ [\ ["{}a"{},\ "{}bc"{},\ "{}def"{},\ "{}g"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}a"{},\ "{}"{},\ "{}bc"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}"{},\ "{}ab"{},\ "{}cd"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}ab"{},\ "{}cd"{},\ "{}"{}]\ ]}
\DoxyCodeLine{s2\ =\ split\_record\_re(s,\ "{}[\ \_]"{},\ 1)}
\DoxyCodeLine{s2\ is\ a\ lists\ column\ of\ strings:}
\DoxyCodeLine{\ \ \ \ [\ ["{}a"{},\ "{}bc\ def\_g"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}a"{},\ "{}\_bc"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}"{},\ "{}ab\ cd"{}],}
\DoxyCodeLine{\ \ \ \ \ \ ["{}ab"{},\ "{}cd\ "{}]\ ]}

\end{DoxyCode}



\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily pattern} is empty.\\
\hline
\end{DoxyExceptions}
See the Regex Features page for details on patterns supported by this API.


\begin{DoxyParams}{参数}
{\em input} & A column of string elements to be split. \\
\hline
{\em pattern} & The regex pattern for delimiting characters within each string. \\
\hline
{\em maxsplit} & Maximum number of splits to perform. Default of -\/1 indicates all possible splits on each string. \\
\hline
{\em mr} & Device memory resource used to allocate the returned result\textquotesingle{}s device memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Lists column of strings. 
\end{DoxyReturn}
