\doxysection{cudf\+::detail 命名空间参考}
\hypertarget{namespacecudf_1_1detail}{}\label{namespacecudf_1_1detail}\index{cudf::detail@{cudf::detail}}


Inner interfaces and implementations  


\doxysubsubsection*{类}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1aggregation__finalizer}{aggregation\+\_\+finalizer}}
\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1all__aggregation}{all\+\_\+aggregation}}
\begin{DoxyCompactList}\small\item\em Derived class for specifying an all aggregation \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1any__aggregation}{any\+\_\+aggregation}}
\begin{DoxyCompactList}\small\item\em Derived class for specifying an any aggregation \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1argmax__aggregation}{argmax\+\_\+aggregation}}
\begin{DoxyCompactList}\small\item\em Derived class for specifying an argmax aggregation \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1argmin__aggregation}{argmin\+\_\+aggregation}}
\begin{DoxyCompactList}\small\item\em Derived class for specifying an argmin aggregation \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1base__2dspan}{base\+\_\+2dspan}}
\begin{DoxyCompactList}\small\item\em Generic class for row-\/major 2D spans. Not compliant with STL container semantics/syntax. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1collect__list__aggregation}{collect\+\_\+list\+\_\+aggregation}}
\begin{DoxyCompactList}\small\item\em Derived aggregation class for specifying COLLECT\+\_\+\+LIST aggregation \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1collect__set__aggregation}{collect\+\_\+set\+\_\+aggregation}}
\begin{DoxyCompactList}\small\item\em Derived aggregation class for specifying COLLECT\+\_\+\+SET aggregation \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1column__view__base}{column\+\_\+view\+\_\+base}}
\begin{DoxyCompactList}\small\item\em A non-\/owning, immutable view of device data as a column of elements, some of which may be null as indicated by a bitmask. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1correlation__aggregation}{correlation\+\_\+aggregation}}
\begin{DoxyCompactList}\small\item\em Derived aggregation class for specifying CORRELATION aggregation \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1count__aggregation}{count\+\_\+aggregation}}
\begin{DoxyCompactList}\small\item\em Derived class for specifying a count aggregation \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1covariance__aggregation}{covariance\+\_\+aggregation}}
\begin{DoxyCompactList}\small\item\em Derived aggregation class for specifying COVARIANCE aggregation \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1dispatch__aggregation}{dispatch\+\_\+aggregation}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1dispatch__source}{dispatch\+\_\+source}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1dremel__data}{dremel\+\_\+data}}
\begin{DoxyCompactList}\small\item\em Dremel data that describes one nested type column \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1dremel__device__view}{dremel\+\_\+device\+\_\+view}}
\begin{DoxyCompactList}\small\item\em Device view for {\ttfamily \doxylink{structcudf_1_1detail_1_1dremel__data}{dremel\+\_\+data}}. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1fixed__width__scalar}{fixed\+\_\+width\+\_\+scalar}}
\begin{DoxyCompactList}\small\item\em An owning class to represent a fixed-\/width type value in device memory. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1has__common__type__impl}{has\+\_\+common\+\_\+type\+\_\+impl}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1has__common__type__impl_3_01void__t_3_01std_1_1common__type__t_3_01_ts_8e2d33eab3ad4b77e8506b3fe056aacf5}{has\+\_\+common\+\_\+type\+\_\+impl$<$ void\+\_\+t$<$ std\+::common\+\_\+type\+\_\+t$<$ Ts... $>$ $>$, Ts... $>$}}
\item 
class \mbox{\hyperlink{structcudf_1_1detail_1_1hash__join}{hash\+\_\+join}}
\begin{DoxyCompactList}\small\item\em Hash join that builds hash table in creation and probes results in subsequent {\ttfamily \texorpdfstring{$\ast$}{*}\+\_\+join} member functions. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1is__equality__comparable__impl}{is\+\_\+equality\+\_\+comparable\+\_\+impl}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1is__equality__comparable__impl_3_01_l_00_01_r_00_01void__t_3_01equality_2f83d168aaedf92541e7f7f4a1af5cfa}{is\+\_\+equality\+\_\+comparable\+\_\+impl$<$ L, R, void\+\_\+t$<$ equality\+\_\+comparable$<$ L, R $>$ $>$ $>$}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1is__relationally__comparable__impl}{is\+\_\+relationally\+\_\+comparable\+\_\+impl}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1is__relationally__comparable__impl_3_01_l_00_01_r_00_01void__t_3_01less_58b6dd73ceb6a464bcab762425ace104}{is\+\_\+relationally\+\_\+comparable\+\_\+impl$<$ L, R, void\+\_\+t$<$ less\+\_\+comparable$<$ L, R $>$, greater\+\_\+comparable$<$ L, R $>$ $>$ $>$}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1kind__to__type__impl}{kind\+\_\+to\+\_\+type\+\_\+impl}}
\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1lead__lag__aggregation}{lead\+\_\+lag\+\_\+aggregation}}
\begin{DoxyCompactList}\small\item\em Derived aggregation class for specifying LEAD/\+LAG window aggregations \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1linked__column__view}{linked\+\_\+column\+\_\+view}}
\begin{DoxyCompactList}\small\item\em \doxylink{classcudf_1_1column__view}{column\+\_\+view} with the added member pointer to the parent of this column. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1m2__aggregation}{m2\+\_\+aggregation}}
\begin{DoxyCompactList}\small\item\em Derived class for specifying a m2 aggregation \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1max__aggregation}{max\+\_\+aggregation}}
\begin{DoxyCompactList}\small\item\em Derived class for specifying a max aggregation \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1mean__aggregation}{mean\+\_\+aggregation}}
\begin{DoxyCompactList}\small\item\em Derived class for specifying a mean aggregation \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1median__aggregation}{median\+\_\+aggregation}}
\begin{DoxyCompactList}\small\item\em Derived class for specifying a median aggregation \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1merge__lists__aggregation}{merge\+\_\+lists\+\_\+aggregation}}
\begin{DoxyCompactList}\small\item\em Derived aggregation class for specifying MERGE\+\_\+\+LISTS aggregation \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1merge__m2__aggregation}{merge\+\_\+m2\+\_\+aggregation}}
\begin{DoxyCompactList}\small\item\em Derived aggregation class for specifying MERGE\+\_\+\+M2 aggregation \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1merge__sets__aggregation}{merge\+\_\+sets\+\_\+aggregation}}
\begin{DoxyCompactList}\small\item\em Derived aggregation class for specifying MERGE\+\_\+\+SETS aggregation \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1merge__tdigest__aggregation}{merge\+\_\+tdigest\+\_\+aggregation}}
\begin{DoxyCompactList}\small\item\em Derived aggregation class for specifying MERGE\+\_\+\+TDIGEST aggregation \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1min__aggregation}{min\+\_\+aggregation}}
\begin{DoxyCompactList}\small\item\em Derived class for specifying a min aggregation \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1_murmur_hash3__32}{Murmur\+Hash3\+\_\+32}}
\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1mutable__column__view__base}{mutable\+\_\+column\+\_\+view\+\_\+base}}
\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1nth__element__aggregation}{nth\+\_\+element\+\_\+aggregation}}
\begin{DoxyCompactList}\small\item\em Derived class for specifying a nth element aggregation \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1nunique__aggregation}{nunique\+\_\+aggregation}}
\begin{DoxyCompactList}\small\item\em Derived class for specifying a nunique aggregation \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1pair__column__aggregation__equal__to}{pair\+\_\+column\+\_\+aggregation\+\_\+equal\+\_\+to}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1pair__column__aggregation__hash}{pair\+\_\+column\+\_\+aggregation\+\_\+hash}}
\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1pinned__allocator}{pinned\+\_\+allocator}}
\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1pinned__allocator_3_01void_01_4}{pinned\+\_\+allocator$<$ void $>$}}
\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1product__aggregation}{product\+\_\+aggregation}}
\begin{DoxyCompactList}\small\item\em Derived class for specifying a product aggregation \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1quantile__aggregation}{quantile\+\_\+aggregation}}
\begin{DoxyCompactList}\small\item\em Derived class for specifying a quantile aggregation \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1rank__aggregation}{rank\+\_\+aggregation}}
\begin{DoxyCompactList}\small\item\em Derived class for specifying a rank aggregation \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1result__cache}{result\+\_\+cache}}
\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1row__number__aggregation}{row\+\_\+number\+\_\+aggregation}}
\begin{DoxyCompactList}\small\item\em Derived class for specifying a row\+\_\+number aggregation \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1simple__aggregations__collector}{simple\+\_\+aggregations\+\_\+collector}}
\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1span__base}{span\+\_\+base}}
\begin{DoxyCompactList}\small\item\em C++20 std\+::span with reduced feature set. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1std__aggregation}{std\+\_\+aggregation}}
\begin{DoxyCompactList}\small\item\em Derived class for specifying a standard deviation aggregation \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1std__var__aggregation}{std\+\_\+var\+\_\+aggregation}}
\begin{DoxyCompactList}\small\item\em Derived class for specifying a standard deviation/variance aggregation \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1sum__aggregation}{sum\+\_\+aggregation}}
\begin{DoxyCompactList}\small\item\em Derived class for specifying a sum aggregation \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1sum__of__squares__aggregation}{sum\+\_\+of\+\_\+squares\+\_\+aggregation}}
\begin{DoxyCompactList}\small\item\em Derived class for specifying a sum\+\_\+of\+\_\+squares aggregation \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1table__view__base}{table\+\_\+view\+\_\+base}}
\begin{DoxyCompactList}\small\item\em Base class for a table of {\ttfamily Column\+View}s \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1target__type__impl}{target\+\_\+type\+\_\+impl}}
\begin{DoxyCompactList}\small\item\em Determines accumulator type based on input type and aggregation. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_a_l_l_01_4}{target\+\_\+type\+\_\+impl$<$ Source, aggregation\+::\+ALL $>$}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_a_n_y_01_4}{target\+\_\+type\+\_\+impl$<$ Source, aggregation\+::\+ANY $>$}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_a_r_g_m_a_x_01_4}{target\+\_\+type\+\_\+impl$<$ Source, aggregation\+::\+ARGMAX $>$}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_a_r_g_m_i_n_01_4}{target\+\_\+type\+\_\+impl$<$ Source, aggregation\+::\+ARGMIN $>$}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_c_o_l_l_e_c_t___l_i_s_t_01_4}{target\+\_\+type\+\_\+impl$<$ Source, aggregation\+::\+COLLECT\+\_\+\+LIST $>$}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_c_o_l_l_e_c_t___s_e_t_01_4}{target\+\_\+type\+\_\+impl$<$ Source, aggregation\+::\+COLLECT\+\_\+\+SET $>$}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_c_o_u_n_t___a_l_l_01_4}{target\+\_\+type\+\_\+impl$<$ Source, aggregation\+::\+COUNT\+\_\+\+ALL $>$}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_c_o_u_n_t___v_a_l_i_d_01_4}{target\+\_\+type\+\_\+impl$<$ Source, aggregation\+::\+COUNT\+\_\+\+VALID $>$}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_l_a_g_01_4}{target\+\_\+type\+\_\+impl$<$ Source, aggregation\+::\+LAG $>$}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_l_e_a_d_01_4}{target\+\_\+type\+\_\+impl$<$ Source, aggregation\+::\+LEAD $>$}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_m_a_x_01_4}{target\+\_\+type\+\_\+impl$<$ Source, aggregation\+::\+MAX $>$}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_m_e_d_i_a_n_01_4}{target\+\_\+type\+\_\+impl$<$ Source, aggregation\+::\+MEDIAN $>$}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_m_e_r_g_e___l_i_s_t_s_01_4}{target\+\_\+type\+\_\+impl$<$ Source, aggregation\+::\+MERGE\+\_\+\+LISTS $>$}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_m_e_r_g_e___s_e_t_s_01_4}{target\+\_\+type\+\_\+impl$<$ Source, aggregation\+::\+MERGE\+\_\+\+SETS $>$}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_m_e_r_g_e___t_d_i_g_b6032354e9dd2aab59ead12451496ee9}{target\+\_\+type\+\_\+impl$<$ Source, aggregation\+::\+MERGE\+\_\+\+TDIGEST, std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+same\+\_\+v$<$ Source, cudf\+::struct\+\_\+view $>$ $>$ $>$}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_m_i_n_01_4}{target\+\_\+type\+\_\+impl$<$ Source, aggregation\+::\+MIN $>$}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_n_t_h___e_l_e_m_e_n_t_01_4}{target\+\_\+type\+\_\+impl$<$ Source, aggregation\+::\+NTH\+\_\+\+ELEMENT $>$}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_n_u_n_i_q_u_e_01_4}{target\+\_\+type\+\_\+impl$<$ Source, aggregation\+::\+NUNIQUE $>$}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_q_u_a_n_t_i_l_e_01_4}{target\+\_\+type\+\_\+impl$<$ Source, aggregation\+::\+QUANTILE $>$}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_r_a_n_k_01_4}{target\+\_\+type\+\_\+impl$<$ Source, aggregation\+::\+RANK $>$}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_r_o_w___n_u_m_b_e_r_01_4}{target\+\_\+type\+\_\+impl$<$ Source, aggregation\+::\+ROW\+\_\+\+NUMBER $>$}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01aggregation_1_1_t_d_i_g_e_s_t_00_01s5303a4b781861b9f20be89a332eefbb3}{target\+\_\+type\+\_\+impl$<$ Source, aggregation\+::\+TDIGEST, std\+::enable\+\_\+if\+\_\+t$<$(is\+\_\+numeric$<$ Source $>$()\texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|}is\+\_\+fixed\+\_\+point$<$ Source $>$())$>$ $>$}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01k_00_01std_1_1enable__if__t_3_01std_9f689773868603c824fb593bd3e5e573}{target\+\_\+type\+\_\+impl$<$ Source, k, std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+floating\+\_\+point\+\_\+v$<$ Source $>$ \&\&is\+\_\+sum\+\_\+product\+\_\+agg(k)$>$ $>$}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01k_00_01std_1_1enable__if__t_3_01std_eb928db258a099e4b94f2dc9fe8c0a44}{target\+\_\+type\+\_\+impl$<$ Source, k, std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+integral\+\_\+v$<$ Source $>$ \&\&is\+\_\+sum\+\_\+product\+\_\+agg(k)$>$ $>$}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1target__type__impl_3_01_source_00_01k_00_01std_1_1enable__if__t_3_07is__2d246396d9b567139696a42c8c67e9c9}{target\+\_\+type\+\_\+impl$<$ Source, k, std\+::enable\+\_\+if\+\_\+t$<$(is\+\_\+chrono$<$ Source $>$() or is\+\_\+fixed\+\_\+point$<$ Source $>$()) \&\&(k==aggregation\+::\+MEAN)$>$ $>$}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1target__type__impl_3_01_source_type_00_01aggregation_1_1_c_o_r_r_e_l_a_t_i_o_n_01_4}{target\+\_\+type\+\_\+impl$<$ Source\+Type, aggregation\+::\+CORRELATION $>$}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1target__type__impl_3_01_source_type_00_01aggregation_1_1_c_o_v_a_r_i_a_n_c_e_01_4}{target\+\_\+type\+\_\+impl$<$ Source\+Type, aggregation\+::\+COVARIANCE $>$}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1target__type__impl_3_01_source_type_00_01aggregation_1_1_m2_01_4}{target\+\_\+type\+\_\+impl$<$ Source\+Type, aggregation\+::\+M2 $>$}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1target__type__impl_3_01_source_type_00_01aggregation_1_1_m_e_r_g_e___m2_01_4}{target\+\_\+type\+\_\+impl$<$ Source\+Type, aggregation\+::\+MERGE\+\_\+\+M2 $>$}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1target__type__impl_3_01_source_type_00_01aggregation_1_1_s_t_d_01_4}{target\+\_\+type\+\_\+impl$<$ Source\+Type, aggregation\+::\+STD $>$}}
\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1target__type__impl_3_01_source_type_00_01aggregation_1_1_v_a_r_i_a_n_c_e_01_4}{target\+\_\+type\+\_\+impl$<$ Source\+Type, aggregation\+::\+VARIANCE $>$}}
\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1tdigest__aggregation}{tdigest\+\_\+aggregation}}
\begin{DoxyCompactList}\small\item\em Derived aggregation class for specifying TDIGEST aggregation \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1udf__aggregation}{udf\+\_\+aggregation}}
\begin{DoxyCompactList}\small\item\em Derived class for specifying a custom aggregation specified in udf \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classcudf_1_1detail_1_1var__aggregation}{var\+\_\+aggregation}}
\begin{DoxyCompactList}\small\item\em Derived class for specifying a variance aggregation \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structcudf_1_1detail_1_1visitor__overload}{visitor\+\_\+overload}}
\begin{DoxyCompactList}\small\item\em Helper class to support inline-\/overloading for all of a variant\textquotesingle{}s alternative types \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{类型定义}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename Source , \mbox{\hyperlink{classcudf_1_1aggregation_a83579ae3cab2fc3d1c3b377d1cfab24c}{aggregation\+::\+Kind}} k$>$ }\\using \mbox{\hyperlink{namespacecudf_1_1detail_ad9f4583fad6d64406129dc1978027b6b}{target\+\_\+type\+\_\+t}} = typename \mbox{\hyperlink{structcudf_1_1detail_1_1target__type__impl}{target\+\_\+type\+\_\+impl}}$<$ Source, k $>$\+::type
\begin{DoxyCompactList}\small\item\em Helper alias to get the accumulator type for performing aggregation {\ttfamily k} on elements of type {\ttfamily Source} \end{DoxyCompactList}\item 
{\footnotesize template$<$\mbox{\hyperlink{classcudf_1_1aggregation_a83579ae3cab2fc3d1c3b377d1cfab24c}{aggregation\+::\+Kind}} k$>$ }\\using \mbox{\hyperlink{namespacecudf_1_1detail_a8a62804f4d08dbf686b957e2bdfb06be}{kind\+\_\+to\+\_\+type}} = typename \mbox{\hyperlink{structcudf_1_1detail_1_1kind__to__type__impl}{kind\+\_\+to\+\_\+type\+\_\+impl}}$<$ k $>$\+::type
\item 
using \mbox{\hyperlink{namespacecudf_1_1detail_a8bef759d42ac528d33f331de080d5584}{Linked\+Col\+Ptr}} = std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{structcudf_1_1detail_1_1linked__column__view}{linked\+\_\+column\+\_\+view}} $>$
\item 
using \mbox{\hyperlink{namespacecudf_1_1detail_a627e116400c1bed3d5f2b3ab78661fe8}{Linked\+Col\+Vector}} = std\+::vector$<$ \mbox{\hyperlink{namespacecudf_1_1detail_a8bef759d42ac528d33f331de080d5584}{Linked\+Col\+Ptr}} $>$
\item 
{\footnotesize template$<$class T $>$ }\\using \mbox{\hyperlink{namespacecudf_1_1detail_ad766fd47aef5cd45824e7789f42247ed}{host\+\_\+2dspan}} = \mbox{\hyperlink{classcudf_1_1detail_1_1base__2dspan}{base\+\_\+2dspan}}$<$ T, \mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}} $>$
\begin{DoxyCompactList}\small\item\em Alias for the 2D span for host data. \end{DoxyCompactList}\item 
{\footnotesize template$<$class T $>$ }\\using \mbox{\hyperlink{namespacecudf_1_1detail_aa8d997e03a111aad833923bbfa0fc631}{device\+\_\+2dspan}} = \mbox{\hyperlink{classcudf_1_1detail_1_1base__2dspan}{base\+\_\+2dspan}}$<$ T, \mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}} $>$
\begin{DoxyCompactList}\small\item\em Alias for the 2D span for device data. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Duration $>$ }\\using \mbox{\hyperlink{namespacecudf_1_1detail_a2d645cde6078342234d5d6ee2c8cd9f9}{time\+\_\+point}} = cuda\+::std\+::chrono\+::sys\+\_\+time$<$ Duration $>$
\begin{DoxyCompactList}\small\item\em Time point type \end{DoxyCompactList}\item 
{\footnotesize template$<$class Duration $>$ }\\using \mbox{\hyperlink{namespacecudf_1_1detail_a3128cb15ed7da5bb5e926bb24a419262}{timestamp}} = \mbox{\hyperlink{namespacecudf_1_1detail_a2d645cde6078342234d5d6ee2c8cd9f9}{time\+\_\+point}}$<$ Duration $>$
\begin{DoxyCompactList}\small\item\em A wrapper around a column of time\+\_\+point in varying resolutions \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{枚举}
\begin{DoxyCompactItemize}
\item 
enum class \mbox{\hyperlink{namespacecudf_1_1detail_a1c29a0e8458ffb159e91481c0f37b0f5}{negative\+\_\+index\+\_\+policy}} \+: bool \{ \mbox{\hyperlink{namespacecudf_1_1detail_a1c29a0e8458ffb159e91481c0f37b0f5a9725825c796122ef40f01b2d8794f902}{ALLOWED}}
, \mbox{\hyperlink{namespacecudf_1_1detail_a1c29a0e8458ffb159e91481c0f37b0f5a4596302bc1e8ce6e62188e769aac94cf}{NOT\+\_\+\+ALLOWED}}
 \}
\item 
enum class \mbox{\hyperlink{namespacecudf_1_1detail_afe99faf2d7a570e5de8dbe1638f91dd0}{join\+\_\+kind}} \{ \newline
\mbox{\hyperlink{namespacecudf_1_1detail_afe99faf2d7a570e5de8dbe1638f91dd0adacfb6b4a93e8c0996af0a50896b2ad6}{INNER\+\_\+\+JOIN}}
, \mbox{\hyperlink{namespacecudf_1_1detail_afe99faf2d7a570e5de8dbe1638f91dd0ab2f77eff2e65e96b41d17cef95c040ca}{LEFT\+\_\+\+JOIN}}
, \mbox{\hyperlink{namespacecudf_1_1detail_afe99faf2d7a570e5de8dbe1638f91dd0a9e94c2918e6b37d619ac174c2f251c4a}{FULL\+\_\+\+JOIN}}
, \mbox{\hyperlink{namespacecudf_1_1detail_afe99faf2d7a570e5de8dbe1638f91dd0a149cf6da1ad9e5e65b85a95c49449ae8}{LEFT\+\_\+\+SEMI\+\_\+\+JOIN}}
, \newline
\mbox{\hyperlink{namespacecudf_1_1detail_afe99faf2d7a570e5de8dbe1638f91dd0a148ec33d1c462dcb952eb70eae78fc6e}{LEFT\+\_\+\+ANTI\+\_\+\+JOIN}}
 \}
\end{DoxyCompactItemize}
\doxysubsubsection*{函数}
\begin{DoxyCompactItemize}
\item 
std\+::size\+\_\+t \mbox{\hyperlink{namespacecudf_1_1detail_a560407ec1815ec2aff96a7c792f53428}{shallow\+\_\+hash}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&input)
\begin{DoxyCompactList}\small\item\em Computes a hash value from the shallow state of the specified column \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespacecudf_1_1detail_a8c566f1ff3c273be1518ca5f7d92d4cc}{is\+\_\+shallow\+\_\+equivalent}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&lhs, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&rhs)
\begin{DoxyCompactList}\small\item\em Uses only shallow state to determine if two {\ttfamily \doxylink{classcudf_1_1column__view}{column\+\_\+view}}s view equivalent columns \end{DoxyCompactList}\item 
constexpr bool \mbox{\hyperlink{namespacecudf_1_1detail_af8a7ba935c016e3b7c537937d88e038f}{is\+\_\+sum\+\_\+product\+\_\+agg}} (\mbox{\hyperlink{classcudf_1_1aggregation_a83579ae3cab2fc3d1c3b377d1cfab24c}{aggregation\+::\+Kind}} k)
\item 
\mbox{\hyperlink{namespacecudf_1_1detail_a325dce4aa776c0bf7cf218e2a27714b5}{AGG\+\_\+\+KIND\+\_\+\+MAPPING}} (\mbox{\hyperlink{classcudf_1_1aggregation_a83579ae3cab2fc3d1c3b377d1cfab24ca6e5361905125d531234e50d50bcf5326}{aggregation\+::\+QUANTILE}}, \mbox{\hyperlink{classcudf_1_1detail_1_1quantile__aggregation}{quantile\+\_\+aggregation}})
\item 
\mbox{\hyperlink{namespacecudf_1_1detail_af21777beb509d8944a3e936c0840e473}{AGG\+\_\+\+KIND\+\_\+\+MAPPING}} (\mbox{\hyperlink{classcudf_1_1aggregation_a83579ae3cab2fc3d1c3b377d1cfab24ca6b1ba846de925ba39b9ee9e352adf84a}{aggregation\+::\+STD}}, \mbox{\hyperlink{classcudf_1_1detail_1_1std__aggregation}{std\+\_\+aggregation}})
\item 
\mbox{\hyperlink{namespacecudf_1_1detail_aad8f5a52bb309f1cdc4906eed538b45d}{AGG\+\_\+\+KIND\+\_\+\+MAPPING}} (\mbox{\hyperlink{classcudf_1_1aggregation_a83579ae3cab2fc3d1c3b377d1cfab24ca668fb6976b34ba937eb74f77700e749d}{aggregation\+::\+VARIANCE}}, \mbox{\hyperlink{classcudf_1_1detail_1_1var__aggregation}{var\+\_\+aggregation}})
\item 
{\footnotesize template$<$typename F , typename... Ts$>$ }\\\mbox{\hyperlink{types_8hpp_adc4a74f3fb4b327ed43b31d0fca65ba3}{CUDF\+\_\+\+HOST\+\_\+\+DEVICE}} decltype(auto) \mbox{\hyperlink{namespacecudf_1_1detail_a20f1cdfbe0b878b8b5143108ed352a2d}{aggregation\+\_\+dispatcher}} (\mbox{\hyperlink{classcudf_1_1aggregation_a83579ae3cab2fc3d1c3b377d1cfab24c}{aggregation\+::\+Kind}} k, F \&\&f, Ts \&\&... args)
\begin{DoxyCompactList}\small\item\em Dispatches {\ttfamily k} as a non-\/type template parameter to a callable, {\ttfamily f}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename F , typename... Ts$>$ }\\\mbox{\hyperlink{types_8hpp_adc4a74f3fb4b327ed43b31d0fca65ba3}{CUDF\+\_\+\+HOST\+\_\+\+DEVICE}} constexpr decltype(auto) \mbox{\hyperlink{namespacecudf_1_1detail_a0159f4dade1ab55499ee6d0606eae6fd}{dispatch\+\_\+type\+\_\+and\+\_\+aggregation}} (\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} type, \mbox{\hyperlink{classcudf_1_1aggregation_a83579ae3cab2fc3d1c3b377d1cfab24c}{aggregation\+::\+Kind}} k, F \&\&f, Ts \&\&... args)
\begin{DoxyCompactList}\small\item\em Dispatches both a type and {\ttfamily \doxylink{classcudf_1_1aggregation_a83579ae3cab2fc3d1c3b377d1cfab24c}{aggregation\+::\+Kind}} template parameters to a callable. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} \mbox{\hyperlink{namespacecudf_1_1detail_a57278828a4e7e978f90c08968d9dec55}{target\+\_\+type}} (\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} source\+\_\+type, \mbox{\hyperlink{classcudf_1_1aggregation_a83579ae3cab2fc3d1c3b377d1cfab24c}{aggregation\+::\+Kind}} k)
\begin{DoxyCompactList}\small\item\em Returns the target {\ttfamily \doxylink{classcudf_1_1data__type}{data\+\_\+type}} for the specified aggregation k performed on elements of type source\+\_\+type. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Source , \mbox{\hyperlink{classcudf_1_1aggregation_a83579ae3cab2fc3d1c3b377d1cfab24c}{aggregation\+::\+Kind}} k$>$ }\\constexpr bool \mbox{\hyperlink{namespacecudf_1_1detail_a79d87c0aa523a30c8ab5b806ab4bb62e}{is\+\_\+valid\+\_\+aggregation}} ()
\begin{DoxyCompactList}\small\item\em Indicates whether the specified aggregation {\ttfamily k} is valid to perform on the type {\ttfamily Source}. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespacecudf_1_1detail_a2e1ec5de7e8b76d00528c28ba90d8fc1}{is\+\_\+valid\+\_\+aggregation}} (\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} source, \mbox{\hyperlink{classcudf_1_1aggregation_a83579ae3cab2fc3d1c3b377d1cfab24c}{aggregation\+::\+Kind}} k)
\begin{DoxyCompactList}\small\item\em Indicates whether the specified aggregation {\ttfamily k} is valid to perform on the {\ttfamily \doxylink{classcudf_1_1data__type}{data\+\_\+type}} {\ttfamily source}. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a71131703adb680670a6b8592b92f56f6}{binary\+\_\+operation}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&lhs, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&rhs, std\+::string const \&ptx, \mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} output\+\_\+type, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Performs a binary operation between two columns using a user-\/defined PTX function.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a4d435282505118b2a58c875780c13890}{binary\+\_\+operation}} (\mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&lhs, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&rhs, \mbox{\hyperlink{group__transformation__binaryops_ga00ed76601b6db662550f6826cfd99edc}{binary\+\_\+operator}} op, \mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} output\+\_\+type, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Performs a binary operation between a scalar and a column.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_ab6c8f19f207ee3db5e2284594edc600c}{binary\+\_\+operation}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&lhs, \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&rhs, \mbox{\hyperlink{group__transformation__binaryops_ga00ed76601b6db662550f6826cfd99edc}{binary\+\_\+operator}} op, \mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} output\+\_\+type, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Performs a binary operation between a column and a scalar.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a6d4ce4e5ee2ebf383eaccdd2d8ab8233}{binary\+\_\+operation}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&lhs, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&rhs, \mbox{\hyperlink{group__transformation__binaryops_ga00ed76601b6db662550f6826cfd99edc}{binary\+\_\+operator}} op, \mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} output\+\_\+type, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Performs a binary operation between two columns.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a4ff65803386d36f8a139f59f14506eef}{concatenate}} (\mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$<$ \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const $>$ columns\+\_\+to\+\_\+concat, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Concatenates multiple columns into a single column.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a03a9a4dad8d8d93a07908bc682e3b76d}{concatenate}} (\mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$<$ \mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const $>$ tables\+\_\+to\+\_\+concat, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Columns of {\ttfamily tables\+\_\+to\+\_\+concat} are concatenated vertically to return a single table   \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Column\+View $>$ }\\Column\+View \mbox{\hyperlink{namespacecudf_1_1detail_accad26dd1e34404dea7ab68735bf8d64}{slice}} (Column\+View const \&input, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{cudf\+::size\+\_\+type}} begin, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{cudf\+::size\+\_\+type}} end)
\begin{DoxyCompactList}\small\item\em Constructs a zero-\/copy {\ttfamily \doxylink{classcudf_1_1column__view}{column\+\_\+view}}/{\ttfamily \doxylink{classcudf_1_1mutable__column__view}{mutable\+\_\+column\+\_\+view}} of the elements in the range {\ttfamily \mbox{[}begin,end)} in {\ttfamily input}. \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a49deebc29b5e46589239ef45caadf78d}{slice}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&input, \mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$ indices, rmm\+::cuda\+\_\+stream\+\_\+view stream)
\begin{DoxyCompactList}\small\item\em Slices a {\ttfamily \doxylink{classcudf_1_1column__view}{column\+\_\+view}} into a set of {\ttfamily \doxylink{classcudf_1_1column__view}{column\+\_\+view}}s according to a set of indices.   \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_aa31cc81e8ff79807da425b06808628a3}{slice}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&input, std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ indices, rmm\+::cuda\+\_\+stream\+\_\+view stream)
\item 
std\+::vector$<$ \mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a5910f60027c0a5ed39ae6d3400504a4c}{slice}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&input, \mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$ indices, rmm\+::cuda\+\_\+stream\+\_\+view stream)
\begin{DoxyCompactList}\small\item\em Slices a {\ttfamily \doxylink{classcudf_1_1table__view}{table\+\_\+view}} into a set of {\ttfamily \doxylink{classcudf_1_1table__view}{table\+\_\+view}}s according to a set of indices.   \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a981d0804d0e1b53e77bcb4b495effdd2}{slice}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&input, std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ indices, rmm\+::cuda\+\_\+stream\+\_\+view stream)
\item 
std\+::vector$<$ \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_ac92c0388c1c85c792be08da6986b8bed}{split}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&input, \mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$ splits, rmm\+::cuda\+\_\+stream\+\_\+view stream)
\begin{DoxyCompactList}\small\item\em Splits a {\ttfamily \doxylink{classcudf_1_1column__view}{column\+\_\+view}} into a set of {\ttfamily \doxylink{classcudf_1_1column__view}{column\+\_\+view}}s according to a set of indices derived from expected splits.   \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a2bbfdd769874212ba1918473509e8d62}{split}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&input, std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ splits, rmm\+::cuda\+\_\+stream\+\_\+view stream)
\item 
std\+::vector$<$ \mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a5c75abac479c304fa7ddd5e472489229}{split}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&input, \mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$ splits, rmm\+::cuda\+\_\+stream\+\_\+view stream)
\begin{DoxyCompactList}\small\item\em Splits a {\ttfamily \doxylink{classcudf_1_1table__view}{table\+\_\+view}} into a set of {\ttfamily \doxylink{classcudf_1_1table__view}{table\+\_\+view}}s according to a set of indices derived from expected splits.   \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a1e6bf2b8a180ce938904811ecb3fca6e}{split}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&input, std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ splits, rmm\+::cuda\+\_\+stream\+\_\+view stream)
\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a659e6bad07531f73e44b0e87e7a59449}{shift}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&input, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} offset, \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&fill\+\_\+value, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Creates a new column by shifting all values by an offset.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a3da5b63902793d46d2048b2f5ccb2e41}{segmented\+\_\+shift}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&segmented\+\_\+values, \mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$ segment\+\_\+offsets, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} offset, \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&fill\+\_\+value, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Performs segmented shifts for specified values. \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{structcudf_1_1packed__table}{packed\+\_\+table}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a047f6e84ed9d8d30fd0a8703ac2085ee}{contiguous\+\_\+split}} (\mbox{\hyperlink{classcudf_1_1table__view}{cudf\+::table\+\_\+view}} const \&input, std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ const \&splits, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Performs a deep-\/copy split of a {\ttfamily \doxylink{classcudf_1_1table__view}{table\+\_\+view}} into a set of {\ttfamily \doxylink{classcudf_1_1table__view}{table\+\_\+view}}s into a single contiguous block of memory.   \end{DoxyCompactList}\item 
\mbox{\hyperlink{structcudf_1_1packed__columns}{packed\+\_\+columns}} \mbox{\hyperlink{namespacecudf_1_1detail_ab8fcbfc5ff5585cc426e609ab8da1720}{pack}} (\mbox{\hyperlink{classcudf_1_1table__view}{cudf\+::table\+\_\+view}} const \&input, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Deep-\/copy a {\ttfamily \doxylink{classcudf_1_1table__view}{table\+\_\+view}} into a serialized contiguous memory format   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a1d90a4e2a03fd0f7bcaeee67267d1557}{allocate\+\_\+like}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&input, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} size, \mbox{\hyperlink{group__column__copy_ga267e03474dcfd85242d2fdc6e5846ec6}{mask\+\_\+allocation\+\_\+policy}} mask\+\_\+alloc=\mbox{\hyperlink{group__column__copy_gga267e03474dcfd85242d2fdc6e5846ec6a47e9136fa770199f6a8a9727b6173eb4}{mask\+\_\+allocation\+\_\+policy\+::\+RETAIN}}, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Creates an uninitialized new column of the specified size and same type as the {\ttfamily input}.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a1f095700ad533a04852f9b75ae33c2bc}{copy\+\_\+if\+\_\+else}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&lhs, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&rhs, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&boolean\+\_\+mask, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Returns a new column, where each element is selected from either {\ttfamily lhs} or {\ttfamily rhs} based on the value of the corresponding element in {\ttfamily boolean\+\_\+mask}   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a3ca44d4fcbf12660edf218195e729eaa}{copy\+\_\+if\+\_\+else}} (\mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&lhs, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&rhs, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&boolean\+\_\+mask, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Returns a new column, where each element is selected from either {\ttfamily lhs} or {\ttfamily rhs} based on the value of the corresponding element in {\ttfamily boolean\+\_\+mask}   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a44102048883bf4ae35957e48b4b650a3}{copy\+\_\+if\+\_\+else}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&lhs, \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&rhs, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&boolean\+\_\+mask, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Returns a new column, where each element is selected from either {\ttfamily lhs} or {\ttfamily rhs} based on the value of the corresponding element in {\ttfamily boolean\+\_\+mask}   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_ac60520ad2d4ed5741035a9e8dd9bfbe8}{copy\+\_\+if\+\_\+else}} (\mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&lhs, \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&rhs, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&boolean\+\_\+mask, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Returns a new column, where each element is selected from either {\ttfamily lhs} or {\ttfamily rhs} based on the value of the corresponding element in {\ttfamily boolean\+\_\+mask}   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a4a082f6c019d5d3462414e341e949c02}{sample}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&input, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const n, \mbox{\hyperlink{group__column__copy_gae7607cde56cb602ab1b198b5bebf7cba}{sample\+\_\+with\+\_\+replacement}} replacement=\mbox{\hyperlink{group__column__copy_ggae7607cde56cb602ab1b198b5bebf7cbaa946003f97ccc52d5d3b54ac0ec31bbfc}{sample\+\_\+with\+\_\+replacement\+::\+FALSE}}, int64\+\_\+t const seed=0, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Gather {\ttfamily n} samples from given {\ttfamily input} randomly   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a84c26312d03ba6528aa4d28c9ec41a67}{get\+\_\+element}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&input, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} index, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Get the element at specified index from a column   \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespacecudf_1_1detail_a5758db52c9f99ddaab9a9de11fd25f4d}{has\+\_\+nonempty\+\_\+nulls}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&input, rmm\+::cuda\+\_\+stream\+\_\+view stream)
\begin{DoxyCompactList}\small\item\em Checks if a column or its descendants have non-\/empty null rows   \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespacecudf_1_1detail_a0d9d7614373d0ef4f4538d1920c6d732}{may\+\_\+have\+\_\+nonempty\+\_\+nulls}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&input, rmm\+::cuda\+\_\+stream\+\_\+view stream)
\begin{DoxyCompactList}\small\item\em Approximates if a column or its descendants {\itshape may} have non-\/empty null elements   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_aacc2fd111114777e8e4e26c3295ca04b}{purge\+\_\+nonempty\+\_\+nulls}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&input, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Copy {\ttfamily input} into output while purging any non-\/empty null rows in the column or its descendants.   \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacecudf_1_1detail_ac6b739ba07b14a2274420abc4f2ea89c}{fill\+\_\+in\+\_\+place}} (\mbox{\hyperlink{classcudf_1_1mutable__column__view}{mutable\+\_\+column\+\_\+view}} \&destination, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} begin, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} end, \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&value, rmm\+::cuda\+\_\+stream\+\_\+view stream)
\begin{DoxyCompactList}\small\item\em Fills a range of elements in-\/place in a column with a scalar value.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_ab1a397072949d54359e047f3dada74d5}{fill}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&input, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} begin, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} end, \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&value, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Fills a range of elements in a column out-\/of-\/place with a scalar value.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a5b23205b2ffc206924167683c00c48f5}{gather}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&source\+\_\+table, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&gather\+\_\+map, \mbox{\hyperlink{group__column__copy_gae3ba74951558bc7966aae86abc6af5df}{out\+\_\+of\+\_\+bounds\+\_\+policy}} bounds\+\_\+policy, \mbox{\hyperlink{namespacecudf_1_1detail_a1c29a0e8458ffb159e91481c0f37b0f5}{negative\+\_\+index\+\_\+policy}} neg\+\_\+indices, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Gathers the specified rows of a set of columns according to a gather map. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_aef5dfc3e39242d68bd887f7e0b9fb373}{gather}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&source\+\_\+table, \mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$ const gather\+\_\+map, \mbox{\hyperlink{group__column__copy_gae3ba74951558bc7966aae86abc6af5df}{out\+\_\+of\+\_\+bounds\+\_\+policy}} bounds\+\_\+policy, \mbox{\hyperlink{namespacecudf_1_1detail_a1c29a0e8458ffb159e91481c0f37b0f5}{negative\+\_\+index\+\_\+policy}} neg\+\_\+indices, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_ac670d683b1e9e5c0682c3e2d23e79563}{hash}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&input, \mbox{\hyperlink{group__column__hash_gaced8b9d129825edd13d76e912e4413c3}{hash\+\_\+id}} hash\+\_\+function=\mbox{\hyperlink{group__column__hash_ggaced8b9d129825edd13d76e912e4413c3ae9ec854e962136b1afcf108e5301c354}{hash\+\_\+id\+::\+HASH\+\_\+\+MURMUR3}}, uint32\+\_\+t seed=\mbox{\hyperlink{group__column__hash_ga68de1d04aa2c0ea2eeacfc73fd99a915}{cudf\+::\+DEFAULT\+\_\+\+HASH\+\_\+\+SEED}}, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Computes the hash value of each row in the input set of columns.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a349e2b28175e2d9ea71d7761fd9b03ce}{murmur\+\_\+hash3\+\_\+32}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&input, uint32\+\_\+t seed=\mbox{\hyperlink{group__column__hash_ga68de1d04aa2c0ea2eeacfc73fd99a915}{cudf\+::\+DEFAULT\+\_\+\+HASH\+\_\+\+SEED}}, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a19d4598400aec3bb414a475b0e67588a}{spark\+\_\+murmur\+\_\+hash3\+\_\+32}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&input, uint32\+\_\+t seed=\mbox{\hyperlink{group__column__hash_ga68de1d04aa2c0ea2eeacfc73fd99a915}{cudf\+::\+DEFAULT\+\_\+\+HASH\+\_\+\+SEED}}, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_affdf27f8bc86ce410050f009d8b9d894}{md5\+\_\+hash}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&input, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\item 
constexpr uint32\+\_\+t \mbox{\hyperlink{namespacecudf_1_1detail_afacc4b3c523b45ae3046691dcc061191}{hash\+\_\+combine}} (uint32\+\_\+t lhs, uint32\+\_\+t rhs)
\begin{DoxyCompactList}\small\item\em Combines two hash values into a single hash value. \end{DoxyCompactList}\item 
constexpr std\+::size\+\_\+t \mbox{\hyperlink{namespacecudf_1_1detail_a31fed6fb6d5421eadcf1516f8d4e4fe9}{hash\+\_\+combine}} (std\+::size\+\_\+t lhs, std\+::size\+\_\+t rhs)
\begin{DoxyCompactList}\small\item\em Combines two hash values into a single hash value. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a94b63d8998a9b7eb5e1d4ae842f95a66}{from\+\_\+dlpack}} (DLManaged\+Tensor const \texorpdfstring{$\ast$}{*}managed\+\_\+tensor, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Convert a DLPack DLTensor into a cudf table   \end{DoxyCompactList}\item 
DLManaged\+Tensor \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{namespacecudf_1_1detail_a93794af21ad050c5390d6ccd97783c52}{to\+\_\+dlpack}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&input, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Convert a cudf table into a DLPack DLTensor   \end{DoxyCompactList}\item 
{\footnotesize template$<$typename... Ts$>$ }\\std\+::shared\+\_\+ptr$<$ arrow\+::\+Array $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a65b402cf23474cf91d987693ebfdeaa9}{to\+\_\+arrow\+\_\+array}} (\mbox{\hyperlink{group__utility__types_gadf077607da617d1dadcc5417e2783539}{cudf\+::type\+\_\+id}} id, Ts \&\&... args)
\item 
\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} \mbox{\hyperlink{namespacecudf_1_1detail_a1b91b19cf5f6210875f2c8066c263092}{arrow\+\_\+to\+\_\+cudf\+\_\+type}} (arrow\+::\+Data\+Type const \&arrow\+\_\+type)
\item 
std\+::shared\+\_\+ptr$<$ arrow\+::\+Table $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a69fbe0566c564337747a5ba0c30f7813}{to\+\_\+arrow}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} input, std\+::vector$<$ \mbox{\hyperlink{structcudf_1_1column__metadata}{column\+\_\+metadata}} $>$ const \&metadata=\{\}, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), arrow\+::\+Memory\+Pool \texorpdfstring{$\ast$}{*}ar\+\_\+mr=arrow\+::default\+\_\+memory\+\_\+pool())
\begin{DoxyCompactList}\small\item\em Create {\ttfamily arrow\+::\+Table} from cudf table {\ttfamily input}   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_ad2d059bf11972e2337fde993dbd2582b}{from\+\_\+arrow}} (arrow\+::\+Table const \&input\+\_\+table, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\item 
bool \mbox{\hyperlink{namespacecudf_1_1detail_a342ee3e4fa47300f2b57966d0eb3405f}{is\+\_\+element\+\_\+valid\+\_\+sync}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&col\+\_\+view, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} element\+\_\+index, rmm\+::cuda\+\_\+stream\+\_\+view stream)
\begin{DoxyCompactList}\small\item\em Return validity of a row \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{group__label__bins_ga7c25ea42d2c182e01e2eefb6174114f3}{label\+\_\+bins}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&input, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&left\+\_\+edges, \mbox{\hyperlink{group__label__bins_gabadbffbcb403fac1ff712330ea10f2b3}{inclusive}} left\+\_\+inclusive, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&right\+\_\+edges, \mbox{\hyperlink{group__label__bins_gabadbffbcb403fac1ff712330ea10f2b3}{inclusive}} right\+\_\+inclusive, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\item 
rmm\+::device\+\_\+buffer \mbox{\hyperlink{namespacecudf_1_1detail_a690f0e70c8c2bad53bf877483f2d346d}{create\+\_\+null\+\_\+mask}} (\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} size, \mbox{\hyperlink{group__utility__types_ga4daf20c000ab374d76f4d56f0ddb7b26}{mask\+\_\+state}} state, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Creates a {\ttfamily device\+\_\+buffer} for use as a null value indicator bitmask of a {\ttfamily column}.   \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespacecudf_1_1detail_a522f5649cb74a11dba58378f96e40f01}{set\+\_\+null\+\_\+mask}} (\mbox{\hyperlink{group__utility__types_ga1d17001baf070a639c3a5e8ed8c46d34}{bitmask\+\_\+type}} \texorpdfstring{$\ast$}{*}bitmask, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} begin\+\_\+bit, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} end\+\_\+bit, bool valid, rmm\+::cuda\+\_\+stream\+\_\+view stream)
\begin{DoxyCompactList}\small\item\em Sets a pre-\/allocated bitmask buffer to a given state in the range {\ttfamily \mbox{[}begin\+\_\+bit, end\+\_\+bit)}   \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{cudf\+::size\+\_\+type}} \mbox{\hyperlink{namespacecudf_1_1detail_aedafe62653e88ef1440aed7287f89ab8}{count\+\_\+set\+\_\+bits}} (\mbox{\hyperlink{group__utility__types_ga1d17001baf070a639c3a5e8ed8c46d34}{bitmask\+\_\+type}} const \texorpdfstring{$\ast$}{*}bitmask, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} start, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} stop, rmm\+::cuda\+\_\+stream\+\_\+view stream)
\begin{DoxyCompactList}\small\item\em Given a bitmask, counts the number of set (1) bits in the range {\ttfamily \mbox{[}start, stop)}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{cudf\+::size\+\_\+type}} \mbox{\hyperlink{namespacecudf_1_1detail_a96a79295789c1ba220298ea1dbc0e8f7}{count\+\_\+unset\+\_\+bits}} (\mbox{\hyperlink{group__utility__types_ga1d17001baf070a639c3a5e8ed8c46d34}{bitmask\+\_\+type}} const \texorpdfstring{$\ast$}{*}bitmask, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} start, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} stop, rmm\+::cuda\+\_\+stream\+\_\+view stream)
\begin{DoxyCompactList}\small\item\em Given a bitmask, counts the number of unset (0) bits in the range {\ttfamily \mbox{[}start, stop)}. \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a0568781207d7824429d333aa3a8e0870}{segmented\+\_\+count\+\_\+set\+\_\+bits}} (\mbox{\hyperlink{group__utility__types_ga1d17001baf070a639c3a5e8ed8c46d34}{bitmask\+\_\+type}} const \texorpdfstring{$\ast$}{*}bitmask, \mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$ indices, rmm\+::cuda\+\_\+stream\+\_\+view stream)
\begin{DoxyCompactList}\small\item\em Given a bitmask, counts the number of set (1) bits in every range {\ttfamily \mbox{[}indices\mbox{[}2\texorpdfstring{$\ast$}{*}i\mbox{]}, indices\mbox{[}(2\texorpdfstring{$\ast$}{*}i)+1\mbox{]})} (where 0 \texorpdfstring{$<$}{<}= i \texorpdfstring{$<$}{<} indices.\+size() / 2). \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_aab0e7344544634b61fd1f48a0931b231}{segmented\+\_\+count\+\_\+unset\+\_\+bits}} (\mbox{\hyperlink{group__utility__types_ga1d17001baf070a639c3a5e8ed8c46d34}{bitmask\+\_\+type}} const \texorpdfstring{$\ast$}{*}bitmask, \mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$ indices, rmm\+::cuda\+\_\+stream\+\_\+view stream)
\begin{DoxyCompactList}\small\item\em Given a bitmask, counts the number of unset (0) bits in every range {\ttfamily \mbox{[}indices\mbox{[}2\texorpdfstring{$\ast$}{*}i\mbox{]}, indices\mbox{[}(2\texorpdfstring{$\ast$}{*}i)+1\mbox{]})} (where 0 \texorpdfstring{$<$}{<}= i \texorpdfstring{$<$}{<} indices.\+size() / 2). \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{cudf\+::size\+\_\+type}} \mbox{\hyperlink{namespacecudf_1_1detail_a052b9cabb17b4fc2ef27e00a6414c707}{valid\+\_\+count}} (\mbox{\hyperlink{group__utility__types_ga1d17001baf070a639c3a5e8ed8c46d34}{bitmask\+\_\+type}} const \texorpdfstring{$\ast$}{*}bitmask, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} start, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} stop, rmm\+::cuda\+\_\+stream\+\_\+view stream)
\begin{DoxyCompactList}\small\item\em Given a validity bitmask, counts the number of valid elements (set bits) in the range {\ttfamily \mbox{[}start, stop)}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{cudf\+::size\+\_\+type}} \mbox{\hyperlink{namespacecudf_1_1detail_a289827dc5428527e139352669318e55f}{null\+\_\+count}} (\mbox{\hyperlink{group__utility__types_ga1d17001baf070a639c3a5e8ed8c46d34}{bitmask\+\_\+type}} const \texorpdfstring{$\ast$}{*}bitmask, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} start, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} stop, rmm\+::cuda\+\_\+stream\+\_\+view stream)
\begin{DoxyCompactList}\small\item\em Given a validity bitmask, counts the number of null elements (unset bits) in the range {\ttfamily \mbox{[}start, stop)}. \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a35145843e5dd4a43853838b02241881f}{segmented\+\_\+valid\+\_\+count}} (\mbox{\hyperlink{group__utility__types_ga1d17001baf070a639c3a5e8ed8c46d34}{bitmask\+\_\+type}} const \texorpdfstring{$\ast$}{*}bitmask, \mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$ indices, rmm\+::cuda\+\_\+stream\+\_\+view stream)
\begin{DoxyCompactList}\small\item\em Given a validity bitmask, counts the number of valid elements (set bits) in every range {\ttfamily \mbox{[}indices\mbox{[}2\texorpdfstring{$\ast$}{*}i\mbox{]}, indices\mbox{[}(2\texorpdfstring{$\ast$}{*}i)+1\mbox{]})} (where 0 \texorpdfstring{$<$}{<}= i \texorpdfstring{$<$}{<} indices.\+size() / 2). \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_aee03027237bac182e4be6d37fa6c4f37}{segmented\+\_\+null\+\_\+count}} (\mbox{\hyperlink{group__utility__types_ga1d17001baf070a639c3a5e8ed8c46d34}{bitmask\+\_\+type}} const \texorpdfstring{$\ast$}{*}bitmask, \mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$ indices, rmm\+::cuda\+\_\+stream\+\_\+view stream)
\begin{DoxyCompactList}\small\item\em Given a validity bitmask, counts the number of null elements (unset bits) in every range {\ttfamily \mbox{[}indices\mbox{[}2\texorpdfstring{$\ast$}{*}i\mbox{]}, indices\mbox{[}(2\texorpdfstring{$\ast$}{*}i)+1\mbox{]})} (where 0 \texorpdfstring{$<$}{<}= i \texorpdfstring{$<$}{<} indices.\+size() / 2). \end{DoxyCompactList}\item 
rmm\+::device\+\_\+buffer \mbox{\hyperlink{namespacecudf_1_1detail_a9423550e270db631d429d61b140d7108}{copy\+\_\+bitmask}} (\mbox{\hyperlink{group__utility__types_ga1d17001baf070a639c3a5e8ed8c46d34}{bitmask\+\_\+type}} const \texorpdfstring{$\ast$}{*}mask, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} begin\+\_\+bit, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} end\+\_\+bit, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Creates a {\ttfamily device\+\_\+buffer} from a slice of bitmask defined by a range of indices {\ttfamily \mbox{[}begin\+\_\+bit, end\+\_\+bit)}.   \end{DoxyCompactList}\item 
rmm\+::device\+\_\+buffer \mbox{\hyperlink{namespacecudf_1_1detail_aaddec64eefdf906a669dd8e65e23137c}{copy\+\_\+bitmask}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&view, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Copies {\ttfamily view}\textquotesingle{}s bitmask from the bits {\ttfamily \mbox{[}view.\+offset(), view.\+offset() + view.\+size())} into a {\ttfamily device\+\_\+buffer}   \end{DoxyCompactList}\item 
std\+::pair$<$ rmm\+::device\+\_\+buffer, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_adc5e9bcff0d652d054817afa71d20399}{bitmask\+\_\+and}} (\mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga1d17001baf070a639c3a5e8ed8c46d34}{bitmask\+\_\+type}} const \texorpdfstring{$\ast$}{*}const $>$ masks, \mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$ masks\+\_\+begin\+\_\+bits, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} mask\+\_\+size\+\_\+bits, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\item 
std\+::pair$<$ rmm\+::device\+\_\+buffer, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_abf99352f85f59ae17972b8462cfb4760}{bitmask\+\_\+and}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&view, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Performs bitwise AND of the bitmasks of columns of a table. Returns a pair of resulting mask and count of unset bits.   \end{DoxyCompactList}\item 
std\+::pair$<$ rmm\+::device\+\_\+buffer, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a280d3e05cbbc973356f38c0ee1fca2e3}{bitmask\+\_\+or}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&view, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Performs bitwise OR of the bitmasks of columns of a table. Returns a pair of resulting mask and count of unset bits.   \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{cudf\+::size\+\_\+type}} \mbox{\hyperlink{namespacecudf_1_1detail_af99f371b8101fc545e0c64553e5d81a9}{inplace\+\_\+bitmask\+\_\+and}} (\mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga1d17001baf070a639c3a5e8ed8c46d34}{bitmask\+\_\+type}} $>$ dest\+\_\+mask, \mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga1d17001baf070a639c3a5e8ed8c46d34}{bitmask\+\_\+type}} const \texorpdfstring{$\ast$}{*}const $>$ masks, \mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$ masks\+\_\+begin\+\_\+bits, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} mask\+\_\+size\+\_\+bits, rmm\+::cuda\+\_\+stream\+\_\+view stream)
\begin{DoxyCompactList}\small\item\em Performs a bitwise AND of the specified bitmasks, and writes in place to destination \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a3f9e3cf937df8cb28860d3fc8e9843d7}{quantile}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&input, std\+::vector$<$ double $>$ const \&q, \mbox{\hyperlink{group__utility__types_ga9cd17c1cdf028ead9a4783f605276ab3}{interpolation}} interp=\mbox{\hyperlink{group__utility__types_gga9cd17c1cdf028ead9a4783f605276ab3aaac544aacc3615aada24897a215f5046}{interpolation\+::\+LINEAR}}, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&ordered\+\_\+indices=\{\}, bool exact=true, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Computes quantiles with interpolation.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a9db69c255a5f64c2b3f9e4bc7e73caa9}{quantiles}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&input, std\+::vector$<$ double $>$ const \&q, \mbox{\hyperlink{group__utility__types_ga9cd17c1cdf028ead9a4783f605276ab3}{interpolation}} interp=\mbox{\hyperlink{group__utility__types_gga9cd17c1cdf028ead9a4783f605276ab3aad135772d7cf93dd0ccf9d2474b34e6a}{interpolation\+::\+NEAREST}}, \mbox{\hyperlink{group__utility__types_gab283c517931abd4152ffa62fec62425d}{cudf\+::sorted}} is\+\_\+input\+\_\+sorted=\mbox{\hyperlink{group__utility__types_ggab283c517931abd4152ffa62fec62425dac2f3f489a00553e7a01d369c103c7251}{sorted\+::\+NO}}, std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga750f02016b046079f7062d334890b4fc}{order}} $>$ const \&column\+\_\+order=\{\}, std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga058e6d6e8a21583ce0e85ee73e5abb31}{null\+\_\+order}} $>$ const \&null\+\_\+precedence=\{\}, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Returns the rows of the input corresponding to the requested quantiles.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a698c778a6399397c6013e7d45c835b4c}{percentile\+\_\+approx}} (\mbox{\hyperlink{classcudf_1_1tdigest_1_1tdigest__column__view}{tdigest\+::tdigest\+\_\+column\+\_\+view}} const \&input, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&percentiles, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a47a307e124575b78186601f1c689c05c}{repeat}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&input\+\_\+table, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&count, bool check\+\_\+count, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a75705d38197681267f667733ef0c1be4}{repeat}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&input\+\_\+table, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} count, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Repeat rows of a Table.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_aa2782e7c057de7e1596841c366b471b3}{replace\+\_\+nulls}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&input, \mbox{\hyperlink{classcudf_1_1column__view}{cudf\+::column\+\_\+view}} const \&replacement, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Replaces all null values in a column with corresponding values of another column   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a089e06d35c8fc924a836da9e7fcce84e}{replace\+\_\+nulls}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&input, \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&replacement, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Replaces all null values in a column with a scalar.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a9c0b4a9cf791df1c239576b67b2d9255}{replace\+\_\+nulls}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&input, \mbox{\hyperlink{group__transformation__replace_ga7cdbc9bc3671930a743c86f36c38abf9}{replace\+\_\+policy}} const \&\mbox{\hyperlink{group__transformation__replace_ga7cdbc9bc3671930a743c86f36c38abf9}{replace\+\_\+policy}}, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Replaces all null values in a column with the first non-\/null value that precedes/follows.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_ade00a5854797478de85ef4f4735be57d}{replace\+\_\+nans}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&input, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&replacement, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Replaces all NaN values in a column with corresponding values from another column   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_ad0298a6133c943e5ef6107630fd267f1}{replace\+\_\+nans}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&input, \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&replacement, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Replaces all NaN values in a column with a scalar   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_adacfa4e22fd6f93938a4d72131d9aff7}{find\+\_\+and\+\_\+replace\+\_\+all}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&input\+\_\+col, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&values\+\_\+to\+\_\+replace, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&replacement\+\_\+values, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Return a copy of {\ttfamily input\+\_\+col} replacing any {\ttfamily values\+\_\+to\+\_\+replace\mbox{[}i\mbox{]}} found with {\ttfamily replacement\+\_\+values\mbox{[}i\mbox{]}}.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a841c17146b279d123c4d579ddd7e7f14}{normalize\+\_\+nans\+\_\+and\+\_\+zeros}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&input, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Copies from a column of floating-\/point elements and replaces {\ttfamily -\/NaN} and {\ttfamily -\/0.\+0} with {\ttfamily +NaN} and {\ttfamily +0.\+0}, respectively.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a0390f62b7fcc7ea895d0ca910e6403c7}{tile}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&input, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} count, rmm\+::cuda\+\_\+stream\+\_\+view, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Repeats the rows from {\ttfamily input} table {\ttfamily count} times to form a new table.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a08a76bcdabba736bbb9948129f723028}{interleave\+\_\+columns}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&input, rmm\+::cuda\+\_\+stream\+\_\+view, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Interleave columns of a table into a single column.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a10e1b8f89952c1c18a574a822fa8c189}{rolling\+\_\+window}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&input, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&preceding\+\_\+window, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&following\+\_\+window, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} min\+\_\+periods, \mbox{\hyperlink{classcudf_1_1rolling__aggregation}{rolling\+\_\+aggregation}} const \&agg, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em \doxylink{group__aggregation__rolling_gaaed6574615700cec1d4bf5469fe28141}{rolling\+\_\+window(           column\+\_\+view const\& input,           column\+\_\+view const\& preceding\+\_\+window,           column\+\_\+view const\& following\+\_\+window,           size\+\_\+type min\+\_\+periods,           rolling\+\_\+aggregation const\& agg,           rmm\+::mr\+::device\+\_\+memory\+\_\+resource\texorpdfstring{$\ast$}{*} mr)} \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a8131d320d1ae7d8daea58311bc10ffeb}{round}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&input, int32\+\_\+t decimal\+\_\+places, \mbox{\hyperlink{group__transformation__unaryops_ga02028fc18312cdb2f07159c6297e74bb}{rounding\+\_\+method}} method, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Rounds all the values in a column to the specified number of decimal places.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_ac9be538c2fe0b9e74c569460ecc65261}{scan\+\_\+exclusive}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&input, \mbox{\hyperlink{classcudf_1_1scan__aggregation}{scan\+\_\+aggregation}} const \&agg, \mbox{\hyperlink{group__utility__types_ga1b8cda4afb95a7c42c4679b4fae61009}{null\+\_\+policy}} null\+\_\+handling, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr)
\begin{DoxyCompactList}\small\item\em Computes the exclusive scan of a column. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_adc391e283f48ecd780dec6ceb2d0a6f9}{scan\+\_\+inclusive}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&input, \mbox{\hyperlink{classcudf_1_1scan__aggregation}{scan\+\_\+aggregation}} const \&agg, \mbox{\hyperlink{group__utility__types_ga1b8cda4afb95a7c42c4679b4fae61009}{null\+\_\+policy}} null\+\_\+handling, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr)
\begin{DoxyCompactList}\small\item\em Computes the inclusive scan of a column. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a2b644db01ab5c564aa3e2e865669b59d}{inclusive\+\_\+rank\+\_\+scan}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&order\+\_\+by, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr)
\begin{DoxyCompactList}\small\item\em Generate row ranks for a column. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_acc8016a38976fc8af9b8a9b3c23a08ae}{inclusive\+\_\+dense\+\_\+rank\+\_\+scan}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&order\+\_\+by, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr)
\begin{DoxyCompactList}\small\item\em Generate row dense ranks for a column. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_ab6f61e90d14f101f0f7da7f140649f80}{inclusive\+\_\+one\+\_\+normalized\+\_\+percent\+\_\+rank\+\_\+scan}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&order\+\_\+by, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr)
\begin{DoxyCompactList}\small\item\em Generate row ONE\+\_\+\+NORMALIZED percent ranks for a column. Also, knowns as ANSI SQL PERCENT RANK. Calculated by (rank -\/ 1) / (count -\/ 1). \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_ab0fafddc49374af3d9ab6815196d426f}{scatter}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&source, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&scatter\+\_\+map, \mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&target, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Scatters the rows of the source table into a copy of the target table according to a scatter map. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a642afeffe44abb5382a4c44534503907}{scatter}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&source, \mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$ const scatter\+\_\+map, \mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&target, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a5bdf86f00fd97bb400afe50fe644af52}{scatter}} (std\+::vector$<$ std\+::reference\+\_\+wrapper$<$ const \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} $>$ $>$ const \&source, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&indices, \mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&target, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Scatters a row of scalar values into a copy of the target table according to a scatter map. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_ab632fac16d86dcdec8172f105e9cc3bb}{boolean\+\_\+mask\+\_\+scatter}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&source, \mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&target, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&boolean\+\_\+mask, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Scatters rows from the input table to rows of the output corresponding to true values in a boolean mask.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_aca6f0ca2c888fcffaf3c516ba0b05498}{boolean\+\_\+mask\+\_\+scatter}} (std\+::vector$<$ std\+::reference\+\_\+wrapper$<$ const \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} $>$ $>$ const \&source, \mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&target, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&boolean\+\_\+mask, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a45dd74287624f555fcfb232087bb16e6}{lower\+\_\+bound}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&haystack, \mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&needles, std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga750f02016b046079f7062d334890b4fc}{order}} $>$ const \&column\+\_\+order, std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga058e6d6e8a21583ce0e85ee73e5abb31}{null\+\_\+order}} $>$ const \&null\+\_\+precedence, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr)
\begin{DoxyCompactList}\small\item\em Find smallest indices in a sorted table where values should be inserted to maintain order.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_ad5c2375ffd17459ecf1ef510fe8c2ea2}{upper\+\_\+bound}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&haystack, \mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&needles, std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga750f02016b046079f7062d334890b4fc}{order}} $>$ const \&column\+\_\+order, std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga058e6d6e8a21583ce0e85ee73e5abb31}{null\+\_\+order}} $>$ const \&null\+\_\+precedence, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr)
\begin{DoxyCompactList}\small\item\em Find largest indices in a sorted table where values should be inserted to maintain order.   \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespacecudf_1_1detail_aabbae19d91d3507be87defb820d2e603}{contains}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&haystack, \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&needle, rmm\+::cuda\+\_\+stream\+\_\+view stream)
\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a6c1de6dab4d4d341e17ff17cdff7a133}{contains}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&haystack, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&needles, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr)
\begin{DoxyCompactList}\small\item\em Check if the given {\ttfamily needles} values exists in the {\ttfamily haystack} column.   \end{DoxyCompactList}\item 
rmm\+::device\+\_\+uvector$<$ bool $>$ \mbox{\hyperlink{namespacecudf_1_1detail_aa272dc48c5c03c83e46dc103a86bdeb4}{contains}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&haystack, \mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&needles, \mbox{\hyperlink{group__utility__types_ga08a672308cd0f61562410d106b377771}{null\+\_\+equality}} compare\+\_\+nulls, \mbox{\hyperlink{group__utility__types_gae9d1055c69c3089452794783c7c82f83}{nan\+\_\+equality}} compare\+\_\+nans, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Check if rows in the given {\ttfamily needles} table exist in the {\ttfamily haystack} table. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_acaed9837e40ff8bcba1cb84806e191f3}{sequence}} (\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} size, \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&init, \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&step, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Fills a column with a sequence of value specified by an initial value and a step.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a4de28f6150ae69e92bb463bdb86c94e3}{sequence}} (\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} size, \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&init, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Fills a column with a sequence of value specified by an initial value and a step of 1.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{cudf\+::column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a8ab76605084c4a005ccd720c76fb828f}{calendrical\+\_\+month\+\_\+sequence}} (\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} size, \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&init, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} months, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Generate a sequence of timestamps beginning at {\ttfamily init} and incrementing by {\ttfamily months} for each successive element, i.\+e., {\ttfamily output\mbox{[}i\mbox{]} = init + i \texorpdfstring{$\ast$}{*} months} for {\ttfamily i} in {\ttfamily \mbox{[}0, size)}.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a02dc7ba3e6b64741911634d22f34fa91}{sorted\+\_\+order}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&input, std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga750f02016b046079f7062d334890b4fc}{order}} $>$ const \&column\+\_\+order=\{\}, std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga058e6d6e8a21583ce0e85ee73e5abb31}{null\+\_\+order}} $>$ const \&null\+\_\+precedence=\{\}, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Computes the row indices that would produce {\ttfamily input} in a lexicographical sorted order.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a7eacf26ccb873b752827c9316f858ca9}{stable\+\_\+sorted\+\_\+order}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&input, std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga750f02016b046079f7062d334890b4fc}{order}} $>$ const \&column\+\_\+order=\{\}, std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga058e6d6e8a21583ce0e85ee73e5abb31}{null\+\_\+order}} $>$ const \&null\+\_\+precedence=\{\}, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Computes the row indices that would produce {\ttfamily input} in a stable lexicographical sorted order.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a8ef04bcc6a371c3a2ecdd1a24d413b06}{sort\+\_\+by\+\_\+key}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&values, \mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&keys, std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga750f02016b046079f7062d334890b4fc}{order}} $>$ const \&column\+\_\+order=\{\}, std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga058e6d6e8a21583ce0e85ee73e5abb31}{null\+\_\+order}} $>$ const \&null\+\_\+precedence=\{\}, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Performs a key-\/value sort.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_af8ef84bbffe708df280ab3edd030a761}{stable\+\_\+sort\+\_\+by\+\_\+key}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&values, \mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&keys, std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga750f02016b046079f7062d334890b4fc}{order}} $>$ const \&column\+\_\+order=\{\}, std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga058e6d6e8a21583ce0e85ee73e5abb31}{null\+\_\+order}} $>$ const \&null\+\_\+precedence=\{\}, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Performs a key-\/value stable sort.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a5ee83cd6aa2e87076b5f8c39fbf08719}{segmented\+\_\+sorted\+\_\+order}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&keys, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&segment\+\_\+offsets, std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga750f02016b046079f7062d334890b4fc}{order}} $>$ const \&column\+\_\+order=\{\}, std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga058e6d6e8a21583ce0e85ee73e5abb31}{null\+\_\+order}} $>$ const \&null\+\_\+precedence=\{\}, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Returns sorted order after sorting each segment in the table.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a9f2457ab266f3c83ee1803af46d40431}{stable\+\_\+segmented\+\_\+sorted\+\_\+order}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&keys, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&segment\+\_\+offsets, std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga750f02016b046079f7062d334890b4fc}{order}} $>$ const \&column\+\_\+order=\{\}, std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga058e6d6e8a21583ce0e85ee73e5abb31}{null\+\_\+order}} $>$ const \&null\+\_\+precedence=\{\}, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Returns sorted order after stably sorting each segment in the table.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a0143b14fe58e9f453958200e4bd745b2}{segmented\+\_\+sort\+\_\+by\+\_\+key}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&values, \mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&keys, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&segment\+\_\+offsets, std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga750f02016b046079f7062d334890b4fc}{order}} $>$ const \&column\+\_\+order=\{\}, std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga058e6d6e8a21583ce0e85ee73e5abb31}{null\+\_\+order}} $>$ const \&null\+\_\+precedence=\{\}, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Performs a lexicographic segmented sort of a table   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a617cf9daf1ccb662f23d1751d8e9eef1}{stable\+\_\+segmented\+\_\+sort\+\_\+by\+\_\+key}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&values, \mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&keys, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&segment\+\_\+offsets, std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga750f02016b046079f7062d334890b4fc}{order}} $>$ const \&column\+\_\+order=\{\}, std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga058e6d6e8a21583ce0e85ee73e5abb31}{null\+\_\+order}} $>$ const \&null\+\_\+precedence=\{\}, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Performs a stably lexicographic segmented sort of a table   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a6ecb769bcadd1469d96dab94bc9fb92c}{sort}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&values, std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga750f02016b046079f7062d334890b4fc}{order}} $>$ const \&column\+\_\+order=\{\}, std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga058e6d6e8a21583ce0e85ee73e5abb31}{null\+\_\+order}} $>$ const \&null\+\_\+precedence=\{\}, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Performs a lexicographic sort of the rows of a table   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a3ad692201878dfd4b9058cef0428bf3d}{drop\+\_\+nulls}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&input, std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ const \&keys, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{cudf\+::size\+\_\+type}} keep\+\_\+threshold, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Filters a table to remove null elements with threshold count.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a8bde81471b27ab73aa588c4e79937199}{drop\+\_\+nans}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&input, std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ const \&keys, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{cudf\+::size\+\_\+type}} keep\+\_\+threshold, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Filters a table to remove NANs with threshold count.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a37b172e383c23e8f5266dae0ffc4d53d}{apply\+\_\+boolean\+\_\+mask}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&input, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&boolean\+\_\+mask, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Filters {\ttfamily input} using {\ttfamily boolean\+\_\+mask} of boolean values as a mask.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a641f75ce86d28e459d73c6afe246f43c}{unique}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&input, std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ const \&keys, \mbox{\hyperlink{group__reorder__compact_ga69091647ea1f9c9d4cdcf7c8876bea3a}{duplicate\+\_\+keep\+\_\+option}} keep, \mbox{\hyperlink{group__utility__types_ga08a672308cd0f61562410d106b377771}{null\+\_\+equality}} nulls\+\_\+equal=\mbox{\hyperlink{group__utility__types_gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44}{null\+\_\+equality\+::\+EQUAL}}, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Create a new table with consecutive duplicate rows removed.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a32d13444c532389ceda0e73e6fa73081}{distinct}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&input, std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ const \&keys, \mbox{\hyperlink{group__reorder__compact_ga69091647ea1f9c9d4cdcf7c8876bea3a}{duplicate\+\_\+keep\+\_\+option}} keep=\mbox{\hyperlink{group__reorder__compact_gga69091647ea1f9c9d4cdcf7c8876bea3aa0546025abe5830d9334bb82102420394}{duplicate\+\_\+keep\+\_\+option\+::\+KEEP\+\_\+\+ANY}}, \mbox{\hyperlink{group__utility__types_ga08a672308cd0f61562410d106b377771}{null\+\_\+equality}} nulls\+\_\+equal=\mbox{\hyperlink{group__utility__types_gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44}{null\+\_\+equality\+::\+EQUAL}}, \mbox{\hyperlink{group__utility__types_gae9d1055c69c3089452794783c7c82f83}{nan\+\_\+equality}} nans\+\_\+equal=\mbox{\hyperlink{group__utility__types_ggae9d1055c69c3089452794783c7c82f83acd6d9f766e6e2753da429d26078711d7}{nan\+\_\+equality\+::\+ALL\+\_\+\+EQUAL}}, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Create a new table without duplicate rows.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_ae447240ab710451b66b73e15b19e50f4}{stable\+\_\+distinct}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&input, std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ const \&keys, \mbox{\hyperlink{group__reorder__compact_ga69091647ea1f9c9d4cdcf7c8876bea3a}{duplicate\+\_\+keep\+\_\+option}} keep=\mbox{\hyperlink{group__reorder__compact_gga69091647ea1f9c9d4cdcf7c8876bea3aa0546025abe5830d9334bb82102420394}{duplicate\+\_\+keep\+\_\+option\+::\+KEEP\+\_\+\+ANY}}, \mbox{\hyperlink{group__utility__types_ga08a672308cd0f61562410d106b377771}{null\+\_\+equality}} nulls\+\_\+equal=\mbox{\hyperlink{group__utility__types_gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44}{null\+\_\+equality\+::\+EQUAL}}, \mbox{\hyperlink{group__utility__types_gae9d1055c69c3089452794783c7c82f83}{nan\+\_\+equality}} nans\+\_\+equal=\mbox{\hyperlink{group__utility__types_ggae9d1055c69c3089452794783c7c82f83acd6d9f766e6e2753da429d26078711d7}{nan\+\_\+equality\+::\+ALL\+\_\+\+EQUAL}}, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Create a new table without duplicate rows. \end{DoxyCompactList}\item 
rmm\+::device\+\_\+uvector$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a67374a27ed17df376e445010d699fc62}{get\+\_\+distinct\+\_\+indices}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&input, \mbox{\hyperlink{group__reorder__compact_ga69091647ea1f9c9d4cdcf7c8876bea3a}{duplicate\+\_\+keep\+\_\+option}} keep=\mbox{\hyperlink{group__reorder__compact_gga69091647ea1f9c9d4cdcf7c8876bea3aa0546025abe5830d9334bb82102420394}{duplicate\+\_\+keep\+\_\+option\+::\+KEEP\+\_\+\+ANY}}, \mbox{\hyperlink{group__utility__types_ga08a672308cd0f61562410d106b377771}{null\+\_\+equality}} nulls\+\_\+equal=\mbox{\hyperlink{group__utility__types_gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44}{null\+\_\+equality\+::\+EQUAL}}, \mbox{\hyperlink{group__utility__types_gae9d1055c69c3089452794783c7c82f83}{nan\+\_\+equality}} nans\+\_\+equal=\mbox{\hyperlink{group__utility__types_ggae9d1055c69c3089452794783c7c82f83acd6d9f766e6e2753da429d26078711d7}{nan\+\_\+equality\+::\+ALL\+\_\+\+EQUAL}}, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}(), rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Create a column of indices of all distinct rows in the input table. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{cudf\+::size\+\_\+type}} \mbox{\hyperlink{namespacecudf_1_1detail_a98e8b391af43f65454777fb93ac1810b}{unique\+\_\+count}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&input, \mbox{\hyperlink{group__utility__types_ga1b8cda4afb95a7c42c4679b4fae61009}{null\+\_\+policy}} null\+\_\+handling, \mbox{\hyperlink{group__utility__types_ga74641d3dfd6d96d0939b492ecf9b9cc8}{nan\+\_\+policy}} nan\+\_\+handling, rmm\+::cuda\+\_\+stream\+\_\+view stream)
\begin{DoxyCompactList}\small\item\em Count the number of consecutive groups of equivalent rows in a column.   \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{cudf\+::size\+\_\+type}} \mbox{\hyperlink{namespacecudf_1_1detail_a310da6da06499f366f5df272a540182e}{unique\+\_\+count}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&input, \mbox{\hyperlink{group__utility__types_ga08a672308cd0f61562410d106b377771}{null\+\_\+equality}} nulls\+\_\+equal=\mbox{\hyperlink{group__utility__types_gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44}{null\+\_\+equality\+::\+EQUAL}}, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}())
\begin{DoxyCompactList}\small\item\em Count the number of consecutive groups of equivalent rows in a table.   \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{cudf\+::size\+\_\+type}} \mbox{\hyperlink{namespacecudf_1_1detail_aedc80778d27d66fad4e9e6d102f5b4f6}{distinct\+\_\+count}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&input, \mbox{\hyperlink{group__utility__types_ga1b8cda4afb95a7c42c4679b4fae61009}{null\+\_\+policy}} null\+\_\+handling, \mbox{\hyperlink{group__utility__types_ga74641d3dfd6d96d0939b492ecf9b9cc8}{nan\+\_\+policy}} nan\+\_\+handling, rmm\+::cuda\+\_\+stream\+\_\+view stream)
\begin{DoxyCompactList}\small\item\em Count the distinct elements in the \doxylink{classcudf_1_1column__view}{column\+\_\+view}.   \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{cudf\+::size\+\_\+type}} \mbox{\hyperlink{namespacecudf_1_1detail_ab3e020feeee7f44561f850a2e42647d5}{distinct\+\_\+count}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&input, \mbox{\hyperlink{group__utility__types_ga08a672308cd0f61562410d106b377771}{null\+\_\+equality}} nulls\+\_\+equal=\mbox{\hyperlink{group__utility__types_gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44}{null\+\_\+equality\+::\+EQUAL}}, rmm\+::cuda\+\_\+stream\+\_\+view stream=\mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}())
\begin{DoxyCompactList}\small\item\em Count the distinct rows in a table.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a8dea2d4015483abd8062b4f3e8c49ecf}{transform}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&input, std\+::string const \&unary\+\_\+udf, \mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} output\+\_\+type, bool is\+\_\+ptx, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Creates a new column by applying a unary function against every element of an input column.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a0c8323757962d4b3d4b41b9d06289914}{compute\+\_\+column}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \mbox{\hyperlink{classcudf_1_1table}{table}}, \mbox{\hyperlink{classcudf_1_1ast_1_1operation}{ast\+::operation}} const \&expr, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Compute a new column by evaluating an expression tree on a table.   \end{DoxyCompactList}\item 
std\+::pair$<$ std\+::unique\+\_\+ptr$<$ rmm\+::device\+\_\+buffer $>$, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_abb7e1bd82e43f366a0455d2c606ff212}{nans\+\_\+to\+\_\+nulls}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&input, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Creates a null\+\_\+mask from {\ttfamily input} by converting {\ttfamily NaN} to null and preserving existing null values and also returns new null\+\_\+count.   \end{DoxyCompactList}\item 
std\+::pair$<$ std\+::unique\+\_\+ptr$<$ rmm\+::device\+\_\+buffer $>$, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{cudf\+::size\+\_\+type}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_ad38866396e5c2b317d7075374fe64777}{bools\+\_\+to\+\_\+mask}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&input, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Creates a bitmask from a column of boolean elements.   \end{DoxyCompactList}\item 
std\+::pair$<$ std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{cudf\+::table}} $>$, std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{cudf\+::column}} $>$ $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a861eb8ba4d559b6db57beb584530fb31}{encode}} (\mbox{\hyperlink{classcudf_1_1table__view}{cudf\+::table\+\_\+view}} const \&input, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Encode the rows of the given table as integers   \end{DoxyCompactList}\item 
std\+::pair$<$ std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$, \mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_ad30bc52a8dbe05164e2d5fc0b49e1844}{one\+\_\+hot\+\_\+encode}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&input, \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&categories, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Encodes {\ttfamily input} by generating a new column for each value in {\ttfamily categories} indicating the presence of that value in {\ttfamily input}.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_adcca95b53757f3fc776e4a53c762e318}{mask\+\_\+to\+\_\+bools}} (\mbox{\hyperlink{group__utility__types_ga1d17001baf070a639c3a5e8ed8c46d34}{bitmask\+\_\+type}} const \texorpdfstring{$\ast$}{*}null\+\_\+mask, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} begin\+\_\+bit, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} end\+\_\+bit, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Creates a boolean column from given bitmask.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a6f65c99023599795be67aafb3c125b88}{row\+\_\+bit\+\_\+count}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&t, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Returns an approximate cumulative size in bits of all columns in the {\ttfamily \doxylink{classcudf_1_1table__view}{table\+\_\+view}} for each row.   \end{DoxyCompactList}\item 
std\+::pair$<$ std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$, \mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_ac5fe789c6b4148db15bad46557ad89d1}{transpose}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&input, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Transposes a table.   \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Input\+Iterator , typename Predicate $>$ }\\std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_ac0e1aa6f630065804422ba95e76da8f2}{true\+\_\+if}} (Input\+Iterator begin, Input\+Iterator end, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} size, Predicate p, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Creates a column of {\ttfamily \doxylink{group__utility__types_ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd}{type\+\_\+id\+::\+BOOL8}} elements by applying a predicate to every element between \mbox{[}{\ttfamily begin,}end{\ttfamily )}true{\ttfamily indicates the value is satisfies the predicate and}false\`{} indicates it doesn\textquotesingle{}t. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{cudf\+::column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_acc1d1df6733679d2f522bd838eae342a}{unary\+\_\+operation}} (\mbox{\hyperlink{classcudf_1_1column__view}{cudf\+::column\+\_\+view}} const \&input, \mbox{\hyperlink{group__transformation__unaryops_ga030e62f30b296602f398e70d1ca657c4}{cudf\+::unary\+\_\+operator}} op, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Performs unary op on all values in column   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_ac2d9341a3c49eb3b9d237d9da1c1e5ac}{cast}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&input, \mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} type, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Casts data from dtype specified in input to dtype specified in output.   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a87fb076548c816c8477d213d3b56362a}{is\+\_\+nan}} (\mbox{\hyperlink{classcudf_1_1column__view}{cudf\+::column\+\_\+view}} const \&input, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Creates a column of {\ttfamily \doxylink{group__utility__types_ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd}{type\+\_\+id\+::\+BOOL8}} elements indicating the presence of {\ttfamily NaN} values in a column of floating point values. The output element at row {\ttfamily i} is {\ttfamily true} if the element in {\ttfamily input} at row i is {\ttfamily NAN}, else {\ttfamily false}   \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ \mbox{\hyperlink{namespacecudf_1_1detail_aab222fc99bdf3b292820aa2502058869}{is\+\_\+not\+\_\+nan}} (\mbox{\hyperlink{classcudf_1_1column__view}{cudf\+::column\+\_\+view}} const \&input, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Creates a column of {\ttfamily \doxylink{group__utility__types_ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd}{type\+\_\+id\+::\+BOOL8}} elements indicating the absence of {\ttfamily NaN} values in a column of floating point values. The output element at row {\ttfamily i} is {\ttfamily false} if the element in {\ttfamily input} at row i is {\ttfamily NAN}, else {\ttfamily true}   \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\T \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{namespacecudf_1_1detail_a1454447a634ec7b0e34b066fd6f950a2}{align\+\_\+ptr\+\_\+for\+\_\+type}} (void \texorpdfstring{$\ast$}{*}destination)
\begin{DoxyCompactList}\small\item\em Returns the aligned address for holding array of type T in pre-\/allocated memory. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespacecudf_1_1detail_a627e116400c1bed3d5f2b3ab78661fe8}{Linked\+Col\+Vector}} \mbox{\hyperlink{namespacecudf_1_1detail_ab6afca7c4d88ca63b0e0903ac5c09ae0}{table\+\_\+to\+\_\+linked\+\_\+columns}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&\mbox{\hyperlink{classcudf_1_1table}{table}})
\begin{DoxyCompactList}\small\item\em Converts all column\+\_\+views of a table into linked\+\_\+column\+\_\+views \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\rmm\+::device\+\_\+uvector$<$ T $>$ \mbox{\hyperlink{namespacecudf_1_1detail_ab330bdc16d921431c949ade216386305}{make\+\_\+zeroed\+\_\+device\+\_\+uvector\+\_\+async}} (std\+::size\+\_\+t size, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Asynchronously construct a {\ttfamily device\+\_\+uvector} and set all elements to zero. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\rmm\+::device\+\_\+uvector$<$ T $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a1cbce3bdea9ae93c27fedd21b4177e4f}{make\+\_\+zeroed\+\_\+device\+\_\+uvector\+\_\+sync}} (std\+::size\+\_\+t size, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Synchronously construct a {\ttfamily device\+\_\+uvector} and set all elements to zero. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\rmm\+::device\+\_\+uvector$<$ T $>$ \mbox{\hyperlink{namespacecudf_1_1detail_af58212f43ad1509a309bf99b6abcabb3}{make\+\_\+device\+\_\+uvector\+\_\+async}} (\mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$<$ T const $>$ source\+\_\+data, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Asynchronously construct a {\ttfamily device\+\_\+uvector} containing a deep copy of data from a {\ttfamily \doxylink{structcudf_1_1host__span}{host\+\_\+span}} \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Container , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+convertible\+\_\+v$<$ Container, \mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$<$ typename Container\+::value\+\_\+type const $>$ $>$ $>$ \texorpdfstring{$\ast$}{*}  = nullptr$>$ }\\rmm\+::device\+\_\+uvector$<$ typename Container\+::value\+\_\+type $>$ \mbox{\hyperlink{namespacecudf_1_1detail_ad3025511800f795e70b22eba7fd0def7}{make\+\_\+device\+\_\+uvector\+\_\+async}} (Container const \&c, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Asynchronously construct a {\ttfamily device\+\_\+uvector} containing a deep copy of data from a host container \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\rmm\+::device\+\_\+uvector$<$ T $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a556dd2e77b79628c78ec6718935f565d}{make\+\_\+device\+\_\+uvector\+\_\+async}} (\mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ T const $>$ source\+\_\+data, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Asynchronously construct a {\ttfamily device\+\_\+uvector} containing a deep copy of data from a {\ttfamily \doxylink{structcudf_1_1device__span}{device\+\_\+span}} \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\rmm\+::device\+\_\+uvector$<$ T $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a567b65a608d7b1818cff9632b3dafde8}{make\+\_\+device\+\_\+uvector\+\_\+sync}} (\mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$<$ T const $>$ source\+\_\+data, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Synchronously construct a {\ttfamily device\+\_\+uvector} containing a deep copy of data from a {\ttfamily \doxylink{structcudf_1_1host__span}{host\+\_\+span}} \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Container , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+convertible\+\_\+v$<$ Container, \mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$<$ typename Container\+::value\+\_\+type const $>$ $>$ $>$ \texorpdfstring{$\ast$}{*}  = nullptr$>$ }\\rmm\+::device\+\_\+uvector$<$ typename Container\+::value\+\_\+type $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a5f1c217de33d11bb490a51d1904361f9}{make\+\_\+device\+\_\+uvector\+\_\+sync}} (Container const \&c, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Synchronously construct a {\ttfamily device\+\_\+uvector} containing a deep copy of data from a host container \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\rmm\+::device\+\_\+uvector$<$ T $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a5a7fae42222fe71f2374141166c508cc}{make\+\_\+device\+\_\+uvector\+\_\+sync}} (\mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ T const $>$ source\+\_\+data, rmm\+::cuda\+\_\+stream\+\_\+view stream, rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}mr=rmm\+::mr\+::get\+\_\+current\+\_\+device\+\_\+resource())
\begin{DoxyCompactList}\small\item\em Synchronously construct a {\ttfamily device\+\_\+uvector} containing a deep copy of data from a {\ttfamily \doxylink{structcudf_1_1device__span}{device\+\_\+span}} \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename Out\+Container $>$ }\\Out\+Container \mbox{\hyperlink{namespacecudf_1_1detail_a0b73da63a9fe3fdc5f94d0095cb43c83}{make\+\_\+vector\+\_\+async}} (\mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ T const $>$ v, rmm\+::cuda\+\_\+stream\+\_\+view stream)
\item 
{\footnotesize template$<$typename T $>$ }\\std\+::vector$<$ T $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a0f86869461e901b87a711c8fb331c17a}{make\+\_\+std\+\_\+vector\+\_\+async}} (\mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ T const $>$ v, rmm\+::cuda\+\_\+stream\+\_\+view stream)
\begin{DoxyCompactList}\small\item\em Asynchronously construct a {\ttfamily std\+::vector} containing a copy of data from a {\ttfamily \doxylink{structcudf_1_1device__span}{device\+\_\+span}} \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Container , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+convertible\+\_\+v$<$ Container, \mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ typename Container\+::value\+\_\+type const $>$ $>$ $>$ \texorpdfstring{$\ast$}{*}  = nullptr$>$ }\\std\+::vector$<$ typename Container\+::value\+\_\+type $>$ \mbox{\hyperlink{namespacecudf_1_1detail_af13119be3a169f0210957725db3d144d}{make\+\_\+std\+\_\+vector\+\_\+async}} (Container const \&c, rmm\+::cuda\+\_\+stream\+\_\+view stream)
\begin{DoxyCompactList}\small\item\em Asynchronously construct a {\ttfamily std\+::vector} containing a copy of data from a device container \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\std\+::vector$<$ T $>$ \mbox{\hyperlink{namespacecudf_1_1detail_aea3ae2fa6ca2edd73742c6e0ffcb8d49}{make\+\_\+std\+\_\+vector\+\_\+sync}} (\mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ T const $>$ v, rmm\+::cuda\+\_\+stream\+\_\+view stream)
\begin{DoxyCompactList}\small\item\em Synchronously construct a {\ttfamily std\+::vector} containing a copy of data from a {\ttfamily \doxylink{structcudf_1_1device__span}{device\+\_\+span}} \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Container , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+convertible\+\_\+v$<$ Container, \mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ typename Container\+::value\+\_\+type const $>$ $>$ $>$ \texorpdfstring{$\ast$}{*}  = nullptr$>$ }\\std\+::vector$<$ typename Container\+::value\+\_\+type $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a76e49334977092cc1447d12b3aad3b76}{make\+\_\+std\+\_\+vector\+\_\+sync}} (Container const \&c, rmm\+::cuda\+\_\+stream\+\_\+view stream)
\begin{DoxyCompactList}\small\item\em Synchronously construct a {\ttfamily std\+::vector} containing a copy of data from a device container \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\thrust\+::host\+\_\+vector$<$ T $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a6a6bc114d57f9b4ebe7b1fd1c0debeb3}{make\+\_\+host\+\_\+vector\+\_\+async}} (\mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ T const $>$ v, rmm\+::cuda\+\_\+stream\+\_\+view stream)
\begin{DoxyCompactList}\small\item\em Asynchronously construct a {\ttfamily thrust\+::host\+\_\+vector} containing a copy of data from a {\ttfamily \doxylink{structcudf_1_1device__span}{device\+\_\+span}} \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Container , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+convertible\+\_\+v$<$ Container, \mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ typename Container\+::value\+\_\+type const $>$ $>$ $>$ \texorpdfstring{$\ast$}{*}  = nullptr$>$ }\\thrust\+::host\+\_\+vector$<$ typename Container\+::value\+\_\+type $>$ \mbox{\hyperlink{namespacecudf_1_1detail_ac8a6ec6815c3166045d3417e832d1601}{make\+\_\+host\+\_\+vector\+\_\+async}} (Container const \&c, rmm\+::cuda\+\_\+stream\+\_\+view stream)
\begin{DoxyCompactList}\small\item\em Asynchronously construct a {\ttfamily std\+::vector} containing a copy of data from a device container \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\thrust\+::host\+\_\+vector$<$ T $>$ \mbox{\hyperlink{namespacecudf_1_1detail_ac324b531a3240ff154b04007561c9f34}{make\+\_\+host\+\_\+vector\+\_\+sync}} (\mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ T const $>$ v, rmm\+::cuda\+\_\+stream\+\_\+view stream)
\begin{DoxyCompactList}\small\item\em Synchronously construct a {\ttfamily std\+::vector} containing a copy of data from a {\ttfamily \doxylink{structcudf_1_1device__span}{device\+\_\+span}} \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Container , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+convertible\+\_\+v$<$ Container, \mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ typename Container\+::value\+\_\+type const $>$ $>$ $>$ \texorpdfstring{$\ast$}{*}  = nullptr$>$ }\\thrust\+::host\+\_\+vector$<$ typename Container\+::value\+\_\+type $>$ \mbox{\hyperlink{namespacecudf_1_1detail_a19a07077e71fffd39a9bae1ef7bfa379}{make\+\_\+host\+\_\+vector\+\_\+sync}} (Container const \&c, rmm\+::cuda\+\_\+stream\+\_\+view stream)
\begin{DoxyCompactList}\small\item\em Synchronously construct a {\ttfamily std\+::vector} containing a copy of data from a device container \end{DoxyCompactList}\item 
{\footnotesize template$<$class... Ts$>$ }\\\mbox{\hyperlink{namespacecudf_1_1detail_a3e5582c4cfcb5c5c104088fb0d03596c}{visitor\+\_\+overload}} (Ts...) -\/$>$ \mbox{\hyperlink{structcudf_1_1detail_1_1visitor__overload}{visitor\+\_\+overload}}$<$ Ts... $>$
\item 
\mbox{\hyperlink{structcudf_1_1detail_1_1dremel__data}{dremel\+\_\+data}} \mbox{\hyperlink{namespacecudf_1_1detail_a6ca203cd4504a08ef2fd489410d6db95}{get\+\_\+dremel\+\_\+data}} (\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} h\+\_\+col, std\+::vector$<$ uint8\+\_\+t $>$ nullability, bool output\+\_\+as\+\_\+byte\+\_\+array, rmm\+::cuda\+\_\+stream\+\_\+view stream)
\begin{DoxyCompactList}\small\item\em Get the dremel offsets and repetition and definition levels for a LIST column \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespacecudf_1_1detail_aee63ff93909aab1cf205625ee996236a}{has\+\_\+nested\+\_\+columns}} (\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&\mbox{\hyperlink{classcudf_1_1table}{table}})
\begin{DoxyCompactList}\small\item\em Determine if any nested columns exist in a given table. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Table\+View $>$ }\\bool \mbox{\hyperlink{namespacecudf_1_1detail_a3723537389c05b4a90958589c304f2fb}{is\+\_\+relationally\+\_\+comparable}} (Table\+View const \&lhs, Table\+View const \&rhs)
\begin{DoxyCompactList}\small\item\em Indicates whether respective columns in input tables are relationally comparable. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\constexpr \mbox{\hyperlink{types_8hpp_adc4a74f3fb4b327ed43b31d0fca65ba3}{CUDF\+\_\+\+HOST\+\_\+\+DEVICE}} std\+::size\+\_\+t \mbox{\hyperlink{namespacecudf_1_1detail_a84962657d1071313a0e63f3c05a4c26a}{size\+\_\+in\+\_\+bits}} ()
\begin{DoxyCompactList}\small\item\em Returns the number of bits the given type can hold. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{变量}
\begin{DoxyCompactItemize}
\item 
constexpr \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} \mbox{\hyperlink{namespacecudf_1_1detail_a6696755213d5d4098e2057a314205f9c}{ARGMAX\+\_\+\+SENTINEL}} \{-\/1\}
\begin{DoxyCompactList}\small\item\em Sentinel value used for {\ttfamily ARGMAX} aggregation. \end{DoxyCompactList}\item 
constexpr \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} \mbox{\hyperlink{namespacecudf_1_1detail_a0ccf176241d88b7575d0e1f72d00c6c6}{ARGMIN\+\_\+\+SENTINEL}} \{-\/1\}
\begin{DoxyCompactList}\small\item\em Sentinel value used for {\ttfamily ARGMIN} aggregation. \end{DoxyCompactList}\item 
constexpr int \mbox{\hyperlink{namespacecudf_1_1detail_ab5aa2bb950ef46c1f618dfa206142597}{DEFAULT\+\_\+\+JOIN\+\_\+\+CG\+\_\+\+SIZE}} = 2
\item 
rmm\+::cuda\+\_\+stream\+\_\+view const \mbox{\hyperlink{namespacecudf_1_1detail_a1dea3cc353c312e3683f15e4a01cf752}{default\+\_\+stream\+\_\+value}}
\begin{DoxyCompactList}\small\item\em Default stream for cudf \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{详细描述}
Inner interfaces and implementations 

\doxysubsection{类型定义说明}
\Hypertarget{namespacecudf_1_1detail_aa8d997e03a111aad833923bbfa0fc631}\label{namespacecudf_1_1detail_aa8d997e03a111aad833923bbfa0fc631} 
\index{cudf::detail@{cudf::detail}!device\_2dspan@{device\_2dspan}}
\index{device\_2dspan@{device\_2dspan}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{device\_2dspan}{device\_2dspan}}
{\footnotesize\ttfamily template$<$class T $>$ \\
using \mbox{\hyperlink{namespacecudf_1_1detail_aa8d997e03a111aad833923bbfa0fc631}{cudf\+::detail\+::device\+\_\+2dspan}} = typedef \mbox{\hyperlink{classcudf_1_1detail_1_1base__2dspan}{base\+\_\+2dspan}}$<$T, \mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$>$}



Alias for the 2D span for device data. 

Index operator returns rows as {\ttfamily \doxylink{structcudf_1_1device__span}{device\+\_\+span}}. 

在文件 \mbox{\hyperlink{span_8hpp_source}{span.\+hpp}} 第 \mbox{\hyperlink{span_8hpp_source_l00496}{496}} 行定义.

\Hypertarget{namespacecudf_1_1detail_ad766fd47aef5cd45824e7789f42247ed}\label{namespacecudf_1_1detail_ad766fd47aef5cd45824e7789f42247ed} 
\index{cudf::detail@{cudf::detail}!host\_2dspan@{host\_2dspan}}
\index{host\_2dspan@{host\_2dspan}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{host\_2dspan}{host\_2dspan}}
{\footnotesize\ttfamily template$<$class T $>$ \\
using \mbox{\hyperlink{namespacecudf_1_1detail_ad766fd47aef5cd45824e7789f42247ed}{cudf\+::detail\+::host\+\_\+2dspan}} = typedef \mbox{\hyperlink{classcudf_1_1detail_1_1base__2dspan}{base\+\_\+2dspan}}$<$T, \mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$>$}



Alias for the 2D span for host data. 

Index operator returns rows as {\ttfamily \doxylink{structcudf_1_1host__span}{host\+\_\+span}}. 

在文件 \mbox{\hyperlink{span_8hpp_source}{span.\+hpp}} 第 \mbox{\hyperlink{span_8hpp_source_l00488}{488}} 行定义.

\Hypertarget{namespacecudf_1_1detail_a8a62804f4d08dbf686b957e2bdfb06be}\label{namespacecudf_1_1detail_a8a62804f4d08dbf686b957e2bdfb06be} 
\index{cudf::detail@{cudf::detail}!kind\_to\_type@{kind\_to\_type}}
\index{kind\_to\_type@{kind\_to\_type}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{kind\_to\_type}{kind\_to\_type}}
{\footnotesize\ttfamily template$<$\mbox{\hyperlink{classcudf_1_1aggregation_a83579ae3cab2fc3d1c3b377d1cfab24c}{aggregation\+::\+Kind}} k$>$ \\
using \mbox{\hyperlink{namespacecudf_1_1detail_a8a62804f4d08dbf686b957e2bdfb06be}{cudf\+::detail\+::kind\+\_\+to\+\_\+type}} = typedef typename \mbox{\hyperlink{structcudf_1_1detail_1_1kind__to__type__impl}{kind\+\_\+to\+\_\+type\+\_\+impl}}$<$k$>$\+::type}



在文件 \mbox{\hyperlink{detail_2aggregation_2aggregation_8hpp_source}{aggregation.\+hpp}} 第 \mbox{\hyperlink{detail_2aggregation_2aggregation_8hpp_source_l01370}{1370}} 行定义.

\Hypertarget{namespacecudf_1_1detail_a8bef759d42ac528d33f331de080d5584}\label{namespacecudf_1_1detail_a8bef759d42ac528d33f331de080d5584} 
\index{cudf::detail@{cudf::detail}!LinkedColPtr@{LinkedColPtr}}
\index{LinkedColPtr@{LinkedColPtr}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{LinkedColPtr}{LinkedColPtr}}
{\footnotesize\ttfamily using \mbox{\hyperlink{namespacecudf_1_1detail_a8bef759d42ac528d33f331de080d5584}{cudf\+::detail\+::\+Linked\+Col\+Ptr}} = typedef std\+::shared\+\_\+ptr$<$\mbox{\hyperlink{structcudf_1_1detail_1_1linked__column__view}{linked\+\_\+column\+\_\+view}}$>$}



在文件 \mbox{\hyperlink{linked__column_8hpp_source}{linked\+\_\+column.\+hpp}} 第 \mbox{\hyperlink{linked__column_8hpp_source_l00027}{27}} 行定义.

\Hypertarget{namespacecudf_1_1detail_a627e116400c1bed3d5f2b3ab78661fe8}\label{namespacecudf_1_1detail_a627e116400c1bed3d5f2b3ab78661fe8} 
\index{cudf::detail@{cudf::detail}!LinkedColVector@{LinkedColVector}}
\index{LinkedColVector@{LinkedColVector}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{LinkedColVector}{LinkedColVector}}
{\footnotesize\ttfamily using \mbox{\hyperlink{namespacecudf_1_1detail_a627e116400c1bed3d5f2b3ab78661fe8}{cudf\+::detail\+::\+Linked\+Col\+Vector}} = typedef std\+::vector$<$\mbox{\hyperlink{namespacecudf_1_1detail_a8bef759d42ac528d33f331de080d5584}{Linked\+Col\+Ptr}}$>$}



在文件 \mbox{\hyperlink{linked__column_8hpp_source}{linked\+\_\+column.\+hpp}} 第 \mbox{\hyperlink{linked__column_8hpp_source_l00028}{28}} 行定义.

\Hypertarget{namespacecudf_1_1detail_ad9f4583fad6d64406129dc1978027b6b}\label{namespacecudf_1_1detail_ad9f4583fad6d64406129dc1978027b6b} 
\index{cudf::detail@{cudf::detail}!target\_type\_t@{target\_type\_t}}
\index{target\_type\_t@{target\_type\_t}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{target\_type\_t}{target\_type\_t}}
{\footnotesize\ttfamily template$<$typename Source , \mbox{\hyperlink{classcudf_1_1aggregation_a83579ae3cab2fc3d1c3b377d1cfab24c}{aggregation\+::\+Kind}} k$>$ \\
using \mbox{\hyperlink{namespacecudf_1_1detail_ad9f4583fad6d64406129dc1978027b6b}{cudf\+::detail\+::target\+\_\+type\+\_\+t}} = typedef typename \mbox{\hyperlink{structcudf_1_1detail_1_1target__type__impl}{target\+\_\+type\+\_\+impl}}$<$Source, k$>$\+::type}



Helper alias to get the accumulator type for performing aggregation {\ttfamily k} on elements of type {\ttfamily Source} 


\begin{DoxyTemplParams}{模板参数}
{\em Source} & The type on which the aggregation is computed \\
\hline
{\em k} & The aggregation performed \\
\hline
\end{DoxyTemplParams}


在文件 \mbox{\hyperlink{detail_2aggregation_2aggregation_8hpp_source}{aggregation.\+hpp}} 第 \mbox{\hyperlink{detail_2aggregation_2aggregation_8hpp_source_l01362}{1362}} 行定义.

\Hypertarget{namespacecudf_1_1detail_a2d645cde6078342234d5d6ee2c8cd9f9}\label{namespacecudf_1_1detail_a2d645cde6078342234d5d6ee2c8cd9f9} 
\index{cudf::detail@{cudf::detail}!time\_point@{time\_point}}
\index{time\_point@{time\_point}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{time\_point}{time\_point}}
{\footnotesize\ttfamily template$<$class Duration $>$ \\
using \mbox{\hyperlink{namespacecudf_1_1detail_a2d645cde6078342234d5d6ee2c8cd9f9}{cudf\+::detail\+::time\+\_\+point}} = typedef cuda\+::std\+::chrono\+::sys\+\_\+time$<$Duration$>$}



Time point type 



在文件 \mbox{\hyperlink{timestamps_8hpp_source}{timestamps.\+hpp}} 第 \mbox{\hyperlink{timestamps_8hpp_source_l00030}{30}} 行定义.

\Hypertarget{namespacecudf_1_1detail_a3128cb15ed7da5bb5e926bb24a419262}\label{namespacecudf_1_1detail_a3128cb15ed7da5bb5e926bb24a419262} 
\index{cudf::detail@{cudf::detail}!timestamp@{timestamp}}
\index{timestamp@{timestamp}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{timestamp}{timestamp}}
{\footnotesize\ttfamily template$<$class Duration $>$ \\
using \mbox{\hyperlink{namespacecudf_1_1detail_a3128cb15ed7da5bb5e926bb24a419262}{cudf\+::detail\+::timestamp}} = typedef \mbox{\hyperlink{namespacecudf_1_1detail_a2d645cde6078342234d5d6ee2c8cd9f9}{time\+\_\+point}}$<$Duration$>$}



A wrapper around a column of time\+\_\+point in varying resolutions 


\begin{DoxyTemplParams}{模板参数}
{\em Duration} & The underlying duration type \\
\hline
\end{DoxyTemplParams}


在文件 \mbox{\hyperlink{timestamps_8hpp_source}{timestamps.\+hpp}} 第 \mbox{\hyperlink{timestamps_8hpp_source_l00038}{38}} 行定义.



\doxysubsection{枚举类型说明}
\Hypertarget{namespacecudf_1_1detail_afe99faf2d7a570e5de8dbe1638f91dd0}\label{namespacecudf_1_1detail_afe99faf2d7a570e5de8dbe1638f91dd0} 
\index{cudf::detail@{cudf::detail}!join\_kind@{join\_kind}}
\index{join\_kind@{join\_kind}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{join\_kind}{join\_kind}}
{\footnotesize\ttfamily enum class \mbox{\hyperlink{namespacecudf_1_1detail_afe99faf2d7a570e5de8dbe1638f91dd0}{cudf\+::detail\+::join\+\_\+kind}}\hspace{0.3cm}{\ttfamily [strong]}}

\begin{DoxyEnumFields}{枚举值}
\raisebox{\heightof{T}}[0pt][0pt]{\index{INNER\_JOIN@{INNER\_JOIN}!cudf::detail@{cudf::detail}}\index{cudf::detail@{cudf::detail}!INNER\_JOIN@{INNER\_JOIN}}}\Hypertarget{namespacecudf_1_1detail_afe99faf2d7a570e5de8dbe1638f91dd0adacfb6b4a93e8c0996af0a50896b2ad6}\label{namespacecudf_1_1detail_afe99faf2d7a570e5de8dbe1638f91dd0adacfb6b4a93e8c0996af0a50896b2ad6} 
INNER\+\_\+\+JOIN&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{LEFT\_JOIN@{LEFT\_JOIN}!cudf::detail@{cudf::detail}}\index{cudf::detail@{cudf::detail}!LEFT\_JOIN@{LEFT\_JOIN}}}\Hypertarget{namespacecudf_1_1detail_afe99faf2d7a570e5de8dbe1638f91dd0ab2f77eff2e65e96b41d17cef95c040ca}\label{namespacecudf_1_1detail_afe99faf2d7a570e5de8dbe1638f91dd0ab2f77eff2e65e96b41d17cef95c040ca} 
LEFT\+\_\+\+JOIN&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{FULL\_JOIN@{FULL\_JOIN}!cudf::detail@{cudf::detail}}\index{cudf::detail@{cudf::detail}!FULL\_JOIN@{FULL\_JOIN}}}\Hypertarget{namespacecudf_1_1detail_afe99faf2d7a570e5de8dbe1638f91dd0a9e94c2918e6b37d619ac174c2f251c4a}\label{namespacecudf_1_1detail_afe99faf2d7a570e5de8dbe1638f91dd0a9e94c2918e6b37d619ac174c2f251c4a} 
FULL\+\_\+\+JOIN&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{LEFT\_SEMI\_JOIN@{LEFT\_SEMI\_JOIN}!cudf::detail@{cudf::detail}}\index{cudf::detail@{cudf::detail}!LEFT\_SEMI\_JOIN@{LEFT\_SEMI\_JOIN}}}\Hypertarget{namespacecudf_1_1detail_afe99faf2d7a570e5de8dbe1638f91dd0a149cf6da1ad9e5e65b85a95c49449ae8}\label{namespacecudf_1_1detail_afe99faf2d7a570e5de8dbe1638f91dd0a149cf6da1ad9e5e65b85a95c49449ae8} 
LEFT\+\_\+\+SEMI\+\_\+\+JOIN&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{LEFT\_ANTI\_JOIN@{LEFT\_ANTI\_JOIN}!cudf::detail@{cudf::detail}}\index{cudf::detail@{cudf::detail}!LEFT\_ANTI\_JOIN@{LEFT\_ANTI\_JOIN}}}\Hypertarget{namespacecudf_1_1detail_afe99faf2d7a570e5de8dbe1638f91dd0a148ec33d1c462dcb952eb70eae78fc6e}\label{namespacecudf_1_1detail_afe99faf2d7a570e5de8dbe1638f91dd0a148ec33d1c462dcb952eb70eae78fc6e} 
LEFT\+\_\+\+ANTI\+\_\+\+JOIN&\\
\hline

\end{DoxyEnumFields}


在文件 \mbox{\hyperlink{detail_2join_8hpp_source}{join.\+hpp}} 第 \mbox{\hyperlink{detail_2join_8hpp_source_l00045}{45}} 行定义.

\Hypertarget{namespacecudf_1_1detail_a1c29a0e8458ffb159e91481c0f37b0f5}\label{namespacecudf_1_1detail_a1c29a0e8458ffb159e91481c0f37b0f5} 
\index{cudf::detail@{cudf::detail}!negative\_index\_policy@{negative\_index\_policy}}
\index{negative\_index\_policy@{negative\_index\_policy}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{negative\_index\_policy}{negative\_index\_policy}}
{\footnotesize\ttfamily enum class \mbox{\hyperlink{namespacecudf_1_1detail_a1c29a0e8458ffb159e91481c0f37b0f5}{cudf\+::detail\+::negative\+\_\+index\+\_\+policy}} \+: bool\hspace{0.3cm}{\ttfamily [strong]}}

\begin{DoxyEnumFields}{枚举值}
\raisebox{\heightof{T}}[0pt][0pt]{\index{ALLOWED@{ALLOWED}!cudf::detail@{cudf::detail}}\index{cudf::detail@{cudf::detail}!ALLOWED@{ALLOWED}}}\Hypertarget{namespacecudf_1_1detail_a1c29a0e8458ffb159e91481c0f37b0f5a9725825c796122ef40f01b2d8794f902}\label{namespacecudf_1_1detail_a1c29a0e8458ffb159e91481c0f37b0f5a9725825c796122ef40f01b2d8794f902} 
ALLOWED&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{NOT\_ALLOWED@{NOT\_ALLOWED}!cudf::detail@{cudf::detail}}\index{cudf::detail@{cudf::detail}!NOT\_ALLOWED@{NOT\_ALLOWED}}}\Hypertarget{namespacecudf_1_1detail_a1c29a0e8458ffb159e91481c0f37b0f5a4596302bc1e8ce6e62188e769aac94cf}\label{namespacecudf_1_1detail_a1c29a0e8458ffb159e91481c0f37b0f5a4596302bc1e8ce6e62188e769aac94cf} 
NOT\+\_\+\+ALLOWED&\\
\hline

\end{DoxyEnumFields}


在文件 \mbox{\hyperlink{detail_2gather_8hpp_source}{gather.\+hpp}} 第 \mbox{\hyperlink{detail_2gather_8hpp_source_l00033}{33}} 行定义.



\doxysubsection{函数说明}
\Hypertarget{namespacecudf_1_1detail_a325dce4aa776c0bf7cf218e2a27714b5}\label{namespacecudf_1_1detail_a325dce4aa776c0bf7cf218e2a27714b5} 
\index{cudf::detail@{cudf::detail}!AGG\_KIND\_MAPPING@{AGG\_KIND\_MAPPING}}
\index{AGG\_KIND\_MAPPING@{AGG\_KIND\_MAPPING}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{AGG\_KIND\_MAPPING()}{AGG\_KIND\_MAPPING()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily cudf\+::detail\+::\+AGG\+\_\+\+KIND\+\_\+\+MAPPING (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1aggregation_a83579ae3cab2fc3d1c3b377d1cfab24ca6e5361905125d531234e50d50bcf5326}{aggregation\+::\+QUANTILE}}}]{,  }\item[{\mbox{\hyperlink{classcudf_1_1detail_1_1quantile__aggregation}{quantile\+\_\+aggregation}}}]{ }\end{DoxyParamCaption})}

\Hypertarget{namespacecudf_1_1detail_af21777beb509d8944a3e936c0840e473}\label{namespacecudf_1_1detail_af21777beb509d8944a3e936c0840e473} 
\index{cudf::detail@{cudf::detail}!AGG\_KIND\_MAPPING@{AGG\_KIND\_MAPPING}}
\index{AGG\_KIND\_MAPPING@{AGG\_KIND\_MAPPING}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{AGG\_KIND\_MAPPING()}{AGG\_KIND\_MAPPING()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily cudf\+::detail\+::\+AGG\+\_\+\+KIND\+\_\+\+MAPPING (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1aggregation_a83579ae3cab2fc3d1c3b377d1cfab24ca6b1ba846de925ba39b9ee9e352adf84a}{aggregation\+::\+STD}}}]{,  }\item[{\mbox{\hyperlink{classcudf_1_1detail_1_1std__aggregation}{std\+\_\+aggregation}}}]{ }\end{DoxyParamCaption})}

\Hypertarget{namespacecudf_1_1detail_aad8f5a52bb309f1cdc4906eed538b45d}\label{namespacecudf_1_1detail_aad8f5a52bb309f1cdc4906eed538b45d} 
\index{cudf::detail@{cudf::detail}!AGG\_KIND\_MAPPING@{AGG\_KIND\_MAPPING}}
\index{AGG\_KIND\_MAPPING@{AGG\_KIND\_MAPPING}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{AGG\_KIND\_MAPPING()}{AGG\_KIND\_MAPPING()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily cudf\+::detail\+::\+AGG\+\_\+\+KIND\+\_\+\+MAPPING (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1aggregation_a83579ae3cab2fc3d1c3b377d1cfab24ca668fb6976b34ba937eb74f77700e749d}{aggregation\+::\+VARIANCE}}}]{,  }\item[{\mbox{\hyperlink{classcudf_1_1detail_1_1var__aggregation}{var\+\_\+aggregation}}}]{ }\end{DoxyParamCaption})}

\Hypertarget{namespacecudf_1_1detail_a20f1cdfbe0b878b8b5143108ed352a2d}\label{namespacecudf_1_1detail_a20f1cdfbe0b878b8b5143108ed352a2d} 
\index{cudf::detail@{cudf::detail}!aggregation\_dispatcher@{aggregation\_dispatcher}}
\index{aggregation\_dispatcher@{aggregation\_dispatcher}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{aggregation\_dispatcher()}{aggregation\_dispatcher()}}
{\footnotesize\ttfamily template$<$typename F , typename... Ts$>$ \\
\mbox{\hyperlink{types_8hpp_adc4a74f3fb4b327ed43b31d0fca65ba3}{CUDF\+\_\+\+HOST\+\_\+\+DEVICE}} decltype(auto) cudf\+::detail\+::aggregation\+\_\+dispatcher (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1aggregation_a83579ae3cab2fc3d1c3b377d1cfab24c}{aggregation\+::\+Kind}}}]{k,  }\item[{F \&\&}]{f,  }\item[{Ts \&\&...}]{args }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Dispatches {\ttfamily k} as a non-\/type template parameter to a callable, {\ttfamily f}. 


\begin{DoxyTemplParams}{模板参数}
{\em F} & Type of callable \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{参数}
{\em k} & The {\ttfamily \doxylink{classcudf_1_1aggregation_a83579ae3cab2fc3d1c3b377d1cfab24c}{aggregation\+::\+Kind}} value to dispatch aram f The callable that accepts an {\ttfamily \doxylink{classcudf_1_1aggregation_a83579ae3cab2fc3d1c3b377d1cfab24c}{aggregation\+::\+Kind}} non-\/type template argument. \\
\hline
{\em args} & Parameter pack forwarded to the {\ttfamily operator()} invocation \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Forwards the return value of the callable. 
\end{DoxyReturn}


在文件 \mbox{\hyperlink{detail_2aggregation_2aggregation_8hpp_source}{aggregation.\+hpp}} 第 \mbox{\hyperlink{detail_2aggregation_2aggregation_8hpp_source_l01396}{1396}} 行定义.

\Hypertarget{namespacecudf_1_1detail_a1454447a634ec7b0e34b066fd6f950a2}\label{namespacecudf_1_1detail_a1454447a634ec7b0e34b066fd6f950a2} 
\index{cudf::detail@{cudf::detail}!align\_ptr\_for\_type@{align\_ptr\_for\_type}}
\index{align\_ptr\_for\_type@{align\_ptr\_for\_type}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{align\_ptr\_for\_type()}{align\_ptr\_for\_type()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
T \texorpdfstring{$\ast$}{*} cudf\+::detail\+::align\+\_\+ptr\+\_\+for\+\_\+type (\begin{DoxyParamCaption}\item[{void \texorpdfstring{$\ast$}{*}}]{destination }\end{DoxyParamCaption})}



Returns the aligned address for holding array of type T in pre-\/allocated memory. 


\begin{DoxyTemplParams}{模板参数}
{\em T} & The data type to align upon.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{参数}
{\em destination} & pointer to pre-\/allocated contiguous storage to store type T. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Pointer of type T, aligned to alignment of type T. 
\end{DoxyReturn}


在文件 \mbox{\hyperlink{alignment_8hpp_source}{alignment.\+hpp}} 第 \mbox{\hyperlink{alignment_8hpp_source_l00033}{33}} 行定义.

\Hypertarget{namespacecudf_1_1detail_a1d90a4e2a03fd0f7bcaeee67267d1557}\label{namespacecudf_1_1detail_a1d90a4e2a03fd0f7bcaeee67267d1557} 
\index{cudf::detail@{cudf::detail}!allocate\_like@{allocate\_like}}
\index{allocate\_like@{allocate\_like}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{allocate\_like()}{allocate\_like()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::allocate\+\_\+like (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{input,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{size,  }\item[{\mbox{\hyperlink{group__column__copy_ga267e03474dcfd85242d2fdc6e5846ec6}{mask\+\_\+allocation\+\_\+policy}}}]{mask\+\_\+alloc = {\ttfamily \mbox{\hyperlink{group__column__copy_gga267e03474dcfd85242d2fdc6e5846ec6a47e9136fa770199f6a8a9727b6173eb4}{mask\+\_\+allocation\+\_\+policy\+::\+RETAIN}}},  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Creates an uninitialized new column of the specified size and same type as the {\ttfamily input}.   

Supports only fixed-\/width types.


\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em input} & Immutable view of input column to emulate \\
\hline
\mbox{\texttt{ in}}  & {\em size} & The desired number of elements that the new column should have capacity for \\
\hline
\mbox{\texttt{ in}}  & {\em mask\+\_\+alloc} & Optional, Policy for allocating null mask. Defaults to RETAIN \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A column with sufficient uninitialized capacity to hold the specified number of elements as {\ttfamily input} of the same type as {\ttfamily input.\+type()}  
\end{DoxyReturn}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a37b172e383c23e8f5266dae0ffc4d53d}\label{namespacecudf_1_1detail_a37b172e383c23e8f5266dae0ffc4d53d} 
\index{cudf::detail@{cudf::detail}!apply\_boolean\_mask@{apply\_boolean\_mask}}
\index{apply\_boolean\_mask@{apply\_boolean\_mask}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{apply\_boolean\_mask()}{apply\_boolean\_mask()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::detail\+::apply\+\_\+boolean\+\_\+mask (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{input,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{boolean\+\_\+mask,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Filters {\ttfamily input} using {\ttfamily boolean\+\_\+mask} of boolean values as a mask.   

Given an input {\ttfamily \doxylink{classcudf_1_1table__view}{table\+\_\+view}} and a mask {\ttfamily \doxylink{classcudf_1_1column__view}{column\+\_\+view}}, an element {\ttfamily i} from each \doxylink{classcudf_1_1column__view}{column\+\_\+view} of the {\ttfamily input} is copied to the corresponding output column if the corresponding element {\ttfamily i} in the mask is non-\/null and {\ttfamily true}. This operation is stable\+: the input order is preserved.

\begin{DoxyNote}{注解}
if {\ttfamily input.\+num\+\_\+rows()} is zero, there is no error, and an empty table is returned.
\end{DoxyNote}

\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily input.\+num\+\_\+rows() != boolean\+\_\+mask.\+size()}. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily boolean\+\_\+mask} is not {\ttfamily \doxylink{group__utility__types_ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd}{type\+\_\+id\+::\+BOOL8}} type.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em input} & The input \doxylink{classcudf_1_1table__view}{table\+\_\+view} to filter \\
\hline
\mbox{\texttt{ in}}  & {\em boolean\+\_\+mask} & A nullable \doxylink{classcudf_1_1column__view}{column\+\_\+view} of type \doxylink{group__utility__types_ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd}{type\+\_\+id\+::\+BOOL8} used as a mask to filter the {\ttfamily input}. \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Device memory resource used to allocate the returned table\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Table containing copy of all rows of {\ttfamily input} passing the filter defined by {\ttfamily boolean\+\_\+mask}.  
\end{DoxyReturn}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a1b91b19cf5f6210875f2c8066c263092}\label{namespacecudf_1_1detail_a1b91b19cf5f6210875f2c8066c263092} 
\index{cudf::detail@{cudf::detail}!arrow\_to\_cudf\_type@{arrow\_to\_cudf\_type}}
\index{arrow\_to\_cudf\_type@{arrow\_to\_cudf\_type}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{arrow\_to\_cudf\_type()}{arrow\_to\_cudf\_type()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} cudf\+::detail\+::arrow\+\_\+to\+\_\+cudf\+\_\+type (\begin{DoxyParamCaption}\item[{arrow\+::\+Data\+Type const \&}]{arrow\+\_\+type }\end{DoxyParamCaption})}

\Hypertarget{namespacecudf_1_1detail_a6d4ce4e5ee2ebf383eaccdd2d8ab8233}\label{namespacecudf_1_1detail_a6d4ce4e5ee2ebf383eaccdd2d8ab8233} 
\index{cudf::detail@{cudf::detail}!binary\_operation@{binary\_operation}}
\index{binary\_operation@{binary\_operation}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{binary\_operation()}{binary\_operation()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::binary\+\_\+operation (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{lhs,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{rhs,  }\item[{\mbox{\hyperlink{group__transformation__binaryops_ga00ed76601b6db662550f6826cfd99edc}{binary\+\_\+operator}}}]{op,  }\item[{\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}}}]{output\+\_\+type,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Performs a binary operation between two columns.   

The output contains the result of {\ttfamily op(lhs\mbox{[}i\mbox{]}, rhs\mbox{[}i\mbox{]})} for all {\ttfamily 0 \texorpdfstring{$<$}{<}= i \texorpdfstring{$<$}{<} lhs.\+size()}

Regardless of the operator, the validity of the output value is the logical AND of the validity of the two operands except Null\+Min and Null\+Max (logical OR).


\begin{DoxyParams}{参数}
{\em lhs} & The left operand column \\
\hline
{\em rhs} & The right operand column \\
\hline
{\em op} & The binary operator \\
\hline
{\em output\+\_\+type} & The desired data type of the output column \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Output column of {\ttfamily output\+\_\+type} type containing the result of the binary operation 
\end{DoxyReturn}

\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily lhs} and {\ttfamily rhs} are different sizes \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily output\+\_\+type} dtype isn\textquotesingle{}t boolean for comparison and logical operations. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily output\+\_\+type} dtype isn\textquotesingle{}t fixed-\/width  \\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a71131703adb680670a6b8592b92f56f6}\label{namespacecudf_1_1detail_a71131703adb680670a6b8592b92f56f6} 
\index{cudf::detail@{cudf::detail}!binary\_operation@{binary\_operation}}
\index{binary\_operation@{binary\_operation}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{binary\_operation()}{binary\_operation()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::binary\+\_\+operation (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{lhs,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{rhs,  }\item[{std\+::string const \&}]{ptx,  }\item[{\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}}}]{output\+\_\+type,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Performs a binary operation between two columns using a user-\/defined PTX function.   

The output contains the result of {\ttfamily op(lhs\mbox{[}i\mbox{]}, rhs\mbox{[}i\mbox{]})} for all {\ttfamily 0 \texorpdfstring{$<$}{<}= i \texorpdfstring{$<$}{<} lhs.\+size()}

Regardless of the operator, the validity of the output value is the logical AND of the validity of the two operands


\begin{DoxyParams}{参数}
{\em lhs} & The left operand column \\
\hline
{\em rhs} & The right operand column \\
\hline
{\em ptx} & String containing the PTX of a binary function \\
\hline
{\em output\+\_\+type} & The desired data type of the output column. It is assumed that output\+\_\+type is compatible with the output data type of the function in the PTX code \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Output column of {\ttfamily output\+\_\+type} type containing the result of the binary operation 
\end{DoxyReturn}

\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily lhs} and {\ttfamily rhs} are different sizes \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily lhs} and {\ttfamily rhs} dtypes aren\textquotesingle{}t numeric \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily output\+\_\+type} dtype isn\textquotesingle{}t numeric  \\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_ab6c8f19f207ee3db5e2284594edc600c}\label{namespacecudf_1_1detail_ab6c8f19f207ee3db5e2284594edc600c} 
\index{cudf::detail@{cudf::detail}!binary\_operation@{binary\_operation}}
\index{binary\_operation@{binary\_operation}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{binary\_operation()}{binary\_operation()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::binary\+\_\+operation (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{lhs,  }\item[{\mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&}]{rhs,  }\item[{\mbox{\hyperlink{group__transformation__binaryops_ga00ed76601b6db662550f6826cfd99edc}{binary\+\_\+operator}}}]{op,  }\item[{\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}}}]{output\+\_\+type,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Performs a binary operation between a column and a scalar.   

The output contains the result of {\ttfamily op(lhs\mbox{[}i\mbox{]}, rhs)} for all {\ttfamily 0 \texorpdfstring{$<$}{<}= i \texorpdfstring{$<$}{<} lhs.\+size()} The column elements are the left operand and the scalar is the right operand. This distinction is significant in case of non-\/commutative binary operations

Regardless of the operator, the validity of the output value is the logical AND of the validity of the two operands except Null\+Min and Null\+Max (logical OR).


\begin{DoxyParams}{参数}
{\em lhs} & The left operand column \\
\hline
{\em rhs} & The right operand scalar \\
\hline
{\em op} & The binary operator \\
\hline
{\em output\+\_\+type} & The desired data type of the output column \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Output column of {\ttfamily output\+\_\+type} type containing the result of the binary operation 
\end{DoxyReturn}

\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily output\+\_\+type} dtype isn\textquotesingle{}t fixed-\/width \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily output\+\_\+type} dtype isn\textquotesingle{}t boolean for comparison and logical operations.  \\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a4d435282505118b2a58c875780c13890}\label{namespacecudf_1_1detail_a4d435282505118b2a58c875780c13890} 
\index{cudf::detail@{cudf::detail}!binary\_operation@{binary\_operation}}
\index{binary\_operation@{binary\_operation}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{binary\_operation()}{binary\_operation()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::binary\+\_\+operation (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&}]{lhs,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{rhs,  }\item[{\mbox{\hyperlink{group__transformation__binaryops_ga00ed76601b6db662550f6826cfd99edc}{binary\+\_\+operator}}}]{op,  }\item[{\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}}}]{output\+\_\+type,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Performs a binary operation between a scalar and a column.   

The output contains the result of {\ttfamily op(lhs, rhs\mbox{[}i\mbox{]})} for all {\ttfamily 0 \texorpdfstring{$<$}{<}= i \texorpdfstring{$<$}{<} rhs.\+size()} The scalar is the left operand and the column elements are the right operand. This distinction is significant in case of non-\/commutative binary operations

Regardless of the operator, the validity of the output value is the logical AND of the validity of the two operands except Null\+Min and Null\+Max (logical OR).


\begin{DoxyParams}{参数}
{\em lhs} & The left operand scalar \\
\hline
{\em rhs} & The right operand column \\
\hline
{\em op} & The binary operator \\
\hline
{\em output\+\_\+type} & The desired data type of the output column \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Output column of {\ttfamily output\+\_\+type} type containing the result of the binary operation 
\end{DoxyReturn}

\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily output\+\_\+type} dtype isn\textquotesingle{}t fixed-\/width \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily output\+\_\+type} dtype isn\textquotesingle{}t boolean for comparison and logical operations.  \\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_adc5e9bcff0d652d054817afa71d20399}\label{namespacecudf_1_1detail_adc5e9bcff0d652d054817afa71d20399} 
\index{cudf::detail@{cudf::detail}!bitmask\_and@{bitmask\_and}}
\index{bitmask\_and@{bitmask\_and}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{bitmask\_and()}{bitmask\_and()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily std\+::pair$<$ rmm\+::device\+\_\+buffer, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ cudf\+::detail\+::bitmask\+\_\+and (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga1d17001baf070a639c3a5e8ed8c46d34}{bitmask\+\_\+type}} const \texorpdfstring{$\ast$}{*}const $>$}]{masks,  }\item[{\mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$}]{masks\+\_\+begin\+\_\+bits,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{mask\+\_\+size\+\_\+bits,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}






\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_abf99352f85f59ae17972b8462cfb4760}\label{namespacecudf_1_1detail_abf99352f85f59ae17972b8462cfb4760} 
\index{cudf::detail@{cudf::detail}!bitmask\_and@{bitmask\_and}}
\index{bitmask\_and@{bitmask\_and}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{bitmask\_and()}{bitmask\_and()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::pair$<$ rmm\+::device\+\_\+buffer, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ cudf\+::detail\+::bitmask\+\_\+and (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{view,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Performs bitwise AND of the bitmasks of columns of a table. Returns a pair of resulting mask and count of unset bits.   

If any of the columns isn\textquotesingle{}t nullable, it is considered all valid. If no column in the table is nullable, an empty bitmask is returned.


\begin{DoxyParams}{参数}
{\em view} & The table of columns \\
\hline
{\em mr} & Device memory resource used to allocate the returned device\+\_\+buffer \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A pair of resulting bitmask and count of unset bits  
\end{DoxyReturn}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a280d3e05cbbc973356f38c0ee1fca2e3}\label{namespacecudf_1_1detail_a280d3e05cbbc973356f38c0ee1fca2e3} 
\index{cudf::detail@{cudf::detail}!bitmask\_or@{bitmask\_or}}
\index{bitmask\_or@{bitmask\_or}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{bitmask\_or()}{bitmask\_or()}}
{\footnotesize\ttfamily std\+::pair$<$ rmm\+::device\+\_\+buffer, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ cudf\+::detail\+::bitmask\+\_\+or (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{view,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Performs bitwise OR of the bitmasks of columns of a table. Returns a pair of resulting mask and count of unset bits.   

If any of the columns isn\textquotesingle{}t nullable, it is considered all valid. If no column in the table is nullable, an empty bitmask is returned.


\begin{DoxyParams}{参数}
{\em view} & The table of columns \\
\hline
{\em mr} & Device memory resource used to allocate the returned device\+\_\+buffer \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A pair of resulting bitmask and count of unset bits  
\end{DoxyReturn}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_aca6f0ca2c888fcffaf3c516ba0b05498}\label{namespacecudf_1_1detail_aca6f0ca2c888fcffaf3c516ba0b05498} 
\index{cudf::detail@{cudf::detail}!boolean\_mask\_scatter@{boolean\_mask\_scatter}}
\index{boolean\_mask\_scatter@{boolean\_mask\_scatter}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{boolean\_mask\_scatter()}{boolean\_mask\_scatter()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::detail\+::boolean\+\_\+mask\+\_\+scatter (\begin{DoxyParamCaption}\item[{std\+::vector$<$ std\+::reference\+\_\+wrapper$<$ const \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} $>$ $>$ const \&}]{source,  }\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{target,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{boolean\+\_\+mask,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}






\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_ab632fac16d86dcdec8172f105e9cc3bb}\label{namespacecudf_1_1detail_ab632fac16d86dcdec8172f105e9cc3bb} 
\index{cudf::detail@{cudf::detail}!boolean\_mask\_scatter@{boolean\_mask\_scatter}}
\index{boolean\_mask\_scatter@{boolean\_mask\_scatter}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{boolean\_mask\_scatter()}{boolean\_mask\_scatter()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::detail\+::boolean\+\_\+mask\+\_\+scatter (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{source,  }\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{target,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{boolean\+\_\+mask,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Scatters rows from the input table to rows of the output corresponding to true values in a boolean mask.   

The {\ttfamily i}th row of {\ttfamily input} will be written to the output table at the location of the {\ttfamily i}th true value in {\ttfamily boolean\+\_\+mask}. All other rows in the output will equal the same row in {\ttfamily target}.

{\ttfamily boolean\+\_\+mask} should have number of {\ttfamily true}s \texorpdfstring{$<$}{<}= number of rows in {\ttfamily input}. If boolean mask is {\ttfamily true}, corresponding value in target is updated with value from corresponding {\ttfamily input} column, else it is left untouched.


\begin{DoxyCode}{0}
\DoxyCodeLine{Example:}
\DoxyCodeLine{input:\ \{\{1,\ 5,\ 6,\ 8,\ 9\}\}}
\DoxyCodeLine{boolean\_mask:\ \{true,\ false,\ false,\ false,\ true,\ true,\ false,\ true,\ true,\ false\}}
\DoxyCodeLine{target:\ \ \ \ \ \ \ \{\{\ \ \ 2,\ \ \ \ \ 2,\ \ \ \ \ 3,\ \ \ \ \ 4,\ \ \ \ 4,\ \ \ \ \ 7,\ \ \ \ 7,\ \ \ \ 7,\ \ \ \ 8,\ \ \ \ 10\}\}}
\DoxyCodeLine{}
\DoxyCodeLine{output:\ \ \ \ \ \ \ \{\{\ \ \ 1,\ \ \ \ \ 2,\ \ \ \ \ 3,\ \ \ \ \ 4,\ \ \ \ 5,\ \ \ \ \ 6,\ \ \ \ 7,\ \ \ \ 8,\ \ \ \ 9,\ \ \ \ 10\}\}}

\end{DoxyCode}



\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if input.\+num\+\_\+columns() != target.\+num\+\_\+columns() \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if any {\ttfamily i}th input\+\_\+column type != {\ttfamily i}th target\+\_\+column type \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if boolean\+\_\+mask.\+type() != bool \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if boolean\+\_\+mask.\+size() != target.\+num\+\_\+rows() \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if number of {\ttfamily true} in {\ttfamily boolean\+\_\+mask} \texorpdfstring{$>$}{>} input.\+num\+\_\+rows()\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em input} & \doxylink{classcudf_1_1table__view}{table\+\_\+view} (set of dense columns) to scatter \\
\hline
\mbox{\texttt{ in}}  & {\em target} & \doxylink{classcudf_1_1table__view}{table\+\_\+view} to modify with scattered values from {\ttfamily input} \\
\hline
\mbox{\texttt{ in}}  & {\em boolean\+\_\+mask} & \doxylink{classcudf_1_1column__view}{column\+\_\+view} which acts as boolean mask \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Device memory resource used to allocate device memory of the returned table\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Returns a table by scattering {\ttfamily input} into {\ttfamily target} as per {\ttfamily boolean\+\_\+mask}  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_ad38866396e5c2b317d7075374fe64777}\label{namespacecudf_1_1detail_ad38866396e5c2b317d7075374fe64777} 
\index{cudf::detail@{cudf::detail}!bools\_to\_mask@{bools\_to\_mask}}
\index{bools\_to\_mask@{bools\_to\_mask}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{bools\_to\_mask()}{bools\_to\_mask()}}
{\footnotesize\ttfamily std\+::pair$<$ std\+::unique\+\_\+ptr$<$ rmm\+::device\+\_\+buffer $>$, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{cudf\+::size\+\_\+type}} $>$ cudf\+::detail\+::bools\+\_\+to\+\_\+mask (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{input,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Creates a bitmask from a column of boolean elements.   

If element {\ttfamily i} in {\ttfamily input} is {\ttfamily true}, bit {\ttfamily i} in the resulting mask is set ({\ttfamily 1}). Else, if element {\ttfamily i} is {\ttfamily false} or null, bit {\ttfamily i} is unset ({\ttfamily 0}).


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily input.\+type()} is a non-\/boolean type\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em input} & Boolean elements to convert to a bitmask \\
\hline
{\em mr} & Device memory resource used to allocate the returned bitmask \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A pair containing a {\ttfamily device\+\_\+buffer} with the new bitmask and it\textquotesingle{}s null count obtained from input considering {\ttfamily true} represent {\ttfamily valid}/{\ttfamily 1} and {\ttfamily false} represent {\ttfamily invalid}/{\ttfamily 0}.  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a8ab76605084c4a005ccd720c76fb828f}\label{namespacecudf_1_1detail_a8ab76605084c4a005ccd720c76fb828f} 
\index{cudf::detail@{cudf::detail}!calendrical\_month\_sequence@{calendrical\_month\_sequence}}
\index{calendrical\_month\_sequence@{calendrical\_month\_sequence}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{calendrical\_month\_sequence()}{calendrical\_month\_sequence()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{cudf\+::column}} $>$ cudf\+::detail\+::calendrical\+\_\+month\+\_\+sequence (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{size,  }\item[{\mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&}]{init,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{months,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Generate a sequence of timestamps beginning at {\ttfamily init} and incrementing by {\ttfamily months} for each successive element, i.\+e., {\ttfamily output\mbox{[}i\mbox{]} = init + i \texorpdfstring{$\ast$}{*} months} for {\ttfamily i} in {\ttfamily \mbox{[}0, size)}.   

If a given date is invalid, the date is scaled back to the last available day of that month.

Example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{size\ =\ 3}
\DoxyCodeLine{init\ =\ 2020-\/01-\/31\ 08:00:00}
\DoxyCodeLine{months\ =\ 1}
\DoxyCodeLine{\textcolor{keywordflow}{return}\ =\ [2020-\/01-\/31\ 08:00:00,\ 2020-\/02-\/29\ 08:00:00,\ 2020-\/03-\/31\ 08:00:00]}

\end{DoxyCode}



\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if input datatype is not a TIMESTAMP\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em size} & Number of timestamps to generate \\
\hline
{\em init} & The initial timestamp \\
\hline
{\em months} & Months to increment \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Timestamps column with sequences of months  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_ac2d9341a3c49eb3b9d237d9da1c1e5ac}\label{namespacecudf_1_1detail_ac2d9341a3c49eb3b9d237d9da1c1e5ac} 
\index{cudf::detail@{cudf::detail}!cast@{cast}}
\index{cast@{cast}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{cast()}{cast()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::cast (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{input,  }\item[{\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}}}]{type,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Casts data from dtype specified in input to dtype specified in output.   

Supports only fixed-\/width types.


\begin{DoxyParams}{参数}
{\em input} & Input column \\
\hline
{\em out\+\_\+type} & Desired datatype of output column \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Column of same size as {\ttfamily input} containing result of the cast operation 
\end{DoxyReturn}

\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily out\+\_\+type} is not a fixed-\/width type  \\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a0c8323757962d4b3d4b41b9d06289914}\label{namespacecudf_1_1detail_a0c8323757962d4b3d4b41b9d06289914} 
\index{cudf::detail@{cudf::detail}!compute\_column@{compute\_column}}
\index{compute\_column@{compute\_column}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{compute\_column()}{compute\_column()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::compute\+\_\+column (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const}]{table,  }\item[{\mbox{\hyperlink{classcudf_1_1ast_1_1operation}{ast\+::operation}} const \&}]{expr,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Compute a new column by evaluating an expression tree on a table.   

This evaluates an expression over a table to produce a new column. Also called an n-\/ary transform.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if passed an expression operating on table\+\_\+reference\+::\+RIGHT.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em table} & The table used for expression evaluation \\
\hline
{\em expr} & The root of the expression tree \\
\hline
{\em mr} & Device memory resource \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
std\+::unique\+\_\+ptr$<$column$>$ Output column  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a4ff65803386d36f8a139f59f14506eef}\label{namespacecudf_1_1detail_a4ff65803386d36f8a139f59f14506eef} 
\index{cudf::detail@{cudf::detail}!concatenate@{concatenate}}
\index{concatenate@{concatenate}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{concatenate()}{concatenate()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::concatenate (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$<$ \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const $>$}]{columns\+\_\+to\+\_\+concat,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Concatenates multiple columns into a single column.   


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & If types of the input columns mismatch\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em columns\+\_\+to\+\_\+concat} & \doxylink{structcudf_1_1host__span}{host\+\_\+span} of column views to be concatenated into a single column \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A single column having all the rows from the elements of {\ttfamily columns\+\_\+to\+\_\+concat} respectively in the same order.  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a03a9a4dad8d8d93a07908bc682e3b76d}\label{namespacecudf_1_1detail_a03a9a4dad8d8d93a07908bc682e3b76d} 
\index{cudf::detail@{cudf::detail}!concatenate@{concatenate}}
\index{concatenate@{concatenate}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{concatenate()}{concatenate()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::detail\+::concatenate (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$<$ \mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const $>$}]{tables\+\_\+to\+\_\+concat,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Columns of {\ttfamily tables\+\_\+to\+\_\+concat} are concatenated vertically to return a single table   

example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{classcudf_1_1column__view}{column\_view}}\ c0;\ \textcolor{comment}{//Contains\ \{0,1,2,3\}}}
\DoxyCodeLine{\mbox{\hyperlink{classcudf_1_1column__view}{column\_view}}\ c1;\ \textcolor{comment}{//Contains\ \{4,5,6,7\}}}
\DoxyCodeLine{\mbox{\hyperlink{classcudf_1_1table__view}{table\_view}}\ t0\{\{c0,\ c0\}\};}
\DoxyCodeLine{table\_view\ t1\{\{c1,\ c1\}\};}
\DoxyCodeLine{...}
\DoxyCodeLine{auto\ t\ =\ \mbox{\hyperlink{namespacecudf_1_1detail_a4ff65803386d36f8a139f59f14506eef}{concatenate}}(\{t0.view(),\ t1.view()\});}
\DoxyCodeLine{column\_view\ tc0\ =\ (t-\/>view()).column(0);\ \textcolor{comment}{//Contains\ \{0,1,2,3,4,5,6,7\}}}
\DoxyCodeLine{column\_view\ tc1\ =\ (t-\/>view()).column(1);\ \textcolor{comment}{//Contains\ \{0,1,2,3,4,5,6,7\}}}

\end{DoxyCode}



\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & If number of columns mismatch\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em tables\+\_\+to\+\_\+concat} & \doxylink{structcudf_1_1host__span}{host\+\_\+span} of table views to be concatenated into a single table \\
\hline
{\em mr} & Device memory resource used to allocate the returned table\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A single table having all the rows from the elements of {\ttfamily tables\+\_\+to\+\_\+concat} respectively in the same order.  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a6c1de6dab4d4d341e17ff17cdff7a133}\label{namespacecudf_1_1detail_a6c1de6dab4d4d341e17ff17cdff7a133} 
\index{cudf::detail@{cudf::detail}!contains@{contains}}
\index{contains@{contains}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{contains()}{contains()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::contains (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{haystack,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{needles,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr }\end{DoxyParamCaption})}



Check if the given {\ttfamily needles} values exists in the {\ttfamily haystack} column.   

The new column will have type BOOL and have the same size and null mask as the input {\ttfamily needles} column. That is, any null row in the {\ttfamily needles} column will result in a nul row in the output column.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & If {\ttfamily haystack.\+type() != needles.\+type()}\\
\hline
\end{DoxyExceptions}

\begin{DoxyCode}{0}
\DoxyCodeLine{haystack\ =\ \{\ 10,\ 20,\ 30,\ 40,\ 50\ \}}
\DoxyCodeLine{needles\ \ =\ \{\ 20,\ 40,\ 60,\ 80\ \}}
\DoxyCodeLine{result\ \ \ =\ \{\ true,\ true,\ false,\ false\ \}}

\end{DoxyCode}



\begin{DoxyParams}{参数}
{\em haystack} & The column containing search space \\
\hline
{\em needles} & A column of values to check for existence in the search space \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A BOOL column indicating if each element in {\ttfamily needles} exists in the search space  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_aabbae19d91d3507be87defb820d2e603}\label{namespacecudf_1_1detail_aabbae19d91d3507be87defb820d2e603} 
\index{cudf::detail@{cudf::detail}!contains@{contains}}
\index{contains@{contains}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{contains()}{contains()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily bool cudf\+::detail\+::contains (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{haystack,  }\item[{\mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&}]{needle,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream }\end{DoxyParamCaption})}






\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_aa272dc48c5c03c83e46dc103a86bdeb4}\label{namespacecudf_1_1detail_aa272dc48c5c03c83e46dc103a86bdeb4} 
\index{cudf::detail@{cudf::detail}!contains@{contains}}
\index{contains@{contains}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{contains()}{contains()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily rmm\+::device\+\_\+uvector$<$ bool $>$ cudf\+::detail\+::contains (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{haystack,  }\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{needles,  }\item[{\mbox{\hyperlink{group__utility__types_ga08a672308cd0f61562410d106b377771}{null\+\_\+equality}}}]{compare\+\_\+nulls,  }\item[{\mbox{\hyperlink{group__utility__types_gae9d1055c69c3089452794783c7c82f83}{nan\+\_\+equality}}}]{compare\+\_\+nans,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Check if rows in the given {\ttfamily needles} table exist in the {\ttfamily haystack} table. 

Given two tables, each row in the {\ttfamily needles} table is checked to see if there is any matching row (i.\+e., compared equal to it) in the {\ttfamily haystack} table. The boolean search results are written into the corresponding rows of the output array.


\begin{DoxyCode}{0}
\DoxyCodeLine{Example:}
\DoxyCodeLine{}
\DoxyCodeLine{haystack\ =\ \{\ \{\ 5,\ 4,\ 1,\ 2,\ 3\ \}\ \}}
\DoxyCodeLine{needles\ \ =\ \{\ \{\ 0,\ 1,\ 2\ \}\ \}}
\DoxyCodeLine{output\ \ \ =\ \{\ false,\ true,\ true\ \}}

\end{DoxyCode}



\begin{DoxyParams}{参数}
{\em haystack} & The table containing the search space \\
\hline
{\em needles} & A table of rows whose existence to check in the search space \\
\hline
{\em compare\+\_\+nulls} & Control whether nulls should be compared as equal or not \\
\hline
{\em compare\+\_\+nans} & Control whether floating-\/point Na\+Ns values should be compared as equal or not \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches \\
\hline
{\em mr} & Device memory resource used to allocate the returned vector \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A vector of bools indicating if each row in {\ttfamily needles} has matching rows in {\ttfamily haystack} 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1detail_a047f6e84ed9d8d30fd0a8703ac2085ee}\label{namespacecudf_1_1detail_a047f6e84ed9d8d30fd0a8703ac2085ee} 
\index{cudf::detail@{cudf::detail}!contiguous\_split@{contiguous\_split}}
\index{contiguous\_split@{contiguous\_split}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{contiguous\_split()}{contiguous\_split()}}
{\footnotesize\ttfamily std\+::vector$<$ \mbox{\hyperlink{structcudf_1_1packed__table}{packed\+\_\+table}} $>$ cudf\+::detail\+::contiguous\+\_\+split (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{cudf\+::table\+\_\+view}} const \&}]{input,  }\item[{std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ const \&}]{splits,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Performs a deep-\/copy split of a {\ttfamily \doxylink{classcudf_1_1table__view}{table\+\_\+view}} into a set of {\ttfamily \doxylink{classcudf_1_1table__view}{table\+\_\+view}}s into a single contiguous block of memory.   

The memory for the output views is allocated in a single contiguous {\ttfamily rmm\+::device\+\_\+buffer} returned in the {\ttfamily \doxylink{structcudf_1_1packed__table}{packed\+\_\+table}}. There is no top-\/level owning table.

The returned views of {\ttfamily input} are constructed from a vector of indices, that indicate where each split should occur. The {\ttfamily i}th returned {\ttfamily \doxylink{classcudf_1_1table__view}{table\+\_\+view}} is sliced as {\ttfamily \mbox{[}0, splits\mbox{[}i\mbox{]})} if {\ttfamily i}=0, else {\ttfamily \mbox{[}splits\mbox{[}i\mbox{]}, input.\+size())} if {\ttfamily i} is the last view and {\ttfamily \mbox{[}splits\mbox{[}i-\/1\mbox{]}, splits\mbox{[}i\mbox{]}\mbox{]}} otherwise.

For all {\ttfamily i} it is expected {\ttfamily splits\mbox{[}i\mbox{]} \texorpdfstring{$<$}{<}= splits\mbox{[}i+1\mbox{]} \texorpdfstring{$<$}{<}= input.\+size()} For a {\ttfamily splits} size N, there will always be N+1 splits in the output

\begin{DoxyNote}{注解}
It is the caller\textquotesingle{}s responsibility to ensure that the returned views do not outlive the viewed device memory contained in the {\ttfamily all\+\_\+data} field of the returned \doxylink{structcudf_1_1packed__table}{packed\+\_\+table}.
\end{DoxyNote}

\begin{DoxyCode}{0}
\DoxyCodeLine{Example:}
\DoxyCodeLine{input:\ \ \ [\{10,\ 12,\ 14,\ 16,\ 18,\ 20,\ 22,\ 24,\ 26,\ 28\},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \{50,\ 52,\ 54,\ 56,\ 58,\ 60,\ 62,\ 64,\ 66,\ 68\}]}
\DoxyCodeLine{splits:\ \ \{2,\ 5,\ 9\}}
\DoxyCodeLine{output:\ \ [\{\{10,\ 12\},\ \{14,\ 16,\ 18\},\ \{20,\ 22,\ 24,\ 26\},\ \{28\}\},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \{\{50,\ 52\},\ \{54,\ 56,\ 58\},\ \{60,\ 62,\ 64,\ 66\},\ \{68\}\}]}

\end{DoxyCode}



\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily splits} has end index \texorpdfstring{$>$}{>} size of {\ttfamily input}. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & When the value in {\ttfamily splits} is not in the range \mbox{[}0, input.\+size()). \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & When the values in the {\ttfamily splits} are \textquotesingle{}strictly decreasing\textquotesingle{}.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}[1]{参数}
 & {\em input} & View of a table to split \\
\hline
 & {\em splits} & A vector of indices where the view will be split \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Device memory resource used to allocate the returned result\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
The set of requested views of {\ttfamily input} indicated by the {\ttfamily splits} and the viewed memory buffer.  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a9423550e270db631d429d61b140d7108}\label{namespacecudf_1_1detail_a9423550e270db631d429d61b140d7108} 
\index{cudf::detail@{cudf::detail}!copy\_bitmask@{copy\_bitmask}}
\index{copy\_bitmask@{copy\_bitmask}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{copy\_bitmask()}{copy\_bitmask()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily rmm\+::device\+\_\+buffer cudf\+::detail\+::copy\+\_\+bitmask (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__utility__types_ga1d17001baf070a639c3a5e8ed8c46d34}{bitmask\+\_\+type}} const \texorpdfstring{$\ast$}{*}}]{mask,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{begin\+\_\+bit,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{end\+\_\+bit,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Creates a {\ttfamily device\+\_\+buffer} from a slice of bitmask defined by a range of indices {\ttfamily \mbox{[}begin\+\_\+bit, end\+\_\+bit)}.   

Returns empty {\ttfamily device\+\_\+buffer} if {\ttfamily bitmask == nullptr}.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily begin\+\_\+bit \texorpdfstring{$>$}{>} end\+\_\+bit} \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily begin\+\_\+bit \texorpdfstring{$<$}{<} 0}\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em mask} & Bitmask residing in device memory whose bits will be copied \\
\hline
{\em begin\+\_\+bit} & Index of the first bit to be copied (inclusive) \\
\hline
{\em end\+\_\+bit} & Index of the last bit to be copied (exclusive) \\
\hline
{\em mr} & Device memory resource used to allocate the returned device\+\_\+buffer \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
rmm\+::device\+\_\+buffer A {\ttfamily device\+\_\+buffer} containing the bits {\ttfamily \mbox{[}begin\+\_\+bit, end\+\_\+bit)} from {\ttfamily mask}.  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_aaddec64eefdf906a669dd8e65e23137c}\label{namespacecudf_1_1detail_aaddec64eefdf906a669dd8e65e23137c} 
\index{cudf::detail@{cudf::detail}!copy\_bitmask@{copy\_bitmask}}
\index{copy\_bitmask@{copy\_bitmask}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{copy\_bitmask()}{copy\_bitmask()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily rmm\+::device\+\_\+buffer cudf\+::detail\+::copy\+\_\+bitmask (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{view,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Copies {\ttfamily view}\textquotesingle{}s bitmask from the bits {\ttfamily \mbox{[}view.\+offset(), view.\+offset() + view.\+size())} into a {\ttfamily device\+\_\+buffer}   

Returns empty {\ttfamily device\+\_\+buffer} if the column is not nullable


\begin{DoxyParams}{参数}
{\em view} & Column view whose bitmask needs to be copied \\
\hline
{\em mr} & Device memory resource used to allocate the returned device\+\_\+buffer \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
rmm\+::device\+\_\+buffer A {\ttfamily device\+\_\+buffer} containing the bits {\ttfamily \mbox{[}view.\+offset(), view.\+offset() + view.\+size())} from {\ttfamily view}\textquotesingle{}s bitmask.  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a1f095700ad533a04852f9b75ae33c2bc}\label{namespacecudf_1_1detail_a1f095700ad533a04852f9b75ae33c2bc} 
\index{cudf::detail@{cudf::detail}!copy\_if\_else@{copy\_if\_else}}
\index{copy\_if\_else@{copy\_if\_else}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{copy\_if\_else()}{copy\_if\_else()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::copy\+\_\+if\+\_\+else (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{lhs,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{rhs,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{boolean\+\_\+mask,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Returns a new column, where each element is selected from either {\ttfamily lhs} or {\ttfamily rhs} based on the value of the corresponding element in {\ttfamily boolean\+\_\+mask}   

Selects each element i in the output column from either {\ttfamily rhs} or {\ttfamily lhs} using the following rule\+: {\ttfamily output\mbox{[}i\mbox{]} = (boolean\+\_\+mask.\+valid(i) and boolean\+\_\+mask\mbox{[}i\mbox{]}) ? lhs\mbox{[}i\mbox{]} \+: rhs\mbox{[}i\mbox{]}}


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if lhs and rhs are not of the same type \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if lhs and rhs are not of the same length \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if boolean mask is not of type bool \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if boolean mask is not of the same length as lhs and rhs \\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em lhs} & left-\/hand \doxylink{classcudf_1_1column__view}{column\+\_\+view} \\
\hline
\mbox{\texttt{ in}}  & {\em rhs} & right-\/hand \doxylink{classcudf_1_1column__view}{column\+\_\+view} \\
\hline
\mbox{\texttt{ in}}  & {\em boolean\+\_\+mask} & column of {\ttfamily \doxylink{group__utility__types_ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd}{type\+\_\+id\+::\+BOOL8}} representing \"{}left (true) / right (false)\"{} boolean for each element. Null element represents false. \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
new column with the selected elements  
\end{DoxyReturn}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a44102048883bf4ae35957e48b4b650a3}\label{namespacecudf_1_1detail_a44102048883bf4ae35957e48b4b650a3} 
\index{cudf::detail@{cudf::detail}!copy\_if\_else@{copy\_if\_else}}
\index{copy\_if\_else@{copy\_if\_else}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{copy\_if\_else()}{copy\_if\_else()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::copy\+\_\+if\+\_\+else (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{lhs,  }\item[{\mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&}]{rhs,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{boolean\+\_\+mask,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Returns a new column, where each element is selected from either {\ttfamily lhs} or {\ttfamily rhs} based on the value of the corresponding element in {\ttfamily boolean\+\_\+mask}   

Selects each element i in the output column from either {\ttfamily rhs} or {\ttfamily lhs} using the following rule\+: {\ttfamily output\mbox{[}i\mbox{]} = (boolean\+\_\+mask.\+valid(i) and boolean\+\_\+mask\mbox{[}i\mbox{]}) ? lhs\mbox{[}i\mbox{]} \+: rhs}


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if lhs and rhs are not of the same type \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if boolean mask is not of type bool \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if boolean mask is not of the same length as lhs \\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em lhs} & left-\/hand \doxylink{classcudf_1_1column__view}{column\+\_\+view} \\
\hline
\mbox{\texttt{ in}}  & {\em rhs} & right-\/hand scalar \\
\hline
\mbox{\texttt{ in}}  & {\em boolean\+\_\+mask} & column of {\ttfamily \doxylink{group__utility__types_ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd}{type\+\_\+id\+::\+BOOL8}} representing \"{}left (true) / right (false)\"{} boolean for each element. Null element represents false. \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
new column with the selected elements  
\end{DoxyReturn}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a3ca44d4fcbf12660edf218195e729eaa}\label{namespacecudf_1_1detail_a3ca44d4fcbf12660edf218195e729eaa} 
\index{cudf::detail@{cudf::detail}!copy\_if\_else@{copy\_if\_else}}
\index{copy\_if\_else@{copy\_if\_else}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{copy\_if\_else()}{copy\_if\_else()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::copy\+\_\+if\+\_\+else (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&}]{lhs,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{rhs,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{boolean\+\_\+mask,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Returns a new column, where each element is selected from either {\ttfamily lhs} or {\ttfamily rhs} based on the value of the corresponding element in {\ttfamily boolean\+\_\+mask}   

Selects each element i in the output column from either {\ttfamily rhs} or {\ttfamily lhs} using the following rule\+: {\ttfamily output\mbox{[}i\mbox{]} = (boolean\+\_\+mask.\+valid(i) and boolean\+\_\+mask\mbox{[}i\mbox{]}) ? lhs \+: rhs\mbox{[}i\mbox{]}}


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if lhs and rhs are not of the same type \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if boolean mask is not of type bool \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if boolean mask is not of the same length as rhs \\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em lhs} & left-\/hand scalar \\
\hline
\mbox{\texttt{ in}}  & {\em rhs} & right-\/hand \doxylink{classcudf_1_1column__view}{column\+\_\+view} \\
\hline
\mbox{\texttt{ in}}  & {\em boolean\+\_\+mask} & column of {\ttfamily \doxylink{group__utility__types_ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd}{type\+\_\+id\+::\+BOOL8}} representing \"{}left (true) / right (false)\"{} boolean for each element. Null element represents false. \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
new column with the selected elements  
\end{DoxyReturn}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_ac60520ad2d4ed5741035a9e8dd9bfbe8}\label{namespacecudf_1_1detail_ac60520ad2d4ed5741035a9e8dd9bfbe8} 
\index{cudf::detail@{cudf::detail}!copy\_if\_else@{copy\_if\_else}}
\index{copy\_if\_else@{copy\_if\_else}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{copy\_if\_else()}{copy\_if\_else()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::copy\+\_\+if\+\_\+else (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&}]{lhs,  }\item[{\mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&}]{rhs,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{boolean\+\_\+mask,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Returns a new column, where each element is selected from either {\ttfamily lhs} or {\ttfamily rhs} based on the value of the corresponding element in {\ttfamily boolean\+\_\+mask}   

Selects each element i in the output column from either {\ttfamily rhs} or {\ttfamily lhs} using the following rule\+: {\ttfamily output\mbox{[}i\mbox{]} = (boolean\+\_\+mask.\+valid(i) and boolean\+\_\+mask\mbox{[}i\mbox{]}) ? lhs \+: rhs}


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if boolean mask is not of type bool \\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em lhs} & left-\/hand scalar \\
\hline
\mbox{\texttt{ in}}  & {\em rhs} & right-\/hand scalar \\
\hline
\mbox{\texttt{ in}}  & {\em boolean\+\_\+mask} & column of {\ttfamily \doxylink{group__utility__types_ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd}{type\+\_\+id\+::\+BOOL8}} representing \"{}left (true) / right (false)\"{} boolean for each element. null element represents false. \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
new column with the selected elements  
\end{DoxyReturn}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_aedafe62653e88ef1440aed7287f89ab8}\label{namespacecudf_1_1detail_aedafe62653e88ef1440aed7287f89ab8} 
\index{cudf::detail@{cudf::detail}!count\_set\_bits@{count\_set\_bits}}
\index{count\_set\_bits@{count\_set\_bits}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{count\_set\_bits()}{count\_set\_bits()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{cudf\+::size\+\_\+type}} cudf\+::detail\+::count\+\_\+set\+\_\+bits (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__utility__types_ga1d17001baf070a639c3a5e8ed8c46d34}{bitmask\+\_\+type}} const \texorpdfstring{$\ast$}{*}}]{bitmask,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{start,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{stop,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream }\end{DoxyParamCaption})}



Given a bitmask, counts the number of set (1) bits in the range {\ttfamily \mbox{[}start, stop)}. 


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily bitmask == nullptr} \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily start \texorpdfstring{$>$}{>} stop} \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily start \texorpdfstring{$<$}{<} 0}\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em bitmask} & Bitmask residing in device memory whose bits will be counted. \\
\hline
{\em start} & Index of the first bit to count (inclusive). \\
\hline
{\em stop} & Index of the last bit to count (exclusive). \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
The number of non-\/zero bits in the specified range. 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1detail_a96a79295789c1ba220298ea1dbc0e8f7}\label{namespacecudf_1_1detail_a96a79295789c1ba220298ea1dbc0e8f7} 
\index{cudf::detail@{cudf::detail}!count\_unset\_bits@{count\_unset\_bits}}
\index{count\_unset\_bits@{count\_unset\_bits}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{count\_unset\_bits()}{count\_unset\_bits()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{cudf\+::size\+\_\+type}} cudf\+::detail\+::count\+\_\+unset\+\_\+bits (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__utility__types_ga1d17001baf070a639c3a5e8ed8c46d34}{bitmask\+\_\+type}} const \texorpdfstring{$\ast$}{*}}]{bitmask,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{start,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{stop,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream }\end{DoxyParamCaption})}



Given a bitmask, counts the number of unset (0) bits in the range {\ttfamily \mbox{[}start, stop)}. 


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily bitmask == nullptr} \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily start \texorpdfstring{$>$}{>} stop} \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily start \texorpdfstring{$<$}{<} 0}\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em bitmask} & Bitmask residing in device memory whose bits will be counted. \\
\hline
{\em start} & Index of the first bit to count (inclusive). \\
\hline
{\em stop} & Index of the last bit to count (exclusive). \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
The number of zero bits in the specified range. 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1detail_a690f0e70c8c2bad53bf877483f2d346d}\label{namespacecudf_1_1detail_a690f0e70c8c2bad53bf877483f2d346d} 
\index{cudf::detail@{cudf::detail}!create\_null\_mask@{create\_null\_mask}}
\index{create\_null\_mask@{create\_null\_mask}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{create\_null\_mask()}{create\_null\_mask()}}
{\footnotesize\ttfamily rmm\+::device\+\_\+buffer cudf\+::detail\+::create\+\_\+null\+\_\+mask (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{size,  }\item[{\mbox{\hyperlink{group__utility__types_ga4daf20c000ab374d76f4d56f0ddb7b26}{mask\+\_\+state}}}]{state,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Creates a {\ttfamily device\+\_\+buffer} for use as a null value indicator bitmask of a {\ttfamily column}.   


\begin{DoxyParams}{参数}
{\em size} & The number of elements to be represented by the mask \\
\hline
{\em state} & The desired state of the mask \\
\hline
{\em mr} & Device memory resource used to allocate the returned device\+\_\+buffer \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
rmm\+::device\+\_\+buffer A {\ttfamily device\+\_\+buffer} for use as a null bitmask satisfying the desired size and state  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a0159f4dade1ab55499ee6d0606eae6fd}\label{namespacecudf_1_1detail_a0159f4dade1ab55499ee6d0606eae6fd} 
\index{cudf::detail@{cudf::detail}!dispatch\_type\_and\_aggregation@{dispatch\_type\_and\_aggregation}}
\index{dispatch\_type\_and\_aggregation@{dispatch\_type\_and\_aggregation}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{dispatch\_type\_and\_aggregation()}{dispatch\_type\_and\_aggregation()}}
{\footnotesize\ttfamily template$<$typename F , typename... Ts$>$ \\
\mbox{\hyperlink{types_8hpp_adc4a74f3fb4b327ed43b31d0fca65ba3}{CUDF\+\_\+\+HOST\+\_\+\+DEVICE}} constexpr decltype(auto) cudf\+::detail\+::dispatch\+\_\+type\+\_\+and\+\_\+aggregation (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}}}]{type,  }\item[{\mbox{\hyperlink{classcudf_1_1aggregation_a83579ae3cab2fc3d1c3b377d1cfab24c}{aggregation\+::\+Kind}}}]{k,  }\item[{F \&\&}]{f,  }\item[{Ts \&\&...}]{args }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}}



Dispatches both a type and {\ttfamily \doxylink{classcudf_1_1aggregation_a83579ae3cab2fc3d1c3b377d1cfab24c}{aggregation\+::\+Kind}} template parameters to a callable. 

This function expects a callable {\ttfamily f} with an {\ttfamily operator()} template accepting two template parameters. The first is a type dispatched from {\ttfamily type}. The second is an {\ttfamily \doxylink{classcudf_1_1aggregation_a83579ae3cab2fc3d1c3b377d1cfab24c}{aggregation\+::\+Kind}} dispatched from {\ttfamily k}.


\begin{DoxyParams}{参数}
{\em type} & The {\ttfamily \doxylink{classcudf_1_1data__type}{data\+\_\+type}} used to dispatch a type for the first template parameter of the callable {\ttfamily F} \\
\hline
{\em k} & The {\ttfamily \doxylink{classcudf_1_1aggregation_a83579ae3cab2fc3d1c3b377d1cfab24c}{aggregation\+::\+Kind}} used to dispatch an {\ttfamily \doxylink{classcudf_1_1aggregation_a83579ae3cab2fc3d1c3b377d1cfab24c}{aggregation\+::\+Kind}} non-\/type template parameter for the second template parameter of the callable \\
\hline
{\em args} & Parameter pack forwarded to the {\ttfamily operator()} invocation {\ttfamily F}. \\
\hline
\end{DoxyParams}


在文件 \mbox{\hyperlink{detail_2aggregation_2aggregation_8hpp_source}{aggregation.\+hpp}} 第 \mbox{\hyperlink{detail_2aggregation_2aggregation_8hpp_source_l01511}{1511}} 行定义.

\Hypertarget{namespacecudf_1_1detail_a32d13444c532389ceda0e73e6fa73081}\label{namespacecudf_1_1detail_a32d13444c532389ceda0e73e6fa73081} 
\index{cudf::detail@{cudf::detail}!distinct@{distinct}}
\index{distinct@{distinct}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{distinct()}{distinct()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::detail\+::distinct (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{input,  }\item[{std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ const \&}]{keys,  }\item[{\mbox{\hyperlink{group__reorder__compact_ga69091647ea1f9c9d4cdcf7c8876bea3a}{duplicate\+\_\+keep\+\_\+option}}}]{keep = {\ttfamily \mbox{\hyperlink{group__reorder__compact_gga69091647ea1f9c9d4cdcf7c8876bea3aa0546025abe5830d9334bb82102420394}{duplicate\+\_\+keep\+\_\+option\+::\+KEEP\+\_\+\+ANY}}},  }\item[{\mbox{\hyperlink{group__utility__types_ga08a672308cd0f61562410d106b377771}{null\+\_\+equality}}}]{nulls\+\_\+equal = {\ttfamily \mbox{\hyperlink{group__utility__types_gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44}{null\+\_\+equality\+::\+EQUAL}}},  }\item[{\mbox{\hyperlink{group__utility__types_gae9d1055c69c3089452794783c7c82f83}{nan\+\_\+equality}}}]{nans\+\_\+equal = {\ttfamily \mbox{\hyperlink{group__utility__types_ggae9d1055c69c3089452794783c7c82f83acd6d9f766e6e2753da429d26078711d7}{nan\+\_\+equality\+::\+ALL\+\_\+\+EQUAL}}},  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Create a new table without duplicate rows.   

Given an {\ttfamily input} \doxylink{classcudf_1_1table__view}{table\+\_\+view}, each row is copied to the output table to create a set of distinct rows. If there are duplicate rows, which row to be copied depends on the specified value of the {\ttfamily keep} parameter.

The order of rows in the output table is not specified.

Performance hint\+: if the input is pre-\/sorted, {\ttfamily \doxylink{group__reorder__compact_ga87352ad4f282dd17365d4c9929d5c644}{cudf\+::unique}} can produce an equivalent result (i.\+e., same set of output rows) but with less running time than {\ttfamily \doxylink{group__reorder__compact_ga201195610929658c5d383fa99434ef9c}{cudf\+::distinct}}.


\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em input} & input \doxylink{classcudf_1_1table__view}{table\+\_\+view} to copy only distinct rows \\
\hline
\mbox{\texttt{ in}}  & {\em keys} & vector of indices representing key columns from {\ttfamily input} \\
\hline
\mbox{\texttt{ in}}  & {\em keep} & keep any, first, last, or none of the found duplicates \\
\hline
\mbox{\texttt{ in}}  & {\em nulls\+\_\+equal} & flag to control if nulls are compared equal or not \\
\hline
\mbox{\texttt{ in}}  & {\em nans\+\_\+equal} & flag to control if floating-\/point NaN values are compared equal or not \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Device memory resource used to allocate the returned table\textquotesingle{}s device memory\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Table with distinct rows in an unspecified order  
\end{DoxyReturn}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_aedc80778d27d66fad4e9e6d102f5b4f6}\label{namespacecudf_1_1detail_aedc80778d27d66fad4e9e6d102f5b4f6} 
\index{cudf::detail@{cudf::detail}!distinct\_count@{distinct\_count}}
\index{distinct\_count@{distinct\_count}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{distinct\_count()}{distinct\_count()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{cudf\+::size\+\_\+type}} cudf\+::detail\+::distinct\+\_\+count (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{input,  }\item[{\mbox{\hyperlink{group__utility__types_ga1b8cda4afb95a7c42c4679b4fae61009}{null\+\_\+policy}}}]{null\+\_\+handling,  }\item[{\mbox{\hyperlink{group__utility__types_ga74641d3dfd6d96d0939b492ecf9b9cc8}{nan\+\_\+policy}}}]{nan\+\_\+handling,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream }\end{DoxyParamCaption})}



Count the distinct elements in the \doxylink{classcudf_1_1column__view}{column\+\_\+view}.   

If {\ttfamily nulls\+\_\+equal == nulls\+\_\+equal\+::\+UNEQUAL}, all {\ttfamily null}s are distinct.

Given an input \doxylink{classcudf_1_1column__view}{column\+\_\+view}, number of distinct elements in this \doxylink{classcudf_1_1column__view}{column\+\_\+view} is returned.

If {\ttfamily null\+\_\+handling} is \doxylink{group__utility__types_gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8}{null\+\_\+policy\+::\+EXCLUDE} and {\ttfamily nan\+\_\+handling} is \doxylink{group__utility__types_gga74641d3dfd6d96d0939b492ecf9b9cc8aeed6bbfa0697c54960c7e0baa97313f4}{nan\+\_\+policy\+::\+NAN\+\_\+\+IS\+\_\+\+NULL}, both {\ttfamily NaN} and {\ttfamily null} values are ignored. If {\ttfamily null\+\_\+handling} is \doxylink{group__utility__types_gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8}{null\+\_\+policy\+::\+EXCLUDE} and {\ttfamily nan\+\_\+handling} is \doxylink{group__utility__types_gga74641d3dfd6d96d0939b492ecf9b9cc8a27adbe26caa2eb99976344933c281a77}{nan\+\_\+policy\+::\+NAN\+\_\+\+IS\+\_\+\+VALID}, only {\ttfamily null} is ignored, {\ttfamily NaN} is considered in distinct count.

{\ttfamily null}s are handled as equal.


\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em input} & The \doxylink{classcudf_1_1column__view}{column\+\_\+view} whose distinct elements will be counted \\
\hline
\mbox{\texttt{ in}}  & {\em null\+\_\+handling} & flag to include or ignore {\ttfamily null} while counting \\
\hline
\mbox{\texttt{ in}}  & {\em nan\+\_\+handling} & flag to consider {\ttfamily NaN==null} or not\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
number of distinct rows in the table  
\end{DoxyReturn}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_ab3e020feeee7f44561f850a2e42647d5}\label{namespacecudf_1_1detail_ab3e020feeee7f44561f850a2e42647d5} 
\index{cudf::detail@{cudf::detail}!distinct\_count@{distinct\_count}}
\index{distinct\_count@{distinct\_count}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{distinct\_count()}{distinct\_count()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{cudf\+::size\+\_\+type}} cudf\+::detail\+::distinct\+\_\+count (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{input,  }\item[{\mbox{\hyperlink{group__utility__types_ga08a672308cd0f61562410d106b377771}{null\+\_\+equality}}}]{nulls\+\_\+equal = {\ttfamily \mbox{\hyperlink{group__utility__types_gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44}{null\+\_\+equality\+::\+EQUAL}}},  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()} }\end{DoxyParamCaption})}



Count the distinct rows in a table.   


\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em input} & Table whose distinct rows will be counted \\
\hline
\mbox{\texttt{ in}}  & {\em nulls\+\_\+equal} & flag to denote if null elements should be considered equal. nulls are not equal if \doxylink{group__utility__types_gga08a672308cd0f61562410d106b377771ac0df9e531f39895029236b71d0d1c0ac}{null\+\_\+equality\+::\+UNEQUAL}.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
number of distinct rows in the table  
\end{DoxyReturn}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a8bde81471b27ab73aa588c4e79937199}\label{namespacecudf_1_1detail_a8bde81471b27ab73aa588c4e79937199} 
\index{cudf::detail@{cudf::detail}!drop\_nans@{drop\_nans}}
\index{drop\_nans@{drop\_nans}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{drop\_nans()}{drop\_nans()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::detail\+::drop\+\_\+nans (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{input,  }\item[{std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ const \&}]{keys,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{cudf\+::size\+\_\+type}}}]{keep\+\_\+threshold,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Filters a table to remove NANs with threshold count.   

Filters the rows of the {\ttfamily input} considering specified columns indicated in {\ttfamily keys} for NANs. These key columns must be of floating-\/point type.

Given an input \doxylink{classcudf_1_1table__view}{table\+\_\+view}, row {\ttfamily i} from the input columns is copied to the output if the same row {\ttfamily i} of {\ttfamily keys} has at least {\ttfamily keep\+\_\+threshold} non-\/\+NAN elements.

This operation is stable\+: the input order is preserved in the output.


\begin{DoxyCode}{0}
\DoxyCodeLine{input\ \ \ \{col1:\ \{1.0,\ 2.0,\ 3.0,\ NAN\},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ col2:\ \{4.0,\ null,\ NAN,\ NAN\},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ col3:\ \{7.0,\ NAN,\ NAN,\ NAN\}\}}
\DoxyCodeLine{keys\ =\ \{0,\ 1,\ 2\}\ //\ All\ columns}
\DoxyCodeLine{keep\_threshold\ =\ 2}
\DoxyCodeLine{}
\DoxyCodeLine{output\ \{col1:\ \{1.0,\ 2.0\}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ col2:\ \{4.0,\ null\}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ col3:\ \{7.0,\ NAN\}\}}

\end{DoxyCode}


\begin{DoxyNote}{注解}
if {\ttfamily input.\+num\+\_\+rows()} is zero, or {\ttfamily keys} is empty, there is no error, and an empty {\ttfamily table} is returned
\end{DoxyNote}

\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if The {\ttfamily keys} columns are not floating-\/point type.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em input} & The input {\ttfamily \doxylink{classcudf_1_1table__view}{table\+\_\+view}} to filter \\
\hline
\mbox{\texttt{ in}}  & {\em keys} & vector of indices representing key columns from {\ttfamily input} \\
\hline
\mbox{\texttt{ in}}  & {\em keep\+\_\+threshold} & The minimum number of non-\/\+NAN elements in a row required to keep the row. \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Device memory resource used to allocate the returned table\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Table containing all rows of the {\ttfamily input} with at least {\ttfamily keep\+\_\+threshold} non-\/\+NAN elements in {\ttfamily keys}.  
\end{DoxyReturn}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a3ad692201878dfd4b9058cef0428bf3d}\label{namespacecudf_1_1detail_a3ad692201878dfd4b9058cef0428bf3d} 
\index{cudf::detail@{cudf::detail}!drop\_nulls@{drop\_nulls}}
\index{drop\_nulls@{drop\_nulls}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{drop\_nulls()}{drop\_nulls()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::detail\+::drop\+\_\+nulls (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{input,  }\item[{std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ const \&}]{keys,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{cudf\+::size\+\_\+type}}}]{keep\+\_\+threshold,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Filters a table to remove null elements with threshold count.   

Filters the rows of the {\ttfamily input} considering specified columns indicated in {\ttfamily keys} for validity / null values.

Given an input \doxylink{classcudf_1_1table__view}{table\+\_\+view}, row {\ttfamily i} from the input columns is copied to the output if the same row {\ttfamily i} of {\ttfamily keys} has at least {\ttfamily keep\+\_\+threshold} non-\/null fields.

This operation is stable\+: the input order is preserved in the output.

Any non-\/nullable column in the input is treated as all non-\/null.


\begin{DoxyCode}{0}
\DoxyCodeLine{input\ \ \ \{col1:\ \{1,\ 2,\ \ \ \ 3,\ \ \ \ null\},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ col2:\ \{4,\ 5,\ \ \ \ null,\ null\},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ col3:\ \{7,\ null,\ null,\ null\}\}}
\DoxyCodeLine{keys\ =\ \{0,\ 1,\ 2\}\ //\ All\ columns}
\DoxyCodeLine{keep\_threshold\ =\ 2}
\DoxyCodeLine{}
\DoxyCodeLine{output\ \{col1:\ \{1,\ 2\}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ col2:\ \{4,\ 5\}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ col3:\ \{7,\ null\}\}}

\end{DoxyCode}


\begin{DoxyNote}{注解}
if {\ttfamily input.\+num\+\_\+rows()} is zero, or {\ttfamily keys} is empty or has no nulls, there is no error, and an empty {\ttfamily table} is returned
\end{DoxyNote}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em input} & The input {\ttfamily \doxylink{classcudf_1_1table__view}{table\+\_\+view}} to filter \\
\hline
\mbox{\texttt{ in}}  & {\em keys} & vector of indices representing key columns from {\ttfamily input} \\
\hline
\mbox{\texttt{ in}}  & {\em keep\+\_\+threshold} & The minimum number of non-\/null fields in a row required to keep the row. \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Device memory resource used to allocate the returned table\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Table containing all rows of the {\ttfamily input} with at least {\ttfamily keep\+\_\+threshold} non-\/null fields in {\ttfamily keys}.  
\end{DoxyReturn}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a861eb8ba4d559b6db57beb584530fb31}\label{namespacecudf_1_1detail_a861eb8ba4d559b6db57beb584530fb31} 
\index{cudf::detail@{cudf::detail}!encode@{encode}}
\index{encode@{encode}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{encode()}{encode()}}
{\footnotesize\ttfamily std\+::pair$<$ std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{cudf\+::table}} $>$, std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{cudf\+::column}} $>$ $>$ cudf\+::detail\+::encode (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{cudf\+::table\+\_\+view}} const \&}]{input,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Encode the rows of the given table as integers   

The encoded values are integers in the range \mbox{[}0, n), where {\ttfamily n} is the number of distinct rows in the input table. The result table is such that {\ttfamily keys\mbox{[}result\mbox{[}i\mbox{]}\mbox{]} == input\mbox{[}i\mbox{]}}, where {\ttfamily keys} is a table containing the distinct rows in {\ttfamily input} in sorted ascending order. Nulls, if any, are sorted to the end of the {\ttfamily keys} table.

Examples\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{input:\ [\{'a',\ 'b',\ 'b',\ 'a'\}]}
\DoxyCodeLine{output:\ [\{'a',\ 'b'\}],\ \{0,\ 1,\ 1,\ 0\}}
\DoxyCodeLine{}
\DoxyCodeLine{input:\ [\{1,\ 3,\ 1,\ 2,\ 9\},\ \{1,\ 2,\ 1,\ 3,\ 5\}]}
\DoxyCodeLine{output:\ [\{1,\ 2,\ 3,\ 9\},\ \{1,\ 3,\ 2,\ 5\}],\ \{0,\ 2,\ 0,\ 1,\ 3\}}

\end{DoxyCode}



\begin{DoxyParams}{参数}
{\em input} & Table containing values to be encoded \\
\hline
{\em mr} & Device memory resource used to allocate the returned table\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A pair containing the distinct row of the input table in sorter order, and a column of integer indices representing the encoded rows.  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_ab1a397072949d54359e047f3dada74d5}\label{namespacecudf_1_1detail_ab1a397072949d54359e047f3dada74d5} 
\index{cudf::detail@{cudf::detail}!fill@{fill}}
\index{fill@{fill}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{fill()}{fill()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::fill (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{input,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{begin,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{end,  }\item[{\mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&}]{value,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Fills a range of elements in a column out-\/of-\/place with a scalar value.   

Creates a new column as-\/if an in-\/place fill was performed into {\ttfamily input}; i.\+e. it is as if a copy of {\ttfamily input} was created first and then the elements indicated by the indices \mbox{[}{\ttfamily begin}, {\ttfamily end}) were overwritten by {\ttfamily value}.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & for invalid range (if {\ttfamily begin} \texorpdfstring{$<$}{<} 0, {\ttfamily begin} \texorpdfstring{$>$}{>} {\ttfamily end}, or {\ttfamily end} \texorpdfstring{$>$}{>} {\ttfamily destination.\+size()}). \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily destination} and {\ttfamily value} have different types.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em input} & The input column used to create a new column. The new column is created by replacing the values of {\ttfamily input} in the specified range with {\ttfamily value}. \\
\hline
{\em begin} & The starting index of the fill range (inclusive) \\
\hline
{\em end} & The index of the last element in the fill range (exclusive) \\
\hline
{\em value} & The scalar value to fill \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
The result output column  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_ac6b739ba07b14a2274420abc4f2ea89c}\label{namespacecudf_1_1detail_ac6b739ba07b14a2274420abc4f2ea89c} 
\index{cudf::detail@{cudf::detail}!fill\_in\_place@{fill\_in\_place}}
\index{fill\_in\_place@{fill\_in\_place}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{fill\_in\_place()}{fill\_in\_place()}}
{\footnotesize\ttfamily void cudf\+::detail\+::fill\+\_\+in\+\_\+place (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1mutable__column__view}{mutable\+\_\+column\+\_\+view}} \&}]{destination,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{begin,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{end,  }\item[{\mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&}]{value,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream }\end{DoxyParamCaption})}



Fills a range of elements in-\/place in a column with a scalar value.   

Fills N elements of {\ttfamily destination} starting at {\ttfamily begin} with {\ttfamily value}, where N = ({\ttfamily end} -\/ {\ttfamily begin}).

Overwrites the range of elements in {\ttfamily destination} indicated by the indices \mbox{[}{\ttfamily begin}, {\ttfamily end}) with {\ttfamily value}. Use the out-\/of-\/place fill function returning std\+::unique\+\_\+ptr$<$column$>$ for use cases requiring memory reallocation.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if memory reallocation is required (e.\+g. for variable width types). \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & for invalid range (if {\ttfamily begin} \texorpdfstring{$<$}{<} 0, {\ttfamily begin} \texorpdfstring{$>$}{>} {\ttfamily end}, or {\ttfamily end} \texorpdfstring{$>$}{>} {\ttfamily destination.\+size()}). \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily destination} and {\ttfamily value} have different types. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily value} is invalid but {\ttfamily destination} is not nullable.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em destination} & The preallocated column to fill into \\
\hline
{\em begin} & The starting index of the fill range (inclusive) \\
\hline
{\em end} & The index of the last element in the fill range (exclusive) \\
\hline
{\em value} & The scalar value to fill  \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_adacfa4e22fd6f93938a4d72131d9aff7}\label{namespacecudf_1_1detail_adacfa4e22fd6f93938a4d72131d9aff7} 
\index{cudf::detail@{cudf::detail}!find\_and\_replace\_all@{find\_and\_replace\_all}}
\index{find\_and\_replace\_all@{find\_and\_replace\_all}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{find\_and\_replace\_all()}{find\_and\_replace\_all()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::find\+\_\+and\+\_\+replace\+\_\+all (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{input\+\_\+col,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{values\+\_\+to\+\_\+replace,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{replacement\+\_\+values,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Return a copy of {\ttfamily input\+\_\+col} replacing any {\ttfamily values\+\_\+to\+\_\+replace\mbox{[}i\mbox{]}} found with {\ttfamily replacement\+\_\+values\mbox{[}i\mbox{]}}.   


\begin{DoxyParams}{参数}
{\em input\+\_\+col} & The column to find and replace values in \\
\hline
{\em values\+\_\+to\+\_\+replace} & The values to replace \\
\hline
{\em replacement\+\_\+values} & The values to replace with \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Copy of {\ttfamily input\+\_\+col} with specified values replaced  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_ad2d059bf11972e2337fde993dbd2582b}\label{namespacecudf_1_1detail_ad2d059bf11972e2337fde993dbd2582b} 
\index{cudf::detail@{cudf::detail}!from\_arrow@{from\_arrow}}
\index{from\_arrow@{from\_arrow}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{from\_arrow()}{from\_arrow()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::detail\+::from\+\_\+arrow (\begin{DoxyParamCaption}\item[{arrow\+::\+Table const \&}]{input\+\_\+table,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}






\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a94b63d8998a9b7eb5e1d4ae842f95a66}\label{namespacecudf_1_1detail_a94b63d8998a9b7eb5e1d4ae842f95a66} 
\index{cudf::detail@{cudf::detail}!from\_dlpack@{from\_dlpack}}
\index{from\_dlpack@{from\_dlpack}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{from\_dlpack()}{from\_dlpack()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::detail\+::from\+\_\+dlpack (\begin{DoxyParamCaption}\item[{DLManaged\+Tensor const \texorpdfstring{$\ast$}{*}}]{managed\+\_\+tensor,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Convert a DLPack DLTensor into a cudf table   

The {\ttfamily device\+\_\+type} of the DLTensor must be {\ttfamily k\+DLCPU}, {\ttfamily k\+DLCuda}, or {\ttfamily k\+DLCUDAHost}, and {\ttfamily device\+\_\+id} must match the current device. The {\ttfamily ndim} must be set to 1 or 2. The {\ttfamily dtype} must have 1 lane and the bitsize must match a supported {\ttfamily \doxylink{classcudf_1_1data__type}{cudf\+::data\+\_\+type}}.

\begin{DoxyNote}{注解}
The managed tensor is not deleted by this function.
\end{DoxyNote}

\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if the any of the DLTensor fields are unsupported\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em managed\+\_\+tensor} & a 1D or 2D column-\/major (Fortran order) tensor \\
\hline
{\em mr} & Device memory resource used to allocate the returned table\textquotesingle{}s device memory\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Table with a copy of the tensor data  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a5b23205b2ffc206924167683c00c48f5}\label{namespacecudf_1_1detail_a5b23205b2ffc206924167683c00c48f5} 
\index{cudf::detail@{cudf::detail}!gather@{gather}}
\index{gather@{gather}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{gather()}{gather()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::detail\+::gather (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{source\+\_\+table,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{gather\+\_\+map,  }\item[{\mbox{\hyperlink{group__column__copy_gae3ba74951558bc7966aae86abc6af5df}{out\+\_\+of\+\_\+bounds\+\_\+policy}}}]{bounds\+\_\+policy,  }\item[{\mbox{\hyperlink{namespacecudf_1_1detail_a1c29a0e8458ffb159e91481c0f37b0f5}{negative\+\_\+index\+\_\+policy}}}]{neg\+\_\+indices,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Gathers the specified rows of a set of columns according to a gather map. 

Gathers the rows of the source columns according to {\ttfamily gather\+\_\+map} such that row \"{}i\"{} in the resulting table\textquotesingle{}s columns will contain row \"{}gather\+\_\+map\mbox{[}i\mbox{]}\"{} from the source columns. The number of rows in the result table will be equal to the number of elements in {\ttfamily gather\+\_\+map}.

A negative value {\ttfamily i} in the {\ttfamily gather\+\_\+map} is interpreted as {\ttfamily i+n}, where {\ttfamily n} is the number of rows in the {\ttfamily source\+\_\+table}.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily check\+\_\+bounds == true} and an index exists in {\ttfamily gather\+\_\+map} outside the range {\ttfamily \mbox{[}-\/n, n)}, where {\ttfamily n} is the number of rows in the source table. If {\ttfamily check\+\_\+bounds == false}, the behavior is undefined.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em source\+\_\+table} & The input columns whose rows will be gathered \\
\hline
\mbox{\texttt{ in}}  & {\em gather\+\_\+map} & View into a non-\/nullable column of integral indices that maps the rows in the source columns to rows in the destination columns. \\
\hline
\mbox{\texttt{ in}}  & {\em bounds\+\_\+policy} & How to treat out-\/of-\/bounds indices. {\ttfamily NULLIFY} coerces rows that correspond to out-\/of-\/bounds indices in the gather map to be null elements. For better performance, use {\ttfamily DONT\+\_\+\+CHECK} when the {\ttfamily gather\+\_\+map} is known to contain only valid indices. If {\ttfamily policy} is set to {\ttfamily DONT\+\_\+\+CHECK} and there are out-\/of-\/bounds indices in {\ttfamily gather\+\_\+map}, the behavior is undefined. \\
\hline
\mbox{\texttt{ in}}  & {\em negative\+\_\+index\+\_\+policy} & Interpret each negative index {\ttfamily i} in the {\ttfamily gather\+\_\+map} as the positive index {\ttfamily i+num\+\_\+source\+\_\+rows}. \\
\hline
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Device memory resource used to allocate the returned table\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Result of the gather 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1detail_aef5dfc3e39242d68bd887f7e0b9fb373}\label{namespacecudf_1_1detail_aef5dfc3e39242d68bd887f7e0b9fb373} 
\index{cudf::detail@{cudf::detail}!gather@{gather}}
\index{gather@{gather}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{gather()}{gather()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::detail\+::gather (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{source\+\_\+table,  }\item[{\mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$ const}]{gather\+\_\+map,  }\item[{\mbox{\hyperlink{group__column__copy_gae3ba74951558bc7966aae86abc6af5df}{out\+\_\+of\+\_\+bounds\+\_\+policy}}}]{bounds\+\_\+policy,  }\item[{\mbox{\hyperlink{namespacecudf_1_1detail_a1c29a0e8458ffb159e91481c0f37b0f5}{negative\+\_\+index\+\_\+policy}}}]{neg\+\_\+indices,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}






\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily gather\+\_\+map} span size is larger than max of {\ttfamily size\+\_\+type}. \\
\hline
\end{DoxyExceptions}
\Hypertarget{namespacecudf_1_1detail_a67374a27ed17df376e445010d699fc62}\label{namespacecudf_1_1detail_a67374a27ed17df376e445010d699fc62} 
\index{cudf::detail@{cudf::detail}!get\_distinct\_indices@{get\_distinct\_indices}}
\index{get\_distinct\_indices@{get\_distinct\_indices}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{get\_distinct\_indices()}{get\_distinct\_indices()}}
{\footnotesize\ttfamily rmm\+::device\+\_\+uvector$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ cudf\+::detail\+::get\+\_\+distinct\+\_\+indices (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{input,  }\item[{\mbox{\hyperlink{group__reorder__compact_ga69091647ea1f9c9d4cdcf7c8876bea3a}{duplicate\+\_\+keep\+\_\+option}}}]{keep = {\ttfamily \mbox{\hyperlink{group__reorder__compact_gga69091647ea1f9c9d4cdcf7c8876bea3aa0546025abe5830d9334bb82102420394}{duplicate\+\_\+keep\+\_\+option\+::\+KEEP\+\_\+\+ANY}}},  }\item[{\mbox{\hyperlink{group__utility__types_ga08a672308cd0f61562410d106b377771}{null\+\_\+equality}}}]{nulls\+\_\+equal = {\ttfamily \mbox{\hyperlink{group__utility__types_gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44}{null\+\_\+equality\+::\+EQUAL}}},  }\item[{\mbox{\hyperlink{group__utility__types_gae9d1055c69c3089452794783c7c82f83}{nan\+\_\+equality}}}]{nans\+\_\+equal = {\ttfamily \mbox{\hyperlink{group__utility__types_ggae9d1055c69c3089452794783c7c82f83acd6d9f766e6e2753da429d26078711d7}{nan\+\_\+equality\+::\+ALL\+\_\+\+EQUAL}}},  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Create a column of indices of all distinct rows in the input table. 

Given an {\ttfamily input} \doxylink{classcudf_1_1table__view}{table\+\_\+view}, an output vector of all row indices of the distinct rows is generated. If there are duplicate rows, which index is kept depends on the {\ttfamily keep} parameter.


\begin{DoxyParams}{参数}
{\em input} & The input table \\
\hline
{\em keep} & Get index of any, first, last, or none of the found duplicates \\
\hline
{\em nulls\+\_\+equal} & Flag to specify whether null elements should be considered as equal \\
\hline
{\em nans\+\_\+equal} & Flag to specify whether NaN elements should be considered as equal \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches \\
\hline
{\em mr} & Device memory resource used to allocate the returned vector \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A device\+\_\+uvector containing the result indices 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1detail_a6ca203cd4504a08ef2fd489410d6db95}\label{namespacecudf_1_1detail_a6ca203cd4504a08ef2fd489410d6db95} 
\index{cudf::detail@{cudf::detail}!get\_dremel\_data@{get\_dremel\_data}}
\index{get\_dremel\_data@{get\_dremel\_data}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{get\_dremel\_data()}{get\_dremel\_data()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structcudf_1_1detail_1_1dremel__data}{dremel\+\_\+data}} cudf\+::detail\+::get\+\_\+dremel\+\_\+data (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}}}]{h\+\_\+col,  }\item[{std\+::vector$<$ uint8\+\_\+t $>$}]{nullability,  }\item[{bool}]{output\+\_\+as\+\_\+byte\+\_\+array,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream }\end{DoxyParamCaption})}



Get the dremel offsets and repetition and definition levels for a LIST column 

Dremel is a query system created by Google for ad hoc data analysis. The Dremel engine is described in depth in the paper \"{}\+Dremel\+: Interactive Analysis of Web-\/\+Scale \+Datasets\"{} (\href{https://research.google/pubs/pub36632/}{\texttt{ https\+://research.\+google/pubs/pub36632/}}). One of the key components of Dremel is an encoding that converts record-\/like data into a columnar store for efficient memory accesses. The Parquet file format uses Dremel encoding to handle nested data, so libcudf requires some facilities for working with this encoding. Furthermore, libcudf leverages Dremel encoding as a means for performing lexicographic comparisons of nested columns.

Dremel encoding is built around two concepts, the repetition and definition levels. Since describing them thoroughly is out of scope for this docstring, here are a couple of blogs that provide useful background\+:

\href{http://www.goldsborough.me/distributed-systems/2019/05/18/21-09-00-a_look_at_dremel/}{\texttt{ http\+://www.\+goldsborough.\+me/distributed-\/systems/2019/05/18/21-\/09-\/00-\/a\+\_\+look\+\_\+at\+\_\+dremel/}} \href{https://akshays-blog.medium.com/wrapping-head-around-repetition-and-definition-levels-in-dremel-powering-bigquery-c1a33c9695da}{\texttt{ https\+://akshays-\/blog.\+medium.\+com/wrapping-\/head-\/around-\/repetition-\/and-\/definition-\/levels-\/in-\/dremel-\/powering-\/bigquery-\/c1a33c9695da}} \href{https://blog.twitter.com/engineering/en_us/a/2013/dremel-made-simple-with-parquet}{\texttt{ https\+://blog.\+twitter.\+com/engineering/en\+\_\+us/a/2013/dremel-\/made-\/simple-\/with-\/parquet}}

The remainder of this documentation assumes familiarity with the Dremel concepts.

Dremel offsets are the per row offsets into the repetition and definition level arrays for a column. Example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{col\ \ \ \ \ \ \ \ \ \ \ \ =\ \{\{1,\ 2,\ 3\},\ \{\ \},\ \{5,\ 6\}\}}
\DoxyCodeLine{dremel\_offsets\ =\ \{\ 0,\ \ \ \ \ \ \ \ \ 3,\ \ \ 4,\ \ 6\}}
\DoxyCodeLine{rep\_level\ \ \ \ \ \ =\ \{\ 0,\ 1,\ 1,\ \ \ 0,\ \ \ 0,\ 1\}}
\DoxyCodeLine{def\_level\ \ \ \ \ \ =\ \{\ 1,\ 1,\ 1,\ \ \ 0,\ \ \ 1,\ 1\}}

\end{DoxyCode}


The repetition and definition level values are ideally computed using a recursive call over a nested structure but in order to better utilize GPU resources, this function calculates them with a bottom up merge method.

Given a LIST column of type {\ttfamily List\texorpdfstring{$<$}{<}List\texorpdfstring{$<$}{<}int\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}} like so\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{col\ =\ \{}
\DoxyCodeLine{\ \ \ [],}
\DoxyCodeLine{\ \ \ [[],\ [1,\ 2,\ 3],\ [4,\ 5]],}
\DoxyCodeLine{\ \ \ [[]]}
\DoxyCodeLine{\}}

\end{DoxyCode}
 We can represent it in cudf format with two level of offsets like this\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{Level\ 0\ offsets\ =\ \{0,\ 0,\ 3,\ 5,\ 6\}}
\DoxyCodeLine{Level\ 1\ offsets\ =\ \{0,\ 0,\ 3,\ 5,\ 5\}}
\DoxyCodeLine{Values\ \ \ \ \ \ \ \ \ \ =\ \{1,\ 2,\ 3,\ 4,\ 5\}}

\end{DoxyCode}
 The desired result of this function is the repetition and definition level values that correspond to the data values\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{col\ =\ \{[],\ [[],\ [1,\ 2,\ 3],\ [4,\ 5]],\ [[]]\}}
\DoxyCodeLine{def\ =\ \{\ 0\ \ \ \ 1,\ \ 2,\ 2,\ 2,\ \ \ 2,\ 2,\ \ \ \ \ 1\ \}}
\DoxyCodeLine{rep\ =\ \{\ 0,\ \ \ 0,\ \ 0,\ 2,\ 2,\ \ \ 1,\ 2,\ \ \ \ \ 0\ \}}

\end{DoxyCode}


Since repetition and definition levels arrays contain a value for each empty list, the size of the rep/def level array can be given by 
\begin{DoxyCode}{0}
\DoxyCodeLine{rep\_level.size()\ =\ size\ of\ leaf\ \mbox{\hyperlink{classcudf_1_1column}{column}}\ +\ number\ of\ empty\ lists\ in\ level\ 0}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ +\ number\ of\ empty\ lists\ in\ level\ 1\ ...}

\end{DoxyCode}


We start with finding the empty lists in the penultimate level and merging it with the indices of the leaf level. The values for the merge are the definition and repetition levels 
\begin{DoxyCode}{0}
\DoxyCodeLine{empties\ at\ level\ 1\ =\ \{0,\ 5\}}
\DoxyCodeLine{def\ values\ at\ 1\ \ \ \ =\ \{1,\ 1\}}
\DoxyCodeLine{rep\ values\ at\ 1\ \ \ \ =\ \{1,\ 1\}}
\DoxyCodeLine{indices\ at\ leaf\ \ \ \ =\ \{0,\ 1,\ 2,\ 3,\ 4\}}
\DoxyCodeLine{def\ values\ at\ leaf\ =\ \{2,\ 2,\ 2,\ 2,\ 2\}}
\DoxyCodeLine{rep\ values\ at\ leaf\ =\ \{2,\ 2,\ 2,\ 2,\ 2\}}

\end{DoxyCode}


merged def values = \{1, 2, 2, 2, 2, 2, 1\} merged rep values = \{1, 2, 2, 2, 2, 2, 1\}

The size of the rep/def values is now larger than the leaf values and the offsets need to be adjusted in order to point to the correct start indices. We do this with an exclusive scan over the indices of offsets of empty lists and adding to existing offsets. 
\begin{DoxyCode}{0}
\DoxyCodeLine{Level\ 1\ \textcolor{keyword}{new}\ offsets\ =\ \{0,\ 1,\ 4,\ 6,\ 7\}}

\end{DoxyCode}
 Repetition values at the beginning of a list need to be decremented. We use the new offsets to scatter the rep value. 
\begin{DoxyCode}{0}
\DoxyCodeLine{merged\ rep\ values\ \ =\ \{1,\ 2,\ 2,\ 2,\ 2,\ 2,\ 1\}}
\DoxyCodeLine{\mbox{\hyperlink{namespacecudf_1_1detail_ab0fafddc49374af3d9ab6815196d426f}{scatter}}\ (1,\ \textcolor{keyword}{new}\ offsets)}
\DoxyCodeLine{\textcolor{keyword}{new}\ offsets\ \ \ \ \ \ \ \ =\ \{0,\ 1,\ \ \ \ \ \ \ 4,\ \ \ \ 6,\ 7\}}
\DoxyCodeLine{\textcolor{keyword}{new}\ rep\ values\ \ \ \ \ =\ \{1,\ 1,\ 2,\ 2,\ 1,\ 2,\ 1\}}

\end{DoxyCode}


Similarly we merge up all the way till level 0 offsets

STRUCT COLUMNS \+: In case of struct columns, we don\textquotesingle{}t have to merge struct levels with their children because a struct is the same size as its children. e.\+g. for a column {\ttfamily struct\texorpdfstring{$<$}{<}int, float\texorpdfstring{$>$}{>}}, if the row {\ttfamily i} is null, then the children columns {\ttfamily int} and {\ttfamily float} are also null at {\ttfamily i}. They also have the null entry represented in their respective null masks. So for any case of strictly struct based nesting, we can get the definition levels merely by iterating over the nesting for the same row.

In case struct and lists are intermixed, the definition levels of all the contiguous struct levels can be constructed using the aforementioned iterative method. Only when we reach a list level, we need to do a merge with the subsequent level.

So, for a column like {\ttfamily struct\texorpdfstring{$<$}{<}list\texorpdfstring{$<$}{<}int\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}}, we are going to merge between the levels {\ttfamily struct\texorpdfstring{$<$}{<}list} and {\ttfamily int}. For a column like {\ttfamily list\texorpdfstring{$<$}{<}struct\texorpdfstring{$<$}{<}int\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}}, we are going to merge between {\ttfamily list} and {\ttfamily struct\texorpdfstring{$<$}{<}int\texorpdfstring{$>$}{>}}.

In general, one nesting level is the list level and any struct level that precedes it.

A few more examples to visualize the partitioning of column hierarchy into nesting levels\+: (L is list, S is struct, i is integer(leaf data level), angle brackets omitted) 
\begin{DoxyCode}{0}
\DoxyCodeLine{1.\ LSi\ \ \ \ \ =\ L\ \ \ Si}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ -\/\ |\ -\/-\/}
\DoxyCodeLine{}
\DoxyCodeLine{2.\ LLSi\ \ \ \ =\ L\ \ \ L\ \ \ Si}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ -\/\ |\ -\/\ |\ -\/-\/}
\DoxyCodeLine{}
\DoxyCodeLine{3.\ SSLi\ \ \ \ =\ SSL\ \ \ i}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ -\/-\/-\/\ |\ -\/}
\DoxyCodeLine{}
\DoxyCodeLine{4.\ LLSLSSi\ =\ L\ \ \ L\ \ \ SL\ \ \ SSi}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ -\/\ |\ -\/\ |\ -\/-\/\ |\ -\/-\/-\/}

\end{DoxyCode}



\begin{DoxyParams}{参数}
{\em col} & Column of LIST type \\
\hline
{\em level\+\_\+nullability} & Pre-\/determined nullability at each list level. Empty means infer from {\ttfamily col} \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A struct containing dremel data 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1detail_a84c26312d03ba6528aa4d28c9ec41a67}\label{namespacecudf_1_1detail_a84c26312d03ba6528aa4d28c9ec41a67} 
\index{cudf::detail@{cudf::detail}!get\_element@{get\_element}}
\index{get\_element@{get\_element}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{get\_element()}{get\_element()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} $>$ cudf\+::detail\+::get\+\_\+element (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{input,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{index,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Get the element at specified index from a column   

\begin{DoxyWarning}{警告}
This function is expensive (invokes a kernel launch). So, it is not recommended to be used in performance sensitive code or inside a loop.
\end{DoxyWarning}

\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily index} is not within the range {\ttfamily \mbox{[}0, input.\+size())}\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em input} & Column view to get the element from \\
\hline
{\em index} & Index into {\ttfamily input} to get the element at \\
\hline
{\em mr} & Device memory resource used to allocate the returned scalar\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
std\+::unique\+\_\+ptr$<$scalar$>$ Scalar containing the single value  
\end{DoxyReturn}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_aee63ff93909aab1cf205625ee996236a}\label{namespacecudf_1_1detail_aee63ff93909aab1cf205625ee996236a} 
\index{cudf::detail@{cudf::detail}!has\_nested\_columns@{has\_nested\_columns}}
\index{has\_nested\_columns@{has\_nested\_columns}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{has\_nested\_columns()}{has\_nested\_columns()}}
{\footnotesize\ttfamily bool cudf\+::detail\+::has\+\_\+nested\+\_\+columns (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{table }\end{DoxyParamCaption})}



Determine if any nested columns exist in a given table. 


\begin{DoxyParams}{参数}
{\em table} & The input table \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Whether nested columns exist in the input table 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1detail_a5758db52c9f99ddaab9a9de11fd25f4d}\label{namespacecudf_1_1detail_a5758db52c9f99ddaab9a9de11fd25f4d} 
\index{cudf::detail@{cudf::detail}!has\_nonempty\_nulls@{has\_nonempty\_nulls}}
\index{has\_nonempty\_nulls@{has\_nonempty\_nulls}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{has\_nonempty\_nulls()}{has\_nonempty\_nulls()}}
{\footnotesize\ttfamily bool cudf\+::detail\+::has\+\_\+nonempty\+\_\+nulls (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{input,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream }\end{DoxyParamCaption})}



Checks if a column or its descendants have non-\/empty null rows   

\begin{DoxyNote}{注解}
This function is exact. If it returns {\ttfamily true}, there exists one or more non-\/empty null elements.
\end{DoxyNote}
A LIST or STRING column might have non-\/empty rows that are marked as null. A STRUCT OR LIST column might have child columns that have non-\/empty null rows. Other types of columns are deemed incapable of having non-\/empty null rows. E.\+g. Fixed width columns have no concept of an \"{}empty\"{} row.


\begin{DoxyParams}{参数}
{\em input} & The column which is (and whose descendants are) to be checked for non-\/empty null rows. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
true If either the column or its descendants have non-\/empty null rows 

false If neither the column or its descendants have non-\/empty null rows  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_ac670d683b1e9e5c0682c3e2d23e79563}\label{namespacecudf_1_1detail_ac670d683b1e9e5c0682c3e2d23e79563} 
\index{cudf::detail@{cudf::detail}!hash@{hash}}
\index{hash@{hash}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{hash()}{hash()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::hash (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{input,  }\item[{\mbox{\hyperlink{group__column__hash_gaced8b9d129825edd13d76e912e4413c3}{hash\+\_\+id}}}]{hash\+\_\+function = {\ttfamily \mbox{\hyperlink{group__column__hash_ggaced8b9d129825edd13d76e912e4413c3ae9ec854e962136b1afcf108e5301c354}{hash\+\_\+id\+::\+HASH\+\_\+\+MURMUR3}}},  }\item[{uint32\+\_\+t}]{seed = {\ttfamily \mbox{\hyperlink{group__column__hash_ga68de1d04aa2c0ea2eeacfc73fd99a915}{cudf\+::\+DEFAULT\+\_\+\+HASH\+\_\+\+SEED}}},  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Computes the hash value of each row in the input set of columns.   


\begin{DoxyParams}{参数}
{\em input} & The table of columns to hash \\
\hline
{\em hash\+\_\+function} & The hash function enum to use \\
\hline
{\em seed} & Optional seed value to use for the hash function \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A column where each row is the hash of a column from the input  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a31fed6fb6d5421eadcf1516f8d4e4fe9}\label{namespacecudf_1_1detail_a31fed6fb6d5421eadcf1516f8d4e4fe9} 
\index{cudf::detail@{cudf::detail}!hash\_combine@{hash\_combine}}
\index{hash\_combine@{hash\_combine}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{hash\_combine()}{hash\_combine()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily constexpr std\+::size\+\_\+t cudf\+::detail\+::hash\+\_\+combine (\begin{DoxyParamCaption}\item[{std\+::size\+\_\+t}]{lhs,  }\item[{std\+::size\+\_\+t}]{rhs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [constexpr]}}



Combines two hash values into a single hash value. 

Adapted from Boost hash\+\_\+combine function and modified for 64-\/bit. \href{https://www.boost.org/doc/libs/1_35_0/doc/html/boost/hash_combine_id241013.html}{\texttt{ https\+://www.\+boost.\+org/doc/libs/1\+\_\+35\+\_\+0/doc/html/boost/hash\+\_\+combine\+\_\+id241013.\+html}}


\begin{DoxyParams}{参数}
{\em lhs} & The first hash value \\
\hline
{\em rhs} & The second hash value \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Combined hash value 
\end{DoxyReturn}


在文件 \mbox{\hyperlink{detail_2hashing_8hpp_source}{hashing.\+hpp}} 第 \mbox{\hyperlink{detail_2hashing_8hpp_source_l00095}{95}} 行定义.

\Hypertarget{namespacecudf_1_1detail_afacc4b3c523b45ae3046691dcc061191}\label{namespacecudf_1_1detail_afacc4b3c523b45ae3046691dcc061191} 
\index{cudf::detail@{cudf::detail}!hash\_combine@{hash\_combine}}
\index{hash\_combine@{hash\_combine}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{hash\_combine()}{hash\_combine()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily constexpr uint32\+\_\+t cudf\+::detail\+::hash\+\_\+combine (\begin{DoxyParamCaption}\item[{uint32\+\_\+t}]{lhs,  }\item[{uint32\+\_\+t}]{rhs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [constexpr]}}



Combines two hash values into a single hash value. 

Taken from the Boost hash\+\_\+combine function. \href{https://www.boost.org/doc/libs/1_35_0/doc/html/boost/hash_combine_id241013.html}{\texttt{ https\+://www.\+boost.\+org/doc/libs/1\+\_\+35\+\_\+0/doc/html/boost/hash\+\_\+combine\+\_\+id241013.\+html}}


\begin{DoxyParams}{参数}
{\em lhs} & The first hash value \\
\hline
{\em rhs} & The second hash value \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Combined hash value 
\end{DoxyReturn}


在文件 \mbox{\hyperlink{detail_2hashing_8hpp_source}{hashing.\+hpp}} 第 \mbox{\hyperlink{detail_2hashing_8hpp_source_l00074}{74}} 行定义.

\Hypertarget{namespacecudf_1_1detail_acc8016a38976fc8af9b8a9b3c23a08ae}\label{namespacecudf_1_1detail_acc8016a38976fc8af9b8a9b3c23a08ae} 
\index{cudf::detail@{cudf::detail}!inclusive\_dense\_rank\_scan@{inclusive\_dense\_rank\_scan}}
\index{inclusive\_dense\_rank\_scan@{inclusive\_dense\_rank\_scan}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{inclusive\_dense\_rank\_scan()}{inclusive\_dense\_rank\_scan()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::inclusive\+\_\+dense\+\_\+rank\+\_\+scan (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{order\+\_\+by,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr }\end{DoxyParamCaption})}



Generate row dense ranks for a column. 


\begin{DoxyParams}{参数}
{\em order\+\_\+by} & Input column to generate ranks for. \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
rank values. 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1detail_ab6f61e90d14f101f0f7da7f140649f80}\label{namespacecudf_1_1detail_ab6f61e90d14f101f0f7da7f140649f80} 
\index{cudf::detail@{cudf::detail}!inclusive\_one\_normalized\_percent\_rank\_scan@{inclusive\_one\_normalized\_percent\_rank\_scan}}
\index{inclusive\_one\_normalized\_percent\_rank\_scan@{inclusive\_one\_normalized\_percent\_rank\_scan}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{inclusive\_one\_normalized\_percent\_rank\_scan()}{inclusive\_one\_normalized\_percent\_rank\_scan()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::inclusive\+\_\+one\+\_\+normalized\+\_\+percent\+\_\+rank\+\_\+scan (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{order\+\_\+by,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr }\end{DoxyParamCaption})}



Generate row ONE\+\_\+\+NORMALIZED percent ranks for a column. Also, knowns as ANSI SQL PERCENT RANK. Calculated by (rank -\/ 1) / (count -\/ 1). 


\begin{DoxyParams}{参数}
{\em order\+\_\+by} & Input column to generate ranks for. \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
rank values. 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1detail_a2b644db01ab5c564aa3e2e865669b59d}\label{namespacecudf_1_1detail_a2b644db01ab5c564aa3e2e865669b59d} 
\index{cudf::detail@{cudf::detail}!inclusive\_rank\_scan@{inclusive\_rank\_scan}}
\index{inclusive\_rank\_scan@{inclusive\_rank\_scan}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{inclusive\_rank\_scan()}{inclusive\_rank\_scan()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::inclusive\+\_\+rank\+\_\+scan (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{order\+\_\+by,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr }\end{DoxyParamCaption})}



Generate row ranks for a column. 


\begin{DoxyParams}{参数}
{\em order\+\_\+by} & Input column to generate ranks for. \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
rank values. 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1detail_af99f371b8101fc545e0c64553e5d81a9}\label{namespacecudf_1_1detail_af99f371b8101fc545e0c64553e5d81a9} 
\index{cudf::detail@{cudf::detail}!inplace\_bitmask\_and@{inplace\_bitmask\_and}}
\index{inplace\_bitmask\_and@{inplace\_bitmask\_and}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{inplace\_bitmask\_and()}{inplace\_bitmask\_and()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{cudf\+::size\+\_\+type}} cudf\+::detail\+::inplace\+\_\+bitmask\+\_\+and (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga1d17001baf070a639c3a5e8ed8c46d34}{bitmask\+\_\+type}} $>$}]{dest\+\_\+mask,  }\item[{\mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga1d17001baf070a639c3a5e8ed8c46d34}{bitmask\+\_\+type}} const \texorpdfstring{$\ast$}{*}const $>$}]{masks,  }\item[{\mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$}]{masks\+\_\+begin\+\_\+bits,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{mask\+\_\+size\+\_\+bits,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream }\end{DoxyParamCaption})}



Performs a bitwise AND of the specified bitmasks, and writes in place to destination 


\begin{DoxyParams}{参数}
{\em dest\+\_\+mask} & Destination to which the AND result is written \\
\hline
{\em masks} & The list of data pointers of the bitmasks to be ANDed \\
\hline
{\em masks\+\_\+begin\+\_\+bits} & The bit offsets from which each mask is to be ANDed \\
\hline
{\em mask\+\_\+size\+\_\+bits} & The number of bits to be ANDed in each mask \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Count of set bits 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1detail_a08a76bcdabba736bbb9948129f723028}\label{namespacecudf_1_1detail_a08a76bcdabba736bbb9948129f723028} 
\index{cudf::detail@{cudf::detail}!interleave\_columns@{interleave\_columns}}
\index{interleave\_columns@{interleave\_columns}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{interleave\_columns()}{interleave\_columns()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::interleave\+\_\+columns (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{input,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Interleave columns of a table into a single column.   

Converts the column major table {\ttfamily input} into a row major column. Example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{in\ \ \ \ \ =\ [[A1,\ A2,\ A3],\ [B1,\ B2,\ B3]]}
\DoxyCodeLine{\textcolor{keywordflow}{return}\ =\ [A1,\ B1,\ A2,\ B2,\ A3,\ B3]}

\end{DoxyCode}



\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if input contains no columns. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if input columns dtypes are not identical.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em input} & Table containing columns to interleave \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
The interleaved columns as a single column  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a342ee3e4fa47300f2b57966d0eb3405f}\label{namespacecudf_1_1detail_a342ee3e4fa47300f2b57966d0eb3405f} 
\index{cudf::detail@{cudf::detail}!is\_element\_valid\_sync@{is\_element\_valid\_sync}}
\index{is\_element\_valid\_sync@{is\_element\_valid\_sync}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{is\_element\_valid\_sync()}{is\_element\_valid\_sync()}}
{\footnotesize\ttfamily bool cudf\+::detail\+::is\+\_\+element\+\_\+valid\+\_\+sync (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{col\+\_\+view,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{element\+\_\+index,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream }\end{DoxyParamCaption})}



Return validity of a row 

Retrieves the validity (NULL or non-\/\+NULL) of the specified row from device memory.

\begin{DoxyNote}{注解}
Synchronizes {\ttfamily stream}.
\end{DoxyNote}

\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily element\+\_\+index \texorpdfstring{$<$}{<} 0 or \texorpdfstring{$>$}{>}= col\+\_\+view.\+size()}\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em col\+\_\+view} & The column to retrieve the validity from. \\
\hline
{\em element\+\_\+index} & The index of the row to retrieve. \\
\hline
{\em stream} & The stream to use for copying the validity to the host. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Host boolean that indicates the validity of the row. 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1detail_a87fb076548c816c8477d213d3b56362a}\label{namespacecudf_1_1detail_a87fb076548c816c8477d213d3b56362a} 
\index{cudf::detail@{cudf::detail}!is\_nan@{is\_nan}}
\index{is\_nan@{is\_nan}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{is\_nan()}{is\_nan()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::is\+\_\+nan (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{cudf\+::column\+\_\+view}} const \&}]{input,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Creates a column of {\ttfamily \doxylink{group__utility__types_ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd}{type\+\_\+id\+::\+BOOL8}} elements indicating the presence of {\ttfamily NaN} values in a column of floating point values. The output element at row {\ttfamily i} is {\ttfamily true} if the element in {\ttfamily input} at row i is {\ttfamily NAN}, else {\ttfamily false}   


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily input} is a non-\/floating point type\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em input} & A column of floating-\/point elements \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A non-\/nullable column of {\ttfamily \doxylink{group__utility__types_ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd}{type\+\_\+id\+::\+BOOL8}} elements with {\ttfamily true} representing {\ttfamily NAN} values  
\end{DoxyReturn}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_aab222fc99bdf3b292820aa2502058869}\label{namespacecudf_1_1detail_aab222fc99bdf3b292820aa2502058869} 
\index{cudf::detail@{cudf::detail}!is\_not\_nan@{is\_not\_nan}}
\index{is\_not\_nan@{is\_not\_nan}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{is\_not\_nan()}{is\_not\_nan()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::is\+\_\+not\+\_\+nan (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{cudf\+::column\+\_\+view}} const \&}]{input,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Creates a column of {\ttfamily \doxylink{group__utility__types_ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd}{type\+\_\+id\+::\+BOOL8}} elements indicating the absence of {\ttfamily NaN} values in a column of floating point values. The output element at row {\ttfamily i} is {\ttfamily false} if the element in {\ttfamily input} at row i is {\ttfamily NAN}, else {\ttfamily true}   


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily input} is a non-\/floating point type\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em input} & A column of floating-\/point elements \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A non-\/nullable column of {\ttfamily \doxylink{group__utility__types_ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd}{type\+\_\+id\+::\+BOOL8}} elements with {\ttfamily false} representing {\ttfamily NAN} values  
\end{DoxyReturn}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a3723537389c05b4a90958589c304f2fb}\label{namespacecudf_1_1detail_a3723537389c05b4a90958589c304f2fb} 
\index{cudf::detail@{cudf::detail}!is\_relationally\_comparable@{is\_relationally\_comparable}}
\index{is\_relationally\_comparable@{is\_relationally\_comparable}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{is\_relationally\_comparable()}{is\_relationally\_comparable()}}
{\footnotesize\ttfamily template$<$typename Table\+View $>$ \\
bool cudf\+::detail\+::is\+\_\+relationally\+\_\+comparable (\begin{DoxyParamCaption}\item[{Table\+View const \&}]{lhs,  }\item[{Table\+View const \&}]{rhs }\end{DoxyParamCaption})}



Indicates whether respective columns in input tables are relationally comparable. 


\begin{DoxyParams}{参数}
{\em lhs} & The first table \\
\hline
{\em rhs} & The second table (may be the same table as {\ttfamily lhs}) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
true all of respective columns on {\ttfamily lhs} and \textquotesingle{}rhs{\ttfamily tables are comparable. @return false any of respective columns on}lhs{\ttfamily and \textquotesingle{}rhs} tables are not comparable. 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1detail_a8c566f1ff3c273be1518ca5f7d92d4cc}\label{namespacecudf_1_1detail_a8c566f1ff3c273be1518ca5f7d92d4cc} 
\index{cudf::detail@{cudf::detail}!is\_shallow\_equivalent@{is\_shallow\_equivalent}}
\index{is\_shallow\_equivalent@{is\_shallow\_equivalent}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{is\_shallow\_equivalent()}{is\_shallow\_equivalent()}}
{\footnotesize\ttfamily bool cudf\+::detail\+::is\+\_\+shallow\+\_\+equivalent (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{lhs,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{rhs }\end{DoxyParamCaption})}



Uses only shallow state to determine if two {\ttfamily \doxylink{classcudf_1_1column__view}{column\+\_\+view}}s view equivalent columns 

Two columns are equivalent if for any operation {\ttfamily F} then\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{namespacecudf_1_1detail_a8c566f1ff3c273be1518ca5f7d92d4cc}{is\_shallow\_equivalent}}(c0,\ c1)\ ==>\ The\ results\ of\ F(c0)\ and\ F(c1)\ are\ equivalent}

\end{DoxyCode}
 For any two non-\/empty columns, {\ttfamily is\+\_\+shallow\+\_\+equivalent(c0,c1)} is true only if they view the exact same physical column. In other words, two physically independent columns may have exactly equivalent elements but their shallow state would not be equivalent.

The complexity of this function is {\ttfamily O( min(count\+\_\+descendants(lhs), count\+\_\+descendants(rhs)) )}, i.\+e., it is independent of the number of elements in either column.

This function does {\itshape not} inspect the elements of {\ttfamily lhs} or {\ttfamily rhs} nor access any device memory nor launch any kernels.


\begin{DoxyParams}{参数}
{\em lhs} & The left {\ttfamily \doxylink{classcudf_1_1column__view}{column\+\_\+view}} to compare \\
\hline
{\em rhs} & The right {\ttfamily \doxylink{classcudf_1_1column__view}{column\+\_\+view}} to compare \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
If {\ttfamily lhs} and {\ttfamily rhs} have equivalent shallow state 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1detail_af8a7ba935c016e3b7c537937d88e038f}\label{namespacecudf_1_1detail_af8a7ba935c016e3b7c537937d88e038f} 
\index{cudf::detail@{cudf::detail}!is\_sum\_product\_agg@{is\_sum\_product\_agg}}
\index{is\_sum\_product\_agg@{is\_sum\_product\_agg}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{is\_sum\_product\_agg()}{is\_sum\_product\_agg()}}
{\footnotesize\ttfamily constexpr bool cudf\+::detail\+::is\+\_\+sum\+\_\+product\+\_\+agg (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1aggregation_a83579ae3cab2fc3d1c3b377d1cfab24c}{aggregation\+::\+Kind}}}]{k }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [constexpr]}}



在文件 \mbox{\hyperlink{detail_2aggregation_2aggregation_8hpp_source}{aggregation.\+hpp}} 第 \mbox{\hyperlink{detail_2aggregation_2aggregation_8hpp_source_l01177}{1177}} 行定义.

\Hypertarget{namespacecudf_1_1detail_a79d87c0aa523a30c8ab5b806ab4bb62e}\label{namespacecudf_1_1detail_a79d87c0aa523a30c8ab5b806ab4bb62e} 
\index{cudf::detail@{cudf::detail}!is\_valid\_aggregation@{is\_valid\_aggregation}}
\index{is\_valid\_aggregation@{is\_valid\_aggregation}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{is\_valid\_aggregation()}{is\_valid\_aggregation()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Source , \mbox{\hyperlink{classcudf_1_1aggregation_a83579ae3cab2fc3d1c3b377d1cfab24c}{aggregation\+::\+Kind}} k$>$ \\
constexpr bool cudf\+::detail\+::is\+\_\+valid\+\_\+aggregation (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}}



Indicates whether the specified aggregation {\ttfamily k} is valid to perform on the type {\ttfamily Source}. 


\begin{DoxyTemplParams}{模板参数}
{\em Source} & Type on which the aggregation is performed \\
\hline
{\em k} & The aggregation to perform \\
\hline
\end{DoxyTemplParams}


在文件 \mbox{\hyperlink{detail_2aggregation_2aggregation_8hpp_source}{aggregation.\+hpp}} 第 \mbox{\hyperlink{detail_2aggregation_2aggregation_8hpp_source_l01537}{1537}} 行定义.

\Hypertarget{namespacecudf_1_1detail_a2e1ec5de7e8b76d00528c28ba90d8fc1}\label{namespacecudf_1_1detail_a2e1ec5de7e8b76d00528c28ba90d8fc1} 
\index{cudf::detail@{cudf::detail}!is\_valid\_aggregation@{is\_valid\_aggregation}}
\index{is\_valid\_aggregation@{is\_valid\_aggregation}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{is\_valid\_aggregation()}{is\_valid\_aggregation()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool cudf\+::detail\+::is\+\_\+valid\+\_\+aggregation (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}}}]{source,  }\item[{\mbox{\hyperlink{classcudf_1_1aggregation_a83579ae3cab2fc3d1c3b377d1cfab24c}{aggregation\+::\+Kind}}}]{k }\end{DoxyParamCaption})}



Indicates whether the specified aggregation {\ttfamily k} is valid to perform on the {\ttfamily \doxylink{classcudf_1_1data__type}{data\+\_\+type}} {\ttfamily source}. 


\begin{DoxyParams}{参数}
{\em source} & Source {\ttfamily \doxylink{classcudf_1_1data__type}{data\+\_\+type}} on which the aggregation is performed \\
\hline
{\em k} & The aggregation to perform \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a45dd74287624f555fcfb232087bb16e6}\label{namespacecudf_1_1detail_a45dd74287624f555fcfb232087bb16e6} 
\index{cudf::detail@{cudf::detail}!lower\_bound@{lower\_bound}}
\index{lower\_bound@{lower\_bound}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{lower\_bound()}{lower\_bound()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::lower\+\_\+bound (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{haystack,  }\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{needles,  }\item[{std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga750f02016b046079f7062d334890b4fc}{order}} $>$ const \&}]{column\+\_\+order,  }\item[{std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga058e6d6e8a21583ce0e85ee73e5abb31}{null\+\_\+order}} $>$ const \&}]{null\+\_\+precedence,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr }\end{DoxyParamCaption})}



Find smallest indices in a sorted table where values should be inserted to maintain order.   

For each row in {\ttfamily needles}, find the first index in {\ttfamily haystack} where inserting the row still maintains its sort order.


\begin{DoxyCode}{0}
\DoxyCodeLine{Example:}
\DoxyCodeLine{}
\DoxyCodeLine{\ Single\ column:}
\DoxyCodeLine{\ \ \ \ \ idx\ \ \ \ \ \ \ \ 0\ \ \ 1\ \ \ 2\ \ \ 3\ \ \ 4}
\DoxyCodeLine{\ \ haystack\ =\ \{\ 10,\ 20,\ 20,\ 30,\ 50\ \}}
\DoxyCodeLine{\ \ needles\ \ =\ \{\ 20\ \}}
\DoxyCodeLine{\ \ result\ \ \ =\ \{\ \ 1\ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ Multi\ Column:}
\DoxyCodeLine{\ \ \ \ \ idx\ \ \ \ \ \ \ \ \ \ 0\ \ \ \ 1\ \ \ \ 2\ \ \ \ 3\ \ \ \ 4}
\DoxyCodeLine{\ \ haystack\ =\ \{\{\ \ 10,\ \ 20,\ \ 20,\ \ 20,\ \ 20\ \},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\ 5.0,\ \ .5,\ \ .5,\ \ .7,\ \ .7\ \},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\ \ 90,\ \ 77,\ \ 78,\ \ 61,\ \ 61\ \}\}}
\DoxyCodeLine{\ \ needles\ \ =\ \{\{\ 20\ \},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\ .7\ \},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\ 61\ \}\}}
\DoxyCodeLine{\ \ result\ \ \ =\ \{\ \ \ 3\ \}}

\end{DoxyCode}



\begin{DoxyParams}{参数}
{\em haystack} & The table containing search space \\
\hline
{\em needles} & Values for which to find the insert locations in the search space \\
\hline
{\em column\+\_\+order} & Vector of column sort order \\
\hline
{\em null\+\_\+precedence} & Vector of null\+\_\+precedence enums needles \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A non-\/nullable column of \doxylink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{cudf\+::size\+\_\+type} elements containing the insertion points  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_ad3025511800f795e70b22eba7fd0def7}\label{namespacecudf_1_1detail_ad3025511800f795e70b22eba7fd0def7} 
\index{cudf::detail@{cudf::detail}!make\_device\_uvector\_async@{make\_device\_uvector\_async}}
\index{make\_device\_uvector\_async@{make\_device\_uvector\_async}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{make\_device\_uvector\_async()}{make\_device\_uvector\_async()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename Container , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+convertible\+\_\+v$<$ Container, \mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$<$ typename Container\+::value\+\_\+type const $>$ $>$ $>$ \texorpdfstring{$\ast$}{*}  = nullptr$>$ \\
rmm\+::device\+\_\+uvector$<$ typename Container\+::value\+\_\+type $>$ cudf\+::detail\+::make\+\_\+device\+\_\+uvector\+\_\+async (\begin{DoxyParamCaption}\item[{Container const \&}]{c,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Asynchronously construct a {\ttfamily device\+\_\+uvector} containing a deep copy of data from a host container 

Asynchronously construct a {\ttfamily device\+\_\+uvector} containing a deep copy of data from a device container

\begin{DoxyNote}{注解}
This function does not synchronize {\ttfamily stream}.
\end{DoxyNote}

\begin{DoxyTemplParams}{模板参数}
{\em Container} & The type of the container to copy from \\
\hline
{\em T} & The type of the data to copy \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{参数}
{\em c} & The input host container from which to copy \\
\hline
{\em stream} & The stream on which to allocate memory and perform the copy \\
\hline
{\em mr} & The memory resource to use for allocating the returned device\+\_\+uvector \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A device\+\_\+uvector containing the copied data
\end{DoxyReturn}


\begin{DoxyNote}{注解}
This function does not synchronize {\ttfamily stream}.
\end{DoxyNote}

\begin{DoxyTemplParams}{模板参数}
{\em Container} & The type of the container to copy from \\
\hline
{\em T} & The type of the data to copy \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{参数}
{\em c} & The input device container from which to copy \\
\hline
{\em stream} & The stream on which to allocate memory and perform the copy \\
\hline
{\em mr} & The memory resource to use for allocating the returned device\+\_\+uvector \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A device\+\_\+uvector containing the copied data 
\end{DoxyReturn}


在文件 \mbox{\hyperlink{vector__factories_8hpp_source}{vector\+\_\+factories.\+hpp}} 第 \mbox{\hyperlink{vector__factories_8hpp_source_l00128}{128}} 行定义.

\Hypertarget{namespacecudf_1_1detail_a556dd2e77b79628c78ec6718935f565d}\label{namespacecudf_1_1detail_a556dd2e77b79628c78ec6718935f565d} 
\index{cudf::detail@{cudf::detail}!make\_device\_uvector\_async@{make\_device\_uvector\_async}}
\index{make\_device\_uvector\_async@{make\_device\_uvector\_async}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{make\_device\_uvector\_async()}{make\_device\_uvector\_async()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
rmm\+::device\+\_\+uvector$<$ T $>$ cudf\+::detail\+::make\+\_\+device\+\_\+uvector\+\_\+async (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ T const $>$}]{source\+\_\+data,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Asynchronously construct a {\ttfamily device\+\_\+uvector} containing a deep copy of data from a {\ttfamily \doxylink{structcudf_1_1device__span}{device\+\_\+span}} 

\begin{DoxyNote}{注解}
This function does not synchronize {\ttfamily stream}.
\end{DoxyNote}

\begin{DoxyTemplParams}{模板参数}
{\em T} & The type of the data to copy \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{参数}
{\em source\+\_\+data} & The \doxylink{structcudf_1_1device__span}{device\+\_\+span} of data to deep copy \\
\hline
{\em stream} & The stream on which to allocate memory and perform the copy \\
\hline
{\em mr} & The memory resource to use for allocating the returned device\+\_\+uvector \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A device\+\_\+uvector containing the copied data 
\end{DoxyReturn}


在文件 \mbox{\hyperlink{vector__factories_8hpp_source}{vector\+\_\+factories.\+hpp}} 第 \mbox{\hyperlink{vector__factories_8hpp_source_l00149}{149}} 行定义.

\Hypertarget{namespacecudf_1_1detail_af58212f43ad1509a309bf99b6abcabb3}\label{namespacecudf_1_1detail_af58212f43ad1509a309bf99b6abcabb3} 
\index{cudf::detail@{cudf::detail}!make\_device\_uvector\_async@{make\_device\_uvector\_async}}
\index{make\_device\_uvector\_async@{make\_device\_uvector\_async}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{make\_device\_uvector\_async()}{make\_device\_uvector\_async()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
rmm\+::device\+\_\+uvector$<$ T $>$ cudf\+::detail\+::make\+\_\+device\+\_\+uvector\+\_\+async (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$<$ T const $>$}]{source\+\_\+data,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Asynchronously construct a {\ttfamily device\+\_\+uvector} containing a deep copy of data from a {\ttfamily \doxylink{structcudf_1_1host__span}{host\+\_\+span}} 

\begin{DoxyNote}{注解}
This function does not synchronize {\ttfamily stream}.
\end{DoxyNote}

\begin{DoxyTemplParams}{模板参数}
{\em T} & The type of the data to copy \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{参数}
{\em source\+\_\+data} & The \doxylink{structcudf_1_1host__span}{host\+\_\+span} of data to deep copy \\
\hline
{\em stream} & The stream on which to allocate memory and perform the copy \\
\hline
{\em mr} & The memory resource to use for allocating the returned device\+\_\+uvector \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A device\+\_\+uvector containing the copied data 
\end{DoxyReturn}


在文件 \mbox{\hyperlink{vector__factories_8hpp_source}{vector\+\_\+factories.\+hpp}} 第 \mbox{\hyperlink{vector__factories_8hpp_source_l00097}{97}} 行定义.

\Hypertarget{namespacecudf_1_1detail_a5f1c217de33d11bb490a51d1904361f9}\label{namespacecudf_1_1detail_a5f1c217de33d11bb490a51d1904361f9} 
\index{cudf::detail@{cudf::detail}!make\_device\_uvector\_sync@{make\_device\_uvector\_sync}}
\index{make\_device\_uvector\_sync@{make\_device\_uvector\_sync}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{make\_device\_uvector\_sync()}{make\_device\_uvector\_sync()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename Container , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+convertible\+\_\+v$<$ Container, \mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$<$ typename Container\+::value\+\_\+type const $>$ $>$ $>$ \texorpdfstring{$\ast$}{*}  = nullptr$>$ \\
rmm\+::device\+\_\+uvector$<$ typename Container\+::value\+\_\+type $>$ cudf\+::detail\+::make\+\_\+device\+\_\+uvector\+\_\+sync (\begin{DoxyParamCaption}\item[{Container const \&}]{c,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Synchronously construct a {\ttfamily device\+\_\+uvector} containing a deep copy of data from a host container 

Synchronously construct a {\ttfamily device\+\_\+uvector} containing a deep copy of data from a device container

\begin{DoxyNote}{注解}
This function synchronizes {\ttfamily stream}.
\end{DoxyNote}

\begin{DoxyTemplParams}{模板参数}
{\em Container} & The type of the container to copy from \\
\hline
{\em T} & The type of the data to copy \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{参数}
{\em c} & The input host container from which to copy \\
\hline
{\em stream} & The stream on which to allocate memory and perform the copy \\
\hline
{\em mr} & The memory resource to use for allocating the returned device\+\_\+uvector \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A device\+\_\+uvector containing the copied data
\end{DoxyReturn}


\begin{DoxyNote}{注解}
This function synchronizes {\ttfamily stream}.
\end{DoxyNote}

\begin{DoxyTemplParams}{模板参数}
{\em Container} & The type of the container to copy from \\
\hline
{\em T} & The type of the data to copy \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{参数}
{\em c} & The input device container from which to copy \\
\hline
{\em stream} & The stream on which to allocate memory and perform the copy \\
\hline
{\em mr} & The memory resource to use for allocating the returned device\+\_\+uvector \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A device\+\_\+uvector containing the copied data 
\end{DoxyReturn}


在文件 \mbox{\hyperlink{vector__factories_8hpp_source}{vector\+\_\+factories.\+hpp}} 第 \mbox{\hyperlink{vector__factories_8hpp_source_l00229}{229}} 行定义.

\Hypertarget{namespacecudf_1_1detail_a5a7fae42222fe71f2374141166c508cc}\label{namespacecudf_1_1detail_a5a7fae42222fe71f2374141166c508cc} 
\index{cudf::detail@{cudf::detail}!make\_device\_uvector\_sync@{make\_device\_uvector\_sync}}
\index{make\_device\_uvector\_sync@{make\_device\_uvector\_sync}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{make\_device\_uvector\_sync()}{make\_device\_uvector\_sync()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
rmm\+::device\+\_\+uvector$<$ T $>$ cudf\+::detail\+::make\+\_\+device\+\_\+uvector\+\_\+sync (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ T const $>$}]{source\+\_\+data,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Synchronously construct a {\ttfamily device\+\_\+uvector} containing a deep copy of data from a {\ttfamily \doxylink{structcudf_1_1device__span}{device\+\_\+span}} 

\begin{DoxyNote}{注解}
This function synchronizes {\ttfamily stream}.
\end{DoxyNote}

\begin{DoxyTemplParams}{模板参数}
{\em T} & The type of the data to copy \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{参数}
{\em source\+\_\+data} & The \doxylink{structcudf_1_1device__span}{device\+\_\+span} of data to deep copy \\
\hline
{\em stream} & The stream on which to allocate memory and perform the copy \\
\hline
{\em mr} & The memory resource to use for allocating the returned device\+\_\+uvector \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A device\+\_\+uvector containing the copied data 
\end{DoxyReturn}


在文件 \mbox{\hyperlink{vector__factories_8hpp_source}{vector\+\_\+factories.\+hpp}} 第 \mbox{\hyperlink{vector__factories_8hpp_source_l00250}{250}} 行定义.

\Hypertarget{namespacecudf_1_1detail_a567b65a608d7b1818cff9632b3dafde8}\label{namespacecudf_1_1detail_a567b65a608d7b1818cff9632b3dafde8} 
\index{cudf::detail@{cudf::detail}!make\_device\_uvector\_sync@{make\_device\_uvector\_sync}}
\index{make\_device\_uvector\_sync@{make\_device\_uvector\_sync}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{make\_device\_uvector\_sync()}{make\_device\_uvector\_sync()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
rmm\+::device\+\_\+uvector$<$ T $>$ cudf\+::detail\+::make\+\_\+device\+\_\+uvector\+\_\+sync (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$<$ T const $>$}]{source\+\_\+data,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Synchronously construct a {\ttfamily device\+\_\+uvector} containing a deep copy of data from a {\ttfamily \doxylink{structcudf_1_1host__span}{host\+\_\+span}} 

\begin{DoxyNote}{注解}
This function synchronizes {\ttfamily stream}.
\end{DoxyNote}

\begin{DoxyTemplParams}{模板参数}
{\em T} & The type of the data to copy \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{参数}
{\em source\+\_\+data} & The \doxylink{structcudf_1_1host__span}{host\+\_\+span} of data to deep copy \\
\hline
{\em stream} & The stream on which to allocate memory and perform the copy \\
\hline
{\em mr} & The memory resource to use for allocating the returned device\+\_\+uvector \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A device\+\_\+uvector containing the copied data 
\end{DoxyReturn}


在文件 \mbox{\hyperlink{vector__factories_8hpp_source}{vector\+\_\+factories.\+hpp}} 第 \mbox{\hyperlink{vector__factories_8hpp_source_l00202}{202}} 行定义.

\Hypertarget{namespacecudf_1_1detail_ac8a6ec6815c3166045d3417e832d1601}\label{namespacecudf_1_1detail_ac8a6ec6815c3166045d3417e832d1601} 
\index{cudf::detail@{cudf::detail}!make\_host\_vector\_async@{make\_host\_vector\_async}}
\index{make\_host\_vector\_async@{make\_host\_vector\_async}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{make\_host\_vector\_async()}{make\_host\_vector\_async()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Container , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+convertible\+\_\+v$<$ Container, \mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ typename Container\+::value\+\_\+type const $>$ $>$ $>$ \texorpdfstring{$\ast$}{*}  = nullptr$>$ \\
thrust\+::host\+\_\+vector$<$ typename Container\+::value\+\_\+type $>$ cudf\+::detail\+::make\+\_\+host\+\_\+vector\+\_\+async (\begin{DoxyParamCaption}\item[{Container const \&}]{c,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream }\end{DoxyParamCaption})}



Asynchronously construct a {\ttfamily std\+::vector} containing a copy of data from a device container 

\begin{DoxyNote}{注解}
This function synchronizes {\ttfamily stream}.
\end{DoxyNote}

\begin{DoxyTemplParams}{模板参数}
{\em Container} & The type of the container to copy from \\
\hline
{\em T} & The type of the data to copy \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{参数}
{\em c} & The input device container from which to copy \\
\hline
{\em stream} & The stream on which to perform the copy \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
The data copied to the host 
\end{DoxyReturn}


在文件 \mbox{\hyperlink{vector__factories_8hpp_source}{vector\+\_\+factories.\+hpp}} 第 \mbox{\hyperlink{vector__factories_8hpp_source_l00408}{408}} 行定义.

\Hypertarget{namespacecudf_1_1detail_a6a6bc114d57f9b4ebe7b1fd1c0debeb3}\label{namespacecudf_1_1detail_a6a6bc114d57f9b4ebe7b1fd1c0debeb3} 
\index{cudf::detail@{cudf::detail}!make\_host\_vector\_async@{make\_host\_vector\_async}}
\index{make\_host\_vector\_async@{make\_host\_vector\_async}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{make\_host\_vector\_async()}{make\_host\_vector\_async()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
thrust\+::host\+\_\+vector$<$ T $>$ cudf\+::detail\+::make\+\_\+host\+\_\+vector\+\_\+async (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ T const $>$}]{v,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream }\end{DoxyParamCaption})}



Asynchronously construct a {\ttfamily thrust\+::host\+\_\+vector} containing a copy of data from a {\ttfamily \doxylink{structcudf_1_1device__span}{device\+\_\+span}} 

\begin{DoxyNote}{注解}
This function does not synchronize {\ttfamily stream}.
\end{DoxyNote}

\begin{DoxyTemplParams}{模板参数}
{\em T} & The type of the data to copy \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{参数}
{\em source\+\_\+data} & The device data to copy \\
\hline
{\em stream} & The stream on which to perform the copy \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
The data copied to the host 
\end{DoxyReturn}


在文件 \mbox{\hyperlink{vector__factories_8hpp_source}{vector\+\_\+factories.\+hpp}} 第 \mbox{\hyperlink{vector__factories_8hpp_source_l00387}{387}} 行定义.

\Hypertarget{namespacecudf_1_1detail_a19a07077e71fffd39a9bae1ef7bfa379}\label{namespacecudf_1_1detail_a19a07077e71fffd39a9bae1ef7bfa379} 
\index{cudf::detail@{cudf::detail}!make\_host\_vector\_sync@{make\_host\_vector\_sync}}
\index{make\_host\_vector\_sync@{make\_host\_vector\_sync}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{make\_host\_vector\_sync()}{make\_host\_vector\_sync()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Container , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+convertible\+\_\+v$<$ Container, \mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ typename Container\+::value\+\_\+type const $>$ $>$ $>$ \texorpdfstring{$\ast$}{*}  = nullptr$>$ \\
thrust\+::host\+\_\+vector$<$ typename Container\+::value\+\_\+type $>$ cudf\+::detail\+::make\+\_\+host\+\_\+vector\+\_\+sync (\begin{DoxyParamCaption}\item[{Container const \&}]{c,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream }\end{DoxyParamCaption})}



Synchronously construct a {\ttfamily std\+::vector} containing a copy of data from a device container 

\begin{DoxyNote}{注解}
This function synchronizes {\ttfamily stream}.
\end{DoxyNote}

\begin{DoxyTemplParams}{模板参数}
{\em Container} & The type of the container to copy from \\
\hline
{\em T} & The type of the data to copy \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{参数}
{\em c} & The input device container from which to copy \\
\hline
{\em stream} & The stream on which to perform the copy \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
The data copied to the host 
\end{DoxyReturn}


在文件 \mbox{\hyperlink{vector__factories_8hpp_source}{vector\+\_\+factories.\+hpp}} 第 \mbox{\hyperlink{vector__factories_8hpp_source_l00449}{449}} 行定义.

\Hypertarget{namespacecudf_1_1detail_ac324b531a3240ff154b04007561c9f34}\label{namespacecudf_1_1detail_ac324b531a3240ff154b04007561c9f34} 
\index{cudf::detail@{cudf::detail}!make\_host\_vector\_sync@{make\_host\_vector\_sync}}
\index{make\_host\_vector\_sync@{make\_host\_vector\_sync}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{make\_host\_vector\_sync()}{make\_host\_vector\_sync()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
thrust\+::host\+\_\+vector$<$ T $>$ cudf\+::detail\+::make\+\_\+host\+\_\+vector\+\_\+sync (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ T const $>$}]{v,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream }\end{DoxyParamCaption})}



Synchronously construct a {\ttfamily std\+::vector} containing a copy of data from a {\ttfamily \doxylink{structcudf_1_1device__span}{device\+\_\+span}} 

\begin{DoxyNote}{注解}
This function does a synchronize on {\ttfamily stream}.
\end{DoxyNote}

\begin{DoxyTemplParams}{模板参数}
{\em T} & The type of the data to copy \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{参数}
{\em source\+\_\+data} & The device data to copy \\
\hline
{\em stream} & The stream on which to perform the copy \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
The data copied to the host 
\end{DoxyReturn}


在文件 \mbox{\hyperlink{vector__factories_8hpp_source}{vector\+\_\+factories.\+hpp}} 第 \mbox{\hyperlink{vector__factories_8hpp_source_l00426}{426}} 行定义.

\Hypertarget{namespacecudf_1_1detail_af13119be3a169f0210957725db3d144d}\label{namespacecudf_1_1detail_af13119be3a169f0210957725db3d144d} 
\index{cudf::detail@{cudf::detail}!make\_std\_vector\_async@{make\_std\_vector\_async}}
\index{make\_std\_vector\_async@{make\_std\_vector\_async}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{make\_std\_vector\_async()}{make\_std\_vector\_async()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Container , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+convertible\+\_\+v$<$ Container, \mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ typename Container\+::value\+\_\+type const $>$ $>$ $>$ \texorpdfstring{$\ast$}{*}  = nullptr$>$ \\
std\+::vector$<$ typename Container\+::value\+\_\+type $>$ cudf\+::detail\+::make\+\_\+std\+\_\+vector\+\_\+async (\begin{DoxyParamCaption}\item[{Container const \&}]{c,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream }\end{DoxyParamCaption})}



Asynchronously construct a {\ttfamily std\+::vector} containing a copy of data from a device container 

\begin{DoxyNote}{注解}
This function synchronizes {\ttfamily stream}.
\end{DoxyNote}

\begin{DoxyTemplParams}{模板参数}
{\em Container} & The type of the container to copy from \\
\hline
{\em T} & The type of the data to copy \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{参数}
{\em c} & The input device container from which to copy \\
\hline
{\em stream} & The stream on which to perform the copy \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
The data copied to the host 
\end{DoxyReturn}


在文件 \mbox{\hyperlink{vector__factories_8hpp_source}{vector\+\_\+factories.\+hpp}} 第 \mbox{\hyperlink{vector__factories_8hpp_source_l00328}{328}} 行定义.

\Hypertarget{namespacecudf_1_1detail_a0f86869461e901b87a711c8fb331c17a}\label{namespacecudf_1_1detail_a0f86869461e901b87a711c8fb331c17a} 
\index{cudf::detail@{cudf::detail}!make\_std\_vector\_async@{make\_std\_vector\_async}}
\index{make\_std\_vector\_async@{make\_std\_vector\_async}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{make\_std\_vector\_async()}{make\_std\_vector\_async()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
std\+::vector$<$ T $>$ cudf\+::detail\+::make\+\_\+std\+\_\+vector\+\_\+async (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ T const $>$}]{v,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream }\end{DoxyParamCaption})}



Asynchronously construct a {\ttfamily std\+::vector} containing a copy of data from a {\ttfamily \doxylink{structcudf_1_1device__span}{device\+\_\+span}} 

\begin{DoxyNote}{注解}
This function does not synchronize {\ttfamily stream}.
\end{DoxyNote}

\begin{DoxyTemplParams}{模板参数}
{\em T} & The type of the data to copy \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{参数}
{\em source\+\_\+data} & The device data to copy \\
\hline
{\em stream} & The stream on which to perform the copy \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
The data copied to the host 
\end{DoxyReturn}


在文件 \mbox{\hyperlink{vector__factories_8hpp_source}{vector\+\_\+factories.\+hpp}} 第 \mbox{\hyperlink{vector__factories_8hpp_source_l00307}{307}} 行定义.

\Hypertarget{namespacecudf_1_1detail_a76e49334977092cc1447d12b3aad3b76}\label{namespacecudf_1_1detail_a76e49334977092cc1447d12b3aad3b76} 
\index{cudf::detail@{cudf::detail}!make\_std\_vector\_sync@{make\_std\_vector\_sync}}
\index{make\_std\_vector\_sync@{make\_std\_vector\_sync}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{make\_std\_vector\_sync()}{make\_std\_vector\_sync()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Container , std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+convertible\+\_\+v$<$ Container, \mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ typename Container\+::value\+\_\+type const $>$ $>$ $>$ \texorpdfstring{$\ast$}{*}  = nullptr$>$ \\
std\+::vector$<$ typename Container\+::value\+\_\+type $>$ cudf\+::detail\+::make\+\_\+std\+\_\+vector\+\_\+sync (\begin{DoxyParamCaption}\item[{Container const \&}]{c,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream }\end{DoxyParamCaption})}



Synchronously construct a {\ttfamily std\+::vector} containing a copy of data from a device container 

\begin{DoxyNote}{注解}
This function synchronizes {\ttfamily stream}.
\end{DoxyNote}

\begin{DoxyTemplParams}{模板参数}
{\em Container} & The type of the container to copy from \\
\hline
{\em T} & The type of the data to copy \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{参数}
{\em c} & The input device container from which to copy \\
\hline
{\em stream} & The stream on which to perform the copy \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
The data copied to the host 
\end{DoxyReturn}


在文件 \mbox{\hyperlink{vector__factories_8hpp_source}{vector\+\_\+factories.\+hpp}} 第 \mbox{\hyperlink{vector__factories_8hpp_source_l00369}{369}} 行定义.

\Hypertarget{namespacecudf_1_1detail_aea3ae2fa6ca2edd73742c6e0ffcb8d49}\label{namespacecudf_1_1detail_aea3ae2fa6ca2edd73742c6e0ffcb8d49} 
\index{cudf::detail@{cudf::detail}!make\_std\_vector\_sync@{make\_std\_vector\_sync}}
\index{make\_std\_vector\_sync@{make\_std\_vector\_sync}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{make\_std\_vector\_sync()}{make\_std\_vector\_sync()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
std\+::vector$<$ T $>$ cudf\+::detail\+::make\+\_\+std\+\_\+vector\+\_\+sync (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ T const $>$}]{v,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream }\end{DoxyParamCaption})}



Synchronously construct a {\ttfamily std\+::vector} containing a copy of data from a {\ttfamily \doxylink{structcudf_1_1device__span}{device\+\_\+span}} 

\begin{DoxyNote}{注解}
This function does a synchronize on {\ttfamily stream}.
\end{DoxyNote}

\begin{DoxyTemplParams}{模板参数}
{\em T} & The type of the data to copy \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{参数}
{\em source\+\_\+data} & The device data to copy \\
\hline
{\em stream} & The stream on which to perform the copy \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
The data copied to the host 
\end{DoxyReturn}


在文件 \mbox{\hyperlink{vector__factories_8hpp_source}{vector\+\_\+factories.\+hpp}} 第 \mbox{\hyperlink{vector__factories_8hpp_source_l00346}{346}} 行定义.

\Hypertarget{namespacecudf_1_1detail_a0b73da63a9fe3fdc5f94d0095cb43c83}\label{namespacecudf_1_1detail_a0b73da63a9fe3fdc5f94d0095cb43c83} 
\index{cudf::detail@{cudf::detail}!make\_vector\_async@{make\_vector\_async}}
\index{make\_vector\_async@{make\_vector\_async}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{make\_vector\_async()}{make\_vector\_async()}}
{\footnotesize\ttfamily template$<$typename T , typename Out\+Container $>$ \\
Out\+Container cudf\+::detail\+::make\+\_\+vector\+\_\+async (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ T const $>$}]{v,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream }\end{DoxyParamCaption})}



在文件 \mbox{\hyperlink{vector__factories_8hpp_source}{vector\+\_\+factories.\+hpp}} 第 \mbox{\hyperlink{vector__factories_8hpp_source_l00287}{287}} 行定义.

\Hypertarget{namespacecudf_1_1detail_ab330bdc16d921431c949ade216386305}\label{namespacecudf_1_1detail_ab330bdc16d921431c949ade216386305} 
\index{cudf::detail@{cudf::detail}!make\_zeroed\_device\_uvector\_async@{make\_zeroed\_device\_uvector\_async}}
\index{make\_zeroed\_device\_uvector\_async@{make\_zeroed\_device\_uvector\_async}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{make\_zeroed\_device\_uvector\_async()}{make\_zeroed\_device\_uvector\_async()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
rmm\+::device\+\_\+uvector$<$ T $>$ cudf\+::detail\+::make\+\_\+zeroed\+\_\+device\+\_\+uvector\+\_\+async (\begin{DoxyParamCaption}\item[{std\+::size\+\_\+t}]{size,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Asynchronously construct a {\ttfamily device\+\_\+uvector} and set all elements to zero. 

\begin{DoxyNote}{注解}
This function does not synchronize {\ttfamily stream}.
\end{DoxyNote}

\begin{DoxyTemplParams}{模板参数}
{\em T} & The type of the data to copy \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{参数}
{\em size} & The number of elements in the created vector \\
\hline
{\em stream} & The stream on which to allocate memory and perform the memset \\
\hline
{\em mr} & The memory resource to use for allocating the returned device\+\_\+uvector \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A device\+\_\+uvector containing zeros 
\end{DoxyReturn}


在文件 \mbox{\hyperlink{vector__factories_8hpp_source}{vector\+\_\+factories.\+hpp}} 第 \mbox{\hyperlink{vector__factories_8hpp_source_l00051}{51}} 行定义.

\Hypertarget{namespacecudf_1_1detail_a1cbce3bdea9ae93c27fedd21b4177e4f}\label{namespacecudf_1_1detail_a1cbce3bdea9ae93c27fedd21b4177e4f} 
\index{cudf::detail@{cudf::detail}!make\_zeroed\_device\_uvector\_sync@{make\_zeroed\_device\_uvector\_sync}}
\index{make\_zeroed\_device\_uvector\_sync@{make\_zeroed\_device\_uvector\_sync}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{make\_zeroed\_device\_uvector\_sync()}{make\_zeroed\_device\_uvector\_sync()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
rmm\+::device\+\_\+uvector$<$ T $>$ cudf\+::detail\+::make\+\_\+zeroed\+\_\+device\+\_\+uvector\+\_\+sync (\begin{DoxyParamCaption}\item[{std\+::size\+\_\+t}]{size,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Synchronously construct a {\ttfamily device\+\_\+uvector} and set all elements to zero. 

\begin{DoxyNote}{注解}
This function synchronizes {\ttfamily stream}.
\end{DoxyNote}

\begin{DoxyTemplParams}{模板参数}
{\em T} & The type of the data to copy \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{参数}
{\em size} & The number of elements in the created vector \\
\hline
{\em stream} & The stream on which to allocate memory and perform the memset \\
\hline
{\em mr} & The memory resource to use for allocating the returned device\+\_\+uvector \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A device\+\_\+uvector containing zeros 
\end{DoxyReturn}


在文件 \mbox{\hyperlink{vector__factories_8hpp_source}{vector\+\_\+factories.\+hpp}} 第 \mbox{\hyperlink{vector__factories_8hpp_source_l00073}{73}} 行定义.

\Hypertarget{namespacecudf_1_1detail_adcca95b53757f3fc776e4a53c762e318}\label{namespacecudf_1_1detail_adcca95b53757f3fc776e4a53c762e318} 
\index{cudf::detail@{cudf::detail}!mask\_to\_bools@{mask\_to\_bools}}
\index{mask\_to\_bools@{mask\_to\_bools}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{mask\_to\_bools()}{mask\_to\_bools()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::mask\+\_\+to\+\_\+bools (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__utility__types_ga1d17001baf070a639c3a5e8ed8c46d34}{bitmask\+\_\+type}} const \texorpdfstring{$\ast$}{*}}]{null\+\_\+mask,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{begin\+\_\+bit,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{end\+\_\+bit,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Creates a boolean column from given bitmask.   

Returns a {\ttfamily bool} for each bit in {\ttfamily \mbox{[}begin\+\_\+bit, end\+\_\+bit)}. If bit {\ttfamily i} in least-\/significant bit numbering is set (1), then element {\ttfamily i} in the output is {\ttfamily true}, otherwise {\ttfamily false}.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily bitmask} is null and end\+\_\+bit-\/begin\+\_\+bit \texorpdfstring{$>$}{>} 0 \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if begin\+\_\+bit \texorpdfstring{$>$}{>} end\+\_\+bit\\
\hline
\end{DoxyExceptions}
Examples\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{input:\ \{0b10101010\}}
\DoxyCodeLine{output:\ [\{false,\ true,\ false,\ true,\ false,\ true,\ false,\ true\}]}

\end{DoxyCode}



\begin{DoxyParams}{参数}
{\em bitmask} & A device pointer to the bitmask which needs to be converted \\
\hline
{\em begin\+\_\+bit} & position of the bit from which the conversion should start \\
\hline
{\em end\+\_\+bit} & position of the bit before which the conversion should stop \\
\hline
{\em mr} & Device memory resource used to allocate the returned columns\textquotesingle{} device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A boolean column representing the given mask from \mbox{[}begin\+\_\+bit, end\+\_\+bit)  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a0d9d7614373d0ef4f4538d1920c6d732}\label{namespacecudf_1_1detail_a0d9d7614373d0ef4f4538d1920c6d732} 
\index{cudf::detail@{cudf::detail}!may\_have\_nonempty\_nulls@{may\_have\_nonempty\_nulls}}
\index{may\_have\_nonempty\_nulls@{may\_have\_nonempty\_nulls}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{may\_have\_nonempty\_nulls()}{may\_have\_nonempty\_nulls()}}
{\footnotesize\ttfamily bool cudf\+::detail\+::may\+\_\+have\+\_\+nonempty\+\_\+nulls (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{input,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream }\end{DoxyParamCaption})}



Approximates if a column or its descendants {\itshape may} have non-\/empty null elements   

\begin{DoxyNote}{注解}
This function is approximate.
\begin{DoxyItemize}
\item {\ttfamily true}\+: Non-\/empty null elements could exist
\item {\ttfamily false}\+: Non-\/empty null elements definitely do not exist
\end{DoxyItemize}
\end{DoxyNote}
False positives are possible, but false negatives are not.

Compared to the exact {\ttfamily \doxylink{namespacecudf_1_1detail_a5758db52c9f99ddaab9a9de11fd25f4d}{has\+\_\+nonempty\+\_\+nulls()}} function, this function is typically more efficient.

Complexity\+:
\begin{DoxyItemize}
\item Best case\+: {\ttfamily O(count\+\_\+descendants(input))}
\item Worst case\+: {\ttfamily O(count\+\_\+descendants(input)) \texorpdfstring{$\ast$}{*} m}, where {\ttfamily m} is the number of rows in the largest descendant
\end{DoxyItemize}


\begin{DoxyParams}{参数}
{\em input} & The column which is (and whose descendants are) to be checked for non-\/empty null rows \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
true If either the column or its descendants have null rows 

false If neither the column nor its descendants have null rows  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_affdf27f8bc86ce410050f009d8b9d894}\label{namespacecudf_1_1detail_affdf27f8bc86ce410050f009d8b9d894} 
\index{cudf::detail@{cudf::detail}!md5\_hash@{md5\_hash}}
\index{md5\_hash@{md5\_hash}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{md5\_hash()}{md5\_hash()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::md5\+\_\+hash (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{input,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}

\Hypertarget{namespacecudf_1_1detail_a349e2b28175e2d9ea71d7761fd9b03ce}\label{namespacecudf_1_1detail_a349e2b28175e2d9ea71d7761fd9b03ce} 
\index{cudf::detail@{cudf::detail}!murmur\_hash3\_32@{murmur\_hash3\_32}}
\index{murmur\_hash3\_32@{murmur\_hash3\_32}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{murmur\_hash3\_32()}{murmur\_hash3\_32()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::murmur\+\_\+hash3\+\_\+32 (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{input,  }\item[{uint32\+\_\+t}]{seed = {\ttfamily \mbox{\hyperlink{group__column__hash_ga68de1d04aa2c0ea2eeacfc73fd99a915}{cudf\+::\+DEFAULT\+\_\+\+HASH\+\_\+\+SEED}}},  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}

\Hypertarget{namespacecudf_1_1detail_abb7e1bd82e43f366a0455d2c606ff212}\label{namespacecudf_1_1detail_abb7e1bd82e43f366a0455d2c606ff212} 
\index{cudf::detail@{cudf::detail}!nans\_to\_nulls@{nans\_to\_nulls}}
\index{nans\_to\_nulls@{nans\_to\_nulls}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{nans\_to\_nulls()}{nans\_to\_nulls()}}
{\footnotesize\ttfamily std\+::pair$<$ std\+::unique\+\_\+ptr$<$ rmm\+::device\+\_\+buffer $>$, \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ cudf\+::detail\+::nans\+\_\+to\+\_\+nulls (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{input,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Creates a null\+\_\+mask from {\ttfamily input} by converting {\ttfamily NaN} to null and preserving existing null values and also returns new null\+\_\+count.   


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily input.\+type()} is a non-\/floating type\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em input} & An immutable view of the input column of floating-\/point type \\
\hline
{\em mr} & Device memory resource used to allocate the returned bitmask \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A pair containing a {\ttfamily device\+\_\+buffer} with the new bitmask and it\textquotesingle{}s null count obtained by replacing {\ttfamily NaN} in {\ttfamily input} with null.  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a841c17146b279d123c4d579ddd7e7f14}\label{namespacecudf_1_1detail_a841c17146b279d123c4d579ddd7e7f14} 
\index{cudf::detail@{cudf::detail}!normalize\_nans\_and\_zeros@{normalize\_nans\_and\_zeros}}
\index{normalize\_nans\_and\_zeros@{normalize\_nans\_and\_zeros}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{normalize\_nans\_and\_zeros()}{normalize\_nans\_and\_zeros()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::normalize\+\_\+nans\+\_\+and\+\_\+zeros (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{input,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Copies from a column of floating-\/point elements and replaces {\ttfamily -\/NaN} and {\ttfamily -\/0.\+0} with {\ttfamily +NaN} and {\ttfamily +0.\+0}, respectively.   

Converts floating point values from {\ttfamily input} using the following rules\+: Convert -\/NaN -\/\texorpdfstring{$>$}{>} NaN Convert -\/0.\+0 -\/\texorpdfstring{$>$}{>} 0.\+0


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if column does not have floating point data type. \\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em input} & \doxylink{classcudf_1_1column__view}{column\+\_\+view} of floating-\/point elements to copy and normalize \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & device\+\_\+memory\+\_\+resource allocator for allocating output data\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
new column with the modified data  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a289827dc5428527e139352669318e55f}\label{namespacecudf_1_1detail_a289827dc5428527e139352669318e55f} 
\index{cudf::detail@{cudf::detail}!null\_count@{null\_count}}
\index{null\_count@{null\_count}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{null\_count()}{null\_count()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{cudf\+::size\+\_\+type}} cudf\+::detail\+::null\+\_\+count (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__utility__types_ga1d17001baf070a639c3a5e8ed8c46d34}{bitmask\+\_\+type}} const \texorpdfstring{$\ast$}{*}}]{bitmask,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{start,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{stop,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream }\end{DoxyParamCaption})}



Given a validity bitmask, counts the number of null elements (unset bits) in the range {\ttfamily \mbox{[}start, stop)}. 

If {\ttfamily bitmask == nullptr}, all elements are assumed to be valid and the function returns \`{}\`{}.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily start \texorpdfstring{$>$}{>} stop} \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily start \texorpdfstring{$<$}{<} 0}\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em bitmask} & Validity bitmask residing in device memory. \\
\hline
\mbox{\texttt{ in}}  & {\em start} & Index of the first bit to count (inclusive). \\
\hline
\mbox{\texttt{ in}}  & {\em stop} & Index of the last bit to count (exclusive). \\
\hline
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
The number of null elements in the specified range. 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1detail_ad30bc52a8dbe05164e2d5fc0b49e1844}\label{namespacecudf_1_1detail_ad30bc52a8dbe05164e2d5fc0b49e1844} 
\index{cudf::detail@{cudf::detail}!one\_hot\_encode@{one\_hot\_encode}}
\index{one\_hot\_encode@{one\_hot\_encode}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{one\_hot\_encode()}{one\_hot\_encode()}}
{\footnotesize\ttfamily std\+::pair$<$ std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$, \mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} $>$ cudf\+::detail\+::one\+\_\+hot\+\_\+encode (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{input,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{categories,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Encodes {\ttfamily input} by generating a new column for each value in {\ttfamily categories} indicating the presence of that value in {\ttfamily input}.   

The resulting per-\/category columns are returned concatenated as a single column viewed by a {\ttfamily \doxylink{classcudf_1_1table__view}{table\+\_\+view}}.

The {\ttfamily i}th row of the {\ttfamily j}th column in the output table equals 1 if {\ttfamily input\mbox{[}i\mbox{]} == categories\mbox{[}j\mbox{]}}, and 0 otherwise.

The {\ttfamily i}th row of the {\ttfamily j}th column in the output table equals 1 if input\mbox{[}i\mbox{]} == categories\mbox{[}j\mbox{]}, and 0 otherwise.

Examples\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{input:\ [\{'a',\ 'c',\ null,\ 'c',\ 'b'\}]}
\DoxyCodeLine{categories:\ ['c',\ null]}
\DoxyCodeLine{output:\ [\{0,\ 1,\ 0,\ 1,\ 0\},\ \{0,\ 0,\ 1,\ 0,\ 0\}]}

\end{DoxyCode}



\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if input and categories are of different types.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em input} & Column containing values to be encoded \\
\hline
{\em categories} & Column containing categories \\
\hline
{\em mr} & Device memory resource used to allocate the returned table\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A pair containing the owner to all encoded data and a table view into the data  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_ab8fcbfc5ff5585cc426e609ab8da1720}\label{namespacecudf_1_1detail_ab8fcbfc5ff5585cc426e609ab8da1720} 
\index{cudf::detail@{cudf::detail}!pack@{pack}}
\index{pack@{pack}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{pack()}{pack()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structcudf_1_1packed__columns}{packed\+\_\+columns}} cudf\+::detail\+::pack (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{cudf\+::table\+\_\+view}} const \&}]{input,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Deep-\/copy a {\ttfamily \doxylink{classcudf_1_1table__view}{table\+\_\+view}} into a serialized contiguous memory format   

The metadata from the {\ttfamily \doxylink{classcudf_1_1table__view}{table\+\_\+view}} is copied into a host vector of bytes and the data from the {\ttfamily \doxylink{classcudf_1_1table__view}{table\+\_\+view}} is copied into a {\ttfamily device\+\_\+buffer}. Pass the output of this function into {\ttfamily \doxylink{group__column__copy_ga1d62a18c2e6f087a92289c63693762cc}{cudf\+::unpack}} to deserialize.


\begin{DoxyParams}[1]{参数}
 & {\em input} & View of the table to pack \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Optional, The resource to use for all returned device allocations \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
\doxylink{structcudf_1_1packed__columns}{packed\+\_\+columns} A struct containing the serialized metadata and data in contiguous host and device memory respectively  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & Optional CUDA stream on which to execute kernels \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a698c778a6399397c6013e7d45c835b4c}\label{namespacecudf_1_1detail_a698c778a6399397c6013e7d45c835b4c} 
\index{cudf::detail@{cudf::detail}!percentile\_approx@{percentile\_approx}}
\index{percentile\_approx@{percentile\_approx}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{percentile\_approx()}{percentile\_approx()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::percentile\+\_\+approx (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1tdigest_1_1tdigest__column__view}{tdigest\+::tdigest\+\_\+column\+\_\+view}} const \&}]{input,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{percentiles,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}






\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_aacc2fd111114777e8e4e26c3295ca04b}\label{namespacecudf_1_1detail_aacc2fd111114777e8e4e26c3295ca04b} 
\index{cudf::detail@{cudf::detail}!purge\_nonempty\_nulls@{purge\_nonempty\_nulls}}
\index{purge\_nonempty\_nulls@{purge\_nonempty\_nulls}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{purge\_nonempty\_nulls()}{purge\_nonempty\_nulls()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::purge\+\_\+nonempty\+\_\+nulls (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{input,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Copy {\ttfamily input} into output while purging any non-\/empty null rows in the column or its descendants.   

If the input column is not of compound type (LIST/\+STRING/\+STRUCT/\+DICTIONARY), the output will be the same as input.

The purge operation only applies directly to LIST and STRING columns, but it applies indirectly to STRUCT/\+DICTIONARY columns as well, since these columns may have child columns that are LIST or STRING.

Examples\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{auto\ const\ lists\ \ \ =\ lists\_column\_wrapper<int32\_t>\{\ \{0,1\},\ \{2,3\},\ \{4,5\}\ \}.release();}
\DoxyCodeLine{cudf::detail::set\_null\_mask(lists-\/>null\_mask(),\ 1,\ 2,\ false);}
\DoxyCodeLine{}
\DoxyCodeLine{lists[1]\ is\ now\ null,\ but\ the\ lists\ child\ column\ still\ stores\ \`{}\{2,3\}`.}
\DoxyCodeLine{The\ lists\ column\ contents\ will\ be:}
\DoxyCodeLine{\ \ Validity:\ 101}
\DoxyCodeLine{\ \ Offsets:\ \ [0,\ 2,\ 4,\ 6]}
\DoxyCodeLine{\ \ Child:\ \ \ \ [0,\ 1,\ 2,\ 3,\ 4,\ 5]}
\DoxyCodeLine{}
\DoxyCodeLine{After\ purging\ the\ contents\ of\ the\ list's\ null\ rows,\ the\ column's\ contents\ will\ be:}
\DoxyCodeLine{\ \ Validity:\ 101}
\DoxyCodeLine{\ \ Offsets:\ \ [0,\ 2,\ 2,\ 4]}
\DoxyCodeLine{\ \ Child:\ \ \ \ [0,\ 1,\ 4,\ 5]}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{auto\ const\ strings\ =\ strings\_column\_wrapper\{\ "{}AB"{},\ "{}CD"{},\ "{}EF"{}\ \}.release();}
\DoxyCodeLine{cudf::detail::set\_null\_mask(strings-\/>null\_mask(),\ 1,\ 2,\ false);}
\DoxyCodeLine{}
\DoxyCodeLine{strings[1]\ is\ now\ null,\ but\ the\ strings\ column\ still\ stores\ \`{}"{}CD"{}`.}
\DoxyCodeLine{The\ lists\ column\ contents\ will\ be:}
\DoxyCodeLine{\ \ Validity:\ 101}
\DoxyCodeLine{\ \ Offsets:\ \ [0,\ 2,\ 4,\ 6]}
\DoxyCodeLine{\ \ Child:\ \ \ \ [A,\ B,\ C,\ D,\ E,\ F]}
\DoxyCodeLine{}
\DoxyCodeLine{After\ purging\ the\ contents\ of\ the\ list's\ null\ rows,\ the\ column's\ contents}
\DoxyCodeLine{will\ be:}
\DoxyCodeLine{\ \ Validity:\ 101}
\DoxyCodeLine{\ \ Offsets:\ \ [0,\ 2,\ 2,\ 4]}
\DoxyCodeLine{\ \ Child:\ \ \ \ [A,\ B,\ E,\ F]}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{auto\ const\ lists\ \ \ =\ lists\_column\_wrapper<int32\_t>\{\ \{0,1\},\ \{2,3\},\ \{4,5\}\ \};}
\DoxyCodeLine{auto\ const\ structs\ =\ structs\_column\_wrapper\{\ \{lists\},\ null\_at(1)\ \};}
\DoxyCodeLine{}
\DoxyCodeLine{structs[1].child\ is\ now\ null,\ but\ the\ lists\ column\ still\ stores\ \`{}\{2,3\}`.}
\DoxyCodeLine{The\ lists\ column\ contents\ will\ be:}
\DoxyCodeLine{\ \ Validity:\ 101}
\DoxyCodeLine{\ \ Offsets:\ \ [0,\ 2,\ 4,\ 6]}
\DoxyCodeLine{\ \ Child:\ \ \ \ [0,\ 1,\ 2,\ 3,\ 4,\ 5]}
\DoxyCodeLine{}
\DoxyCodeLine{After\ purging\ the\ contents\ of\ the\ list's\ null\ rows,\ the\ column's\ contents}
\DoxyCodeLine{will\ be:}
\DoxyCodeLine{\ \ Validity:\ 101}
\DoxyCodeLine{\ \ Offsets:\ \ [0,\ 2,\ 2,\ 4]}
\DoxyCodeLine{\ \ Child:\ \ \ \ [0,\ 1,\ 4,\ 5]}

\end{DoxyCode}



\begin{DoxyParams}{参数}
{\em input} & The column whose null rows are to be checked and purged \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A new column with equivalent contents to {\ttfamily input}, but with null rows purged  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a3f9e3cf937df8cb28860d3fc8e9843d7}\label{namespacecudf_1_1detail_a3f9e3cf937df8cb28860d3fc8e9843d7} 
\index{cudf::detail@{cudf::detail}!quantile@{quantile}}
\index{quantile@{quantile}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{quantile()}{quantile()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::quantile (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{input,  }\item[{std\+::vector$<$ double $>$ const \&}]{q,  }\item[{\mbox{\hyperlink{group__utility__types_ga9cd17c1cdf028ead9a4783f605276ab3}{interpolation}}}]{interp = {\ttfamily \mbox{\hyperlink{group__utility__types_gga9cd17c1cdf028ead9a4783f605276ab3aaac544aacc3615aada24897a215f5046}{interpolation\+::\+LINEAR}}},  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{ordered\+\_\+indices = {\ttfamily \{\}},  }\item[{bool}]{exact = {\ttfamily true},  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Computes quantiles with interpolation.   

Computes the specified quantiles by interpolating values between which they lie, using the interpolation strategy specified in {\ttfamily interp}.


\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em input} & Column from which to compute quantile values \\
\hline
\mbox{\texttt{ in}}  & {\em q} & Specified quantiles in range \mbox{[}0, 1\mbox{]} \\
\hline
\mbox{\texttt{ in}}  & {\em interp} & Strategy used to select between values adjacent to a specified quantile. \\
\hline
\mbox{\texttt{ in}}  & {\em ordered\+\_\+indices} & Column containing the sorted order of {\ttfamily input}. If the column is empty, all {\ttfamily input} values are used in existing order. Indices must be in range \mbox{[}0, {\ttfamily input.\+size()}), but are not required to be unique. Values not indexed by this column will be ignored. \\
\hline
\mbox{\texttt{ in}}  & {\em exact} & If true, returns doubles. If false, returns same type as input. \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Column of specified quantiles, with nulls for indeterminable values  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a9db69c255a5f64c2b3f9e4bc7e73caa9}\label{namespacecudf_1_1detail_a9db69c255a5f64c2b3f9e4bc7e73caa9} 
\index{cudf::detail@{cudf::detail}!quantiles@{quantiles}}
\index{quantiles@{quantiles}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{quantiles()}{quantiles()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::detail\+::quantiles (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{input,  }\item[{std\+::vector$<$ double $>$ const \&}]{q,  }\item[{\mbox{\hyperlink{group__utility__types_ga9cd17c1cdf028ead9a4783f605276ab3}{interpolation}}}]{interp = {\ttfamily \mbox{\hyperlink{group__utility__types_gga9cd17c1cdf028ead9a4783f605276ab3aad135772d7cf93dd0ccf9d2474b34e6a}{interpolation\+::\+NEAREST}}},  }\item[{\mbox{\hyperlink{group__utility__types_gab283c517931abd4152ffa62fec62425d}{cudf\+::sorted}}}]{is\+\_\+input\+\_\+sorted = {\ttfamily \mbox{\hyperlink{group__utility__types_ggab283c517931abd4152ffa62fec62425dac2f3f489a00553e7a01d369c103c7251}{sorted\+::\+NO}}},  }\item[{std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga750f02016b046079f7062d334890b4fc}{order}} $>$ const \&}]{column\+\_\+order = {\ttfamily \{\}},  }\item[{std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga058e6d6e8a21583ce0e85ee73e5abb31}{null\+\_\+order}} $>$ const \&}]{null\+\_\+precedence = {\ttfamily \{\}},  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Returns the rows of the input corresponding to the requested quantiles.   

Quantiles are cut points that divide the range of a dataset into continuous intervals. e.\+g\+: quartiles are the three cut points that divide a dataset into four equal-\/sized groups. See \href{https://en.wikipedia.org/wiki/Quantile}{\texttt{ https\+://en.\+wikipedia.\+org/wiki/\+Quantile}}

The indices used to gather rows are computed by interpolating between the index on either side of the desired quantile. Since some columns may be non-\/arithmetic, interpolation between rows is limited to non-\/arithmetic strategies.

Non-\/arithmetic interpolation strategies include HIGHER, LOWER, and NEAREST.

quantiles {\ttfamily \texorpdfstring{$<$}{<}= 0} correspond to row {\ttfamily 0}. (first) quantiles {\ttfamily \texorpdfstring{$>$}{>}= 1} correspond to row {\ttfamily input.\+size() -\/ 1}. (last)


\begin{DoxyParams}{参数}
{\em input} & Table used to compute quantile rows \\
\hline
{\em q} & Desired quantiles in range \mbox{[}0, 1\mbox{]} \\
\hline
{\em interp} & Strategy used to select between the two rows on either side of the desired quantile. \\
\hline
{\em is\+\_\+input\+\_\+sorted} & Indicates if the input has been pre-\/sorted \\
\hline
{\em column\+\_\+order} & The desired sort order for each column \\
\hline
{\em null\+\_\+precedence} & The desired order of null compared to other elements \\
\hline
{\em mr} & Device memory resource used to allocate the returned table\textquotesingle{}s device memory\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Table of specified quantiles, with nulls for indeterminable values 
\end{DoxyReturn}

\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily interp} is an arithmetic interpolation strategy \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily input} is empty  \\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a47a307e124575b78186601f1c689c05c}\label{namespacecudf_1_1detail_a47a307e124575b78186601f1c689c05c} 
\index{cudf::detail@{cudf::detail}!repeat@{repeat}}
\index{repeat@{repeat}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{repeat()}{repeat()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::detail\+::repeat (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{input\+\_\+table,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{count,  }\item[{bool}]{check\+\_\+count,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}






\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a75705d38197681267f667733ef0c1be4}\label{namespacecudf_1_1detail_a75705d38197681267f667733ef0c1be4} 
\index{cudf::detail@{cudf::detail}!repeat@{repeat}}
\index{repeat@{repeat}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{repeat()}{repeat()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::detail\+::repeat (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{input\+\_\+table,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{count,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Repeat rows of a Table.   

Creates a new table by repeating {\ttfamily count} times the rows of {\ttfamily input\+\_\+table}. Example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{in\ =\ [4,5,6]}
\DoxyCodeLine{count\ =\ 2}
\DoxyCodeLine{\textcolor{keywordflow}{return}\ =\ [4,4,5,5,6,6]}

\end{DoxyCode}
 
\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if the data type of {\ttfamily count} is not size\+\_\+type. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily count} is invalid or {\ttfamily count} is negative. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily input\+\_\+table.\+num\+\_\+rows()} \texorpdfstring{$\ast$}{*} {\ttfamily count} overflows size\+\_\+type.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em input\+\_\+table} & Input table \\
\hline
{\em count} & Number of repetitions \\
\hline
{\em mr} & Device memory resource used to allocate the returned table\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
The result table containing the repetitions  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_ade00a5854797478de85ef4f4735be57d}\label{namespacecudf_1_1detail_ade00a5854797478de85ef4f4735be57d} 
\index{cudf::detail@{cudf::detail}!replace\_nans@{replace\_nans}}
\index{replace\_nans@{replace\_nans}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{replace\_nans()}{replace\_nans()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::replace\+\_\+nans (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{input,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{replacement,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Replaces all NaN values in a column with corresponding values from another column   

If {\ttfamily input\mbox{[}i\mbox{]}} is NaN, then {\ttfamily output\mbox{[}i\mbox{]}} will contain {\ttfamily replacement\mbox{[}i\mbox{]}}. 
\begin{DoxyCode}{0}
\DoxyCodeLine{input\ \ \ \ \ \ \ \ =\ \{1.0,\ NaN,\ 4.0\}}
\DoxyCodeLine{replacement\ \ =\ \{3.0,\ 9.0,\ 7.0\}}
\DoxyCodeLine{output\ \ \ \ \ \ \ =\ \{1.0,\ 9.0,\ 4.0\}}

\end{DoxyCode}


\begin{DoxyNote}{注解}
Nulls are not considered as NaN
\end{DoxyNote}

\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & If {\ttfamily input} and {\ttfamily replacement} are of different type or size. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & If {\ttfamily input} or {\ttfamily replacement} are not of floating-\/point dtype.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em input} & A column whose NaN values will be replaced \\
\hline
{\em replacement} & A \doxylink{classcudf_1_1column}{cudf\+::column} whose values will replace NaN values in input \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A copy of {\ttfamily input} with the NaN values replaced with corresponding values from {\ttfamily replacement}.  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_ad0298a6133c943e5ef6107630fd267f1}\label{namespacecudf_1_1detail_ad0298a6133c943e5ef6107630fd267f1} 
\index{cudf::detail@{cudf::detail}!replace\_nans@{replace\_nans}}
\index{replace\_nans@{replace\_nans}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{replace\_nans()}{replace\_nans()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::replace\+\_\+nans (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{input,  }\item[{\mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&}]{replacement,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Replaces all NaN values in a column with a scalar   

If {\ttfamily input\mbox{[}i\mbox{]}} is NaN, then {\ttfamily output\mbox{[}i\mbox{]}} will contain {\ttfamily replacement}. 
\begin{DoxyCode}{0}
\DoxyCodeLine{input\ \ \ \ \ \ \ \ =\ \{1.0,\ NaN,\ 4.0\}}
\DoxyCodeLine{replacement\ \ =\ 7.0}
\DoxyCodeLine{output\ \ \ \ \ \ \ =\ \{1.0,\ 7.0,\ 4.0\}}

\end{DoxyCode}


\begin{DoxyNote}{注解}
Nulls are not considered as NaN
\end{DoxyNote}

\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & If {\ttfamily input} and {\ttfamily replacement} are of different type. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & If {\ttfamily input} or {\ttfamily replacement} are not of floating-\/point dtype.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em input} & A column whose NaN values will be replaced \\
\hline
{\em replacement} & A \doxylink{classcudf_1_1scalar}{cudf\+::scalar} whose value will replace NaN values in input \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A copy of {\ttfamily input} with the NaN values replaced by {\ttfamily replacement}  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_aa2782e7c057de7e1596841c366b471b3}\label{namespacecudf_1_1detail_aa2782e7c057de7e1596841c366b471b3} 
\index{cudf::detail@{cudf::detail}!replace\_nulls@{replace\_nulls}}
\index{replace\_nulls@{replace\_nulls}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{replace\_nulls()}{replace\_nulls()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::replace\+\_\+nulls (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{input,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{cudf\+::column\+\_\+view}} const \&}]{replacement,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Replaces all null values in a column with corresponding values of another column   

If {\ttfamily input\mbox{[}i\mbox{]}} is NULL, then {\ttfamily output\mbox{[}i\mbox{]}} will contain {\ttfamily replacement\mbox{[}i\mbox{]}}. {\ttfamily input} and {\ttfamily replacement} must be of the same type and size.


\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em input} & A column whose null values will be replaced \\
\hline
\mbox{\texttt{ in}}  & {\em replacement} & A \doxylink{classcudf_1_1column}{cudf\+::column} whose values will replace null values in input \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Device memory resource used to allocate device memory of the returned column\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A copy of {\ttfamily input} with the null values replaced with corresponding values from {\ttfamily replacement}.  
\end{DoxyReturn}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a9c0b4a9cf791df1c239576b67b2d9255}\label{namespacecudf_1_1detail_a9c0b4a9cf791df1c239576b67b2d9255} 
\index{cudf::detail@{cudf::detail}!replace\_nulls@{replace\_nulls}}
\index{replace\_nulls@{replace\_nulls}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{replace\_nulls()}{replace\_nulls()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::replace\+\_\+nulls (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{input,  }\item[{\mbox{\hyperlink{group__transformation__replace_ga7cdbc9bc3671930a743c86f36c38abf9}{replace\+\_\+policy}} const \&}]{replace\+\_\+policy,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Replaces all null values in a column with the first non-\/null value that precedes/follows.   

If {\ttfamily input\mbox{[}i\mbox{]}} is NULL, then {\ttfamily output\mbox{[}i\mbox{]}} will contain the first non-\/null value that precedes or follows the null value, based on {\ttfamily replace\+\_\+policy}.


\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em input} & A column whose null values will be replaced \\
\hline
\mbox{\texttt{ in}}  & {\em replace\+\_\+policy} & Specify the position of replacement values relative to null values \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Device memory resource used to allocate device memory of the returned column\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Copy of {\ttfamily input} with null values replaced based on {\ttfamily replace\+\_\+policy}  
\end{DoxyReturn}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a089e06d35c8fc924a836da9e7fcce84e}\label{namespacecudf_1_1detail_a089e06d35c8fc924a836da9e7fcce84e} 
\index{cudf::detail@{cudf::detail}!replace\_nulls@{replace\_nulls}}
\index{replace\_nulls@{replace\_nulls}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{replace\_nulls()}{replace\_nulls()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::replace\+\_\+nulls (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{input,  }\item[{\mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&}]{replacement,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Replaces all null values in a column with a scalar.   

If {\ttfamily input\mbox{[}i\mbox{]}} is NULL, then {\ttfamily output\mbox{[}i\mbox{]}} will contain {\ttfamily replacement}. {\ttfamily input} and {\ttfamily replacement} must have the same type.


\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em input} & A column whose null values will be replaced \\
\hline
\mbox{\texttt{ in}}  & {\em replacement} & Scalar used to replace null values in {\ttfamily input} \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Device memory resource used to allocate device memory of the returned column\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Copy of {\ttfamily input} with null values replaced by {\ttfamily replacement}  
\end{DoxyReturn}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a10e1b8f89952c1c18a574a822fa8c189}\label{namespacecudf_1_1detail_a10e1b8f89952c1c18a574a822fa8c189} 
\index{cudf::detail@{cudf::detail}!rolling\_window@{rolling\_window}}
\index{rolling\_window@{rolling\_window}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{rolling\_window()}{rolling\_window()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::rolling\+\_\+window (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{input,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{preceding\+\_\+window,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{following\+\_\+window,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{min\+\_\+periods,  }\item[{\mbox{\hyperlink{classcudf_1_1rolling__aggregation}{rolling\+\_\+aggregation}} const \&}]{agg,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



\doxylink{group__aggregation__rolling_gaaed6574615700cec1d4bf5469fe28141}{rolling\+\_\+window(           column\+\_\+view const\& input,           column\+\_\+view const\& preceding\+\_\+window,           column\+\_\+view const\& following\+\_\+window,           size\+\_\+type min\+\_\+periods,           rolling\+\_\+aggregation const\& agg,           rmm\+::mr\+::device\+\_\+memory\+\_\+resource\texorpdfstring{$\ast$}{*} mr)} 

\doxylink{group__aggregation__rolling_gaaed6574615700cec1d4bf5469fe28141}{rolling\+\_\+window(           column\+\_\+view const\& input,           column\+\_\+view const\& preceding\+\_\+window,           column\+\_\+view const\& following\+\_\+window,           size\+\_\+type min\+\_\+periods,           rolling\+\_\+aggregation const\& agg,           rmm\+::mr\+::device\+\_\+memory\+\_\+resource\texorpdfstring{$\ast$}{*} mr)}


\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a8131d320d1ae7d8daea58311bc10ffeb}\label{namespacecudf_1_1detail_a8131d320d1ae7d8daea58311bc10ffeb} 
\index{cudf::detail@{cudf::detail}!round@{round}}
\index{round@{round}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{round()}{round()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::round (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{input,  }\item[{int32\+\_\+t}]{decimal\+\_\+places,  }\item[{\mbox{\hyperlink{group__transformation__unaryops_ga02028fc18312cdb2f07159c6297e74bb}{rounding\+\_\+method}}}]{method,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Rounds all the values in a column to the specified number of decimal places.   

{\ttfamily \doxylink{group__transformation__unaryops_gaaf541a42981e9f31a32de8fdaa105d4b}{cudf\+::round}} currently supports HALF\+\_\+\+UP and HALF\+\_\+\+EVEN rounding for integer, floating point and {\ttfamily decimal32} and {\ttfamily decimal64} numbers. For {\ttfamily decimal32} and {\ttfamily decimal64} numbers, negated {\ttfamily numeric\+::scale} is equivalent to {\ttfamily decimal\+\_\+places}.

Example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{using\ namespace\ }\mbox{\hyperlink{namespacecudf}{cudf}};}
\DoxyCodeLine{}
\DoxyCodeLine{\mbox{\hyperlink{classcudf_1_1column__view}{column\_view}}\ a;\ \textcolor{comment}{//\ contains\ \{\ 1.729,\ 17.29,\ 172.9,\ 1729\ \};}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{auto}\ result1\ =\ \mbox{\hyperlink{namespacecudf_1_1detail_a8131d320d1ae7d8daea58311bc10ffeb}{round}}(a);\ \ \ \ \ \textcolor{comment}{//\ \{\ 2,\ \ \ 17,\ \ \ 173,\ \ \ 1729\ \}}}
\DoxyCodeLine{\textcolor{keyword}{auto}\ result2\ =\ \mbox{\hyperlink{namespacecudf_1_1detail_a8131d320d1ae7d8daea58311bc10ffeb}{round}}(a,\ 1);\ \ \textcolor{comment}{//\ \{\ 1.7,\ 17.3,\ 172.9,\ 1729\ \}}}
\DoxyCodeLine{\textcolor{keyword}{auto}\ result3\ =\ \mbox{\hyperlink{namespacecudf_1_1detail_a8131d320d1ae7d8daea58311bc10ffeb}{round}}(a,\ -\/1);\ \textcolor{comment}{//\ \{\ 0,\ \ \ 20,\ \ \ 170,\ \ \ 1730\ \}}}
\DoxyCodeLine{}
\DoxyCodeLine{\mbox{\hyperlink{classcudf_1_1column__view}{column\_view}}\ b;\ \textcolor{comment}{//\ contains\ \{\ 1.5,\ 2.5,\ 1.35,\ 1.45,\ 15,\ 25\ \};}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{auto}\ result4\ =\ \mbox{\hyperlink{namespacecudf_1_1detail_a8131d320d1ae7d8daea58311bc10ffeb}{round}}(b,\ \ 0,\ \mbox{\hyperlink{group__transformation__unaryops_gga02028fc18312cdb2f07159c6297e74bba29746b187c41c8e51b96a3104cbda3b6}{rounding\_method::HALF\_EVEN}});\ \textcolor{comment}{//\ \{\ 2,\ \ \ 2,\ \ \ 1,\ \ \ 1,\ \ \ 15,\ 25\};}}
\DoxyCodeLine{\textcolor{keyword}{auto}\ result5\ =\ \mbox{\hyperlink{namespacecudf_1_1detail_a8131d320d1ae7d8daea58311bc10ffeb}{round}}(b,\ \ 1,\ \mbox{\hyperlink{group__transformation__unaryops_gga02028fc18312cdb2f07159c6297e74bba29746b187c41c8e51b96a3104cbda3b6}{rounding\_method::HALF\_EVEN}});\ \textcolor{comment}{//\ \{\ 1.5,\ 2.5,\ 1.4,\ 1.4,\ 15,\ 25\};}}
\DoxyCodeLine{\textcolor{keyword}{auto}\ result6\ =\ \mbox{\hyperlink{namespacecudf_1_1detail_a8131d320d1ae7d8daea58311bc10ffeb}{round}}(b,\ -\/1,\ \mbox{\hyperlink{group__transformation__unaryops_gga02028fc18312cdb2f07159c6297e74bba29746b187c41c8e51b96a3104cbda3b6}{rounding\_method::HALF\_EVEN}});\ \textcolor{comment}{//\ \{\ 0,\ \ \ 0,\ \ \ 0,\ \ \ 0,\ \ \ 20,\ 20\};}}

\end{DoxyCode}



\begin{DoxyParams}{参数}
{\em input} & Column of values to be rounded \\
\hline
{\em decimal\+\_\+places} & Number of decimal places to round to (default 0). If negative, this specifies the number of positions to the left of the decimal point. \\
\hline
{\em method} & Rounding method \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
std\+::unique\+\_\+ptr$<$column$>$ Column with each of the values rounded  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a6f65c99023599795be67aafb3c125b88}\label{namespacecudf_1_1detail_a6f65c99023599795be67aafb3c125b88} 
\index{cudf::detail@{cudf::detail}!row\_bit\_count@{row\_bit\_count}}
\index{row\_bit\_count@{row\_bit\_count}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{row\_bit\_count()}{row\_bit\_count()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::row\+\_\+bit\+\_\+count (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{t,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Returns an approximate cumulative size in bits of all columns in the {\ttfamily \doxylink{classcudf_1_1table__view}{table\+\_\+view}} for each row.   

This function counts bits instead of bytes to account for the null mask which only has one bit per row.

Each row in the returned column is the sum of the per-\/row size for each column in the table.

In some cases, this is an inexact approximation. Specifically, columns of lists and strings require N+1 offsets to represent N rows. It is up to the caller to calculate the small additional overhead of the terminating offset for any group of rows being considered.

This function returns the per-\/row sizes as the columns are currently formed. This can end up being larger than the number you would get by gathering the rows. Specifically, the push-\/down of struct column validity masks can nullify rows that contain data for string or list columns. In these cases, the size returned is conservative\+:

row\+\_\+bit\+\_\+count(column(x)) \texorpdfstring{$>$}{>}= row\+\_\+bit\+\_\+count(gather(column(x)))


\begin{DoxyParams}{参数}
{\em t} & The table view to perform the computation on \\
\hline
{\em mr} & Device memory resource used to allocate the returned columns\textquotesingle{} device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A 32-\/bit integer column containing the per-\/row bit counts  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a4a082f6c019d5d3462414e341e949c02}\label{namespacecudf_1_1detail_a4a082f6c019d5d3462414e341e949c02} 
\index{cudf::detail@{cudf::detail}!sample@{sample}}
\index{sample@{sample}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{sample()}{sample()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::detail\+::sample (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{input,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const}]{n,  }\item[{\mbox{\hyperlink{group__column__copy_gae7607cde56cb602ab1b198b5bebf7cba}{sample\+\_\+with\+\_\+replacement}}}]{replacement = {\ttfamily \mbox{\hyperlink{group__column__copy_ggae7607cde56cb602ab1b198b5bebf7cbaa946003f97ccc52d5d3b54ac0ec31bbfc}{sample\+\_\+with\+\_\+replacement\+::\+FALSE}}},  }\item[{int64\+\_\+t const}]{seed = {\ttfamily 0},  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Gather {\ttfamily n} samples from given {\ttfamily input} randomly   


\begin{DoxyCode}{0}
\DoxyCodeLine{Example:}
\DoxyCodeLine{input:\ \{col1:\ \{1,\ 2,\ 3,\ 4,\ 5\},\ col2:\ \{6,\ 7,\ 8,\ 9,\ 10\}\}}
\DoxyCodeLine{n:\ 3}
\DoxyCodeLine{replacement:\ false}
\DoxyCodeLine{}
\DoxyCodeLine{output:\ \ \ \ \ \ \ \{col1:\ \{3,\ 1,\ 4\},\ col2:\ \{8,\ 6,\ 9\}\}}
\DoxyCodeLine{}
\DoxyCodeLine{replacement:\ true}
\DoxyCodeLine{}
\DoxyCodeLine{output:\ \ \ \ \ \ \ \{col1:\ \{3,\ 1,\ 1\},\ col2:\ \{8,\ 6,\ 6\}\}}

\end{DoxyCode}



\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily n} \texorpdfstring{$>$}{>} {\ttfamily input.\+num\+\_\+rows()} and {\ttfamily replacement} == FALSE. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily n} \texorpdfstring{$<$}{<} 0.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em input} & View of a table to sample \\
\hline
{\em n} & non-\/negative number of samples expected from {\ttfamily input} \\
\hline
{\em replacement} & Allow or disallow sampling of the same row more than once \\
\hline
{\em seed} & Seed value to initiate random number generator \\
\hline
{\em mr} & Device memory resource used to allocate the returned table\textquotesingle{}s device memory\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
std\+::unique\+\_\+ptr$<$table$>$ Table containing samples from {\ttfamily input}  
\end{DoxyReturn}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_ac9be538c2fe0b9e74c569460ecc65261}\label{namespacecudf_1_1detail_ac9be538c2fe0b9e74c569460ecc65261} 
\index{cudf::detail@{cudf::detail}!scan\_exclusive@{scan\_exclusive}}
\index{scan\_exclusive@{scan\_exclusive}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{scan\_exclusive()}{scan\_exclusive()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::scan\+\_\+exclusive (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{input,  }\item[{\mbox{\hyperlink{classcudf_1_1scan__aggregation}{scan\+\_\+aggregation}} const \&}]{agg,  }\item[{\mbox{\hyperlink{group__utility__types_ga1b8cda4afb95a7c42c4679b4fae61009}{null\+\_\+policy}}}]{null\+\_\+handling,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr }\end{DoxyParamCaption})}



Computes the exclusive scan of a column. 

The null values are skipped for the operation, and if an input element at {\ttfamily i} is null, then the output element at {\ttfamily i} will also be null.

The identity value for the column type as per the aggregation type is used for the value of the first element in the output column.

Struct columns are allowed with aggregation types Min and Max.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if column \doxylink{classcudf_1_1data__type}{data\+\_\+type} is not an arithmetic type or struct type but the {\ttfamily agg} is not Min or Max.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em input} & The input column view for the scan. \\
\hline
{\em agg} & Aggregation operator applied by the scan \\
\hline
{\em null\+\_\+handling} & Exclude null values when computing the result if \doxylink{group__utility__types_gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8}{null\+\_\+policy\+::\+EXCLUDE}. Include nulls if \doxylink{group__utility__types_gga1b8cda4afb95a7c42c4679b4fae61009a04ff6a9583ba9957ebe1128d0f988ad8}{null\+\_\+policy\+::\+INCLUDE}. Any operation with a null results in a null. \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
{\em mr} & Device memory resource used to allocate the returned scalar\textquotesingle{}s device memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Column with scan results. 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1detail_adc391e283f48ecd780dec6ceb2d0a6f9}\label{namespacecudf_1_1detail_adc391e283f48ecd780dec6ceb2d0a6f9} 
\index{cudf::detail@{cudf::detail}!scan\_inclusive@{scan\_inclusive}}
\index{scan\_inclusive@{scan\_inclusive}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{scan\_inclusive()}{scan\_inclusive()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::scan\+\_\+inclusive (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{input,  }\item[{\mbox{\hyperlink{classcudf_1_1scan__aggregation}{scan\+\_\+aggregation}} const \&}]{agg,  }\item[{\mbox{\hyperlink{group__utility__types_ga1b8cda4afb95a7c42c4679b4fae61009}{null\+\_\+policy}}}]{null\+\_\+handling,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr }\end{DoxyParamCaption})}



Computes the inclusive scan of a column. 

The null values are skipped for the operation, and if an input element at {\ttfamily i} is null, then the output element at {\ttfamily i} will also be null.

String and struct columns are allowed with aggregation types Min and Max.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if column \doxylink{classcudf_1_1data__type}{data\+\_\+type} is not an arithmetic type or string/struct types but the {\ttfamily agg} is not Min or Max.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em input} & The input column view for the scan. \\
\hline
{\em agg} & Aggregation operator applied by the scan \\
\hline
{\em null\+\_\+handling} & Exclude null values when computing the result if \doxylink{group__utility__types_gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8}{null\+\_\+policy\+::\+EXCLUDE}. Include nulls if \doxylink{group__utility__types_gga1b8cda4afb95a7c42c4679b4fae61009a04ff6a9583ba9957ebe1128d0f988ad8}{null\+\_\+policy\+::\+INCLUDE}. Any operation with a null results in a null. \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
{\em mr} & Device memory resource used to allocate the returned scalar\textquotesingle{}s device memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Column with scan results. 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1detail_a5bdf86f00fd97bb400afe50fe644af52}\label{namespacecudf_1_1detail_a5bdf86f00fd97bb400afe50fe644af52} 
\index{cudf::detail@{cudf::detail}!scatter@{scatter}}
\index{scatter@{scatter}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{scatter()}{scatter()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::detail\+::scatter (\begin{DoxyParamCaption}\item[{std\+::vector$<$ std\+::reference\+\_\+wrapper$<$ const \mbox{\hyperlink{classcudf_1_1scalar}{scalar}} $>$ $>$ const \&}]{source,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{indices,  }\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{target,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Scatters a row of scalar values into a copy of the target table according to a scatter map. 

Scatters values from the source row into the target table out-\/of-\/place, returning a \"{}destination table\"{}. The scatter is performed according to a scatter map such that row {\ttfamily scatter\+\_\+map\mbox{[}i\mbox{]}} of the destination table is replaced by the source row. All other rows of the destination table equal corresponding rows of the target table.

The number of elements in source must match the number of columns in target and their corresponding datatypes must be the same.

If the same index appears more than once in the scatter map, the result is undefined.

If any values in {\ttfamily indices} are outside of the interval \mbox{[}-\/n, n) where {\ttfamily n} is the number of rows in the {\ttfamily target} table, behavior is undefined.


\begin{DoxyParams}{参数}
{\em source} & The input scalars containing values to be scattered into the target columns \\
\hline
{\em indices} & A non-\/nullable column of integral indices that indicate the rows in the target table to be replaced by source. \\
\hline
{\em target} & The set of columns into which values from the source\+\_\+table are to be scattered \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
{\em mr} & Device memory resource used to allocate the returned table\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Result of scattering values from source to target 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1detail_ab0fafddc49374af3d9ab6815196d426f}\label{namespacecudf_1_1detail_ab0fafddc49374af3d9ab6815196d426f} 
\index{cudf::detail@{cudf::detail}!scatter@{scatter}}
\index{scatter@{scatter}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{scatter()}{scatter()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::detail\+::scatter (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{source,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{scatter\+\_\+map,  }\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{target,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Scatters the rows of the source table into a copy of the target table according to a scatter map. 

Scatters values from the source table into the target table out-\/of-\/place, returning a \"{}destination table\"{}. The scatter is performed according to a scatter map such that row {\ttfamily scatter\+\_\+map\mbox{[}i\mbox{]}} of the destination table gets row {\ttfamily i} of the source table. All other rows of the destination table equal corresponding rows of the target table.

The number of columns in source must match the number of columns in target and their corresponding datatypes must be the same.

A negative value {\ttfamily i} in the {\ttfamily scatter\+\_\+map} is interpreted as {\ttfamily i+n}, where {\ttfamily n} is the number of rows in the {\ttfamily target} table.

If the same index appears more than once in the scatter map, the result is undefined. If any values in {\ttfamily scatter\+\_\+map} are outside of the interval \mbox{[}-\/n, n) where {\ttfamily n} is the number of rows in the {\ttfamily target} table, behavior is undefined.


\begin{DoxyParams}{参数}
{\em source} & The input columns containing values to be scattered into the target columns \\
\hline
{\em scatter\+\_\+map} & A non-\/nullable column of integral indices that maps the rows in the source table to rows in the target table. The size must be equal to or less than the number of elements in the source columns. \\
\hline
{\em target} & The set of columns into which values from the source\+\_\+table are to be scattered \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
{\em mr} & Device memory resource used to allocate the returned table\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Result of scattering values from source to target 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1detail_a642afeffe44abb5382a4c44534503907}\label{namespacecudf_1_1detail_a642afeffe44abb5382a4c44534503907} 
\index{cudf::detail@{cudf::detail}!scatter@{scatter}}
\index{scatter@{scatter}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{scatter()}{scatter()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::detail\+::scatter (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{source,  }\item[{\mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$ const}]{scatter\+\_\+map,  }\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{target,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}






\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily scatter\+\_\+map} span size is larger than max of {\ttfamily size\+\_\+type}. \\
\hline
\end{DoxyExceptions}
\Hypertarget{namespacecudf_1_1detail_a0568781207d7824429d333aa3a8e0870}\label{namespacecudf_1_1detail_a0568781207d7824429d333aa3a8e0870} 
\index{cudf::detail@{cudf::detail}!segmented\_count\_set\_bits@{segmented\_count\_set\_bits}}
\index{segmented\_count\_set\_bits@{segmented\_count\_set\_bits}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{segmented\_count\_set\_bits()}{segmented\_count\_set\_bits()}}
{\footnotesize\ttfamily std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ cudf\+::detail\+::segmented\+\_\+count\+\_\+set\+\_\+bits (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__utility__types_ga1d17001baf070a639c3a5e8ed8c46d34}{bitmask\+\_\+type}} const \texorpdfstring{$\ast$}{*}}]{bitmask,  }\item[{\mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$}]{indices,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream }\end{DoxyParamCaption})}



Given a bitmask, counts the number of set (1) bits in every range {\ttfamily \mbox{[}indices\mbox{[}2\texorpdfstring{$\ast$}{*}i\mbox{]}, indices\mbox{[}(2\texorpdfstring{$\ast$}{*}i)+1\mbox{]})} (where 0 \texorpdfstring{$<$}{<}= i \texorpdfstring{$<$}{<} indices.\+size() / 2). 


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily bitmask == nullptr} \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily indices.\+size() \% 2 != 0} \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily indices\mbox{[}2\texorpdfstring{$\ast$}{*}i\mbox{]} \texorpdfstring{$<$}{<} 0 or indices\mbox{[}2\texorpdfstring{$\ast$}{*}i\mbox{]} \texorpdfstring{$>$}{>} indices\mbox{[}(2\texorpdfstring{$\ast$}{*}i)+1\mbox{]}}\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em bitmask} & Bitmask residing in device memory whose bits will be counted. \\
\hline
\mbox{\texttt{ in}}  & {\em indices} & A \doxylink{structcudf_1_1host__span}{host\+\_\+span} of indices specifying ranges to count the number of set bits. \\
\hline
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A vector storing the number of non-\/zero bits in the specified ranges. 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1detail_aab0e7344544634b61fd1f48a0931b231}\label{namespacecudf_1_1detail_aab0e7344544634b61fd1f48a0931b231} 
\index{cudf::detail@{cudf::detail}!segmented\_count\_unset\_bits@{segmented\_count\_unset\_bits}}
\index{segmented\_count\_unset\_bits@{segmented\_count\_unset\_bits}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{segmented\_count\_unset\_bits()}{segmented\_count\_unset\_bits()}}
{\footnotesize\ttfamily std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ cudf\+::detail\+::segmented\+\_\+count\+\_\+unset\+\_\+bits (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__utility__types_ga1d17001baf070a639c3a5e8ed8c46d34}{bitmask\+\_\+type}} const \texorpdfstring{$\ast$}{*}}]{bitmask,  }\item[{\mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$}]{indices,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream }\end{DoxyParamCaption})}



Given a bitmask, counts the number of unset (0) bits in every range {\ttfamily \mbox{[}indices\mbox{[}2\texorpdfstring{$\ast$}{*}i\mbox{]}, indices\mbox{[}(2\texorpdfstring{$\ast$}{*}i)+1\mbox{]})} (where 0 \texorpdfstring{$<$}{<}= i \texorpdfstring{$<$}{<} indices.\+size() / 2). 


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily bitmask == nullptr} \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily indices.\+size() \% 2 != 0} \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily indices\mbox{[}2\texorpdfstring{$\ast$}{*}i\mbox{]} \texorpdfstring{$<$}{<} 0 or indices\mbox{[}2\texorpdfstring{$\ast$}{*}i\mbox{]} \texorpdfstring{$>$}{>} indices\mbox{[}(2\texorpdfstring{$\ast$}{*}i)+1\mbox{]}}\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em bitmask} & Bitmask residing in device memory whose bits will be counted. \\
\hline
\mbox{\texttt{ in}}  & {\em indices} & A \doxylink{structcudf_1_1host__span}{host\+\_\+span} of indices specifying ranges to count the number of unset bits. \\
\hline
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A vector storing the number of zero bits in the specified ranges. 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1detail_aee03027237bac182e4be6d37fa6c4f37}\label{namespacecudf_1_1detail_aee03027237bac182e4be6d37fa6c4f37} 
\index{cudf::detail@{cudf::detail}!segmented\_null\_count@{segmented\_null\_count}}
\index{segmented\_null\_count@{segmented\_null\_count}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{segmented\_null\_count()}{segmented\_null\_count()}}
{\footnotesize\ttfamily std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ cudf\+::detail\+::segmented\+\_\+null\+\_\+count (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__utility__types_ga1d17001baf070a639c3a5e8ed8c46d34}{bitmask\+\_\+type}} const \texorpdfstring{$\ast$}{*}}]{bitmask,  }\item[{\mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$}]{indices,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream }\end{DoxyParamCaption})}



Given a validity bitmask, counts the number of null elements (unset bits) in every range {\ttfamily \mbox{[}indices\mbox{[}2\texorpdfstring{$\ast$}{*}i\mbox{]}, indices\mbox{[}(2\texorpdfstring{$\ast$}{*}i)+1\mbox{]})} (where 0 \texorpdfstring{$<$}{<}= i \texorpdfstring{$<$}{<} indices.\+size() / 2). 

If {\ttfamily bitmask == nullptr}, all elements are assumed to be valid and a vector of length {\ttfamily indices.\+size()} containing all zeros is returned.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily indices.\+size() \% 2 != 0} \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily indices\mbox{[}2\texorpdfstring{$\ast$}{*}i\mbox{]} \texorpdfstring{$<$}{<} 0 or indices\mbox{[}2\texorpdfstring{$\ast$}{*}i\mbox{]} \texorpdfstring{$>$}{>} indices\mbox{[}(2\texorpdfstring{$\ast$}{*}i)+1\mbox{]}}\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em bitmask} & Validity bitmask residing in device memory. \\
\hline
\mbox{\texttt{ in}}  & {\em indices} & A \doxylink{structcudf_1_1host__span}{host\+\_\+span} of indices specifying ranges to count the number of null elements. \\
\hline
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A vector storing the number of null elements in each specified range. 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1detail_a3da5b63902793d46d2048b2f5ccb2e41}\label{namespacecudf_1_1detail_a3da5b63902793d46d2048b2f5ccb2e41} 
\index{cudf::detail@{cudf::detail}!segmented\_shift@{segmented\_shift}}
\index{segmented\_shift@{segmented\_shift}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{segmented\_shift()}{segmented\_shift()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::segmented\+\_\+shift (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{segmented\+\_\+values,  }\item[{\mbox{\hyperlink{structcudf_1_1device__span}{device\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$}]{segment\+\_\+offsets,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{offset,  }\item[{\mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&}]{fill\+\_\+value,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Performs segmented shifts for specified values. 

For each segment, {\ttfamily i}th element is determined by the {\ttfamily i -\/ offset}th element of the segment. If {\ttfamily i -\/ offset \texorpdfstring{$<$}{<} 0 or \texorpdfstring{$>$}{>}= segment\+\_\+size}, the value is determined by {\ttfamily fill\+\_\+value}.

Example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{segmented\_values:\ \{\ 3\ 1\ 2\ |\ 3\ 5\ 3\ |\ 2\ 6\ \}}
\DoxyCodeLine{segment\_offsets:\ \{0\ 3\ 6\ 8\}}
\DoxyCodeLine{offset:\ 2}
\DoxyCodeLine{fill\_value:\ @}
\DoxyCodeLine{result:\ \{\ @\ @\ 3\ |\ @\ @\ 3\ |\ @\ @\ \}}
\DoxyCodeLine{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}
\DoxyCodeLine{segmented\_values:\ \{\ 3\ 1\ 2\ |\ 3\ 5\ 3\ |\ 2\ 6\ \}}
\DoxyCodeLine{segment\_offsets:\ \{0\ 3\ 6\ 8\}}
\DoxyCodeLine{offset:\ -\/1}
\DoxyCodeLine{fill\_value:\ -\/1}
\DoxyCodeLine{result:\ \{\ 1\ 2\ -\/1\ |\ 5\ 3\ -\/1\ |\ 6\ -\/1\ \}}

\end{DoxyCode}



\begin{DoxyParams}{参数}
{\em segmented\+\_\+values} & Segmented column, specified by {\ttfamily segment\+\_\+offsets} \\
\hline
{\em segment\+\_\+offsets} & Each segment\textquotesingle{}s offset of {\ttfamily segmented\+\_\+values}. A list of offsets with size {\ttfamily num\+\_\+segments + 1}. The size of each segment is {\ttfamily segment\+\_\+offsets\mbox{[}i+1\mbox{]} -\/ segment\+\_\+offsets\mbox{[}i\mbox{]}}. \\
\hline
{\em offset} & The offset by which to shift the input \\
\hline
{\em fill\+\_\+value} & Fill value for indeterminable outputs \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
{\em mr} & Device memory resource used to allocate the returned table and columns\textquotesingle{} device memory\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{注解}
If {\ttfamily offset == 0}, a copy of {\ttfamily segmented\+\_\+values} is returned. 
\end{DoxyNote}
\Hypertarget{namespacecudf_1_1detail_a0143b14fe58e9f453958200e4bd745b2}\label{namespacecudf_1_1detail_a0143b14fe58e9f453958200e4bd745b2} 
\index{cudf::detail@{cudf::detail}!segmented\_sort\_by\_key@{segmented\_sort\_by\_key}}
\index{segmented\_sort\_by\_key@{segmented\_sort\_by\_key}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{segmented\_sort\_by\_key()}{segmented\_sort\_by\_key()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::detail\+::segmented\+\_\+sort\+\_\+by\+\_\+key (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{values,  }\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{keys,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{segment\+\_\+offsets,  }\item[{std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga750f02016b046079f7062d334890b4fc}{order}} $>$ const \&}]{column\+\_\+order = {\ttfamily \{\}},  }\item[{std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga058e6d6e8a21583ce0e85ee73e5abb31}{null\+\_\+order}} $>$ const \&}]{null\+\_\+precedence = {\ttfamily \{\}},  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Performs a lexicographic segmented sort of a table   

If segment\+\_\+offsets contains values larger than the number of rows, the behavior is undefined. 
\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily values.\+num\+\_\+rows() != keys.\+num\+\_\+rows()}. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily segment\+\_\+offsets} is not {\ttfamily size\+\_\+type} column.\\
\hline
\end{DoxyExceptions}

\begin{DoxyCode}{0}
\DoxyCodeLine{Example:}
\DoxyCodeLine{keys\ =\ \{\ \{9,\ 8,\ 7,\ 6,\ 5,\ 4,\ 3,\ 2,\ 1,\ 0\}\ \}}
\DoxyCodeLine{values\ =\ \{\ \{'a',\ 'b',\ 'c',\ 'd',\ 'e',\ 'f',\ 'g',\ 'h',\ 'i',\ 'j'\}\ \}}
\DoxyCodeLine{offsets\ =\ \{0,\ 3,\ 7,\ 10\}}
\DoxyCodeLine{result\ =\ cudf::segmented\_sort\_by\_key(keys,\ values,\ offsets);}
\DoxyCodeLine{result\ is\ \{\ 'c','b','a',\ 'g','f','e','d',\ 'j','i','h'\ \}}

\end{DoxyCode}


If segment\+\_\+offsets is empty or contains a single index, no values are sorted and the result is a copy of the values.

The segment\+\_\+offsets are not required to include all indices. Any indices outside the specified segments will not be sorted.


\begin{DoxyCode}{0}
\DoxyCodeLine{Example:\ (offsets\ do\ not\ cover\ all\ indices)}
\DoxyCodeLine{keys\ =\ \{\ \{9,\ 8,\ 7,\ 6,\ 5,\ 4,\ 3,\ 2,\ 1,\ 0\}\ \}}
\DoxyCodeLine{values\ =\ \{\ \{'a',\ 'b',\ 'c',\ 'd',\ 'e',\ 'f',\ 'g',\ 'h',\ 'i',\ 'j'\}\ \}}
\DoxyCodeLine{offsets\ =\ \{3,\ 7\}}
\DoxyCodeLine{result\ =\ cudf::segmented\_sort\_by\_key(keys,\ values,\ offsets);}
\DoxyCodeLine{result\ is\ \{\ 'a','b','c',\ 'g','f','e','d',\ 'h','i','j'\ \}}

\end{DoxyCode}



\begin{DoxyParams}{参数}
{\em values} & The table to reorder \\
\hline
{\em keys} & The table that determines the ordering of elements in each segment \\
\hline
{\em segment\+\_\+offsets} & The column of {\ttfamily size\+\_\+type} type containing start offset index for each contiguous segment. \\
\hline
{\em column\+\_\+order} & The desired order for each column in {\ttfamily keys}. Size must be equal to {\ttfamily keys.\+num\+\_\+columns()} or empty. If empty, all columns are sorted in ascending order. \\
\hline
{\em null\+\_\+precedence} & The desired order of a null element compared to other elements for each column in {\ttfamily keys}. Size must be equal to {\ttfamily keys.\+num\+\_\+columns()} or empty. If empty, all columns will be sorted with {\ttfamily \doxylink{group__utility__types_gga058e6d6e8a21583ce0e85ee73e5abb31a3525317285c6126ce3b62a8df8c00b07}{null\+\_\+order\+::\+BEFORE}}. \\
\hline
{\em mr} & Device memory resource to allocate any returned objects \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
table with elements in each segment sorted  
\end{DoxyReturn}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a5ee83cd6aa2e87076b5f8c39fbf08719}\label{namespacecudf_1_1detail_a5ee83cd6aa2e87076b5f8c39fbf08719} 
\index{cudf::detail@{cudf::detail}!segmented\_sorted\_order@{segmented\_sorted\_order}}
\index{segmented\_sorted\_order@{segmented\_sorted\_order}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{segmented\_sorted\_order()}{segmented\_sorted\_order()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::segmented\+\_\+sorted\+\_\+order (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{keys,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{segment\+\_\+offsets,  }\item[{std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga750f02016b046079f7062d334890b4fc}{order}} $>$ const \&}]{column\+\_\+order = {\ttfamily \{\}},  }\item[{std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga058e6d6e8a21583ce0e85ee73e5abb31}{null\+\_\+order}} $>$ const \&}]{null\+\_\+precedence = {\ttfamily \{\}},  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Returns sorted order after sorting each segment in the table.   

If segment\+\_\+offsets contains values larger than the number of rows, the behavior is undefined. 
\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily segment\+\_\+offsets} is not {\ttfamily size\+\_\+type} column.\\
\hline
\end{DoxyExceptions}

\begin{DoxyCode}{0}
\DoxyCodeLine{Example:}
\DoxyCodeLine{keys\ =\ \{\ \{9,\ 8,\ 7,\ 6,\ 5,\ 4,\ 3,\ 2,\ 1,\ 0\}\ \}}
\DoxyCodeLine{offsets\ =\ \{0,\ 3,\ 7,\ 10\}}
\DoxyCodeLine{result\ =\ cudf::segmented\_sorted\_order(keys,\ offsets);}
\DoxyCodeLine{result\ is\ \{\ 2,1,0,\ 6,5,4,3,\ 9,8,7\ \}}

\end{DoxyCode}


If segment\+\_\+offsets is empty or contains a single index, no values are sorted and the result is a sequence of integers from 0 to keys.\+size()-\/1.

The segment\+\_\+offsets are not required to include all indices. Any indices outside the specified segments will not be sorted.


\begin{DoxyCode}{0}
\DoxyCodeLine{Example:\ (offsets\ do\ not\ cover\ all\ indices)}
\DoxyCodeLine{keys\ =\ \{\ \{9,\ 8,\ 7,\ 6,\ 5,\ 4,\ 3,\ 2,\ 1,\ 0\}\ \}}
\DoxyCodeLine{offsets\ =\ \{3,\ 7\}}
\DoxyCodeLine{result\ =\ cudf::segmented\_sorted\_order(keys,\ offsets);}
\DoxyCodeLine{result\ is\ \{\ 0,1,2,\ 6,5,4,3,\ 7,8,9\ \}}

\end{DoxyCode}



\begin{DoxyParams}{参数}
{\em keys} & The table that determines the ordering of elements in each segment \\
\hline
{\em segment\+\_\+offsets} & The column of {\ttfamily size\+\_\+type} type containing start offset index for each contiguous segment. \\
\hline
{\em column\+\_\+order} & The desired order for each column in {\ttfamily keys}. Size must be equal to {\ttfamily keys.\+num\+\_\+columns()} or empty. If empty, all columns are sorted in ascending order. \\
\hline
{\em null\+\_\+precedence} & The desired order of a null element compared to other elements for each column in {\ttfamily keys}. Size must be equal to {\ttfamily keys.\+num\+\_\+columns()} or empty. If empty, all columns will be sorted with {\ttfamily \doxylink{group__utility__types_gga058e6d6e8a21583ce0e85ee73e5abb31a3525317285c6126ce3b62a8df8c00b07}{null\+\_\+order\+::\+BEFORE}}. \\
\hline
{\em mr} & Device memory resource to allocate any returned objects \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
sorted order of the segment sorted table  
\end{DoxyReturn}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a35145843e5dd4a43853838b02241881f}\label{namespacecudf_1_1detail_a35145843e5dd4a43853838b02241881f} 
\index{cudf::detail@{cudf::detail}!segmented\_valid\_count@{segmented\_valid\_count}}
\index{segmented\_valid\_count@{segmented\_valid\_count}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{segmented\_valid\_count()}{segmented\_valid\_count()}}
{\footnotesize\ttfamily std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ cudf\+::detail\+::segmented\+\_\+valid\+\_\+count (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__utility__types_ga1d17001baf070a639c3a5e8ed8c46d34}{bitmask\+\_\+type}} const \texorpdfstring{$\ast$}{*}}]{bitmask,  }\item[{\mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$}]{indices,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream }\end{DoxyParamCaption})}



Given a validity bitmask, counts the number of valid elements (set bits) in every range {\ttfamily \mbox{[}indices\mbox{[}2\texorpdfstring{$\ast$}{*}i\mbox{]}, indices\mbox{[}(2\texorpdfstring{$\ast$}{*}i)+1\mbox{]})} (where 0 \texorpdfstring{$<$}{<}= i \texorpdfstring{$<$}{<} indices.\+size() / 2). 

If {\ttfamily bitmask == nullptr}, all elements are assumed to be valid and a vector of length {\ttfamily indices.\+size()} containing segment lengths is returned.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily indices.\+size() \% 2 != 0}. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily indices\mbox{[}2\texorpdfstring{$\ast$}{*}i\mbox{]} \texorpdfstring{$<$}{<} 0 or indices\mbox{[}2\texorpdfstring{$\ast$}{*}i\mbox{]} \texorpdfstring{$>$}{>} indices\mbox{[}(2\texorpdfstring{$\ast$}{*}i)+1\mbox{]}}.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em bitmask} & Validity bitmask residing in device memory. \\
\hline
\mbox{\texttt{ in}}  & {\em indices} & A \doxylink{structcudf_1_1host__span}{host\+\_\+span} of indices specifying ranges to count the number of valid elements. \\
\hline
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A vector storing the number of valid elements in each specified range. 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1detail_a4de28f6150ae69e92bb463bdb86c94e3}\label{namespacecudf_1_1detail_a4de28f6150ae69e92bb463bdb86c94e3} 
\index{cudf::detail@{cudf::detail}!sequence@{sequence}}
\index{sequence@{sequence}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{sequence()}{sequence()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::sequence (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{size,  }\item[{\mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&}]{init,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Fills a column with a sequence of value specified by an initial value and a step of 1.   

Creates a new column and fills with {\ttfamily size} values starting at {\ttfamily init} and incrementing by 1, generating the sequence \mbox{[} init, init+1, init+2, ... init + (size -\/ 1)\mbox{]}


\begin{DoxyCode}{0}
\DoxyCodeLine{size\ =\ 3}
\DoxyCodeLine{init\ =\ 0}
\DoxyCodeLine{\textcolor{keywordflow}{return}\ =\ [0,\ 1,\ 2]}

\end{DoxyCode}
 
\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily init} is not numeric. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily size} is \texorpdfstring{$<$}{<} 0.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em size} & Size of the output column \\
\hline
{\em init} & First value in the sequence \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
The result column containing the generated sequence  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_acaed9837e40ff8bcba1cb84806e191f3}\label{namespacecudf_1_1detail_acaed9837e40ff8bcba1cb84806e191f3} 
\index{cudf::detail@{cudf::detail}!sequence@{sequence}}
\index{sequence@{sequence}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{sequence()}{sequence()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::sequence (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{size,  }\item[{\mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&}]{init,  }\item[{\mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&}]{step,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Fills a column with a sequence of value specified by an initial value and a step.   

Creates a new column and fills with {\ttfamily size} values starting at {\ttfamily init} and incrementing by {\ttfamily step}, generating the sequence \mbox{[} init, init+step, init+2\texorpdfstring{$\ast$}{*}step, ... init + (size -\/ 1)\texorpdfstring{$\ast$}{*}step\mbox{]}


\begin{DoxyCode}{0}
\DoxyCodeLine{size\ =\ 3}
\DoxyCodeLine{init\ =\ 0}
\DoxyCodeLine{step\ =\ 2}
\DoxyCodeLine{\textcolor{keywordflow}{return}\ =\ [0,\ 2,\ 4]}

\end{DoxyCode}
 
\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily init} and {\ttfamily step} are not the same type. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if scalar types are not numeric. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily size} is \texorpdfstring{$<$}{<} 0.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em size} & Size of the output column \\
\hline
{\em init} & First value in the sequence \\
\hline
{\em step} & Increment value \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
The result column containing the generated sequence  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a522f5649cb74a11dba58378f96e40f01}\label{namespacecudf_1_1detail_a522f5649cb74a11dba58378f96e40f01} 
\index{cudf::detail@{cudf::detail}!set\_null\_mask@{set\_null\_mask}}
\index{set\_null\_mask@{set\_null\_mask}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{set\_null\_mask()}{set\_null\_mask()}}
{\footnotesize\ttfamily void cudf\+::detail\+::set\+\_\+null\+\_\+mask (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__utility__types_ga1d17001baf070a639c3a5e8ed8c46d34}{bitmask\+\_\+type}} \texorpdfstring{$\ast$}{*}}]{bitmask,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{begin\+\_\+bit,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{end\+\_\+bit,  }\item[{bool}]{valid,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream }\end{DoxyParamCaption})}



Sets a pre-\/allocated bitmask buffer to a given state in the range {\ttfamily \mbox{[}begin\+\_\+bit, end\+\_\+bit)}   

Sets {\ttfamily \mbox{[}begin\+\_\+bit, end\+\_\+bit)} bits of bitmask to valid if {\ttfamily valid==true} or null otherwise.


\begin{DoxyParams}{参数}
{\em bitmask} & Pointer to bitmask (e.\+g. returned by {\ttfamily column\+\_\+viewnull\+\_\+mask()}) \\
\hline
{\em begin\+\_\+bit} & Index of the first bit to set (inclusive) \\
\hline
{\em end\+\_\+bit} & Index of the last bit to set (exclusive) \\
\hline
{\em valid} & If true set all entries to valid; otherwise, set all to null  \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a560407ec1815ec2aff96a7c792f53428}\label{namespacecudf_1_1detail_a560407ec1815ec2aff96a7c792f53428} 
\index{cudf::detail@{cudf::detail}!shallow\_hash@{shallow\_hash}}
\index{shallow\_hash@{shallow\_hash}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{shallow\_hash()}{shallow\_hash()}}
{\footnotesize\ttfamily std\+::size\+\_\+t cudf\+::detail\+::shallow\+\_\+hash (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{input }\end{DoxyParamCaption})}



Computes a hash value from the shallow state of the specified column 

For any two columns, if {\ttfamily is\+\_\+shallow\+\_\+equivalent(c0,c1)} then {\ttfamily shallow\+\_\+hash(c0) == shallow\+\_\+hash(c1)}.

The complexity of computing the hash value of {\ttfamily input} is {\ttfamily O( count\+\_\+descendants(input) )}, i.\+e., it is independent of the number of elements in the column.

This function does {\itshape not} inspect the elements of {\ttfamily input} nor access any device memory or launch any kernels.


\begin{DoxyParams}{参数}
{\em input} & The {\ttfamily \doxylink{classcudf_1_1column__view}{column\+\_\+view}} to compute hash \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
The hash value derived from the shallow state of {\ttfamily input}. 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1detail_a659e6bad07531f73e44b0e87e7a59449}\label{namespacecudf_1_1detail_a659e6bad07531f73e44b0e87e7a59449} 
\index{cudf::detail@{cudf::detail}!shift@{shift}}
\index{shift@{shift}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{shift()}{shift()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::shift (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{input,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{offset,  }\item[{\mbox{\hyperlink{classcudf_1_1scalar}{scalar}} const \&}]{fill\+\_\+value,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Creates a new column by shifting all values by an offset.   

Elements will be determined by {\ttfamily output\mbox{[}idx\mbox{]} = input\mbox{[}idx -\/ offset\mbox{]}}. Some elements in the output may be indeterminable from the input. For those elements, the value will be determined by {\ttfamily fill\+\_\+values}.


\begin{DoxyCode}{0}
\DoxyCodeLine{Examples}
\DoxyCodeLine{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}
\DoxyCodeLine{input\ \ \ \ \ \ \ =\ [0,\ 1,\ 2,\ 3,\ 4]}
\DoxyCodeLine{offset\ \ \ \ \ \ =\ 3}
\DoxyCodeLine{fill\_values\ =\ @}
\DoxyCodeLine{return\ \ \ \ \ \ =\ [@,\ @,\ @,\ 0,\ 1]}
\DoxyCodeLine{-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}
\DoxyCodeLine{input\ \ \ \ \ \ \ =\ [5,\ 4,\ 3,\ 2,\ 1]}
\DoxyCodeLine{offset\ \ \ \ \ \ =\ -\/2}
\DoxyCodeLine{fill\_values\ =\ 7}
\DoxyCodeLine{return\ \ \ \ \ \ =\ [3,\ 2,\ 1,\ 7,\ 7]}

\end{DoxyCode}


\begin{DoxyNote}{注解}
if the input is nullable, the output will be nullable. 

if the fill value is null, the output will be nullable.
\end{DoxyNote}

\begin{DoxyParams}{参数}
{\em input} & Column to be shifted \\
\hline
{\em offset} & The offset by which to shift the input \\
\hline
{\em fill\+\_\+value} & Fill value for indeterminable outputs \\
\hline
{\em mr} & Device memory resource used to allocate the returned result\textquotesingle{}s device memory\\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily input} dtype is neither fixed-\/width nor string type \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily fill\+\_\+value} dtype does not match {\ttfamily input} dtype.\\
\hline
\end{DoxyExceptions}
\begin{DoxyReturn}{返回}
The shifted column  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a84962657d1071313a0e63f3c05a4c26a}\label{namespacecudf_1_1detail_a84962657d1071313a0e63f3c05a4c26a} 
\index{cudf::detail@{cudf::detail}!size\_in\_bits@{size\_in\_bits}}
\index{size\_in\_bits@{size\_in\_bits}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{size\_in\_bits()}{size\_in\_bits()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
constexpr \mbox{\hyperlink{types_8hpp_adc4a74f3fb4b327ed43b31d0fca65ba3}{CUDF\+\_\+\+HOST\+\_\+\+DEVICE}} std\+::size\+\_\+t cudf\+::detail\+::size\+\_\+in\+\_\+bits (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}}



Returns the number of bits the given type can hold. 


\begin{DoxyTemplParams}{模板参数}
{\em T} & The type to query \\
\hline
\end{DoxyTemplParams}
\begin{DoxyReturn}{返回}
{\ttfamily sizeof(\+T)} in bits 
\end{DoxyReturn}


在文件 \mbox{\hyperlink{bit_8hpp_source}{bit.\+hpp}} 第 \mbox{\hyperlink{bit_8hpp_source_l00053}{53}} 行定义.

\Hypertarget{namespacecudf_1_1detail_a49deebc29b5e46589239ef45caadf78d}\label{namespacecudf_1_1detail_a49deebc29b5e46589239ef45caadf78d} 
\index{cudf::detail@{cudf::detail}!slice@{slice}}
\index{slice@{slice}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{slice()}{slice()}\hspace{0.1cm}{\footnotesize\ttfamily [1/5]}}
{\footnotesize\ttfamily std\+::vector$<$ \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} $>$ cudf\+::detail\+::slice (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{input,  }\item[{\mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$}]{indices,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream }\end{DoxyParamCaption})}



Slices a {\ttfamily \doxylink{classcudf_1_1column__view}{column\+\_\+view}} into a set of {\ttfamily \doxylink{classcudf_1_1column__view}{column\+\_\+view}}s according to a set of indices.   

The returned views of {\ttfamily input} are constructed from an even number indices where the {\ttfamily i}th returned {\ttfamily \doxylink{classcudf_1_1column__view}{column\+\_\+view}} views the elements in {\ttfamily input} indicated by the range {\ttfamily \mbox{[}indices\mbox{[}2\texorpdfstring{$\ast$}{*}i\mbox{]}, indices\mbox{[}(2\texorpdfstring{$\ast$}{*}i)+1\mbox{]})}.

For all {\ttfamily i} it is expected {\ttfamily indices\mbox{[}i\mbox{]} \texorpdfstring{$<$}{<}= input.\+size()} For all {\ttfamily i\%2==0}, it is expected that {\ttfamily indices\mbox{[}i\mbox{]} \texorpdfstring{$<$}{<}= indices\mbox{[}i+1\mbox{]}}

\begin{DoxyNote}{注解}
It is the caller\textquotesingle{}s responsibility to ensure that the returned views do not outlive the viewed device memory.
\end{DoxyNote}

\begin{DoxyCode}{0}
\DoxyCodeLine{input:\ \ \ \{10,\ 12,\ 14,\ 16,\ 18,\ 20,\ 22,\ 24,\ 26,\ 28\}}
\DoxyCodeLine{indices:\ \{1,\ 3,\ 5,\ 9,\ 2,\ 4,\ 8,\ 8\}}
\DoxyCodeLine{output:\ \ \{\{12,\ 14\},\ \{20,\ 22,\ 24,\ 26\},\ \{14,\ 16\},\ \{\}\}}

\end{DoxyCode}



\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily indices} size is not even. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & When the values in the pair are strictly decreasing. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & When any of the values in the pair don\textquotesingle{}t belong to the range \mbox{[}0, input.\+size()).\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em input} & View of column to slice \\
\hline
{\em indices} & Indices used to take slices of {\ttfamily input} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Vector of views of {\ttfamily input} indicated by the ranges in {\ttfamily indices}  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_aa31cc81e8ff79807da425b06808628a3}\label{namespacecudf_1_1detail_aa31cc81e8ff79807da425b06808628a3} 
\index{cudf::detail@{cudf::detail}!slice@{slice}}
\index{slice@{slice}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{slice()}{slice()}\hspace{0.1cm}{\footnotesize\ttfamily [2/5]}}
{\footnotesize\ttfamily std\+::vector$<$ \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} $>$ cudf\+::detail\+::slice (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{input,  }\item[{std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$}]{indices,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream }\end{DoxyParamCaption})}





Slices a {\ttfamily \doxylink{classcudf_1_1column__view}{column\+\_\+view}} into a set of {\ttfamily \doxylink{classcudf_1_1column__view}{column\+\_\+view}}s according to a set of indices.  

The returned views of {\ttfamily input} are constructed from an even number indices where the {\ttfamily i}th returned {\ttfamily \doxylink{classcudf_1_1column__view}{column\+\_\+view}} views the elements in {\ttfamily input} indicated by the range {\ttfamily \mbox{[}indices\mbox{[}2\texorpdfstring{$\ast$}{*}i\mbox{]}, indices\mbox{[}(2\texorpdfstring{$\ast$}{*}i)+1\mbox{]})}.

For all {\ttfamily i} it is expected {\ttfamily indices\mbox{[}i\mbox{]} \texorpdfstring{$<$}{<}= input.\+size()} For all {\ttfamily i\%2==0}, it is expected that {\ttfamily indices\mbox{[}i\mbox{]} \texorpdfstring{$<$}{<}= indices\mbox{[}i+1\mbox{]}}

\begin{DoxyNote}{注解}
It is the caller\textquotesingle{}s responsibility to ensure that the returned views do not outlive the viewed device memory.
\end{DoxyNote}

\begin{DoxyCode}{0}
\DoxyCodeLine{input:\ \ \ \{10,\ 12,\ 14,\ 16,\ 18,\ 20,\ 22,\ 24,\ 26,\ 28\}}
\DoxyCodeLine{indices:\ \{1,\ 3,\ 5,\ 9,\ 2,\ 4,\ 8,\ 8\}}
\DoxyCodeLine{output:\ \ \{\{12,\ 14\},\ \{20,\ 22,\ 24,\ 26\},\ \{14,\ 16\},\ \{\}\}}

\end{DoxyCode}



\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily indices} size is not even. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & When the values in the pair are strictly decreasing. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & When any of the values in the pair don\textquotesingle{}t belong to the range \mbox{[}0, input.\+size()).\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em input} & View of column to slice \\
\hline
{\em indices} & Indices used to take slices of {\ttfamily input} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Vector of views of {\ttfamily input} indicated by the ranges in {\ttfamily indices}    
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_accad26dd1e34404dea7ab68735bf8d64}\label{namespacecudf_1_1detail_accad26dd1e34404dea7ab68735bf8d64} 
\index{cudf::detail@{cudf::detail}!slice@{slice}}
\index{slice@{slice}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{slice()}{slice()}\hspace{0.1cm}{\footnotesize\ttfamily [3/5]}}
{\footnotesize\ttfamily template$<$typename Column\+View $>$ \\
Column\+View cudf\+::detail\+::slice (\begin{DoxyParamCaption}\item[{Column\+View const \&}]{input,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{cudf\+::size\+\_\+type}}}]{begin,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{cudf\+::size\+\_\+type}}}]{end }\end{DoxyParamCaption})}



Constructs a zero-\/copy {\ttfamily \doxylink{classcudf_1_1column__view}{column\+\_\+view}}/{\ttfamily \doxylink{classcudf_1_1mutable__column__view}{mutable\+\_\+column\+\_\+view}} of the elements in the range {\ttfamily \mbox{[}begin,end)} in {\ttfamily input}. 

\begin{DoxyNote}{注解}
It is the caller\textquotesingle{}s responsibility to ensure that the returned view does not outlive the viewed device memory.
\end{DoxyNote}

\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily begin \texorpdfstring{$<$}{<} 0}, {\ttfamily end \texorpdfstring{$<$}{<} begin} or {\ttfamily end \texorpdfstring{$>$}{>} input.\+size()}.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em input} & View of input column to slice \\
\hline
\mbox{\texttt{ in}}  & {\em begin} & Index of the first desired element in the slice (inclusive). \\
\hline
\mbox{\texttt{ in}}  & {\em end} & Index of the last desired element in the slice (exclusive).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Column\+View View of the elements {\ttfamily \mbox{[}begin,end)} from {\ttfamily input}. 
\end{DoxyReturn}


在文件 \mbox{\hyperlink{copy_8hpp_source}{copy.\+hpp}} 第 \mbox{\hyperlink{copy_8hpp_source_l00049}{49}} 行定义.

\Hypertarget{namespacecudf_1_1detail_a5910f60027c0a5ed39ae6d3400504a4c}\label{namespacecudf_1_1detail_a5910f60027c0a5ed39ae6d3400504a4c} 
\index{cudf::detail@{cudf::detail}!slice@{slice}}
\index{slice@{slice}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{slice()}{slice()}\hspace{0.1cm}{\footnotesize\ttfamily [4/5]}}
{\footnotesize\ttfamily std\+::vector$<$ \mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} $>$ cudf\+::detail\+::slice (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{input,  }\item[{\mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$}]{indices,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream }\end{DoxyParamCaption})}



Slices a {\ttfamily \doxylink{classcudf_1_1table__view}{table\+\_\+view}} into a set of {\ttfamily \doxylink{classcudf_1_1table__view}{table\+\_\+view}}s according to a set of indices.   

The returned views of {\ttfamily input} are constructed from an even number indices where the {\ttfamily i}th returned {\ttfamily \doxylink{classcudf_1_1table__view}{table\+\_\+view}} views the elements in {\ttfamily input} indicated by the range {\ttfamily \mbox{[}indices\mbox{[}2\texorpdfstring{$\ast$}{*}i\mbox{]}, indices\mbox{[}(2\texorpdfstring{$\ast$}{*}i)+1\mbox{]})}.

For all {\ttfamily i} it is expected {\ttfamily indices\mbox{[}i\mbox{]} \texorpdfstring{$<$}{<}= input.\+size()} For all {\ttfamily i\%2==0}, it is expected that {\ttfamily indices\mbox{[}i\mbox{]} \texorpdfstring{$<$}{<}= indices\mbox{[}i+1\mbox{]}}

\begin{DoxyNote}{注解}
It is the caller\textquotesingle{}s responsibility to ensure that the returned views do not outlive the viewed device memory.
\end{DoxyNote}

\begin{DoxyCode}{0}
\DoxyCodeLine{input:\ \ \ [\{10,\ 12,\ 14,\ 16,\ 18,\ 20,\ 22,\ 24,\ 26,\ 28\},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \{50,\ 52,\ 54,\ 56,\ 58,\ 60,\ 62,\ 64,\ 66,\ 68\}]}
\DoxyCodeLine{indices:\ \{1,\ 3,\ 5,\ 9,\ 2,\ 4,\ 8,\ 8\}}
\DoxyCodeLine{output:\ \ [\{\{12,\ 14\},\ \{20,\ 22,\ 24,\ 26\},\ \{14,\ 16\},\ \{\}\},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \{\{52,\ 54\},\ \{60,\ 22,\ 24,\ 26\},\ \{14,\ 16\},\ \{\}\}]}

\end{DoxyCode}



\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily indices} size is not even. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & When the values in the pair are strictly decreasing. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & When any of the values in the pair don\textquotesingle{}t belong to the range \mbox{[}0, input.\+size()).\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em input} & View of table to slice \\
\hline
{\em indices} & Indices used to take slices of {\ttfamily input} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Vector of views of {\ttfamily input} indicated by the ranges in {\ttfamily indices}  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a981d0804d0e1b53e77bcb4b495effdd2}\label{namespacecudf_1_1detail_a981d0804d0e1b53e77bcb4b495effdd2} 
\index{cudf::detail@{cudf::detail}!slice@{slice}}
\index{slice@{slice}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{slice()}{slice()}\hspace{0.1cm}{\footnotesize\ttfamily [5/5]}}
{\footnotesize\ttfamily std\+::vector$<$ \mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} $>$ cudf\+::detail\+::slice (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{input,  }\item[{std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$}]{indices,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream }\end{DoxyParamCaption})}





Slices a {\ttfamily \doxylink{classcudf_1_1table__view}{table\+\_\+view}} into a set of {\ttfamily \doxylink{classcudf_1_1table__view}{table\+\_\+view}}s according to a set of indices.  

The returned views of {\ttfamily input} are constructed from an even number indices where the {\ttfamily i}th returned {\ttfamily \doxylink{classcudf_1_1table__view}{table\+\_\+view}} views the elements in {\ttfamily input} indicated by the range {\ttfamily \mbox{[}indices\mbox{[}2\texorpdfstring{$\ast$}{*}i\mbox{]}, indices\mbox{[}(2\texorpdfstring{$\ast$}{*}i)+1\mbox{]})}.

For all {\ttfamily i} it is expected {\ttfamily indices\mbox{[}i\mbox{]} \texorpdfstring{$<$}{<}= input.\+size()} For all {\ttfamily i\%2==0}, it is expected that {\ttfamily indices\mbox{[}i\mbox{]} \texorpdfstring{$<$}{<}= indices\mbox{[}i+1\mbox{]}}

\begin{DoxyNote}{注解}
It is the caller\textquotesingle{}s responsibility to ensure that the returned views do not outlive the viewed device memory.
\end{DoxyNote}

\begin{DoxyCode}{0}
\DoxyCodeLine{input:\ \ \ [\{10,\ 12,\ 14,\ 16,\ 18,\ 20,\ 22,\ 24,\ 26,\ 28\},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \{50,\ 52,\ 54,\ 56,\ 58,\ 60,\ 62,\ 64,\ 66,\ 68\}]}
\DoxyCodeLine{indices:\ \{1,\ 3,\ 5,\ 9,\ 2,\ 4,\ 8,\ 8\}}
\DoxyCodeLine{output:\ \ [\{\{12,\ 14\},\ \{20,\ 22,\ 24,\ 26\},\ \{14,\ 16\},\ \{\}\},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \{\{52,\ 54\},\ \{60,\ 22,\ 24,\ 26\},\ \{14,\ 16\},\ \{\}\}]}

\end{DoxyCode}



\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily indices} size is not even. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & When the values in the pair are strictly decreasing. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & When any of the values in the pair don\textquotesingle{}t belong to the range \mbox{[}0, input.\+size()).\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em input} & View of table to slice \\
\hline
{\em indices} & Indices used to take slices of {\ttfamily input} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Vector of views of {\ttfamily input} indicated by the ranges in {\ttfamily indices}    
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a6ecb769bcadd1469d96dab94bc9fb92c}\label{namespacecudf_1_1detail_a6ecb769bcadd1469d96dab94bc9fb92c} 
\index{cudf::detail@{cudf::detail}!sort@{sort}}
\index{sort@{sort}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{sort()}{sort()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::detail\+::sort (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{values,  }\item[{std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga750f02016b046079f7062d334890b4fc}{order}} $>$ const \&}]{column\+\_\+order = {\ttfamily \{\}},  }\item[{std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga058e6d6e8a21583ce0e85ee73e5abb31}{null\+\_\+order}} $>$ const \&}]{null\+\_\+precedence = {\ttfamily \{\}},  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Performs a lexicographic sort of the rows of a table   


\begin{DoxyParams}{参数}
{\em input} & The table to sort \\
\hline
{\em column\+\_\+order} & The desired order for each column. Size must be equal to {\ttfamily input.\+num\+\_\+columns()} or empty. If empty, all columns are sorted in ascending order. \\
\hline
{\em null\+\_\+precedence} & The desired order of a null element compared to other elements for each column in {\ttfamily input}. Size must be equal to {\ttfamily input.\+num\+\_\+columns()} or empty. If empty, all columns will be sorted with {\ttfamily \doxylink{group__utility__types_gga058e6d6e8a21583ce0e85ee73e5abb31a3525317285c6126ce3b62a8df8c00b07}{null\+\_\+order\+::\+BEFORE}}. \\
\hline
{\em mr} & Device memory resource used to allocate the returned table\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
New table containing the desired sorted order of {\ttfamily input}  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a8ef04bcc6a371c3a2ecdd1a24d413b06}\label{namespacecudf_1_1detail_a8ef04bcc6a371c3a2ecdd1a24d413b06} 
\index{cudf::detail@{cudf::detail}!sort\_by\_key@{sort\_by\_key}}
\index{sort\_by\_key@{sort\_by\_key}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{sort\_by\_key()}{sort\_by\_key()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::detail\+::sort\+\_\+by\+\_\+key (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{values,  }\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{keys,  }\item[{std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga750f02016b046079f7062d334890b4fc}{order}} $>$ const \&}]{column\+\_\+order = {\ttfamily \{\}},  }\item[{std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga058e6d6e8a21583ce0e85ee73e5abb31}{null\+\_\+order}} $>$ const \&}]{null\+\_\+precedence = {\ttfamily \{\}},  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Performs a key-\/value sort.   

Creates a new table that reorders the rows of {\ttfamily values} according to the lexicographic ordering of the rows of {\ttfamily keys}.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily values.\+num\+\_\+rows() != keys.\+num\+\_\+rows()}.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em values} & The table to reorder \\
\hline
{\em keys} & The table that determines the ordering \\
\hline
{\em column\+\_\+order} & The desired order for each column in {\ttfamily keys}. Size must be equal to {\ttfamily keys.\+num\+\_\+columns()} or empty. If empty, all columns are sorted in ascending order. \\
\hline
{\em null\+\_\+precedence} & The desired order of a null element compared to other elements for each column in {\ttfamily keys}. Size must be equal to {\ttfamily keys.\+num\+\_\+columns()} or empty. If empty, all columns will be sorted with {\ttfamily \doxylink{group__utility__types_gga058e6d6e8a21583ce0e85ee73e5abb31a3525317285c6126ce3b62a8df8c00b07}{null\+\_\+order\+::\+BEFORE}}. \\
\hline
{\em mr} & Device memory resource used to allocate the returned table\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
The reordering of {\ttfamily values} determined by the lexicographic order of the rows of {\ttfamily keys}.  
\end{DoxyReturn}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a02dc7ba3e6b64741911634d22f34fa91}\label{namespacecudf_1_1detail_a02dc7ba3e6b64741911634d22f34fa91} 
\index{cudf::detail@{cudf::detail}!sorted\_order@{sorted\_order}}
\index{sorted\_order@{sorted\_order}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{sorted\_order()}{sorted\_order()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::sorted\+\_\+order (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{input,  }\item[{std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga750f02016b046079f7062d334890b4fc}{order}} $>$ const \&}]{column\+\_\+order = {\ttfamily \{\}},  }\item[{std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga058e6d6e8a21583ce0e85ee73e5abb31}{null\+\_\+order}} $>$ const \&}]{null\+\_\+precedence = {\ttfamily \{\}},  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Computes the row indices that would produce {\ttfamily input} in a lexicographical sorted order.   


\begin{DoxyParams}{参数}
{\em input} & The table to sort \\
\hline
{\em column\+\_\+order} & The desired sort order for each column. Size must be equal to {\ttfamily input.\+num\+\_\+columns()} or empty. If empty, all columns will be sorted in ascending order. \\
\hline
{\em null\+\_\+precedence} & The desired order of null compared to other elements for each column. Size must be equal to {\ttfamily input.\+num\+\_\+columns()} or empty. If empty, all columns will be sorted in {\ttfamily \doxylink{group__utility__types_gga058e6d6e8a21583ce0e85ee73e5abb31a3525317285c6126ce3b62a8df8c00b07}{null\+\_\+order\+::\+BEFORE}}. \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A non-\/nullable column of {\ttfamily size\+\_\+type} elements containing the permuted row indices of {\ttfamily input} if it were sorted  
\end{DoxyReturn}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a19d4598400aec3bb414a475b0e67588a}\label{namespacecudf_1_1detail_a19d4598400aec3bb414a475b0e67588a} 
\index{cudf::detail@{cudf::detail}!spark\_murmur\_hash3\_32@{spark\_murmur\_hash3\_32}}
\index{spark\_murmur\_hash3\_32@{spark\_murmur\_hash3\_32}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{spark\_murmur\_hash3\_32()}{spark\_murmur\_hash3\_32()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::spark\+\_\+murmur\+\_\+hash3\+\_\+32 (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{input,  }\item[{uint32\+\_\+t}]{seed = {\ttfamily \mbox{\hyperlink{group__column__hash_ga68de1d04aa2c0ea2eeacfc73fd99a915}{cudf\+::\+DEFAULT\+\_\+\+HASH\+\_\+\+SEED}}},  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}

\Hypertarget{namespacecudf_1_1detail_ac92c0388c1c85c792be08da6986b8bed}\label{namespacecudf_1_1detail_ac92c0388c1c85c792be08da6986b8bed} 
\index{cudf::detail@{cudf::detail}!split@{split}}
\index{split@{split}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{split()}{split()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily std\+::vector$<$ \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} $>$ cudf\+::detail\+::split (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{input,  }\item[{\mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$}]{splits,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream }\end{DoxyParamCaption})}



Splits a {\ttfamily \doxylink{classcudf_1_1column__view}{column\+\_\+view}} into a set of {\ttfamily \doxylink{classcudf_1_1column__view}{column\+\_\+view}}s according to a set of indices derived from expected splits.   

The returned view\textquotesingle{}s of {\ttfamily input} are constructed from vector of splits, which indicates where the split should occur. The {\ttfamily i}th returned {\ttfamily \doxylink{classcudf_1_1column__view}{column\+\_\+view}} is sliced as {\ttfamily \mbox{[}0, splits\mbox{[}i\mbox{]})} if {\ttfamily i}=0, else {\ttfamily \mbox{[}splits\mbox{[}i\mbox{]}, input.\+size())} if {\ttfamily i} is the last view and {\ttfamily \mbox{[}splits\mbox{[}i-\/1\mbox{]}, splits\mbox{[}i\mbox{]}\mbox{]}} otherwise.

For all {\ttfamily i} it is expected {\ttfamily splits\mbox{[}i\mbox{]} \texorpdfstring{$<$}{<}= splits\mbox{[}i+1\mbox{]} \texorpdfstring{$<$}{<}= input.\+size()} For a {\ttfamily splits} size N, there will always be N+1 splits in the output

\begin{DoxyNote}{注解}
It is the caller\textquotesingle{}s responsibility to ensure that the returned views do not outlive the viewed device memory.
\end{DoxyNote}

\begin{DoxyCode}{0}
\DoxyCodeLine{Example:}
\DoxyCodeLine{input:\ \ \ \{10,\ 12,\ 14,\ 16,\ 18,\ 20,\ 22,\ 24,\ 26,\ 28\}}
\DoxyCodeLine{splits:\ \ \{2,\ 5,\ 9\}}
\DoxyCodeLine{output:\ \ \{\{10,\ 12\},\ \{14,\ 16,\ 18\},\ \{20,\ 22,\ 24,\ 26\},\ \{28\}\}}

\end{DoxyCode}



\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily splits} has end index \texorpdfstring{$>$}{>} size of {\ttfamily input}. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & When the value in {\ttfamily splits} is not in the range \mbox{[}0, input.\+size()). \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & When the values in the {\ttfamily splits} are \textquotesingle{}strictly decreasing\textquotesingle{}.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em input} & View of column to split \\
\hline
{\em splits} & Indices where the view will be split \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
The set of requested views of {\ttfamily input} indicated by the {\ttfamily splits}  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a2bbfdd769874212ba1918473509e8d62}\label{namespacecudf_1_1detail_a2bbfdd769874212ba1918473509e8d62} 
\index{cudf::detail@{cudf::detail}!split@{split}}
\index{split@{split}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{split()}{split()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily std\+::vector$<$ \mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} $>$ cudf\+::detail\+::split (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{input,  }\item[{std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$}]{splits,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream }\end{DoxyParamCaption})}





Splits a {\ttfamily \doxylink{classcudf_1_1column__view}{column\+\_\+view}} into a set of {\ttfamily \doxylink{classcudf_1_1column__view}{column\+\_\+view}}s according to a set of indices derived from expected splits.  

The returned view\textquotesingle{}s of {\ttfamily input} are constructed from vector of splits, which indicates where the split should occur. The {\ttfamily i}th returned {\ttfamily \doxylink{classcudf_1_1column__view}{column\+\_\+view}} is sliced as {\ttfamily \mbox{[}0, splits\mbox{[}i\mbox{]})} if {\ttfamily i}=0, else {\ttfamily \mbox{[}splits\mbox{[}i\mbox{]}, input.\+size())} if {\ttfamily i} is the last view and {\ttfamily \mbox{[}splits\mbox{[}i-\/1\mbox{]}, splits\mbox{[}i\mbox{]}\mbox{]}} otherwise.

For all {\ttfamily i} it is expected {\ttfamily splits\mbox{[}i\mbox{]} \texorpdfstring{$<$}{<}= splits\mbox{[}i+1\mbox{]} \texorpdfstring{$<$}{<}= input.\+size()} For a {\ttfamily splits} size N, there will always be N+1 splits in the output

\begin{DoxyNote}{注解}
It is the caller\textquotesingle{}s responsibility to ensure that the returned views do not outlive the viewed device memory.
\end{DoxyNote}

\begin{DoxyCode}{0}
\DoxyCodeLine{Example:}
\DoxyCodeLine{input:\ \ \ \{10,\ 12,\ 14,\ 16,\ 18,\ 20,\ 22,\ 24,\ 26,\ 28\}}
\DoxyCodeLine{splits:\ \ \{2,\ 5,\ 9\}}
\DoxyCodeLine{output:\ \ \{\{10,\ 12\},\ \{14,\ 16,\ 18\},\ \{20,\ 22,\ 24,\ 26\},\ \{28\}\}}

\end{DoxyCode}



\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily splits} has end index \texorpdfstring{$>$}{>} size of {\ttfamily input}. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & When the value in {\ttfamily splits} is not in the range \mbox{[}0, input.\+size()). \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & When the values in the {\ttfamily splits} are \textquotesingle{}strictly decreasing\textquotesingle{}.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em input} & View of column to split \\
\hline
{\em splits} & Indices where the view will be split \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
The set of requested views of {\ttfamily input} indicated by the {\ttfamily splits}    
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a5c75abac479c304fa7ddd5e472489229}\label{namespacecudf_1_1detail_a5c75abac479c304fa7ddd5e472489229} 
\index{cudf::detail@{cudf::detail}!split@{split}}
\index{split@{split}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{split()}{split()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily std\+::vector$<$ \mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} $>$ cudf\+::detail\+::split (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{input,  }\item[{\mbox{\hyperlink{structcudf_1_1host__span}{host\+\_\+span}}$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} const $>$}]{splits,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream }\end{DoxyParamCaption})}



Splits a {\ttfamily \doxylink{classcudf_1_1table__view}{table\+\_\+view}} into a set of {\ttfamily \doxylink{classcudf_1_1table__view}{table\+\_\+view}}s according to a set of indices derived from expected splits.   

The returned views of {\ttfamily input} are constructed from vector of splits, which indicates where the split should occur. The {\ttfamily i}th returned {\ttfamily \doxylink{classcudf_1_1table__view}{table\+\_\+view}} is sliced as {\ttfamily \mbox{[}0, splits\mbox{[}i\mbox{]})} if {\ttfamily i}=0, else {\ttfamily \mbox{[}splits\mbox{[}i\mbox{]}, input.\+size())} if {\ttfamily i} is the last view and {\ttfamily \mbox{[}splits\mbox{[}i-\/1\mbox{]}, splits\mbox{[}i\mbox{]}\mbox{]}} otherwise.

For all {\ttfamily i} it is expected {\ttfamily splits\mbox{[}i\mbox{]} \texorpdfstring{$<$}{<}= splits\mbox{[}i+1\mbox{]} \texorpdfstring{$<$}{<}= input.\+size()} For a {\ttfamily splits} size N, there will always be N+1 splits in the output

\begin{DoxyNote}{注解}
It is the caller\textquotesingle{}s responsibility to ensure that the returned views do not outlive the viewed device memory.
\end{DoxyNote}

\begin{DoxyCode}{0}
\DoxyCodeLine{Example:}
\DoxyCodeLine{input:\ \ \ [\{10,\ 12,\ 14,\ 16,\ 18,\ 20,\ 22,\ 24,\ 26,\ 28\},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \{50,\ 52,\ 54,\ 56,\ 58,\ 60,\ 62,\ 64,\ 66,\ 68\}]}
\DoxyCodeLine{splits:\ \ \{2,\ 5,\ 9\}}
\DoxyCodeLine{output:\ \ [\{\{10,\ 12\},\ \{14,\ 16,\ 18\},\ \{20,\ 22,\ 24,\ 26\},\ \{28\}\},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \{\{50,\ 52\},\ \{54,\ 56,\ 58\},\ \{60,\ 62,\ 64,\ 66\},\ \{68\}\}]}

\end{DoxyCode}



\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily splits} has end index \texorpdfstring{$>$}{>} size of {\ttfamily input}. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & When the value in {\ttfamily splits} is not in the range \mbox{[}0, input.\+size()). \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & When the values in the {\ttfamily splits} are \textquotesingle{}strictly decreasing\textquotesingle{}.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em input} & View of a table to split \\
\hline
{\em splits} & Indices where the view will be split \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
The set of requested views of {\ttfamily input} indicated by the {\ttfamily splits}  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a1e6bf2b8a180ce938904811ecb3fca6e}\label{namespacecudf_1_1detail_a1e6bf2b8a180ce938904811ecb3fca6e} 
\index{cudf::detail@{cudf::detail}!split@{split}}
\index{split@{split}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{split()}{split()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily std\+::vector$<$ \mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} $>$ cudf\+::detail\+::split (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{input,  }\item[{std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$}]{splits,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream }\end{DoxyParamCaption})}





Splits a {\ttfamily \doxylink{classcudf_1_1table__view}{table\+\_\+view}} into a set of {\ttfamily \doxylink{classcudf_1_1table__view}{table\+\_\+view}}s according to a set of indices derived from expected splits.  

The returned views of {\ttfamily input} are constructed from vector of splits, which indicates where the split should occur. The {\ttfamily i}th returned {\ttfamily \doxylink{classcudf_1_1table__view}{table\+\_\+view}} is sliced as {\ttfamily \mbox{[}0, splits\mbox{[}i\mbox{]})} if {\ttfamily i}=0, else {\ttfamily \mbox{[}splits\mbox{[}i\mbox{]}, input.\+size())} if {\ttfamily i} is the last view and {\ttfamily \mbox{[}splits\mbox{[}i-\/1\mbox{]}, splits\mbox{[}i\mbox{]}\mbox{]}} otherwise.

For all {\ttfamily i} it is expected {\ttfamily splits\mbox{[}i\mbox{]} \texorpdfstring{$<$}{<}= splits\mbox{[}i+1\mbox{]} \texorpdfstring{$<$}{<}= input.\+size()} For a {\ttfamily splits} size N, there will always be N+1 splits in the output

\begin{DoxyNote}{注解}
It is the caller\textquotesingle{}s responsibility to ensure that the returned views do not outlive the viewed device memory.
\end{DoxyNote}

\begin{DoxyCode}{0}
\DoxyCodeLine{Example:}
\DoxyCodeLine{input:\ \ \ [\{10,\ 12,\ 14,\ 16,\ 18,\ 20,\ 22,\ 24,\ 26,\ 28\},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \{50,\ 52,\ 54,\ 56,\ 58,\ 60,\ 62,\ 64,\ 66,\ 68\}]}
\DoxyCodeLine{splits:\ \ \{2,\ 5,\ 9\}}
\DoxyCodeLine{output:\ \ [\{\{10,\ 12\},\ \{14,\ 16,\ 18\},\ \{20,\ 22,\ 24,\ 26\},\ \{28\}\},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \{\{50,\ 52\},\ \{54,\ 56,\ 58\},\ \{60,\ 62,\ 64,\ 66\},\ \{68\}\}]}

\end{DoxyCode}



\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily splits} has end index \texorpdfstring{$>$}{>} size of {\ttfamily input}. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & When the value in {\ttfamily splits} is not in the range \mbox{[}0, input.\+size()). \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & When the values in the {\ttfamily splits} are \textquotesingle{}strictly decreasing\textquotesingle{}.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em input} & View of a table to split \\
\hline
{\em splits} & Indices where the view will be split \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
The set of requested views of {\ttfamily input} indicated by the {\ttfamily splits}    
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_ae447240ab710451b66b73e15b19e50f4}\label{namespacecudf_1_1detail_ae447240ab710451b66b73e15b19e50f4} 
\index{cudf::detail@{cudf::detail}!stable\_distinct@{stable\_distinct}}
\index{stable\_distinct@{stable\_distinct}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{stable\_distinct()}{stable\_distinct()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::detail\+::stable\+\_\+distinct (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{input,  }\item[{std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ const \&}]{keys,  }\item[{\mbox{\hyperlink{group__reorder__compact_ga69091647ea1f9c9d4cdcf7c8876bea3a}{duplicate\+\_\+keep\+\_\+option}}}]{keep = {\ttfamily \mbox{\hyperlink{group__reorder__compact_gga69091647ea1f9c9d4cdcf7c8876bea3aa0546025abe5830d9334bb82102420394}{duplicate\+\_\+keep\+\_\+option\+::\+KEEP\+\_\+\+ANY}}},  }\item[{\mbox{\hyperlink{group__utility__types_ga08a672308cd0f61562410d106b377771}{null\+\_\+equality}}}]{nulls\+\_\+equal = {\ttfamily \mbox{\hyperlink{group__utility__types_gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44}{null\+\_\+equality\+::\+EQUAL}}},  }\item[{\mbox{\hyperlink{group__utility__types_gae9d1055c69c3089452794783c7c82f83}{nan\+\_\+equality}}}]{nans\+\_\+equal = {\ttfamily \mbox{\hyperlink{group__utility__types_ggae9d1055c69c3089452794783c7c82f83acd6d9f766e6e2753da429d26078711d7}{nan\+\_\+equality\+::\+ALL\+\_\+\+EQUAL}}},  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Create a new table without duplicate rows. 

Given an {\ttfamily input} \doxylink{classcudf_1_1table__view}{table\+\_\+view}, each row is copied to the output table to create a set of distinct rows. The row order is guaranteed to be preserved as in the input.

If there are duplicate rows, which row to be copied depends on the specified value of the {\ttfamily keep} parameter.

This API produces exactly the same set of output rows as {\ttfamily \doxylink{group__reorder__compact_ga201195610929658c5d383fa99434ef9c}{cudf\+::distinct}}.


\begin{DoxyParams}{参数}
{\em input} & The input table \\
\hline
{\em keys} & Vector of indices indicating key columns in the {\ttfamily input} table \\
\hline
{\em keep} & Copy any, first, last, or none of the found duplicates \\
\hline
{\em nulls\+\_\+equal} & Flag to specify whether null elements should be considered as equal \\
\hline
{\em nans\+\_\+equal} & Flag to specify whether NaN elements should be considered as equal \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches \\
\hline
{\em mr} & Device memory resource used to allocate the returned table \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A table containing the resulting distinct rows 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1detail_a617cf9daf1ccb662f23d1751d8e9eef1}\label{namespacecudf_1_1detail_a617cf9daf1ccb662f23d1751d8e9eef1} 
\index{cudf::detail@{cudf::detail}!stable\_segmented\_sort\_by\_key@{stable\_segmented\_sort\_by\_key}}
\index{stable\_segmented\_sort\_by\_key@{stable\_segmented\_sort\_by\_key}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{stable\_segmented\_sort\_by\_key()}{stable\_segmented\_sort\_by\_key()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::detail\+::stable\+\_\+segmented\+\_\+sort\+\_\+by\+\_\+key (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{values,  }\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{keys,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{segment\+\_\+offsets,  }\item[{std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga750f02016b046079f7062d334890b4fc}{order}} $>$ const \&}]{column\+\_\+order = {\ttfamily \{\}},  }\item[{std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga058e6d6e8a21583ce0e85ee73e5abb31}{null\+\_\+order}} $>$ const \&}]{null\+\_\+precedence = {\ttfamily \{\}},  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Performs a stably lexicographic segmented sort of a table   

Performs a lexicographic segmented sort of a table  

If segment\+\_\+offsets contains values larger than the number of rows, the behavior is undefined. 
\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily values.\+num\+\_\+rows() != keys.\+num\+\_\+rows()}. \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily segment\+\_\+offsets} is not {\ttfamily size\+\_\+type} column.\\
\hline
\end{DoxyExceptions}

\begin{DoxyCode}{0}
\DoxyCodeLine{Example:}
\DoxyCodeLine{keys\ =\ \{\ \{9,\ 8,\ 7,\ 6,\ 5,\ 4,\ 3,\ 2,\ 1,\ 0\}\ \}}
\DoxyCodeLine{values\ =\ \{\ \{'a',\ 'b',\ 'c',\ 'd',\ 'e',\ 'f',\ 'g',\ 'h',\ 'i',\ 'j'\}\ \}}
\DoxyCodeLine{offsets\ =\ \{0,\ 3,\ 7,\ 10\}}
\DoxyCodeLine{result\ =\ cudf::segmented\_sort\_by\_key(keys,\ values,\ offsets);}
\DoxyCodeLine{result\ is\ \{\ 'c','b','a',\ 'g','f','e','d',\ 'j','i','h'\ \}}

\end{DoxyCode}


If segment\+\_\+offsets is empty or contains a single index, no values are sorted and the result is a copy of the values.

The segment\+\_\+offsets are not required to include all indices. Any indices outside the specified segments will not be sorted.


\begin{DoxyCode}{0}
\DoxyCodeLine{Example:\ (offsets\ do\ not\ cover\ all\ indices)}
\DoxyCodeLine{keys\ =\ \{\ \{9,\ 8,\ 7,\ 6,\ 5,\ 4,\ 3,\ 2,\ 1,\ 0\}\ \}}
\DoxyCodeLine{values\ =\ \{\ \{'a',\ 'b',\ 'c',\ 'd',\ 'e',\ 'f',\ 'g',\ 'h',\ 'i',\ 'j'\}\ \}}
\DoxyCodeLine{offsets\ =\ \{3,\ 7\}}
\DoxyCodeLine{result\ =\ cudf::segmented\_sort\_by\_key(keys,\ values,\ offsets);}
\DoxyCodeLine{result\ is\ \{\ 'a','b','c',\ 'g','f','e','d',\ 'h','i','j'\ \}}

\end{DoxyCode}



\begin{DoxyParams}{参数}
{\em values} & The table to reorder \\
\hline
{\em keys} & The table that determines the ordering of elements in each segment \\
\hline
{\em segment\+\_\+offsets} & The column of {\ttfamily size\+\_\+type} type containing start offset index for each contiguous segment. \\
\hline
{\em column\+\_\+order} & The desired order for each column in {\ttfamily keys}. Size must be equal to {\ttfamily keys.\+num\+\_\+columns()} or empty. If empty, all columns are sorted in ascending order. \\
\hline
{\em null\+\_\+precedence} & The desired order of a null element compared to other elements for each column in {\ttfamily keys}. Size must be equal to {\ttfamily keys.\+num\+\_\+columns()} or empty. If empty, all columns will be sorted with {\ttfamily \doxylink{group__utility__types_gga058e6d6e8a21583ce0e85ee73e5abb31a3525317285c6126ce3b62a8df8c00b07}{null\+\_\+order\+::\+BEFORE}}. \\
\hline
{\em mr} & Device memory resource to allocate any returned objects \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
table with elements in each segment sorted    
\end{DoxyReturn}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a9f2457ab266f3c83ee1803af46d40431}\label{namespacecudf_1_1detail_a9f2457ab266f3c83ee1803af46d40431} 
\index{cudf::detail@{cudf::detail}!stable\_segmented\_sorted\_order@{stable\_segmented\_sorted\_order}}
\index{stable\_segmented\_sorted\_order@{stable\_segmented\_sorted\_order}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{stable\_segmented\_sorted\_order()}{stable\_segmented\_sorted\_order()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::stable\+\_\+segmented\+\_\+sorted\+\_\+order (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{keys,  }\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{segment\+\_\+offsets,  }\item[{std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga750f02016b046079f7062d334890b4fc}{order}} $>$ const \&}]{column\+\_\+order = {\ttfamily \{\}},  }\item[{std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga058e6d6e8a21583ce0e85ee73e5abb31}{null\+\_\+order}} $>$ const \&}]{null\+\_\+precedence = {\ttfamily \{\}},  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Returns sorted order after stably sorting each segment in the table.   

Returns sorted order after sorting each segment in the table.  

If segment\+\_\+offsets contains values larger than the number of rows, the behavior is undefined. 
\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily segment\+\_\+offsets} is not {\ttfamily size\+\_\+type} column.\\
\hline
\end{DoxyExceptions}

\begin{DoxyCode}{0}
\DoxyCodeLine{Example:}
\DoxyCodeLine{keys\ =\ \{\ \{9,\ 8,\ 7,\ 6,\ 5,\ 4,\ 3,\ 2,\ 1,\ 0\}\ \}}
\DoxyCodeLine{offsets\ =\ \{0,\ 3,\ 7,\ 10\}}
\DoxyCodeLine{result\ =\ cudf::segmented\_sorted\_order(keys,\ offsets);}
\DoxyCodeLine{result\ is\ \{\ 2,1,0,\ 6,5,4,3,\ 9,8,7\ \}}

\end{DoxyCode}


If segment\+\_\+offsets is empty or contains a single index, no values are sorted and the result is a sequence of integers from 0 to keys.\+size()-\/1.

The segment\+\_\+offsets are not required to include all indices. Any indices outside the specified segments will not be sorted.


\begin{DoxyCode}{0}
\DoxyCodeLine{Example:\ (offsets\ do\ not\ cover\ all\ indices)}
\DoxyCodeLine{keys\ =\ \{\ \{9,\ 8,\ 7,\ 6,\ 5,\ 4,\ 3,\ 2,\ 1,\ 0\}\ \}}
\DoxyCodeLine{offsets\ =\ \{3,\ 7\}}
\DoxyCodeLine{result\ =\ cudf::segmented\_sorted\_order(keys,\ offsets);}
\DoxyCodeLine{result\ is\ \{\ 0,1,2,\ 6,5,4,3,\ 7,8,9\ \}}

\end{DoxyCode}



\begin{DoxyParams}{参数}
{\em keys} & The table that determines the ordering of elements in each segment \\
\hline
{\em segment\+\_\+offsets} & The column of {\ttfamily size\+\_\+type} type containing start offset index for each contiguous segment. \\
\hline
{\em column\+\_\+order} & The desired order for each column in {\ttfamily keys}. Size must be equal to {\ttfamily keys.\+num\+\_\+columns()} or empty. If empty, all columns are sorted in ascending order. \\
\hline
{\em null\+\_\+precedence} & The desired order of a null element compared to other elements for each column in {\ttfamily keys}. Size must be equal to {\ttfamily keys.\+num\+\_\+columns()} or empty. If empty, all columns will be sorted with {\ttfamily \doxylink{group__utility__types_gga058e6d6e8a21583ce0e85ee73e5abb31a3525317285c6126ce3b62a8df8c00b07}{null\+\_\+order\+::\+BEFORE}}. \\
\hline
{\em mr} & Device memory resource to allocate any returned objects \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
sorted order of the segment sorted table    
\end{DoxyReturn}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_af8ef84bbffe708df280ab3edd030a761}\label{namespacecudf_1_1detail_af8ef84bbffe708df280ab3edd030a761} 
\index{cudf::detail@{cudf::detail}!stable\_sort\_by\_key@{stable\_sort\_by\_key}}
\index{stable\_sort\_by\_key@{stable\_sort\_by\_key}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{stable\_sort\_by\_key()}{stable\_sort\_by\_key()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::detail\+::stable\+\_\+sort\+\_\+by\+\_\+key (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{values,  }\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{keys,  }\item[{std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga750f02016b046079f7062d334890b4fc}{order}} $>$ const \&}]{column\+\_\+order = {\ttfamily \{\}},  }\item[{std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga058e6d6e8a21583ce0e85ee73e5abb31}{null\+\_\+order}} $>$ const \&}]{null\+\_\+precedence = {\ttfamily \{\}},  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Performs a key-\/value stable sort.   

Creates a new table that reorders the rows of {\ttfamily values} according to the lexicographic ordering of the rows of {\ttfamily keys}.

The order of equivalent elements is guaranteed to be preserved.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily values.\+num\+\_\+rows() != keys.\+num\+\_\+rows()}.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em values} & The table to reorder \\
\hline
{\em keys} & The table that determines the ordering \\
\hline
{\em column\+\_\+order} & The desired order for each column in {\ttfamily keys}. Size must be equal to {\ttfamily keys.\+num\+\_\+columns()} or empty. If empty, all columns are sorted in ascending order. \\
\hline
{\em null\+\_\+precedence} & The desired order of a null element compared to other elements for each column in {\ttfamily keys}. Size must be equal to {\ttfamily keys.\+num\+\_\+columns()} or empty. If empty, all columns will be sorted with {\ttfamily \doxylink{group__utility__types_gga058e6d6e8a21583ce0e85ee73e5abb31a3525317285c6126ce3b62a8df8c00b07}{null\+\_\+order\+::\+BEFORE}}. \\
\hline
{\em mr} & Device memory resource used to allocate the returned table\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
The reordering of {\ttfamily values} determined by the lexicographic order of the rows of {\ttfamily keys}.  
\end{DoxyReturn}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a7eacf26ccb873b752827c9316f858ca9}\label{namespacecudf_1_1detail_a7eacf26ccb873b752827c9316f858ca9} 
\index{cudf::detail@{cudf::detail}!stable\_sorted\_order@{stable\_sorted\_order}}
\index{stable\_sorted\_order@{stable\_sorted\_order}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{stable\_sorted\_order()}{stable\_sorted\_order()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::stable\+\_\+sorted\+\_\+order (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{input,  }\item[{std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga750f02016b046079f7062d334890b4fc}{order}} $>$ const \&}]{column\+\_\+order = {\ttfamily \{\}},  }\item[{std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga058e6d6e8a21583ce0e85ee73e5abb31}{null\+\_\+order}} $>$ const \&}]{null\+\_\+precedence = {\ttfamily \{\}},  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Computes the row indices that would produce {\ttfamily input} in a stable lexicographical sorted order.   

The order of equivalent elements is guaranteed to be preserved.

Computes the row indices that would produce {\ttfamily input} in a lexicographical sorted order.  


\begin{DoxyParams}{参数}
{\em input} & The table to sort \\
\hline
{\em column\+\_\+order} & The desired sort order for each column. Size must be equal to {\ttfamily input.\+num\+\_\+columns()} or empty. If empty, all columns will be sorted in ascending order. \\
\hline
{\em null\+\_\+precedence} & The desired order of null compared to other elements for each column. Size must be equal to {\ttfamily input.\+num\+\_\+columns()} or empty. If empty, all columns will be sorted in {\ttfamily \doxylink{group__utility__types_gga058e6d6e8a21583ce0e85ee73e5abb31a3525317285c6126ce3b62a8df8c00b07}{null\+\_\+order\+::\+BEFORE}}. \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A non-\/nullable column of {\ttfamily size\+\_\+type} elements containing the permuted row indices of {\ttfamily input} if it were sorted    
\end{DoxyReturn}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_ab6afca7c4d88ca63b0e0903ac5c09ae0}\label{namespacecudf_1_1detail_ab6afca7c4d88ca63b0e0903ac5c09ae0} 
\index{cudf::detail@{cudf::detail}!table\_to\_linked\_columns@{table\_to\_linked\_columns}}
\index{table\_to\_linked\_columns@{table\_to\_linked\_columns}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{table\_to\_linked\_columns()}{table\_to\_linked\_columns()}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespacecudf_1_1detail_a627e116400c1bed3d5f2b3ab78661fe8}{Linked\+Col\+Vector}} cudf\+::detail\+::table\+\_\+to\+\_\+linked\+\_\+columns (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{table }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Converts all column\+\_\+views of a table into linked\+\_\+column\+\_\+views 


\begin{DoxyParams}{参数}
{\em table} & table of columns to convert \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Vector of converted linked\+\_\+column\+\_\+views 
\end{DoxyReturn}


在文件 \mbox{\hyperlink{linked__column_8hpp_source}{linked\+\_\+column.\+hpp}} 第 \mbox{\hyperlink{linked__column_8hpp_source_l00073}{73}} 行定义.

\Hypertarget{namespacecudf_1_1detail_a57278828a4e7e978f90c08968d9dec55}\label{namespacecudf_1_1detail_a57278828a4e7e978f90c08968d9dec55} 
\index{cudf::detail@{cudf::detail}!target\_type@{target\_type}}
\index{target\_type@{target\_type}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{target\_type()}{target\_type()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}} cudf\+::detail\+::target\+\_\+type (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}}}]{source\+\_\+type,  }\item[{\mbox{\hyperlink{classcudf_1_1aggregation_a83579ae3cab2fc3d1c3b377d1cfab24c}{aggregation\+::\+Kind}}}]{k }\end{DoxyParamCaption})}



Returns the target {\ttfamily \doxylink{classcudf_1_1data__type}{data\+\_\+type}} for the specified aggregation k performed on elements of type source\+\_\+type. 

aram source\+\_\+type The element type to be aggregated aram k The aggregation \begin{DoxyReturn}{返回}
\doxylink{classcudf_1_1data__type}{data\+\_\+type} The target\+\_\+type of k performed on source\+\_\+type elements 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1detail_a0390f62b7fcc7ea895d0ca910e6403c7}\label{namespacecudf_1_1detail_a0390f62b7fcc7ea895d0ca910e6403c7} 
\index{cudf::detail@{cudf::detail}!tile@{tile}}
\index{tile@{tile}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{tile()}{tile()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::detail\+::tile (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{input,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{count,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Repeats the rows from {\ttfamily input} table {\ttfamily count} times to form a new table.   

{\ttfamily output.\+num\+\_\+columns() == input.\+num\+\_\+columns()} {\ttfamily output.\+num\+\_\+rows() == input.\+num\+\_\+rows() \texorpdfstring{$\ast$}{*} count}


\begin{DoxyCode}{0}
\DoxyCodeLine{input\ \ =\ [[8,\ 4,\ 7],\ [5,\ 2,\ 3]]}
\DoxyCodeLine{count\ \ =\ 2}
\DoxyCodeLine{\textcolor{keywordflow}{return}\ =\ [[8,\ 4,\ 7,\ 8,\ 4,\ 7],\ [5,\ 2,\ 3,\ 5,\ 2,\ 3]]}

\end{DoxyCode}



\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em input} & Table containing rows to be repeated \\
\hline
\mbox{\texttt{ in}}  & {\em count} & Number of times to tile \"{}rows\"{}. Must be non-\/negative \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Device memory resource used to allocate the returned table\textquotesingle{}s device memory\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
The table containing the tiled \"{}rows\"{}  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a69fbe0566c564337747a5ba0c30f7813}\label{namespacecudf_1_1detail_a69fbe0566c564337747a5ba0c30f7813} 
\index{cudf::detail@{cudf::detail}!to\_arrow@{to\_arrow}}
\index{to\_arrow@{to\_arrow}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{to\_arrow()}{to\_arrow()}}
{\footnotesize\ttfamily std\+::shared\+\_\+ptr$<$ arrow\+::\+Table $>$ cudf\+::detail\+::to\+\_\+arrow (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}}}]{input,  }\item[{std\+::vector$<$ \mbox{\hyperlink{structcudf_1_1column__metadata}{column\+\_\+metadata}} $>$ const \&}]{metadata = {\ttfamily \{\}},  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{arrow\+::\+Memory\+Pool \texorpdfstring{$\ast$}{*}}]{ar\+\_\+mr = {\ttfamily arrow\+:\+:default\+\_\+memory\+\_\+pool()} }\end{DoxyParamCaption})}



Create {\ttfamily arrow\+::\+Table} from cudf table {\ttfamily input}   

Converts the {\ttfamily \doxylink{classcudf_1_1table__view}{cudf\+::table\+\_\+view}} to {\ttfamily arrow\+::\+Table} with the provided metadata {\ttfamily column\+\_\+names}.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily column\+\_\+names} size doesn\textquotesingle{}t match with number of columns.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em input} & \doxylink{classcudf_1_1table__view}{table\+\_\+view} that needs to be converted to arrow Table \\
\hline
{\em metadata} & Contains hierarchy of names of columns and children \\
\hline
{\em ar\+\_\+mr} & arrow memory pool to allocate memory for arrow Table \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
arrow Table generated from {\ttfamily input}  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a65b402cf23474cf91d987693ebfdeaa9}\label{namespacecudf_1_1detail_a65b402cf23474cf91d987693ebfdeaa9} 
\index{cudf::detail@{cudf::detail}!to\_arrow\_array@{to\_arrow\_array}}
\index{to\_arrow\_array@{to\_arrow\_array}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{to\_arrow\_array()}{to\_arrow\_array()}}
{\footnotesize\ttfamily template$<$typename... Ts$>$ \\
std\+::shared\+\_\+ptr$<$ arrow\+::\+Array $>$ cudf\+::detail\+::to\+\_\+arrow\+\_\+array (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__utility__types_gadf077607da617d1dadcc5417e2783539}{cudf\+::type\+\_\+id}}}]{id,  }\item[{Ts \&\&...}]{args }\end{DoxyParamCaption})}



在文件 \mbox{\hyperlink{detail_2interop_8hpp_source}{interop.\+hpp}} 第 \mbox{\hyperlink{detail_2interop_8hpp_source_l00058}{58}} 行定义.

\Hypertarget{namespacecudf_1_1detail_a93794af21ad050c5390d6ccd97783c52}\label{namespacecudf_1_1detail_a93794af21ad050c5390d6ccd97783c52} 
\index{cudf::detail@{cudf::detail}!to\_dlpack@{to\_dlpack}}
\index{to\_dlpack@{to\_dlpack}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{to\_dlpack()}{to\_dlpack()}}
{\footnotesize\ttfamily DLManaged\+Tensor \texorpdfstring{$\ast$}{*} cudf\+::detail\+::to\+\_\+dlpack (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{input,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Convert a cudf table into a DLPack DLTensor   

All columns must have the same data type and this type must be numeric. The columns may be nullable, but the null count must be zero. If the input table is empty or has zero rows, the result will be nullptr.

\begin{DoxyNote}{注解}
The {\ttfamily deleter} method of the returned {\ttfamily DLManaged\+Tensor} must be used to free the memory allocated for the tensor.
\end{DoxyNote}

\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if the data types are not equal or not numeric, or if any of columns have non-\/zero null count\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{参数}
{\em input} & Table to convert to DLPack \\
\hline
{\em mr} & Device memory resource used to allocate the returned DLPack tensor\textquotesingle{}s device memory\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
1D or 2D DLPack tensor with a copy of the table data, or nullptr  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a8dea2d4015483abd8062b4f3e8c49ecf}\label{namespacecudf_1_1detail_a8dea2d4015483abd8062b4f3e8c49ecf} 
\index{cudf::detail@{cudf::detail}!transform@{transform}}
\index{transform@{transform}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{transform()}{transform()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::transform (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{input,  }\item[{std\+::string const \&}]{unary\+\_\+udf,  }\item[{\mbox{\hyperlink{classcudf_1_1data__type}{data\+\_\+type}}}]{output\+\_\+type,  }\item[{bool}]{is\+\_\+ptx,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Creates a new column by applying a unary function against every element of an input column.   

Computes\+: {\ttfamily out\mbox{[}i\mbox{]} = F(in\mbox{[}i\mbox{]})}

The output null mask is the same is the input null mask so if input\mbox{[}i\mbox{]} is null then output\mbox{[}i\mbox{]} is also null


\begin{DoxyParams}{参数}
{\em input} & An immutable view of the input column to transform \\
\hline
{\em unary\+\_\+udf} & The PTX/\+CUDA string of the unary function to apply \\
\hline
{\em output\+\_\+type} & The output type that is compatible with the output type in the UDF \\
\hline
{\em is\+\_\+ptx} & true\+: the UDF is treated as PTX code; false\+: the UDF is treated as CUDA code \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
The column resulting from applying the unary function to every element of the input  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_ac5fe789c6b4148db15bad46557ad89d1}\label{namespacecudf_1_1detail_ac5fe789c6b4148db15bad46557ad89d1} 
\index{cudf::detail@{cudf::detail}!transpose@{transpose}}
\index{transpose@{transpose}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{transpose()}{transpose()}}
{\footnotesize\ttfamily std\+::pair$<$ std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$, \mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} $>$ cudf\+::detail\+::transpose (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{input,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Transposes a table.   

Stores output in a contiguous column, exposing the transposed table as a {\ttfamily \doxylink{classcudf_1_1table__view}{table\+\_\+view}}.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if column types are non-\/homogeneous \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if column types are non-\/fixed-\/width\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em input} & A table (M cols x N rows) to be transposed \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Device memory resource used to allocate the device memory of returned value \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
The transposed input (N cols x M rows) as a {\ttfamily column} and {\ttfamily \doxylink{classcudf_1_1table__view}{table\+\_\+view}}, representing the owner and transposed table, respectively.  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_ac0e1aa6f630065804422ba95e76da8f2}\label{namespacecudf_1_1detail_ac0e1aa6f630065804422ba95e76da8f2} 
\index{cudf::detail@{cudf::detail}!true\_if@{true\_if}}
\index{true\_if@{true\_if}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{true\_if()}{true\_if()}}
{\footnotesize\ttfamily template$<$typename Input\+Iterator , typename Predicate $>$ \\
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::true\+\_\+if (\begin{DoxyParamCaption}\item[{Input\+Iterator}]{begin,  }\item[{Input\+Iterator}]{end,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{size,  }\item[{Predicate}]{p,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Creates a column of {\ttfamily \doxylink{group__utility__types_ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd}{type\+\_\+id\+::\+BOOL8}} elements by applying a predicate to every element between \mbox{[}{\ttfamily begin,}end{\ttfamily )}true{\ttfamily indicates the value is satisfies the predicate and}false\`{} indicates it doesn\textquotesingle{}t. 


\begin{DoxyTemplParams}{模板参数}
{\em Input\+Iterator} & Iterator type for {\ttfamily begin} and {\ttfamily end} \\
\hline
{\em Predicate} & A predicator type which will be evaluated \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{参数}
{\em begin} & Beginning of the sequence of elements \\
\hline
{\em end} & End of the sequence of elements \\
\hline
{\em p} & Predicate to be applied to each element in {\ttfamily \mbox{[}begin,end)} \\
\hline
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A column of type {\ttfamily \doxylink{group__utility__types_ggadf077607da617d1dadcc5417e2783539a05afd9eb8887a406d47474cd3809a5dd}{type\+\_\+id\+::\+BOOL8},} with {\ttfamily true} representing predicate is satisfied. 
\end{DoxyReturn}


在文件 \mbox{\hyperlink{detail_2unary_8hpp_source}{unary.\+hpp}} 第 \mbox{\hyperlink{detail_2unary_8hpp_source_l00048}{48}} 行定义.

\Hypertarget{namespacecudf_1_1detail_acc1d1df6733679d2f522bd838eae342a}\label{namespacecudf_1_1detail_acc1d1df6733679d2f522bd838eae342a} 
\index{cudf::detail@{cudf::detail}!unary\_operation@{unary\_operation}}
\index{unary\_operation@{unary\_operation}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{unary\_operation()}{unary\_operation()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{cudf\+::column}} $>$ cudf\+::detail\+::unary\+\_\+operation (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{cudf\+::column\+\_\+view}} const \&}]{input,  }\item[{\mbox{\hyperlink{group__transformation__unaryops_ga030e62f30b296602f398e70d1ca657c4}{cudf\+::unary\+\_\+operator}}}]{op,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Performs unary op on all values in column   

Note\+: For {\ttfamily decimal32} and {\ttfamily decimal64}, only {\ttfamily ABS}, {\ttfamily CEIL} and {\ttfamily FLOOR} are supported.


\begin{DoxyParams}{参数}
{\em input} & A {\ttfamily \doxylink{classcudf_1_1column__view}{column\+\_\+view}} as input \\
\hline
{\em op} & operation to perform \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Column of same size as {\ttfamily input} containing result of the operation  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a641f75ce86d28e459d73c6afe246f43c}\label{namespacecudf_1_1detail_a641f75ce86d28e459d73c6afe246f43c} 
\index{cudf::detail@{cudf::detail}!unique@{unique}}
\index{unique@{unique}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{unique()}{unique()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1table}{table}} $>$ cudf\+::detail\+::unique (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{input,  }\item[{std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} $>$ const \&}]{keys,  }\item[{\mbox{\hyperlink{group__reorder__compact_ga69091647ea1f9c9d4cdcf7c8876bea3a}{duplicate\+\_\+keep\+\_\+option}}}]{keep,  }\item[{\mbox{\hyperlink{group__utility__types_ga08a672308cd0f61562410d106b377771}{null\+\_\+equality}}}]{nulls\+\_\+equal = {\ttfamily \mbox{\hyperlink{group__utility__types_gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44}{null\+\_\+equality\+::\+EQUAL}}},  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()},  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr = {\ttfamily rmm\+:\+:mr\+:\+:get\+\_\+current\+\_\+device\+\_\+resource()} }\end{DoxyParamCaption})}



Create a new table with consecutive duplicate rows removed.   

Given an {\ttfamily input} \doxylink{classcudf_1_1table__view}{table\+\_\+view}, each row is copied to the output table to create a set of distinct rows. If there are duplicate rows, which row is copied depends on the {\ttfamily keep} parameter.

The order of rows in the output table remains the same as in the input.

A row is distinct if there are no equivalent rows in the table. A row is unique if there is no adjacent equivalent row. That is, keeping distinct rows removes all duplicates in the table/column, while keeping unique rows only removes duplicates from consecutive groupings.

Performance hint\+: if the input is pre-\/sorted, {\ttfamily \doxylink{group__reorder__compact_ga87352ad4f282dd17365d4c9929d5c644}{cudf\+::unique}} can produce an equivalent result (i.\+e., same set of output rows) but with less running time than {\ttfamily \doxylink{group__reorder__compact_ga201195610929658c5d383fa99434ef9c}{cudf\+::distinct}}.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if the {\ttfamily keys} column indices are out of bounds in the {\ttfamily input} table.\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em input} & input \doxylink{classcudf_1_1table__view}{table\+\_\+view} to copy only unique rows \\
\hline
\mbox{\texttt{ in}}  & {\em keys} & vector of indices representing key columns from {\ttfamily input} \\
\hline
\mbox{\texttt{ in}}  & {\em keep} & keep any, first, last, or none of the found duplicates \\
\hline
\mbox{\texttt{ in}}  & {\em nulls\+\_\+equal} & flag to denote nulls are equal if \doxylink{group__utility__types_gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44}{null\+\_\+equality\+::\+EQUAL}, nulls are not equal if \doxylink{group__utility__types_gga08a672308cd0f61562410d106b377771ac0df9e531f39895029236b71d0d1c0ac}{null\+\_\+equality\+::\+UNEQUAL} \\
\hline
\mbox{\texttt{ in}}  & {\em mr} & Device memory resource used to allocate the returned table\textquotesingle{}s device memory\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
Table with unique rows from each sequence of equivalent rows as specified by {\ttfamily keep}  
\end{DoxyReturn}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a98e8b391af43f65454777fb93ac1810b}\label{namespacecudf_1_1detail_a98e8b391af43f65454777fb93ac1810b} 
\index{cudf::detail@{cudf::detail}!unique\_count@{unique\_count}}
\index{unique\_count@{unique\_count}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{unique\_count()}{unique\_count()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{cudf\+::size\+\_\+type}} cudf\+::detail\+::unique\+\_\+count (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1column__view}{column\+\_\+view}} const \&}]{input,  }\item[{\mbox{\hyperlink{group__utility__types_ga1b8cda4afb95a7c42c4679b4fae61009}{null\+\_\+policy}}}]{null\+\_\+handling,  }\item[{\mbox{\hyperlink{group__utility__types_ga74641d3dfd6d96d0939b492ecf9b9cc8}{nan\+\_\+policy}}}]{nan\+\_\+handling,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream }\end{DoxyParamCaption})}



Count the number of consecutive groups of equivalent rows in a column.   

If {\ttfamily null\+\_\+handling} is \doxylink{group__utility__types_gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8}{null\+\_\+policy\+::\+EXCLUDE} and {\ttfamily nan\+\_\+handling} is \doxylink{group__utility__types_gga74641d3dfd6d96d0939b492ecf9b9cc8aeed6bbfa0697c54960c7e0baa97313f4}{nan\+\_\+policy\+::\+NAN\+\_\+\+IS\+\_\+\+NULL}, both {\ttfamily NaN} and {\ttfamily null} values are ignored. If {\ttfamily null\+\_\+handling} is \doxylink{group__utility__types_gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8}{null\+\_\+policy\+::\+EXCLUDE} and {\ttfamily nan\+\_\+handling} is \doxylink{group__utility__types_gga74641d3dfd6d96d0939b492ecf9b9cc8a27adbe26caa2eb99976344933c281a77}{nan\+\_\+policy\+::\+NAN\+\_\+\+IS\+\_\+\+VALID}, only {\ttfamily null} is ignored, {\ttfamily NaN} is considered in count.

{\ttfamily null}s are handled as equal.


\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em input} & The \doxylink{classcudf_1_1column__view}{column\+\_\+view} whose consecutive groups of equivalent rows will be counted \\
\hline
\mbox{\texttt{ in}}  & {\em null\+\_\+handling} & flag to include or ignore {\ttfamily null} while counting \\
\hline
\mbox{\texttt{ in}}  & {\em nan\+\_\+handling} & flag to consider {\ttfamily NaN==null} or not\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
number of consecutive groups of equivalent rows in the column  
\end{DoxyReturn}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a310da6da06499f366f5df272a540182e}\label{namespacecudf_1_1detail_a310da6da06499f366f5df272a540182e} 
\index{cudf::detail@{cudf::detail}!unique\_count@{unique\_count}}
\index{unique\_count@{unique\_count}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{unique\_count()}{unique\_count()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{cudf\+::size\+\_\+type}} cudf\+::detail\+::unique\+\_\+count (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{input,  }\item[{\mbox{\hyperlink{group__utility__types_ga08a672308cd0f61562410d106b377771}{null\+\_\+equality}}}]{nulls\+\_\+equal = {\ttfamily \mbox{\hyperlink{group__utility__types_gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44}{null\+\_\+equality\+::\+EQUAL}}},  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream = {\ttfamily \mbox{\hyperlink{namespacecudf_a001ed29e71e759518cae31e52312befa}{cudf\+::get\+\_\+default\+\_\+stream}}()} }\end{DoxyParamCaption})}



Count the number of consecutive groups of equivalent rows in a table.   


\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em input} & Table whose consecutive groups of equivalent rows will be counted \\
\hline
\mbox{\texttt{ in}}  & {\em nulls\+\_\+equal} & flag to denote if null elements should be considered equal nulls are not equal if \doxylink{group__utility__types_gga08a672308cd0f61562410d106b377771ac0df9e531f39895029236b71d0d1c0ac}{null\+\_\+equality\+::\+UNEQUAL}.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
number of consecutive groups of equivalent rows in the column  
\end{DoxyReturn}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_ad5c2375ffd17459ecf1ef510fe8c2ea2}\label{namespacecudf_1_1detail_ad5c2375ffd17459ecf1ef510fe8c2ea2} 
\index{cudf::detail@{cudf::detail}!upper\_bound@{upper\_bound}}
\index{upper\_bound@{upper\_bound}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{upper\_bound()}{upper\_bound()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{classcudf_1_1column}{column}} $>$ cudf\+::detail\+::upper\+\_\+bound (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{haystack,  }\item[{\mbox{\hyperlink{classcudf_1_1table__view}{table\+\_\+view}} const \&}]{needles,  }\item[{std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga750f02016b046079f7062d334890b4fc}{order}} $>$ const \&}]{column\+\_\+order,  }\item[{std\+::vector$<$ \mbox{\hyperlink{group__utility__types_ga058e6d6e8a21583ce0e85ee73e5abb31}{null\+\_\+order}} $>$ const \&}]{null\+\_\+precedence,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream,  }\item[{rmm\+::mr\+::device\+\_\+memory\+\_\+resource \texorpdfstring{$\ast$}{*}}]{mr }\end{DoxyParamCaption})}



Find largest indices in a sorted table where values should be inserted to maintain order.   

For each row in {\ttfamily needles}, find the last index in {\ttfamily haystack} where inserting the row still maintains its sort order.


\begin{DoxyCode}{0}
\DoxyCodeLine{Example:}
\DoxyCodeLine{}
\DoxyCodeLine{\ Single\ Column:}
\DoxyCodeLine{\ \ \ \ \ idx\ \ \ \ \ \ \ \ 0\ \ \ 1\ \ \ 2\ \ \ 3\ \ \ 4}
\DoxyCodeLine{\ \ haystack\ =\ \{\ 10,\ 20,\ 20,\ 30,\ 50\ \}}
\DoxyCodeLine{\ \ needles\ \ =\ \{\ 20\ \}}
\DoxyCodeLine{\ \ result\ \ \ =\ \{\ \ 3\ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ Multi\ Column:}
\DoxyCodeLine{\ \ \ \ \ idx\ \ \ \ \ \ \ \ \ \ 0\ \ \ \ 1\ \ \ \ 2\ \ \ \ 3\ \ \ \ 4}
\DoxyCodeLine{\ \ haystack\ =\ \{\{\ \ 10,\ \ 20,\ \ 20,\ \ 20,\ \ 20\ \},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\ 5.0,\ \ .5,\ \ .5,\ \ .7,\ \ .7\ \},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\ \ 90,\ \ 77,\ \ 78,\ \ 61,\ \ 61\ \}\}}
\DoxyCodeLine{\ \ needles\ \ =\ \{\{\ 20\ \},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\ .7\ \},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \{\ 61\ \}\}}
\DoxyCodeLine{\ \ result\ =\ \ \ \ \ \{\ 5\ \}}

\end{DoxyCode}



\begin{DoxyParams}{参数}
{\em haystack} & The table containing search space \\
\hline
{\em needles} & Values for which to find the insert locations in the search space \\
\hline
{\em column\+\_\+order} & Vector of column sort order \\
\hline
{\em null\+\_\+precedence} & Vector of null\+\_\+precedence enums needles \\
\hline
{\em mr} & Device memory resource used to allocate the returned column\textquotesingle{}s device memory \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
A non-\/nullable column of \doxylink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{cudf\+::size\+\_\+type} elements containing the insertion points  
\end{DoxyReturn}

\begin{DoxyParams}{参数}
{\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\Hypertarget{namespacecudf_1_1detail_a052b9cabb17b4fc2ef27e00a6414c707}\label{namespacecudf_1_1detail_a052b9cabb17b4fc2ef27e00a6414c707} 
\index{cudf::detail@{cudf::detail}!valid\_count@{valid\_count}}
\index{valid\_count@{valid\_count}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{valid\_count()}{valid\_count()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{cudf\+::size\+\_\+type}} cudf\+::detail\+::valid\+\_\+count (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__utility__types_ga1d17001baf070a639c3a5e8ed8c46d34}{bitmask\+\_\+type}} const \texorpdfstring{$\ast$}{*}}]{bitmask,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{start,  }\item[{\mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}}}]{stop,  }\item[{rmm\+::cuda\+\_\+stream\+\_\+view}]{stream }\end{DoxyParamCaption})}



Given a validity bitmask, counts the number of valid elements (set bits) in the range {\ttfamily \mbox{[}start, stop)}. 

If {\ttfamily bitmask == nullptr}, all elements are assumed to be valid and the function returns {\ttfamily stop-\/start}.


\begin{DoxyExceptions}{异常}
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily start \texorpdfstring{$>$}{>} stop} \\
\hline
{\em \doxylink{structcudf_1_1logic__error}{cudf\+::logic\+\_\+error}} & if {\ttfamily start \texorpdfstring{$<$}{<} 0}\\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ in}}  & {\em bitmask} & Validity bitmask residing in device memory. \\
\hline
\mbox{\texttt{ in}}  & {\em start} & Index of the first bit to count (inclusive). \\
\hline
\mbox{\texttt{ in}}  & {\em stop} & Index of the last bit to count (exclusive). \\
\hline
\mbox{\texttt{ in}}  & {\em stream} & CUDA stream used for device memory operations and kernel launches. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
The number of valid elements in the specified range. 
\end{DoxyReturn}
\Hypertarget{namespacecudf_1_1detail_a3e5582c4cfcb5c5c104088fb0d03596c}\label{namespacecudf_1_1detail_a3e5582c4cfcb5c5c104088fb0d03596c} 
\index{cudf::detail@{cudf::detail}!visitor\_overload@{visitor\_overload}}
\index{visitor\_overload@{visitor\_overload}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{visitor\_overload()}{visitor\_overload()}}
{\footnotesize\ttfamily template$<$class... Ts$>$ \\
\mbox{\hyperlink{structcudf_1_1detail_1_1visitor__overload}{cudf\+::detail\+::visitor\+\_\+overload}} (\begin{DoxyParamCaption}\item[{Ts...}]{ }\end{DoxyParamCaption}) -\/$>$  \mbox{\hyperlink{structcudf_1_1detail_1_1visitor__overload}{visitor\+\_\+overload}}$<$ Ts... $>$}



\doxysubsection{变量说明}
\Hypertarget{namespacecudf_1_1detail_a6696755213d5d4098e2057a314205f9c}\label{namespacecudf_1_1detail_a6696755213d5d4098e2057a314205f9c} 
\index{cudf::detail@{cudf::detail}!ARGMAX\_SENTINEL@{ARGMAX\_SENTINEL}}
\index{ARGMAX\_SENTINEL@{ARGMAX\_SENTINEL}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{ARGMAX\_SENTINEL}{ARGMAX\_SENTINEL}}
{\footnotesize\ttfamily constexpr \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} cudf\+::detail\+::\+ARGMAX\+\_\+\+SENTINEL \{-\/1\}\hspace{0.3cm}{\ttfamily [constexpr]}}



Sentinel value used for {\ttfamily ARGMAX} aggregation. 

The output column for an {\ttfamily ARGMAX} aggregation is initialized with the sentinel value to indicate an unused element. 

在文件 \mbox{\hyperlink{detail_2aggregation_2aggregation_8hpp_source}{aggregation.\+hpp}} 第 \mbox{\hyperlink{detail_2aggregation_2aggregation_8hpp_source_l01100}{1100}} 行定义.

\Hypertarget{namespacecudf_1_1detail_a0ccf176241d88b7575d0e1f72d00c6c6}\label{namespacecudf_1_1detail_a0ccf176241d88b7575d0e1f72d00c6c6} 
\index{cudf::detail@{cudf::detail}!ARGMIN\_SENTINEL@{ARGMIN\_SENTINEL}}
\index{ARGMIN\_SENTINEL@{ARGMIN\_SENTINEL}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{ARGMIN\_SENTINEL}{ARGMIN\_SENTINEL}}
{\footnotesize\ttfamily constexpr \mbox{\hyperlink{group__utility__types_ga0aff16b2db009d92300befaca11827e9}{size\+\_\+type}} cudf\+::detail\+::\+ARGMIN\+\_\+\+SENTINEL \{-\/1\}\hspace{0.3cm}{\ttfamily [constexpr]}}



Sentinel value used for {\ttfamily ARGMIN} aggregation. 

The output column for an {\ttfamily ARGMIN} aggregation is initialized with the sentinel value to indicate an unused element. 

在文件 \mbox{\hyperlink{detail_2aggregation_2aggregation_8hpp_source}{aggregation.\+hpp}} 第 \mbox{\hyperlink{detail_2aggregation_2aggregation_8hpp_source_l01108}{1108}} 行定义.

\Hypertarget{namespacecudf_1_1detail_ab5aa2bb950ef46c1f618dfa206142597}\label{namespacecudf_1_1detail_ab5aa2bb950ef46c1f618dfa206142597} 
\index{cudf::detail@{cudf::detail}!DEFAULT\_JOIN\_CG\_SIZE@{DEFAULT\_JOIN\_CG\_SIZE}}
\index{DEFAULT\_JOIN\_CG\_SIZE@{DEFAULT\_JOIN\_CG\_SIZE}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{DEFAULT\_JOIN\_CG\_SIZE}{DEFAULT\_JOIN\_CG\_SIZE}}
{\footnotesize\ttfamily constexpr int cudf\+::detail\+::\+DEFAULT\+\_\+\+JOIN\+\_\+\+CG\+\_\+\+SIZE = 2\hspace{0.3cm}{\ttfamily [constexpr]}}



在文件 \mbox{\hyperlink{detail_2join_8hpp_source}{join.\+hpp}} 第 \mbox{\hyperlink{detail_2join_8hpp_source_l00043}{43}} 行定义.

\Hypertarget{namespacecudf_1_1detail_a1dea3cc353c312e3683f15e4a01cf752}\label{namespacecudf_1_1detail_a1dea3cc353c312e3683f15e4a01cf752} 
\index{cudf::detail@{cudf::detail}!default\_stream\_value@{default\_stream\_value}}
\index{default\_stream\_value@{default\_stream\_value}!cudf::detail@{cudf::detail}}
\doxysubsubsection{\texorpdfstring{default\_stream\_value}{default\_stream\_value}}
{\footnotesize\ttfamily rmm\+::cuda\+\_\+stream\+\_\+view const cudf\+::detail\+::default\+\_\+stream\+\_\+value\hspace{0.3cm}{\ttfamily [extern]}}



Default stream for cudf 

Use this value to ensure the correct stream is used when compiled with per thread default stream. 